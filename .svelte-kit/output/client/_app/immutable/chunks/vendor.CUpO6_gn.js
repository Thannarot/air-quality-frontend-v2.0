var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a, _b;
import { c as commonjsGlobal, g as getDefaultExportFromCjs, a as getAugmentedNamespace } from "./charts.LQfde5yM.js";
function noop$4() {
}
const identity$4 = (x) => x;
function assign$1(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback2 of callbacks) {
      callback2(void 0);
    }
    return noop$4;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback2) {
  component.$$.on_destroy.push(subscribe(store, callback2));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$4;
}
function split_css_unit(value) {
  const split = typeof value === "string" && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
  return split ? [parseFloat(split[1]), split[2] || "px"] : [
    /** @type {number} */
    value,
    "px"
  ];
}
const is_client = typeof window !== "undefined";
let now$1 = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$4;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback2) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback2, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
let is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function upper_bound(low, high, key, value) {
  while (low < high) {
    const mid = low + (high - low >> 1);
    if (key(mid) <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function init_hydrate(target2) {
  if (target2.hydrate_init)
    return;
  target2.hydrate_init = true;
  let children2 = (
    /** @type {ArrayLike<NodeEx2>} */
    target2.childNodes
  );
  if (target2.nodeName === "HEAD") {
    const my_children = [];
    for (let i = 0; i < children2.length; i++) {
      const node = children2[i];
      if (node.claim_order !== void 0) {
        my_children.push(node);
      }
    }
    children2 = my_children;
  }
  const m = new Int32Array(children2.length + 1);
  const p = new Int32Array(children2.length);
  m[0] = -1;
  let longest = 0;
  for (let i = 0; i < children2.length; i++) {
    const current2 = children2[i].claim_order;
    const seq_len = (longest > 0 && children2[m[longest]].claim_order <= current2 ? longest + 1 : upper_bound(1, longest, (idx) => children2[m[idx]].claim_order, current2)) - 1;
    p[i] = m[seq_len] + 1;
    const new_len = seq_len + 1;
    m[new_len] = i;
    longest = Math.max(new_len, longest);
  }
  const lis = [];
  const to_move = [];
  let last = children2.length - 1;
  for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
    lis.push(children2[cur - 1]);
    for (; last >= cur; last--) {
      to_move.push(children2[last]);
    }
    last--;
  }
  for (; last >= 0; last--) {
    to_move.push(children2[last]);
  }
  lis.reverse();
  to_move.sort((a, b) => a.claim_order - b.claim_order);
  for (let i = 0, j = 0; i < to_move.length; i++) {
    while (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {
      j++;
    }
    const anchor = j < lis.length ? lis[j] : null;
    target2.insertBefore(to_move[i], anchor);
  }
}
function append(target2, node) {
  target2.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root2 && /** @type {ShadowRoot} */
  root2.host) {
    return (
      /** @type {ShadowRoot} */
      root2
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function append_hydration(target2, node) {
  if (is_hydrating) {
    init_hydrate(target2);
    if (target2.actual_end_child === void 0 || target2.actual_end_child !== null && target2.actual_end_child.parentNode !== target2) {
      target2.actual_end_child = target2.firstChild;
    }
    while (target2.actual_end_child !== null && target2.actual_end_child.claim_order === void 0) {
      target2.actual_end_child = target2.actual_end_child.nextSibling;
    }
    if (node !== target2.actual_end_child) {
      if (node.claim_order !== void 0 || node.parentNode !== target2) {
        target2.insertBefore(node, target2.actual_end_child);
      }
    } else {
      target2.actual_end_child = node.nextSibling;
    }
  } else if (node.parentNode !== target2 || node.nextSibling !== null) {
    target2.appendChild(node);
  }
}
function insert(target2, node, anchor) {
  target2.insertBefore(node, anchor || null);
}
function insert_hydration(target2, node, anchor) {
  if (is_hydrating && !anchor) {
    append_hydration(target2, node);
  } else if (node.parentNode !== target2 || node.nextSibling != anchor) {
    target2.insertBefore(node, anchor || null);
  }
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty$1() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function self$1(fn) {
  return function(event) {
    if (event.target === this)
      fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors2 = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors2[key] && descriptors2[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function get_svelte_dataset(node) {
  return node.dataset.svelteH;
}
function children$1(element2) {
  return Array.from(element2.childNodes);
}
function init_claim_info(nodes) {
  if (nodes.claim_info === void 0) {
    nodes.claim_info = { last_index: 0, total_claimed: 0 };
  }
}
function claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {
  init_claim_info(nodes);
  const result_node = (() => {
    for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
      const node = nodes[i];
      if (predicate(node)) {
        const replacement = process_node(node);
        if (replacement === void 0) {
          nodes.splice(i, 1);
        } else {
          nodes[i] = replacement;
        }
        if (!dont_update_last_index) {
          nodes.claim_info.last_index = i;
        }
        return node;
      }
    }
    for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
      const node = nodes[i];
      if (predicate(node)) {
        const replacement = process_node(node);
        if (replacement === void 0) {
          nodes.splice(i, 1);
        } else {
          nodes[i] = replacement;
        }
        if (!dont_update_last_index) {
          nodes.claim_info.last_index = i;
        } else if (replacement === void 0) {
          nodes.claim_info.last_index--;
        }
        return node;
      }
    }
    return create_node();
  })();
  result_node.claim_order = nodes.claim_info.total_claimed;
  nodes.claim_info.total_claimed += 1;
  return result_node;
}
function claim_element_base(nodes, name, attributes, create_element) {
  return claim_node(
    nodes,
    /** @returns {node is Element | SVGElement} */
    (node) => node.nodeName === name,
    /** @param {Element} node */
    (node) => {
      const remove2 = [];
      for (let j = 0; j < node.attributes.length; j++) {
        const attribute = node.attributes[j];
        if (!attributes[attribute.name]) {
          remove2.push(attribute.name);
        }
      }
      remove2.forEach((v) => node.removeAttribute(v));
      return void 0;
    },
    () => create_element(name)
  );
}
function claim_element(nodes, name, attributes) {
  return claim_element_base(nodes, name, attributes, element);
}
function claim_svg_element(nodes, name, attributes) {
  return claim_element_base(nodes, name, attributes, svg_element);
}
function claim_text(nodes, data) {
  return claim_node(
    nodes,
    /** @returns {node is Text} */
    (node) => node.nodeType === 3,
    /** @param {Text} node */
    (node) => {
      const data_str = "" + data;
      if (node.data.startsWith(data_str)) {
        if (node.data.length !== data_str.length) {
          return node.splitText(data_str.length);
        }
      } else {
        node.data = data_str;
      }
    },
    () => text(data),
    true
    // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
  );
}
function claim_space(nodes) {
  return claim_text(nodes, " ");
}
function get_comment_idx(nodes, text2, start2) {
  for (let i = start2; i < nodes.length; i += 1) {
    const node = nodes[i];
    if (node.nodeType === 8 && node.textContent.trim() === text2) {
      return i;
    }
  }
  return -1;
}
function claim_html_tag(nodes, is_svg) {
  const start_index = get_comment_idx(nodes, "HTML_TAG_START", 0);
  const end_index = get_comment_idx(nodes, "HTML_TAG_END", start_index + 1);
  if (start_index === -1 || end_index === -1) {
    return new HtmlTagHydration(is_svg);
  }
  init_claim_info(nodes);
  const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
  detach(html_tag_nodes[0]);
  detach(html_tag_nodes[html_tag_nodes.length - 1]);
  const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
  if (claimed_nodes.length === 0) {
    return new HtmlTagHydration(is_svg);
  }
  for (const n of claimed_nodes) {
    n.claim_order = nodes.claim_info.total_claimed;
    nodes.claim_info.total_claimed += 1;
  }
  return new HtmlTagHydration(is_svg, claimed_nodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_data_contenteditable(text2, data) {
  data = "" + data;
  if (text2.wholeText === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select2, value, mounting) {
  for (let i = 0; i < select2.options.length; i += 1) {
    const option = select2.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select2.selectedIndex = -1;
  }
}
function select_value(select2) {
  const selected_option = select2.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type2, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type2, { detail, bubbles, cancelable });
}
class HtmlTag {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target2, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target2.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target2.nodeType === 11 ? "TEMPLATE" : target2.nodeName
        );
      this.t = target2.tagName !== "TEMPLATE" ? target2 : (
        /** @type {HTMLTemplateElement} */
        target2.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
class HtmlTagHydration extends HtmlTag {
  constructor(is_svg = false, claimed_nodes) {
    super(is_svg);
    /** @type {Element[]} hydration claimed nodes */
    __publicField(this, "l");
    this.e = this.n = null;
    this.l = claimed_nodes;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    if (this.l) {
      this.n = this.l;
    } else {
      super.c(html);
    }
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert_hydration(this.t, this.n[i], anchor);
    }
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash$1(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid2 = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash$1(rule)}_${uid2}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type2, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type2];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type2,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback2 = render_callbacks[i];
      if (!seen_callbacks.has(callback2)) {
        seen_callbacks.add(callback2);
        callback2();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch$1(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback2) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback2) {
        if (detach2)
          block.d(1);
        callback2();
      }
    });
    block.o(local);
  } else if (callback2) {
    callback2();
  }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity$4,
      tick: tick2 = noop$4,
      css
    } = config || null_transition;
    const program = {
      start: now$1() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch$1(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch$1(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch$1(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config = config(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function get_spread_update(levels2, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels2.length;
  while (i--) {
    const o = levels2[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels2[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind$3(component, name, callback2) {
  const index2 = component.$$.props[name];
  if (index2 !== void 0) {
    component.$$.bound[index2] = callback2;
    callback2(component.$$.ctx[index2]);
  }
}
function create_component(block) {
  block && block.c();
}
function claim_component(block, parent_nodes) {
  block && block.l(parent_nodes);
}
function mount_component(component, target2, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target2, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init$1(component, options, instance2, create_fragment2, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop$4,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children$1(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$4;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type2, callback2) {
    if (!is_function(callback2)) {
      return noop$4;
    }
    const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
    callbacks.push(callback2);
    return () => {
      const index2 = callbacks.indexOf(callback2);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
new URL("sveltekit-internal://");
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key in params) {
    params[key] = decodeURIComponent(params[key]);
  }
  return params;
}
function strip_hash({ href }) {
  return href.split("#")[0];
}
const tracked_url_properties = (
  /** @type {const} */
  [
    "href",
    "pathname",
    "search",
    "toString",
    "toJSON"
  ]
);
function make_trackable(url, callback2, search_params_callback) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key) {
        if (key === "get" || key === "getAll" || key === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key](param);
          };
        }
        callback2();
        const value = Reflect.get(obj, key);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback2();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  return tracked;
}
const DATA_SUFFIX = "/__data.json";
const HTML_DATA_SUFFIX = ".html__data.json";
function add_data_suffix(pathname) {
  if (pathname.endsWith(".html"))
    return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i = value.length;
      while (i)
        hash2 = hash2 * 33 ^ value.charCodeAt(--i);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i = buffer.length;
      while (i)
        hash2 = hash2 * 33 ^ buffer[--i];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
function b64_decode(text2) {
  const d = atob(text2);
  const u8 = new Uint8Array(d.length);
  for (let i = 0; i < d.length; i++) {
    u8[i] = d.charCodeAt(i);
  }
  return u8.buffer;
}
const native_fetch = window.fetch;
{
  window.fetch = (input, init2) => {
    const method = input instanceof Request ? input.method : (init2 == null ? void 0 : init2.method) || "GET";
    if (method !== "GET") {
      cache.delete(build_selector(input));
    }
    return native_fetch(input, init2);
  };
}
const cache = /* @__PURE__ */ new Map();
function initial_fetch(resource, opts) {
  const selector2 = build_selector(resource, opts);
  const script = document.querySelector(selector2);
  if (script == null ? void 0 : script.textContent) {
    let { body, ...init2 } = JSON.parse(script.textContent);
    const ttl = script.getAttribute("data-ttl");
    if (ttl)
      cache.set(selector2, { body, init: init2, ttl: 1e3 * Number(ttl) });
    const b64 = script.getAttribute("data-b64");
    if (b64 !== null) {
      body = b64_decode(body);
    }
    return Promise.resolve(new Response(body, init2));
  }
  return window.fetch(resource, opts);
}
function subsequent_fetch(resource, resolved, opts) {
  if (cache.size > 0) {
    const selector2 = build_selector(resource, opts);
    const cached = cache.get(selector2);
    if (cached) {
      if (performance.now() < cached.ttl && ["default", "force-cache", "only-if-cached", void 0].includes(opts == null ? void 0 : opts.cache)) {
        return new Response(cached.body, cached.init);
      }
      cache.delete(selector2);
    }
  }
  return window.fetch(resolved, opts);
}
function build_selector(resource, opts) {
  const url = JSON.stringify(resource instanceof Request ? resource.url : resource);
  let selector2 = `script[data-sveltekit-fetched][data-url=${url}]`;
  if ((opts == null ? void 0 : opts.headers) || (opts == null ? void 0 : opts.body)) {
    const values = [];
    if (opts.headers) {
      values.push([...new Headers(opts.headers)].join(","));
    }
    if (opts.body && (typeof opts.body === "string" || ArrayBuffer.isView(opts.body))) {
      values.push(opts.body);
    }
    selector2 += `[data-hash="${hash(...values)}"]`;
  }
  return selector2;
}
const param_pattern = /^(\[)?(\.\.\.)?(\w+)(?:=(\w+))?(\])?$/;
function parse_route_id(id2) {
  const params = [];
  const pattern = id2 === "/" ? /^\/$/ : new RegExp(
    `^${get_route_segments(id2).map((segment) => {
      const rest_match = /^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(segment);
      if (rest_match) {
        params.push({
          name: rest_match[1],
          matcher: rest_match[2],
          optional: false,
          rest: true,
          chained: true
        });
        return "(?:/(.*))?";
      }
      const optional_match = /^\[\[(\w+)(?:=(\w+))?\]\]$/.exec(segment);
      if (optional_match) {
        params.push({
          name: optional_match[1],
          matcher: optional_match[2],
          optional: true,
          rest: false,
          chained: true
        });
        return "(?:/([^/]+))?";
      }
      if (!segment) {
        return;
      }
      const parts = segment.split(/\[(.+?)\](?!\])/);
      const result = parts.map((content, i) => {
        if (i % 2) {
          if (content.startsWith("x+")) {
            return escape$1(String.fromCharCode(parseInt(content.slice(2), 16)));
          }
          if (content.startsWith("u+")) {
            return escape$1(
              String.fromCharCode(
                ...content.slice(2).split("-").map((code) => parseInt(code, 16))
              )
            );
          }
          const match = (
            /** @type {RegExpExecArray} */
            param_pattern.exec(content)
          );
          const [, is_optional, is_rest, name, matcher2] = match;
          params.push({
            name,
            matcher: matcher2,
            optional: !!is_optional,
            rest: !!is_rest,
            chained: is_rest ? i === 1 && parts[0] === "" : false
          });
          return is_rest ? "(.*?)" : is_optional ? "([^/]*)?" : "([^/]+?)";
        }
        return escape$1(content);
      }).join("");
      return "/" + result;
    }).join("")}/?$`
  );
  return { pattern, params };
}
function affects_path(segment) {
  return !/^\([^)]+\)$/.test(segment);
}
function get_route_segments(route) {
  return route.slice(1).split("/").filter(affects_path);
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i = 0; i < params.length; i += 1) {
    const param = params[i];
    let value = values[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i - buffered, i + 1).filter((s) => s).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i + 1];
      const next_value = values[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function escape$1(str) {
  return str.normalize().replace(/[[\]]/g, "\\$&").replace(/%/g, "%25").replace(/\//g, "%2[Ff]").replace(/\?/g, "%3[Ff]").replace(/#/g, "%23").replace(/[.*+?^${}()|\\]/g, "\\$&");
}
function parse$5({ nodes, server_loads, dictionary, matchers }) {
  const layouts_with_server_load = new Set(server_loads);
  return Object.entries(dictionary).map(([id2, [leaf, layouts2, errors]]) => {
    const { pattern, params } = parse_route_id(id2);
    const route = {
      id: id2,
      /** @param {string} path */
      exec: (path) => {
        const match = pattern.exec(path);
        if (match)
          return exec(match, params, matchers);
      },
      errors: [1, ...errors || []].map((n) => nodes[n]),
      layouts: [0, ...layouts2 || []].map(create_layout_loader),
      leaf: create_leaf_loader(leaf)
    };
    route.errors.length = route.layouts.length = Math.max(
      route.errors.length,
      route.layouts.length
    );
    return route;
  });
  function create_leaf_loader(id2) {
    const uses_server_data = id2 < 0;
    if (uses_server_data)
      id2 = ~id2;
    return [uses_server_data, nodes[id2]];
  }
  function create_layout_loader(id2) {
    return id2 === void 0 ? id2 : [layouts_with_server_load.has(id2), nodes[id2]];
  }
}
function get$2(key, parse2 = JSON.parse) {
  try {
    return parse2(sessionStorage[key]);
  } catch {
  }
}
function set$3(key, value, stringify3 = JSON.stringify) {
  const data = stringify3(value);
  try {
    sessionStorage[key] = data;
  } catch {
  }
}
const subscriber_queue = [];
function writable(value, start2 = noop$4) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe2(run2, invalidate = noop$4) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2, update2) || noop$4;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
const base = ((_a = globalThis.__sveltekit_mg0khp) == null ? void 0 : _a.base) ?? "";
const assets = ((_b = globalThis.__sveltekit_mg0khp) == null ? void 0 : _b.assets) ?? base;
const version$1 = "1710354102680";
const SNAPSHOT_KEY = "sveltekit:snapshot";
const SCROLL_KEY = "sveltekit:scroll";
const STATES_KEY = "sveltekit:states";
const PAGE_URL_KEY = "sveltekit:pageurl";
const HISTORY_INDEX = "sveltekit:history";
const NAVIGATION_INDEX = "sveltekit:navigation";
const PRELOAD_PRIORITIES = (
  /** @type {const} */
  {
    tap: 1,
    hover: 2,
    viewport: 3,
    eager: 4,
    off: -1,
    false: -1
  }
);
const origin = location.origin;
function resolve_url(url) {
  if (url instanceof URL)
    return url;
  let baseURI = document.baseURI;
  if (!baseURI) {
    const baseTags = document.getElementsByTagName("base");
    baseURI = baseTags.length ? baseTags[0].href : document.URL;
  }
  return new URL(url, baseURI);
}
function scroll_state() {
  return {
    x: pageXOffset,
    y: pageYOffset
  };
}
function link_option(element2, name) {
  const value = (
    /** @type {ValidLinkOptions<T> | null} */
    element2.getAttribute(`data-sveltekit-${name}`)
  );
  return value;
}
const levels = {
  ...PRELOAD_PRIORITIES,
  "": PRELOAD_PRIORITIES.hover
};
function parent_element(element2) {
  let parent2 = element2.assignedSlot ?? element2.parentNode;
  if ((parent2 == null ? void 0 : parent2.nodeType) === 11)
    parent2 = parent2.host;
  return (
    /** @type {Element} */
    parent2
  );
}
function find_anchor(element2, target2) {
  while (element2 && element2 !== target2) {
    if (element2.nodeName.toUpperCase() === "A" && element2.hasAttribute("href")) {
      return (
        /** @type {HTMLAnchorElement | SVGAElement} */
        element2
      );
    }
    element2 = /** @type {Element} */
    parent_element(element2);
  }
}
function get_link_info(a, base2) {
  let url;
  try {
    url = new URL(a instanceof SVGAElement ? a.href.baseVal : a.href, document.baseURI);
  } catch {
  }
  const target2 = a instanceof SVGAElement ? a.target.baseVal : a.target;
  const external = !url || !!target2 || is_external_url(url, base2) || (a.getAttribute("rel") || "").split(/\s+/).includes("external");
  const download = (url == null ? void 0 : url.origin) === origin && a.hasAttribute("download");
  return { url, external, target: target2, download };
}
function get_router_options(element2) {
  let keepfocus = null;
  let noscroll = null;
  let preload_code = null;
  let preload_data = null;
  let reload = null;
  let replace_state = null;
  let el = element2;
  while (el && el !== document.documentElement) {
    if (preload_code === null)
      preload_code = link_option(el, "preload-code");
    if (preload_data === null)
      preload_data = link_option(el, "preload-data");
    if (keepfocus === null)
      keepfocus = link_option(el, "keepfocus");
    if (noscroll === null)
      noscroll = link_option(el, "noscroll");
    if (reload === null)
      reload = link_option(el, "reload");
    if (replace_state === null)
      replace_state = link_option(el, "replacestate");
    el = /** @type {Element} */
    parent_element(el);
  }
  function get_option_state(value) {
    switch (value) {
      case "":
      case "true":
        return true;
      case "off":
      case "false":
        return false;
      default:
        return void 0;
    }
  }
  return {
    preload_code: levels[preload_code ?? "off"],
    preload_data: levels[preload_data ?? "off"],
    keepfocus: get_option_state(keepfocus),
    noscroll: get_option_state(noscroll),
    reload: get_option_state(reload),
    replace_state: get_option_state(replace_state)
  };
}
function notifiable_store(value) {
  const store = writable(value);
  let ready = true;
  function notify() {
    ready = true;
    store.update((val) => val);
  }
  function set2(new_value) {
    ready = false;
    store.set(new_value);
  }
  function subscribe2(run2) {
    let old_value;
    return store.subscribe((new_value) => {
      if (old_value === void 0 || ready && new_value !== old_value) {
        run2(old_value = new_value);
      }
    });
  }
  return { notify, set: set2, subscribe: subscribe2 };
}
function create_updated_store() {
  const { set: set2, subscribe: subscribe2 } = writable(false);
  let timeout2;
  async function check() {
    clearTimeout(timeout2);
    try {
      const res = await fetch(`${assets}/${"_app/version.json"}`, {
        headers: {
          pragma: "no-cache",
          "cache-control": "no-cache"
        }
      });
      if (!res.ok) {
        return false;
      }
      const data = await res.json();
      const updated = data.version !== version$1;
      if (updated) {
        set2(true);
        clearTimeout(timeout2);
      }
      return updated;
    } catch {
      return false;
    }
  }
  return {
    subscribe: subscribe2,
    check
  };
}
function is_external_url(url, base2) {
  return url.origin !== origin || !url.pathname.startsWith(base2);
}
const UNDEFINED = -1;
const HOLE = -2;
const NAN = -3;
const POSITIVE_INFINITY = -4;
const NEGATIVE_INFINITY = -5;
const NEGATIVE_ZERO = -6;
function unflatten(parsed, revivers) {
  if (typeof parsed === "number")
    return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated2 = Array(values.length);
  function hydrate(index2, standalone = false) {
    if (index2 === UNDEFINED)
      return void 0;
    if (index2 === NAN)
      return NaN;
    if (index2 === POSITIVE_INFINITY)
      return Infinity;
    if (index2 === NEGATIVE_INFINITY)
      return -Infinity;
    if (index2 === NEGATIVE_ZERO)
      return -0;
    if (standalone)
      throw new Error(`Invalid input`);
    if (index2 in hydrated2)
      return hydrated2[index2];
    const value = values[index2];
    if (!value || typeof value !== "object") {
      hydrated2[index2] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type2 = value[0];
        const reviver = revivers == null ? void 0 : revivers[type2];
        if (reviver) {
          return hydrated2[index2] = reviver(hydrate(value[1]));
        }
        switch (type2) {
          case "Date":
            hydrated2[index2] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated2[index2] = set2;
            for (let i = 1; i < value.length; i += 1) {
              set2.add(hydrate(value[i]));
            }
            break;
          case "Map":
            const map2 = /* @__PURE__ */ new Map();
            hydrated2[index2] = map2;
            for (let i = 1; i < value.length; i += 2) {
              map2.set(hydrate(value[i]), hydrate(value[i + 1]));
            }
            break;
          case "RegExp":
            hydrated2[index2] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated2[index2] = Object(value[1]);
            break;
          case "BigInt":
            hydrated2[index2] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated2[index2] = obj;
            for (let i = 1; i < value.length; i += 2) {
              obj[value[i]] = hydrate(value[i + 1]);
            }
            break;
          default:
            throw new Error(`Unknown type ${type2}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated2[index2] = array2;
        for (let i = 0; i < value.length; i += 1) {
          const n = value[i];
          if (n === HOLE)
            continue;
          array2[i] = hydrate(n);
        }
      }
    } else {
      const object2 = {};
      hydrated2[index2] = object2;
      for (const key in value) {
        const n = value[key];
        object2[key] = hydrate(n);
      }
    }
    return hydrated2[index2];
  }
  return hydrate(0);
}
const valid_layout_exports = /* @__PURE__ */ new Set([
  "load",
  "prerender",
  "csr",
  "ssr",
  "trailingSlash",
  "config"
]);
/* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
const valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
/* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
function compact$1(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
class HttpError {
  /**
   * @param {number} status
   * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
   */
  constructor(status, body) {
    this.status = status;
    if (typeof body === "string") {
      this.body = { message: body };
    } else if (body) {
      this.body = body;
    } else {
      this.body = { message: `Error: ${status}` };
    }
  }
  toString() {
    return JSON.stringify(this.body);
  }
}
class Redirect {
  /**
   * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
   * @param {string} location
   */
  constructor(status, location2) {
    this.status = status;
    this.location = location2;
  }
}
class SvelteKitError extends Error {
  /**
   * @param {number} status
   * @param {string} text
   * @param {string} message
   */
  constructor(status, text2, message) {
    super(message);
    this.status = status;
    this.text = text2;
  }
}
const INVALIDATED_PARAM = "x-sveltekit-invalidated";
const TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function get_status(error) {
  return error instanceof HttpError || error instanceof SvelteKitError ? error.status : 500;
}
function get_message(error) {
  return error instanceof SvelteKitError ? error.text : "Internal Error";
}
const scroll_positions = get$2(SCROLL_KEY) ?? {};
const snapshots = get$2(SNAPSHOT_KEY) ?? {};
const stores = {
  url: /* @__PURE__ */ notifiable_store({}),
  page: /* @__PURE__ */ notifiable_store({}),
  navigating: /* @__PURE__ */ writable(
    /** @type {import('@sveltejs/kit').Navigation | null} */
    null
  ),
  updated: /* @__PURE__ */ create_updated_store()
};
function update_scroll_positions(index2) {
  scroll_positions[index2] = scroll_state();
}
function clear_onward_history(current_history_index2, current_navigation_index2) {
  let i = current_history_index2 + 1;
  while (scroll_positions[i]) {
    delete scroll_positions[i];
    i += 1;
  }
  i = current_navigation_index2 + 1;
  while (snapshots[i]) {
    delete snapshots[i];
    i += 1;
  }
}
function native_navigation(url) {
  location.href = url.href;
  return new Promise(() => {
  });
}
function noop$3() {
}
let routes;
let default_layout_loader;
let default_error_loader;
let container;
let target;
let app;
const invalidated = [];
const components = [];
let load_cache = null;
const before_navigate_callbacks = [];
const on_navigate_callbacks = [];
let after_navigate_callbacks = [];
let current = {
  branch: [],
  error: null,
  // @ts-ignore - we need the initial value to be null
  url: null
};
let hydrated = false;
let started = false;
let autoscroll = true;
let navigating = false;
let hash_navigating = false;
let has_navigated = false;
let force_invalidation = false;
let root$1;
let current_history_index;
let current_navigation_index;
let page$1;
let token;
const preload_tokens = /* @__PURE__ */ new Set();
async function start$1(_app, _target, hydrate) {
  var _a2, _b2;
  if (document.URL !== location.href) {
    location.href = location.href;
  }
  app = _app;
  routes = parse$5(_app);
  container = document.documentElement;
  target = _target;
  default_layout_loader = _app.nodes[0];
  default_error_loader = _app.nodes[1];
  default_layout_loader();
  default_error_loader();
  current_history_index = (_a2 = history.state) == null ? void 0 : _a2[HISTORY_INDEX];
  current_navigation_index = (_b2 = history.state) == null ? void 0 : _b2[NAVIGATION_INDEX];
  if (!current_history_index) {
    current_history_index = current_navigation_index = Date.now();
    history.replaceState(
      {
        ...history.state,
        [HISTORY_INDEX]: current_history_index,
        [NAVIGATION_INDEX]: current_navigation_index
      },
      ""
    );
  }
  const scroll = scroll_positions[current_history_index];
  if (scroll) {
    history.scrollRestoration = "manual";
    scrollTo(scroll.x, scroll.y);
  }
  if (hydrate) {
    await _hydrate(target, hydrate);
  } else {
    goto(location.href, { replaceState: true });
  }
  _start_router();
}
function reset_invalidation() {
  invalidated.length = 0;
  force_invalidation = false;
}
function capture_snapshot(index2) {
  if (components.some((c) => c == null ? void 0 : c.snapshot)) {
    snapshots[index2] = components.map((c) => {
      var _a2;
      return (_a2 = c == null ? void 0 : c.snapshot) == null ? void 0 : _a2.capture();
    });
  }
}
function restore_snapshot(index2) {
  var _a2;
  (_a2 = snapshots[index2]) == null ? void 0 : _a2.forEach((value, i) => {
    var _a3, _b2;
    (_b2 = (_a3 = components[i]) == null ? void 0 : _a3.snapshot) == null ? void 0 : _b2.restore(value);
  });
}
function persist_state() {
  update_scroll_positions(current_history_index);
  set$3(SCROLL_KEY, scroll_positions);
  capture_snapshot(current_navigation_index);
  set$3(SNAPSHOT_KEY, snapshots);
}
async function _goto(url, options, redirect_count, nav_token) {
  return navigate({
    type: "goto",
    url: resolve_url(url),
    keepfocus: options.keepFocus,
    noscroll: options.noScroll,
    replace_state: options.replaceState,
    state: options.state,
    redirect_count,
    nav_token,
    accept: () => {
      if (options.invalidateAll) {
        force_invalidation = true;
      }
    }
  });
}
async function _preload_data(intent) {
  if (intent.id !== (load_cache == null ? void 0 : load_cache.id)) {
    const preload2 = {};
    preload_tokens.add(preload2);
    load_cache = {
      id: intent.id,
      token: preload2,
      promise: load_route({ ...intent, preload: preload2 }).then((result) => {
        preload_tokens.delete(preload2);
        if (result.type === "loaded" && result.state.error) {
          load_cache = null;
        }
        return result;
      })
    };
  }
  return load_cache.promise;
}
async function _preload_code(pathname) {
  const route = routes.find((route2) => route2.exec(get_url_path(pathname)));
  if (route) {
    await Promise.all([...route.layouts, route.leaf].map((load) => load == null ? void 0 : load[1]()));
  }
}
function initialize(result, target2) {
  var _a2;
  current = result.state;
  const style = document.querySelector("style[data-sveltekit]");
  if (style)
    style.remove();
  page$1 = /** @type {import('@sveltejs/kit').Page} */
  result.props.page;
  root$1 = new app.root({
    target: target2,
    props: { ...result.props, stores, components },
    hydrate: true
  });
  restore_snapshot(current_navigation_index);
  const navigation = {
    from: null,
    to: {
      params: current.params,
      route: { id: ((_a2 = current.route) == null ? void 0 : _a2.id) ?? null },
      url: new URL(location.href)
    },
    willUnload: false,
    type: "enter",
    complete: Promise.resolve()
  };
  after_navigate_callbacks.forEach((fn) => fn(navigation));
  started = true;
}
async function get_navigation_result_from_branch({
  url,
  params,
  branch,
  status,
  error,
  route,
  form
}) {
  let slash = "never";
  if (base && (url.pathname === base || url.pathname === base + "/")) {
    slash = "always";
  } else {
    for (const node of branch) {
      if ((node == null ? void 0 : node.slash) !== void 0)
        slash = node.slash;
    }
  }
  url.pathname = normalize_path(url.pathname, slash);
  url.search = url.search;
  const result = {
    type: "loaded",
    state: {
      url,
      params,
      branch,
      error,
      route
    },
    props: {
      // @ts-ignore Somehow it's getting SvelteComponent and SvelteComponentDev mixed up
      constructors: compact$1(branch).map((branch_node) => branch_node.node.component),
      page: page$1
    }
  };
  if (form !== void 0) {
    result.props.form = form;
  }
  let data = {};
  let data_changed = !page$1;
  let p = 0;
  for (let i = 0; i < Math.max(branch.length, current.branch.length); i += 1) {
    const node = branch[i];
    const prev = current.branch[i];
    if ((node == null ? void 0 : node.data) !== (prev == null ? void 0 : prev.data))
      data_changed = true;
    if (!node)
      continue;
    data = { ...data, ...node.data };
    if (data_changed) {
      result.props[`data_${p}`] = data;
    }
    p += 1;
  }
  const page_changed = !current.url || url.href !== current.url.href || current.error !== error || form !== void 0 && form !== page$1.form || data_changed;
  if (page_changed) {
    result.props.page = {
      error,
      params,
      route: {
        id: (route == null ? void 0 : route.id) ?? null
      },
      state: {},
      status,
      url: new URL(url),
      form: form ?? null,
      // The whole page store is updated, but this way the object reference stays the same
      data: data_changed ? data : page$1.data
    };
  }
  return result;
}
async function load_node({ loader, parent: parent2, url, params, route, server_data_node }) {
  var _a2, _b2, _c;
  let data = null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const node = await loader();
  if ((_a2 = node.universal) == null ? void 0 : _a2.load) {
    let depends = function(...deps) {
      for (const dep of deps) {
        const { href } = new URL(dep, url);
        uses.dependencies.add(href);
      }
    };
    const load_input = {
      route: new Proxy(route, {
        get: (target2, key) => {
          if (is_tracking) {
            uses.route = true;
          }
          return target2[
            /** @type {'id'} */
            key
          ];
        }
      }),
      params: new Proxy(params, {
        get: (target2, key) => {
          if (is_tracking) {
            uses.params.add(
              /** @type {string} */
              key
            );
          }
          return target2[
            /** @type {string} */
            key
          ];
        }
      }),
      data: (server_data_node == null ? void 0 : server_data_node.data) ?? null,
      url: make_trackable(
        url,
        () => {
          if (is_tracking) {
            uses.url = true;
          }
        },
        (param) => {
          if (is_tracking) {
            uses.search_params.add(param);
          }
        }
      ),
      async fetch(resource, init2) {
        let requested;
        if (resource instanceof Request) {
          requested = resource.url;
          init2 = {
            // the request body must be consumed in memory until browsers
            // implement streaming request bodies and/or the body getter
            body: resource.method === "GET" || resource.method === "HEAD" ? void 0 : await resource.blob(),
            cache: resource.cache,
            credentials: resource.credentials,
            headers: resource.headers,
            integrity: resource.integrity,
            keepalive: resource.keepalive,
            method: resource.method,
            mode: resource.mode,
            redirect: resource.redirect,
            referrer: resource.referrer,
            referrerPolicy: resource.referrerPolicy,
            signal: resource.signal,
            ...init2
          };
        } else {
          requested = resource;
        }
        const resolved = new URL(requested, url);
        if (is_tracking) {
          depends(resolved.href);
        }
        if (resolved.origin === url.origin) {
          requested = resolved.href.slice(url.origin.length);
        }
        return started ? subsequent_fetch(requested, resolved.href, init2) : initial_fetch(requested, init2);
      },
      setHeaders: () => {
      },
      // noop
      depends,
      parent() {
        if (is_tracking) {
          uses.parent = true;
        }
        return parent2();
      },
      untrack(fn) {
        is_tracking = false;
        try {
          return fn();
        } finally {
          is_tracking = true;
        }
      }
    };
    {
      data = await node.universal.load.call(null, load_input) ?? null;
    }
  }
  return {
    node,
    loader,
    server: server_data_node,
    universal: ((_b2 = node.universal) == null ? void 0 : _b2.load) ? { type: "data", data, uses } : null,
    data: data ?? (server_data_node == null ? void 0 : server_data_node.data) ?? null,
    slash: ((_c = node.universal) == null ? void 0 : _c.trailingSlash) ?? (server_data_node == null ? void 0 : server_data_node.slash)
  };
}
function has_changed(parent_changed, route_changed, url_changed, search_params_changed, uses, params) {
  if (force_invalidation)
    return true;
  if (!uses)
    return false;
  if (uses.parent && parent_changed)
    return true;
  if (uses.route && route_changed)
    return true;
  if (uses.url && url_changed)
    return true;
  for (const tracked_params of uses.search_params) {
    if (search_params_changed.has(tracked_params))
      return true;
  }
  for (const param of uses.params) {
    if (params[param] !== current.params[param])
      return true;
  }
  for (const href of uses.dependencies) {
    if (invalidated.some((fn) => fn(new URL(href))))
      return true;
  }
  return false;
}
function create_data_node(node, previous) {
  if ((node == null ? void 0 : node.type) === "data")
    return node;
  if ((node == null ? void 0 : node.type) === "skip")
    return previous ?? null;
  return null;
}
function diff_search_params(old_url, new_url) {
  if (!old_url)
    return new Set(new_url.searchParams.keys());
  const changed = /* @__PURE__ */ new Set([...old_url.searchParams.keys(), ...new_url.searchParams.keys()]);
  for (const key of changed) {
    const old_values = old_url.searchParams.getAll(key);
    const new_values = new_url.searchParams.getAll(key);
    if (old_values.every((value) => new_values.includes(value)) && new_values.every((value) => old_values.includes(value))) {
      changed.delete(key);
    }
  }
  return changed;
}
function preload_error({ error, url, route, params }) {
  return {
    type: "loaded",
    state: {
      error,
      url,
      route,
      params,
      branch: []
    },
    props: { page: page$1, constructors: [] }
  };
}
async function load_route({ id: id2, invalidating, url, params, route, preload: preload2 }) {
  if ((load_cache == null ? void 0 : load_cache.id) === id2) {
    preload_tokens.delete(load_cache.token);
    return load_cache.promise;
  }
  const { errors, layouts: layouts2, leaf } = route;
  const loaders = [...layouts2, leaf];
  errors.forEach((loader) => loader == null ? void 0 : loader().catch(() => {
  }));
  loaders.forEach((loader) => loader == null ? void 0 : loader[1]().catch(() => {
  }));
  let server_data = null;
  const url_changed = current.url ? id2 !== current.url.pathname + current.url.search : false;
  const route_changed = current.route ? route.id !== current.route.id : false;
  const search_params_changed = diff_search_params(current.url, url);
  let parent_invalid = false;
  const invalid_server_nodes = loaders.map((loader, i) => {
    var _a2;
    const previous = current.branch[i];
    const invalid = !!(loader == null ? void 0 : loader[0]) && ((previous == null ? void 0 : previous.loader) !== loader[1] || has_changed(
      parent_invalid,
      route_changed,
      url_changed,
      search_params_changed,
      (_a2 = previous.server) == null ? void 0 : _a2.uses,
      params
    ));
    if (invalid) {
      parent_invalid = true;
    }
    return invalid;
  });
  if (invalid_server_nodes.some(Boolean)) {
    try {
      server_data = await load_data(url, invalid_server_nodes);
    } catch (error) {
      const handled_error = await handle_error(error, { url, params, route: { id: id2 } });
      if (preload_tokens.has(preload2)) {
        return preload_error({ error: handled_error, url, params, route });
      }
      return load_root_error_page({
        status: get_status(error),
        error: handled_error,
        url,
        route
      });
    }
    if (server_data.type === "redirect") {
      return server_data;
    }
  }
  const server_data_nodes = server_data == null ? void 0 : server_data.nodes;
  let parent_changed = false;
  const branch_promises = loaders.map(async (loader, i) => {
    var _a2;
    if (!loader)
      return;
    const previous = current.branch[i];
    const server_data_node = server_data_nodes == null ? void 0 : server_data_nodes[i];
    const valid = (!server_data_node || server_data_node.type === "skip") && loader[1] === (previous == null ? void 0 : previous.loader) && !has_changed(
      parent_changed,
      route_changed,
      url_changed,
      search_params_changed,
      (_a2 = previous.universal) == null ? void 0 : _a2.uses,
      params
    );
    if (valid)
      return previous;
    parent_changed = true;
    if ((server_data_node == null ? void 0 : server_data_node.type) === "error") {
      throw server_data_node;
    }
    return load_node({
      loader: loader[1],
      url,
      params,
      route,
      parent: async () => {
        var _a3;
        const data = {};
        for (let j = 0; j < i; j += 1) {
          Object.assign(data, (_a3 = await branch_promises[j]) == null ? void 0 : _a3.data);
        }
        return data;
      },
      server_data_node: create_data_node(
        // server_data_node is undefined if it wasn't reloaded from the server;
        // and if current loader uses server data, we want to reuse previous data.
        server_data_node === void 0 && loader[0] ? { type: "skip" } : server_data_node ?? null,
        loader[0] ? previous == null ? void 0 : previous.server : void 0
      )
    });
  });
  for (const p of branch_promises)
    p.catch(() => {
    });
  const branch = [];
  for (let i = 0; i < loaders.length; i += 1) {
    if (loaders[i]) {
      try {
        branch.push(await branch_promises[i]);
      } catch (err) {
        if (err instanceof Redirect) {
          return {
            type: "redirect",
            location: err.location
          };
        }
        if (preload_tokens.has(preload2)) {
          return preload_error({
            error: await handle_error(err, { params, url, route: { id: route.id } }),
            url,
            params,
            route
          });
        }
        let status = get_status(err);
        let error;
        if (server_data_nodes == null ? void 0 : server_data_nodes.includes(
          /** @type {import('types').ServerErrorNode} */
          err
        )) {
          status = /** @type {import('types').ServerErrorNode} */
          err.status ?? status;
          error = /** @type {import('types').ServerErrorNode} */
          err.error;
        } else if (err instanceof HttpError) {
          error = err.body;
        } else {
          const updated = await stores.updated.check();
          if (updated) {
            return await native_navigation(url);
          }
          error = await handle_error(err, { params, url, route: { id: route.id } });
        }
        const error_load = await load_nearest_error_page(i, branch, errors);
        if (error_load) {
          return await get_navigation_result_from_branch({
            url,
            params,
            branch: branch.slice(0, error_load.idx).concat(error_load.node),
            status,
            error,
            route
          });
        } else {
          return await server_fallback(url, { id: route.id }, error, status);
        }
      }
    } else {
      branch.push(void 0);
    }
  }
  return await get_navigation_result_from_branch({
    url,
    params,
    branch,
    status: 200,
    error: null,
    route,
    // Reset `form` on navigation, but not invalidation
    form: invalidating ? void 0 : null
  });
}
async function load_nearest_error_page(i, branch, errors) {
  while (i--) {
    if (errors[i]) {
      let j = i;
      while (!branch[j])
        j -= 1;
      try {
        return {
          idx: j + 1,
          node: {
            node: await /** @type {import('types').CSRPageNodeLoader } */
            errors[i](),
            loader: (
              /** @type {import('types').CSRPageNodeLoader } */
              errors[i]
            ),
            data: {},
            server: null,
            universal: null
          }
        };
      } catch (e) {
        continue;
      }
    }
  }
}
async function load_root_error_page({ status, error, url, route }) {
  const params = {};
  let server_data_node = null;
  const default_layout_has_server_load = app.server_loads[0] === 0;
  if (default_layout_has_server_load) {
    try {
      const server_data = await load_data(url, [true]);
      if (server_data.type !== "data" || server_data.nodes[0] && server_data.nodes[0].type !== "data") {
        throw 0;
      }
      server_data_node = server_data.nodes[0] ?? null;
    } catch {
      if (url.origin !== origin || url.pathname !== location.pathname || hydrated) {
        await native_navigation(url);
      }
    }
  }
  const root_layout = await load_node({
    loader: default_layout_loader,
    url,
    params,
    route,
    parent: () => Promise.resolve({}),
    server_data_node: create_data_node(server_data_node)
  });
  const root_error = {
    node: await default_error_loader(),
    loader: default_error_loader,
    universal: null,
    server: null,
    data: null
  };
  return await get_navigation_result_from_branch({
    url,
    params,
    branch: [root_layout, root_error],
    status,
    error,
    route: null
  });
}
function get_navigation_intent(url, invalidating) {
  if (!url)
    return void 0;
  if (is_external_url(url, base))
    return;
  let rerouted;
  try {
    rerouted = app.hooks.reroute({ url: new URL(url) }) ?? url.pathname;
  } catch (e) {
    return void 0;
  }
  const path = get_url_path(rerouted);
  for (const route of routes) {
    const params = route.exec(path);
    if (params) {
      const id2 = url.pathname + url.search;
      const intent = {
        id: id2,
        invalidating,
        route,
        params: decode_params(params),
        url
      };
      return intent;
    }
  }
}
function get_url_path(pathname) {
  return decode_pathname(pathname.slice(base.length) || "/");
}
function _before_navigate({ url, type: type2, intent, delta }) {
  let should_block = false;
  const nav = create_navigation(current, intent, url, type2);
  if (delta !== void 0) {
    nav.navigation.delta = delta;
  }
  const cancellable = {
    ...nav.navigation,
    cancel: () => {
      should_block = true;
      nav.reject(new Error("navigation cancelled"));
    }
  };
  if (!navigating) {
    before_navigate_callbacks.forEach((fn) => fn(cancellable));
  }
  return should_block ? null : nav;
}
async function navigate({
  type: type2,
  url,
  popped,
  keepfocus,
  noscroll,
  replace_state,
  state = {},
  redirect_count = 0,
  nav_token = {},
  accept = noop$3,
  block = noop$3
}) {
  const intent = get_navigation_intent(url, false);
  const nav = _before_navigate({ url, type: type2, delta: popped == null ? void 0 : popped.delta, intent });
  if (!nav) {
    block();
    return;
  }
  const previous_history_index = current_history_index;
  const previous_navigation_index = current_navigation_index;
  accept();
  navigating = true;
  if (started) {
    stores.navigating.set(nav.navigation);
  }
  token = nav_token;
  let navigation_result = intent && await load_route(intent);
  if (!navigation_result) {
    if (is_external_url(url, base)) {
      return await native_navigation(url);
    }
    navigation_result = await server_fallback(
      url,
      { id: null },
      await handle_error(new SvelteKitError(404, "Not Found", `Not found: ${url.pathname}`), {
        url,
        params: {},
        route: { id: null }
      }),
      404
    );
  }
  url = (intent == null ? void 0 : intent.url) || url;
  if (token !== nav_token) {
    nav.reject(new Error("navigation aborted"));
    return false;
  }
  if (navigation_result.type === "redirect") {
    if (redirect_count >= 20) {
      navigation_result = await load_root_error_page({
        status: 500,
        error: await handle_error(new Error("Redirect loop"), {
          url,
          params: {},
          route: { id: null }
        }),
        url,
        route: { id: null }
      });
    } else {
      _goto(new URL(navigation_result.location, url).href, {}, redirect_count + 1, nav_token);
      return false;
    }
  } else if (
    /** @type {number} */
    navigation_result.props.page.status >= 400
  ) {
    const updated = await stores.updated.check();
    if (updated) {
      await native_navigation(url);
    }
  }
  reset_invalidation();
  update_scroll_positions(previous_history_index);
  capture_snapshot(previous_navigation_index);
  if (navigation_result.props.page.url.pathname !== url.pathname) {
    url.pathname = navigation_result.props.page.url.pathname;
  }
  state = popped ? popped.state : state;
  if (!popped) {
    const change = replace_state ? 0 : 1;
    const entry = {
      [HISTORY_INDEX]: current_history_index += change,
      [NAVIGATION_INDEX]: current_navigation_index += change,
      [STATES_KEY]: state
    };
    const fn = replace_state ? history.replaceState : history.pushState;
    fn.call(history, entry, "", url);
    if (!replace_state) {
      clear_onward_history(current_history_index, current_navigation_index);
    }
  }
  load_cache = null;
  navigation_result.props.page.state = state;
  if (started) {
    current = navigation_result.state;
    if (navigation_result.props.page) {
      navigation_result.props.page.url = url;
    }
    const after_navigate = (await Promise.all(
      on_navigate_callbacks.map(
        (fn) => fn(
          /** @type {import('@sveltejs/kit').OnNavigate} */
          nav.navigation
        )
      )
    )).filter(
      /** @returns {value is () => void} */
      (value) => typeof value === "function"
    );
    if (after_navigate.length > 0) {
      let cleanup = function() {
        after_navigate_callbacks = after_navigate_callbacks.filter(
          // @ts-ignore
          (fn) => !after_navigate.includes(fn)
        );
      };
      after_navigate.push(cleanup);
      after_navigate_callbacks.push(...after_navigate);
    }
    root$1.$set(navigation_result.props);
    has_navigated = true;
  } else {
    initialize(navigation_result, target);
  }
  const { activeElement } = document;
  await tick();
  const scroll = popped ? popped.scroll : noscroll ? scroll_state() : null;
  if (autoscroll) {
    const deep_linked = url.hash && document.getElementById(decodeURIComponent(url.hash.slice(1)));
    if (scroll) {
      scrollTo(scroll.x, scroll.y);
    } else if (deep_linked) {
      deep_linked.scrollIntoView();
    } else {
      scrollTo(0, 0);
    }
  }
  const changed_focus = (
    // reset focus only if any manual focus management didn't override it
    document.activeElement !== activeElement && // also refocus when activeElement is body already because the
    // focus event might not have been fired on it yet
    document.activeElement !== document.body
  );
  if (!keepfocus && !changed_focus) {
    reset_focus();
  }
  autoscroll = true;
  if (navigation_result.props.page) {
    page$1 = navigation_result.props.page;
  }
  navigating = false;
  if (type2 === "popstate") {
    restore_snapshot(current_navigation_index);
  }
  nav.fulfil(void 0);
  after_navigate_callbacks.forEach(
    (fn) => fn(
      /** @type {import('@sveltejs/kit').AfterNavigate} */
      nav.navigation
    )
  );
  stores.navigating.set(null);
}
async function server_fallback(url, route, error, status) {
  if (url.origin === origin && url.pathname === location.pathname && !hydrated) {
    return await load_root_error_page({
      status,
      error,
      url,
      route
    });
  }
  return await native_navigation(url);
}
function setup_preload() {
  let mousemove_timeout;
  container.addEventListener("mousemove", (event) => {
    const target2 = (
      /** @type {Element} */
      event.target
    );
    clearTimeout(mousemove_timeout);
    mousemove_timeout = setTimeout(() => {
      preload2(target2, 2);
    }, 20);
  });
  function tap(event) {
    preload2(
      /** @type {Element} */
      event.composedPath()[0],
      1
    );
  }
  container.addEventListener("mousedown", tap);
  container.addEventListener("touchstart", tap, { passive: true });
  const observer = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (entry.isIntersecting) {
          _preload_code(
            /** @type {HTMLAnchorElement} */
            entry.target.href
          );
          observer.unobserve(entry.target);
        }
      }
    },
    { threshold: 0 }
  );
  function preload2(element2, priority) {
    const a = find_anchor(element2, container);
    if (!a)
      return;
    const { url, external, download } = get_link_info(a, base);
    if (external || download)
      return;
    const options = get_router_options(a);
    if (!options.reload) {
      if (priority <= options.preload_data) {
        const intent = get_navigation_intent(url, false);
        if (intent) {
          {
            _preload_data(intent);
          }
        }
      } else if (priority <= options.preload_code) {
        _preload_code(
          /** @type {URL} */
          url.pathname
        );
      }
    }
  }
  function after_navigate() {
    observer.disconnect();
    for (const a of container.querySelectorAll("a")) {
      const { url, external, download } = get_link_info(a, base);
      if (external || download)
        continue;
      const options = get_router_options(a);
      if (options.reload)
        continue;
      if (options.preload_code === PRELOAD_PRIORITIES.viewport) {
        observer.observe(a);
      }
      if (options.preload_code === PRELOAD_PRIORITIES.eager) {
        _preload_code(
          /** @type {URL} */
          url.pathname
        );
      }
    }
  }
  after_navigate_callbacks.push(after_navigate);
  after_navigate();
}
function handle_error(error, event) {
  if (error instanceof HttpError) {
    return error.body;
  }
  const status = get_status(error);
  const message = get_message(error);
  return app.hooks.handleError({ error, event, status, message }) ?? /** @type {any} */
  { message };
}
function goto(url, opts = {}) {
  url = resolve_url(url);
  if (url.origin !== origin) {
    return Promise.reject(
      new Error(
        "goto: invalid URL"
      )
    );
  }
  return _goto(url, opts, 0);
}
function _start_router() {
  var _a2;
  history.scrollRestoration = "manual";
  addEventListener("beforeunload", (e) => {
    let should_block = false;
    persist_state();
    if (!navigating) {
      const nav = create_navigation(current, void 0, null, "leave");
      const navigation = {
        ...nav.navigation,
        cancel: () => {
          should_block = true;
          nav.reject(new Error("navigation cancelled"));
        }
      };
      before_navigate_callbacks.forEach((fn) => fn(navigation));
    }
    if (should_block) {
      e.preventDefault();
      e.returnValue = "";
    } else {
      history.scrollRestoration = "auto";
    }
  });
  addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") {
      persist_state();
    }
  });
  if (!((_a2 = navigator.connection) == null ? void 0 : _a2.saveData)) {
    setup_preload();
  }
  container.addEventListener("click", (event) => {
    var _a3;
    if (event.button || event.which !== 1)
      return;
    if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey)
      return;
    if (event.defaultPrevented)
      return;
    const a = find_anchor(
      /** @type {Element} */
      event.composedPath()[0],
      container
    );
    if (!a)
      return;
    const { url, external, target: target2, download } = get_link_info(a, base);
    if (!url)
      return;
    if (target2 === "_parent" || target2 === "_top") {
      if (window.parent !== window)
        return;
    } else if (target2 && target2 !== "_self") {
      return;
    }
    const options = get_router_options(a);
    const is_svg_a_element = a instanceof SVGAElement;
    if (!is_svg_a_element && url.protocol !== location.protocol && !(url.protocol === "https:" || url.protocol === "http:"))
      return;
    if (download)
      return;
    if (external || options.reload) {
      if (_before_navigate({ url, type: "link" })) {
        navigating = true;
      } else {
        event.preventDefault();
      }
      return;
    }
    const [nonhash, hash2] = url.href.split("#");
    if (hash2 !== void 0 && nonhash === strip_hash(location)) {
      const [, current_hash] = current.url.href.split("#");
      if (current_hash === hash2) {
        event.preventDefault();
        if (hash2 === "" || hash2 === "top" && a.ownerDocument.getElementById("top") === null) {
          window.scrollTo({ top: 0 });
        } else {
          (_a3 = a.ownerDocument.getElementById(hash2)) == null ? void 0 : _a3.scrollIntoView();
        }
        return;
      }
      hash_navigating = true;
      update_scroll_positions(current_history_index);
      update_url(url);
      if (!options.replace_state)
        return;
      hash_navigating = false;
    }
    event.preventDefault();
    navigate({
      type: "link",
      url,
      keepfocus: options.keepfocus,
      noscroll: options.noscroll,
      replace_state: options.replace_state ?? url.href === location.href
    });
  });
  container.addEventListener("submit", (event) => {
    if (event.defaultPrevented)
      return;
    const form = (
      /** @type {HTMLFormElement} */
      HTMLFormElement.prototype.cloneNode.call(event.target)
    );
    const submitter = (
      /** @type {HTMLButtonElement | HTMLInputElement | null} */
      event.submitter
    );
    const method = (submitter == null ? void 0 : submitter.formMethod) || form.method;
    if (method !== "get")
      return;
    const url = new URL(
      (submitter == null ? void 0 : submitter.hasAttribute("formaction")) && (submitter == null ? void 0 : submitter.formAction) || form.action
    );
    if (is_external_url(url, base))
      return;
    const event_form = (
      /** @type {HTMLFormElement} */
      event.target
    );
    const options = get_router_options(event_form);
    if (options.reload)
      return;
    event.preventDefault();
    event.stopPropagation();
    const data = new FormData(event_form);
    const submitter_name = submitter == null ? void 0 : submitter.getAttribute("name");
    if (submitter_name) {
      data.append(submitter_name, (submitter == null ? void 0 : submitter.getAttribute("value")) ?? "");
    }
    url.search = new URLSearchParams(data).toString();
    navigate({
      type: "form",
      url,
      keepfocus: options.keepfocus,
      noscroll: options.noscroll,
      replace_state: options.replace_state ?? url.href === location.href
    });
  });
  addEventListener("popstate", async (event) => {
    var _a3;
    if ((_a3 = event.state) == null ? void 0 : _a3[HISTORY_INDEX]) {
      const history_index = event.state[HISTORY_INDEX];
      token = {};
      if (history_index === current_history_index)
        return;
      const scroll = scroll_positions[history_index];
      const state = event.state[STATES_KEY] ?? {};
      const url = new URL(event.state[PAGE_URL_KEY] ?? location.href);
      const navigation_index = event.state[NAVIGATION_INDEX];
      const is_hash_change = strip_hash(location) === strip_hash(current.url);
      const shallow = navigation_index === current_navigation_index && (has_navigated || is_hash_change);
      if (shallow) {
        update_url(url);
        scroll_positions[current_history_index] = scroll_state();
        if (scroll)
          scrollTo(scroll.x, scroll.y);
        if (state !== page$1.state) {
          page$1 = { ...page$1, state };
          root$1.$set({ page: page$1 });
        }
        current_history_index = history_index;
        return;
      }
      const delta = history_index - current_history_index;
      await navigate({
        type: "popstate",
        url,
        popped: {
          state,
          scroll,
          delta
        },
        accept: () => {
          current_history_index = history_index;
          current_navigation_index = navigation_index;
        },
        block: () => {
          history.go(-delta);
        },
        nav_token: token
      });
    } else {
      if (!hash_navigating) {
        const url = new URL(location.href);
        update_url(url);
      }
    }
  });
  addEventListener("hashchange", () => {
    if (hash_navigating) {
      hash_navigating = false;
      history.replaceState(
        {
          ...history.state,
          [HISTORY_INDEX]: ++current_history_index,
          [NAVIGATION_INDEX]: current_navigation_index
        },
        "",
        location.href
      );
    }
  });
  for (const link of document.querySelectorAll("link")) {
    if (link.rel === "icon")
      link.href = link.href;
  }
  addEventListener("pageshow", (event) => {
    if (event.persisted) {
      stores.navigating.set(null);
    }
  });
  function update_url(url) {
    current.url = url;
    stores.page.set({ ...page$1, url });
    stores.page.notify();
  }
}
async function _hydrate(target2, { status = 200, error, node_ids, params, route, data: server_data_nodes, form }) {
  hydrated = true;
  const url = new URL(location.href);
  {
    ({ params = {}, route = { id: null } } = get_navigation_intent(url, false) || {});
  }
  let result;
  try {
    const branch_promises = node_ids.map(async (n, i) => {
      const server_data_node = server_data_nodes[i];
      if (server_data_node == null ? void 0 : server_data_node.uses) {
        server_data_node.uses = deserialize_uses(server_data_node.uses);
      }
      return load_node({
        loader: app.nodes[n],
        url,
        params,
        route,
        parent: async () => {
          const data = {};
          for (let j = 0; j < i; j += 1) {
            Object.assign(data, (await branch_promises[j]).data);
          }
          return data;
        },
        server_data_node: create_data_node(server_data_node)
      });
    });
    const branch = await Promise.all(branch_promises);
    const parsed_route = routes.find(({ id: id2 }) => id2 === route.id);
    if (parsed_route) {
      const layouts2 = parsed_route.layouts;
      for (let i = 0; i < layouts2.length; i++) {
        if (!layouts2[i]) {
          branch.splice(i, 0, void 0);
        }
      }
    }
    result = await get_navigation_result_from_branch({
      url,
      params,
      branch,
      status,
      error,
      form,
      route: parsed_route ?? null
    });
  } catch (error2) {
    if (error2 instanceof Redirect) {
      await native_navigation(new URL(error2.location, location.href));
      return;
    }
    result = await load_root_error_page({
      status: get_status(error2),
      error: await handle_error(error2, { url, params, route }),
      url,
      route
    });
  }
  if (result.props.page) {
    result.props.page.state = {};
  }
  initialize(result, target2);
}
async function load_data(url, invalid) {
  var _a2;
  const data_url = new URL(url);
  data_url.pathname = add_data_suffix(url.pathname);
  if (url.pathname.endsWith("/")) {
    data_url.searchParams.append(TRAILING_SLASH_PARAM, "1");
  }
  data_url.searchParams.append(INVALIDATED_PARAM, invalid.map((i) => i ? "1" : "0").join(""));
  const res = await native_fetch(data_url.href);
  if (!res.ok) {
    let message;
    if ((_a2 = res.headers.get("content-type")) == null ? void 0 : _a2.includes("application/json")) {
      message = await res.json();
    } else if (res.status === 404) {
      message = "Not Found";
    } else if (res.status === 500) {
      message = "Internal Error";
    }
    throw new HttpError(res.status, message);
  }
  return new Promise(async (resolve2) => {
    var _a3;
    const deferreds = /* @__PURE__ */ new Map();
    const reader = (
      /** @type {ReadableStream<Uint8Array>} */
      res.body.getReader()
    );
    const decoder = new TextDecoder();
    function deserialize(data) {
      return unflatten(data, {
        Promise: (id2) => {
          return new Promise((fulfil, reject) => {
            deferreds.set(id2, { fulfil, reject });
          });
        }
      });
    }
    let text2 = "";
    while (true) {
      const { done, value } = await reader.read();
      if (done && !text2)
        break;
      text2 += !value && text2 ? "\n" : decoder.decode(value, { stream: true });
      while (true) {
        const split = text2.indexOf("\n");
        if (split === -1) {
          break;
        }
        const node = JSON.parse(text2.slice(0, split));
        text2 = text2.slice(split + 1);
        if (node.type === "redirect") {
          return resolve2(node);
        }
        if (node.type === "data") {
          (_a3 = node.nodes) == null ? void 0 : _a3.forEach((node2) => {
            if ((node2 == null ? void 0 : node2.type) === "data") {
              node2.uses = deserialize_uses(node2.uses);
              node2.data = deserialize(node2.data);
            }
          });
          resolve2(node);
        } else if (node.type === "chunk") {
          const { id: id2, data, error } = node;
          const deferred = (
            /** @type {import('types').Deferred} */
            deferreds.get(id2)
          );
          deferreds.delete(id2);
          if (error) {
            deferred.reject(deserialize(error));
          } else {
            deferred.fulfil(deserialize(data));
          }
        }
      }
    }
  });
}
function deserialize_uses(uses) {
  return {
    dependencies: new Set((uses == null ? void 0 : uses.dependencies) ?? []),
    params: new Set((uses == null ? void 0 : uses.params) ?? []),
    parent: !!(uses == null ? void 0 : uses.parent),
    route: !!(uses == null ? void 0 : uses.route),
    url: !!(uses == null ? void 0 : uses.url),
    search_params: new Set((uses == null ? void 0 : uses.search_params) ?? [])
  };
}
function reset_focus() {
  const autofocus = document.querySelector("[autofocus]");
  if (autofocus) {
    autofocus.focus();
  } else {
    const root2 = document.body;
    const tabindex = root2.getAttribute("tabindex");
    root2.tabIndex = -1;
    root2.focus({ preventScroll: true, focusVisible: false });
    if (tabindex !== null) {
      root2.setAttribute("tabindex", tabindex);
    } else {
      root2.removeAttribute("tabindex");
    }
    const selection2 = getSelection();
    if (selection2 && selection2.type !== "None") {
      const ranges = [];
      for (let i = 0; i < selection2.rangeCount; i += 1) {
        ranges.push(selection2.getRangeAt(i));
      }
      setTimeout(() => {
        if (selection2.rangeCount !== ranges.length)
          return;
        for (let i = 0; i < selection2.rangeCount; i += 1) {
          const a = ranges[i];
          const b = selection2.getRangeAt(i);
          if (a.commonAncestorContainer !== b.commonAncestorContainer || a.startContainer !== b.startContainer || a.endContainer !== b.endContainer || a.startOffset !== b.startOffset || a.endOffset !== b.endOffset) {
            return;
          }
        }
        selection2.removeAllRanges();
      });
    }
  }
}
function create_navigation(current2, intent, url, type2) {
  var _a2, _b2;
  let fulfil;
  let reject;
  const complete = new Promise((f, r) => {
    fulfil = f;
    reject = r;
  });
  complete.catch(() => {
  });
  const navigation = {
    from: {
      params: current2.params,
      route: { id: ((_a2 = current2.route) == null ? void 0 : _a2.id) ?? null },
      url: current2.url
    },
    to: url && {
      params: (intent == null ? void 0 : intent.params) ?? null,
      route: { id: ((_b2 = intent == null ? void 0 : intent.route) == null ? void 0 : _b2.id) ?? null },
      url
    },
    willUnload: !intent,
    type: type2,
    complete
  };
  return {
    navigation,
    // @ts-expect-error
    fulfil,
    // @ts-expect-error
    reject
  };
}
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise2 = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    promise2 = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link2 = links[i];
          if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link.as = "script";
        link.crossOrigin = "";
      }
      link.href = dep;
      document.head.appendChild(link);
      if (isCss) {
        return new Promise((res, rej) => {
          link.addEventListener("load", res);
          link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise2.then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
const getStores = () => {
  const stores$1 = stores;
  return {
    /** @type {typeof page} */
    page: {
      subscribe: stores$1.page.subscribe
    },
    /** @type {typeof navigating} */
    navigating: {
      subscribe: stores$1.navigating.subscribe
    },
    /** @type {typeof updated} */
    updated: stores$1.updated
  };
};
const page = {
  subscribe(fn) {
    const store = getStores().page;
    return store.subscribe(fn);
  }
};
function create_fragment$8(ctx) {
  var _a2;
  let h12;
  let t0_value = (
    /*$page*/
    ctx[0].status + ""
  );
  let t0;
  let t1;
  let p;
  let t2_value = (
    /*$page*/
    ((_a2 = ctx[0].error) == null ? void 0 : _a2.message) + ""
  );
  let t2;
  return {
    c() {
      h12 = element("h1");
      t0 = text(t0_value);
      t1 = space();
      p = element("p");
      t2 = text(t2_value);
    },
    l(nodes) {
      h12 = claim_element(nodes, "H1", {});
      var h1_nodes = children$1(h12);
      t0 = claim_text(h1_nodes, t0_value);
      h1_nodes.forEach(detach);
      t1 = claim_space(nodes);
      p = claim_element(nodes, "P", {});
      var p_nodes = children$1(p);
      t2 = claim_text(p_nodes, t2_value);
      p_nodes.forEach(detach);
    },
    m(target2, anchor) {
      insert_hydration(target2, h12, anchor);
      append_hydration(h12, t0);
      insert_hydration(target2, t1, anchor);
      insert_hydration(target2, p, anchor);
      append_hydration(p, t2);
    },
    p(ctx2, [dirty]) {
      var _a3;
      if (dirty & /*$page*/
      1 && t0_value !== (t0_value = /*$page*/
      ctx2[0].status + ""))
        set_data(t0, t0_value);
      if (dirty & /*$page*/
      1 && t2_value !== (t2_value = /*$page*/
      ((_a3 = ctx2[0].error) == null ? void 0 : _a3.message) + ""))
        set_data(t2, t2_value);
    },
    i: noop$4,
    o: noop$4,
    d(detaching) {
      if (detaching) {
        detach(h12);
        detach(t1);
        detach(p);
      }
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $page;
  component_subscribe($$self, page, ($$value) => $$invalidate(0, $page = $$value));
  return [$page];
}
let Error$1 = class Error2 extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$8, create_fragment$8, safe_not_equal, {});
  }
};
var mapboxGl = { exports: {} };
(function(module, exports) {
  var define_process_env_default = {};
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define2(_, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define2(["exports"], function(t) {
      var e = "3.2.0";
      let r;
      const n = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (null == r) {
          const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            r = null != define_process_env_default.API_URL_REGEX ? new RegExp(define_process_env_default.API_URL_REGEX) : t2;
          } catch (e22) {
            r = t2;
          }
        }
        return r;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!n.API_URL)
          return null;
        try {
          const t2 = new URL(n.API_URL);
          return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
        } catch (t2) {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf" }, i = { supported: false, testSupport: function(t2) {
        !o && a && (l ? c(t2) : s = t2);
      } };
      let s, a, o = false, l = false;
      const u = "undefined" != typeof self ? self : {};
      function c(t2) {
        const e22 = t2.createTexture();
        t2.bindTexture(t2.TEXTURE_2D, e22);
        try {
          if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, a), t2.isContextLost())
            return;
          i.supported = true;
        } catch (t3) {
        }
        t2.deleteTexture(e22), o = true;
      }
      u.document && (a = u.document.createElement("img"), a.onload = function() {
        s && c(s), s = null, l = true;
      }, a.onerror = function() {
        o = true, s = null;
      }, a.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const h = "01";
      function p(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      var f = d;
      function d(t2, e22, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e22, this.by = 3 * (n2 - e22) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e22, this.p2x = r2, this.p2y = n2;
      }
      d.prototype = { sampleCurveX: function(t2) {
        return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
      }, sampleCurveY: function(t2) {
        return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
      }, sampleCurveDerivativeX: function(t2) {
        return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
      }, solveCurveX: function(t2, e22) {
        if (void 0 === e22 && (e22 = 1e-6), t2 < 0)
          return 0;
        if (t2 > 1)
          return 1;
        for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
          var i2 = this.sampleCurveX(r2) - t2;
          if (Math.abs(i2) < e22)
            return r2;
          var s2 = this.sampleCurveDerivativeX(r2);
          if (Math.abs(s2) < 1e-6)
            break;
          r2 -= i2 / s2;
        }
        var a2 = 0, o2 = 1;
        for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e22)); n2++)
          t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
        return r2;
      }, solve: function(t2, e22) {
        return this.sampleCurveY(this.solveCurveX(t2, e22));
      } };
      var m = p(f), y = g;
      function g(t2, e22) {
        this.x = t2, this.y = e22;
      }
      g.prototype = { clone: function() {
        return new g(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e22) {
        return this.clone()._rotateAround(t2, e22);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e22 = t2.x - this.x, r2 = t2.y - this.y;
        return e22 * e22 + r2 * r2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e22) {
        return Math.atan2(this.x * e22 - this.y * t2, this.x * t2 + this.y * e22);
      }, _matMult: function(t2) {
        var e22 = t2[2] * this.x + t2[3] * this.y;
        return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e22, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e22 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e22 * this.y;
        return this.x = e22 * this.x - r2 * this.y, this.y = n2, this;
      }, _rotateAround: function(t2, e22) {
        var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e22.y + n2 * (this.x - e22.x) + r2 * (this.y - e22.y);
        return this.x = e22.x + r2 * (this.x - e22.x) - n2 * (this.y - e22.y), this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, g.convert = function(t2) {
        return t2 instanceof g ? t2 : Array.isArray(t2) ? new g(t2[0], t2[1]) : t2;
      };
      var x = p(y);
      const v = Math.PI / 180, b = 180 / Math.PI;
      function _(t2) {
        return t2 * v;
      }
      function w(t2) {
        return t2 * b;
      }
      const M = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function A(t2) {
        if (t2 <= 0)
          return 0;
        if (t2 >= 1)
          return 1;
        const e22 = t2 * t2, r2 = e22 * t2;
        return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e22) + r2 - 0.75);
      }
      function S(t2, e22, r2, n2) {
        const i2 = new m(t2, e22, r2, n2);
        return function(t3) {
          return i2.solve(t3);
        };
      }
      const I = S(0.25, 0.1, 0.25, 1);
      function k(t2, e22, r2) {
        return Math.min(r2, Math.max(e22, t2));
      }
      function T(t2, e22, r2) {
        return (r2 = k((r2 - t2) / (e22 - t2), 0, 1)) * r2 * (3 - 2 * r2);
      }
      function P(t2, e22, r2) {
        const n2 = r2 - e22, i2 = ((t2 - e22) % n2 + n2) % n2 + e22;
        return i2 === e22 ? r2 : i2;
      }
      function z(t2, e22, r2) {
        if (!t2.length)
          return r2(null, []);
        let n2 = t2.length;
        const i2 = new Array(t2.length);
        let s2 = null;
        t2.forEach((t3, a2) => {
          e22(t3, (t4, e3) => {
            t4 && (s2 = t4), i2[a2] = e3, 0 == --n2 && r2(s2, i2);
          });
        });
      }
      function E(t2) {
        const e22 = [];
        for (const r2 in t2)
          e22.push(t2[r2]);
        return e22;
      }
      function B(t2, ...e22) {
        for (const r2 of e22)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      let D = 1;
      function C() {
        return D++;
      }
      function R() {
        return function t2(e22) {
          return e22 ? (e22 ^ Math.random() * (16 >> e22 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
        }();
      }
      function L(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }
      function V(t2) {
        return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
      }
      function O(t2, e22) {
        t2.forEach((t3) => {
          e22[t3] && (e22[t3] = e22[t3].bind(e22));
        });
      }
      function F(t2, e22) {
        return -1 !== t2.indexOf(e22, t2.length - e22.length);
      }
      function j(t2, e22, r2) {
        const n2 = {};
        for (const i2 in t2)
          n2[i2] = e22.call(r2 || this, t2[i2], i2, t2);
        return n2;
      }
      function U(t2, e22, r2) {
        const n2 = {};
        for (const i2 in t2)
          e22.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
        return n2;
      }
      function N(t2) {
        return Array.isArray(t2) ? t2.map(N) : "object" == typeof t2 && t2 ? j(t2, N) : t2;
      }
      const $ = {};
      function q(t2) {
        $[t2] || ("undefined" != typeof console && console.warn(t2), $[t2] = true);
      }
      function G(t2, e22, r2) {
        return (r2.y - t2.y) * (e22.x - t2.x) > (e22.y - t2.y) * (r2.x - t2.x);
      }
      function Y(t2) {
        let e22 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e22 += (n2.x - r2.x) * (r2.y + n2.y);
        return e22;
      }
      function Z([t2, e22, r2]) {
        const n2 = _(e22 + 90), i2 = _(r2);
        return { x: t2 * Math.cos(n2) * Math.sin(i2), y: t2 * Math.sin(n2) * Math.sin(i2), z: t2 * Math.cos(i2), azimuthal: e22, polar: r2 };
      }
      function X() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      function K(t2) {
        const e22 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
          const s2 = n2 || i2;
          return e22[r2] = !s2 || s2.toLowerCase(), "";
        }), e22["max-age"]) {
          const t3 = parseInt(e22["max-age"], 10);
          isNaN(t3) ? delete e22["max-age"] : e22["max-age"] = t3;
        }
        return e22;
      }
      let W = null;
      function H(t2) {
        try {
          const e22 = self[t2];
          return e22.setItem("_mapbox_test_", 1), e22.removeItem("_mapbox_test_"), true;
        } catch (t3) {
          return false;
        }
      }
      function J(t2, e22) {
        return [t2[4 * e22], t2[4 * e22 + 1], t2[4 * e22 + 2], t2[4 * e22 + 3]];
      }
      function Q(t2, e22, r2, n2) {
        for (; e22 < r2; ) {
          const i2 = e22 + r2 >> 1;
          t2[i2] < n2 ? e22 = i2 + 1 : r2 = i2;
        }
        return e22;
      }
      function tt(t2, e22, r2, n2) {
        for (; e22 < r2; ) {
          const i2 = e22 + r2 >> 1;
          t2[i2] <= n2 ? e22 = i2 + 1 : r2 = i2;
        }
        return e22;
      }
      const et = "mapbox-tiles";
      let rt = 500, nt = 50;
      let it, st;
      function at() {
        try {
          return caches;
        } catch (t2) {
        }
      }
      function ot() {
        const t2 = at();
        t2 && !it && (it = t2.open(et));
      }
      function lt(t2) {
        const e22 = t2.indexOf("?");
        if (e22 < 0)
          return t2;
        const r2 = function(t3) {
          const e3 = t3.indexOf("?");
          return e3 > 0 ? t3.slice(e3 + 1).split("&") : [];
        }(t2), n2 = r2.filter((t3) => {
          const e3 = t3.split("=");
          return "language" === e3[0] || "worldview" === e3[0];
        });
        return n2.length ? `${t2.slice(0, e22)}?${n2.join("&")}` : t2.slice(0, e22);
      }
      let ut = 1 / 0;
      const ct = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image", Model: "Model" };
      "function" == typeof Object.freeze && Object.freeze(ct);
      class ht extends Error {
        constructor(t2, e22, r2) {
          401 === e22 && wt(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e22, this.url = r2;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const pt = X() ? () => self.worker && self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
      const ft = function(t2, e22) {
        if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(pt()) && !/^\w+:/.test(r2))) {
          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
            return function(t3, e3) {
              const r3 = new AbortController(), n2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: pt(), referrerPolicy: t3.referrerPolicy, signal: r3.signal });
              let i2 = false, s2 = false;
              const a2 = (o2 = n2.url).indexOf("sku=") > 0 && wt(o2);
              var o2;
              "json" === t3.type && n2.headers.set("Accept", "application/json");
              const l2 = (r4, i3, o3) => {
                if (s2)
                  return;
                if (r4 && "SecurityError" !== r4.message && q(r4.toString()), i3 && o3)
                  return u2(i3);
                const l3 = Date.now();
                fetch(n2).then((r5) => {
                  if (r5.ok) {
                    const t4 = a2 ? r5.clone() : null;
                    return u2(r5, t4, l3);
                  }
                  return e3(new ht(r5.statusText, r5.status, t3.url));
                }).catch((r5) => {
                  "AbortError" !== r5.name && e3(new Error(`${r5.message} ${t3.url}`));
                });
              }, u2 = (r4, a3, o3) => {
                ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                  s2 || (a3 && o3 && function(t5, e4, r5) {
                    if (ot(), !it)
                      return;
                    const n3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                    e4.headers.forEach((t6, e52) => n3.headers.set(e52, t6));
                    const i3 = K(e4.headers.get("Cache-Control") || "");
                    if (i3["no-store"])
                      return;
                    i3["max-age"] && n3.headers.set("Expires", new Date(r5 + 1e3 * i3["max-age"]).toUTCString());
                    const s3 = n3.headers.get("Expires");
                    s3 && (new Date(s3).getTime() - r5 < 42e4 || function(t6, e52) {
                      if (void 0 === st)
                        try {
                          new Response(new ReadableStream()), st = true;
                        } catch (t7) {
                          st = false;
                        }
                      st ? e52(t6.body) : t6.blob().then(e52);
                    }(e4, (e52) => {
                      const r6 = new Response(e52, n3);
                      ot(), it && it.then((e6) => e6.put(lt(t5.url), r6)).catch((t6) => q(t6.message));
                    }));
                  }(n2, a3, o3), i2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                }).catch((t4) => {
                  s2 || e3(new Error(t4.message));
                });
              };
              return a2 ? function(t4, e4) {
                if (ot(), !it)
                  return e4(null);
                const r4 = lt(t4.url);
                it.then((t5) => {
                  t5.match(r4).then((n3) => {
                    const i3 = function(t6) {
                      if (!t6)
                        return false;
                      const e52 = new Date(t6.headers.get("Expires") || 0), r5 = K(t6.headers.get("Cache-Control") || "");
                      return e52 > Date.now() && !r5["no-cache"];
                    }(n3);
                    t5.delete(r4), i3 && t5.put(r4, n3.clone()), e4(null, n3, i3);
                  }).catch(e4);
                }).catch(e4);
              }(n2, l2) : l2(null, null), { cancel: () => {
                s2 = true, i2 || r3.abort();
              } };
            }(t2, e22);
          if (X() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t2, e22, void 0, true);
        }
        var r2;
        return function(t3, e3) {
          const r3 = new XMLHttpRequest();
          r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
          for (const e4 in t3.headers)
            r3.setRequestHeader(e4, t3.headers[e4]);
          return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
            e3(new Error(r3.statusText));
          }, r3.onload = () => {
            if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
              let n2 = r3.response;
              if ("json" === t3.type)
                try {
                  n2 = JSON.parse(r3.response);
                } catch (t4) {
                  return e3(t4);
                }
              e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
            } else
              e3(new ht(r3.statusText, r3.status, t3.url));
          }, r3.send(t3.body), { cancel: () => r3.abort() };
        }(t2, e22);
      }, dt = function(t2, e22) {
        return ft(B(t2, { type: "arrayBuffer" }), e22);
      };
      function mt(t2) {
        const e22 = document.createElement("a");
        return e22.href = t2, e22.protocol === location.protocol && e22.host === location.host;
      }
      const yt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let gt, xt;
      gt = [], xt = 0;
      const vt = function(t2, e22) {
        if (i.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), xt >= n.MAX_PARALLEL_IMAGE_REQUESTS) {
          const r3 = { requestParameters: t2, callback: e22, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return gt.push(r3), r3;
        }
        xt++;
        let r2 = false;
        const s2 = () => {
          if (!r2)
            for (r2 = true, xt--; gt.length && xt < n.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t3 = gt.shift(), { requestParameters: e3, callback: r3, cancelled: n2 } = t3;
              n2 || (t3.cancel = vt(e3, r3).cancel);
            }
        }, a2 = dt(t2, (t3, r3, n2, i2) => {
          s2(), t3 ? e22(t3) : r3 && (self.createImageBitmap ? function(t4, e3) {
            const r4 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            createImageBitmap(r4).then((t5) => {
              e3(null, t5);
            }).catch((t5) => {
              e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(r3, (t4, r4) => e22(t4, r4, n2, i2)) : function(t4, e3) {
            const r4 = new Image();
            r4.onload = () => {
              e3(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, requestAnimationFrame(() => {
                r4.src = yt;
              });
            }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            r4.src = t4.byteLength ? URL.createObjectURL(n3) : yt;
          }(r3, (t4, r4) => e22(t4, r4, n2, i2)));
        });
        return { cancel: () => {
          a2.cancel(), s2();
        } };
      }, bt = "NO_ACCESS_TOKEN";
      function _t(t2) {
        return 0 === t2.indexOf("mapbox:");
      }
      function wt(t2) {
        return n.API_URL_REGEX.test(t2);
      }
      function Mt(t2) {
        return n.API_CDN_URL_REGEX.test(t2);
      }
      function At(t2) {
        return n.API_STYLE_REGEX.test(t2) && !St(t2);
      }
      function St(t2) {
        return n.API_SPRITE_REGEX.test(t2);
      }
      const It = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function kt(t2) {
        const e22 = t2.match(It);
        if (!e22)
          throw new Error("Unable to parse URL object");
        return { protocol: e22[1], authority: e22[2], path: e22[3] || "/", params: e22[4] ? e22[4].split("&") : [] };
      }
      function Tt(t2) {
        const e22 = t2.params.length ? `?${t2.params.join("&")}` : "";
        return `${t2.protocol}://${t2.authority}${t2.path}${e22}`;
      }
      const Pt = "mapbox.eventData";
      function zt(t2) {
        if (!t2)
          return null;
        const e22 = t2.split(".");
        if (!e22 || 3 !== e22.length)
          return null;
        try {
          return JSON.parse(decodeURIComponent(atob(e22[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch (t3) {
          return null;
        }
      }
      class Et {
        constructor(t2) {
          this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t2) {
          const e22 = zt(n.ACCESS_TOKEN);
          let r2 = "";
          return r2 = e22 && e22.u ? btoa(encodeURIComponent(e22.u).replace(/%([0-9A-F]{2})/g, (t3, e3) => String.fromCharCode(Number("0x" + e3)))) : n.ACCESS_TOKEN || "", t2 ? `${Pt}.${t2}:${r2}` : `${Pt}:${r2}`;
        }
        fetchEventData() {
          const t2 = H("localStorage"), e22 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              const t3 = localStorage.getItem(e22);
              t3 && (this.eventData = JSON.parse(t3));
              const n2 = localStorage.getItem(r2);
              n2 && (this.anonId = n2);
            } catch (t3) {
              q("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t2 = H("localStorage"), e22 = this.getStorageKey(), r2 = this.getStorageKey("uuid"), n2 = this.anonId;
          if (t2 && n2)
            try {
              localStorage.setItem(r2, n2), Object.keys(this.eventData).length >= 1 && localStorage.setItem(e22, JSON.stringify(this.eventData));
            } catch (t3) {
              q("Unable to write to LocalStorage");
            }
        }
        processRequests(t2) {
        }
        postEvent(t2, e22, r2, i2) {
          if (!n.EVENTS_URL)
            return;
          const s2 = kt(n.EVENTS_URL);
          s2.params.push(`access_token=${i2 || n.ACCESS_TOKEN || ""}`);
          const a2 = { event: this.type, created: new Date(t2).toISOString() }, o2 = e22 ? B(a2, e22) : a2, l2 = { url: Tt(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
          this.pendingRequest = function(t3, e3) {
            return ft(B(t3, { method: "POST" }), e3);
          }(l2, (t3) => {
            this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(i2);
          });
        }
        queueRequest(t2, e22) {
          this.queue.push(t2), this.processRequests(e22);
        }
      }
      const Bt = new class extends Et {
        constructor(t2) {
          super("appUserTurnstile"), this._customAccessToken = t2;
        }
        postTurnstileEvent(t2, e22) {
          n.EVENTS_URL && n.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => _t(t3) || wt(t3)) && this.queueRequest(Date.now(), e22);
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const r2 = zt(n.ACCESS_TOKEN), i2 = r2 ? r2.u : n.ACCESS_TOKEN;
          let s2 = i2 !== this.eventData.tokenU;
          V(this.anonId) || (this.anonId = R(), s2 = true);
          const a2 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const t3 = new Date(this.eventData.lastSuccess), e22 = new Date(a2), r3 = (a2 - this.eventData.lastSuccess) / 864e5;
            s2 = s2 || r3 >= 1 || r3 < -1 || t3.getDate() !== e22.getDate();
          } else
            s2 = true;
          s2 ? this.postEvent(a2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: e, skuId: h, "enabled.telemetry": false, userId: this.anonId }, (t3) => {
            t3 || (this.eventData.lastSuccess = a2, this.eventData.tokenU = i2);
          }, t2) : this.processRequests();
        }
      }(), Dt = Bt.postTurnstileEvent.bind(Bt), Ct = new class extends Et {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t2, e22, r2, i2) {
          this.skuToken = e22, this.errorCb = i2, n.EVENTS_URL && (r2 || n.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(bt)));
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: r2, timestamp: n2 } = this.queue.shift();
          r2 && this.success[r2] || (this.anonId || this.fetchEventData(), V(this.anonId) || (this.anonId = R()), this.postEvent(n2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: e, skuId: h, skuToken: this.skuToken, userId: this.anonId }, (t3) => {
            t3 ? this.errorCb(t3) : r2 && (this.success[r2] = true);
          }, t2));
        }
      }(), Rt = Ct.postMapLoadEvent.bind(Ct), Lt = new class extends Et {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(t2, e22) {
          n.EVENTS_URL && (t2 || n.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e22 }, t2);
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { timestamp: r2, performanceData: n2 } = this.queue.shift(), i2 = function(t3) {
            const r3 = performance.getEntriesByType("resource"), n3 = performance.getEntriesByType("mark"), i3 = function(t4) {
              const e22 = {};
              if (t4) {
                for (const r4 in t4)
                  if ("other" !== r4)
                    for (const n4 of t4[r4]) {
                      const t5 = `${r4}ResolveRangeMin`, i4 = `${r4}ResolveRangeMax`, s3 = `${r4}RequestCount`, a3 = `${r4}RequestCachedCount`;
                      e22[t5] = Math.min(e22[t5] || 1 / 0, n4.startTime), e22[i4] = Math.max(e22[i4] || -1 / 0, n4.responseEnd);
                      const o3 = (t6) => {
                        void 0 === e22[t6] && (e22[t6] = 0), ++e22[t6];
                      };
                      void 0 !== n4.transferSize && 0 === n4.transferSize && o3(a3), o3(s3);
                    }
              }
              return e22;
            }(function(t4, e22) {
              const r4 = {};
              if (t4)
                for (const n4 of t4) {
                  const t5 = e22(n4);
                  void 0 === r4[t5] && (r4[t5] = []), r4[t5].push(n4);
                }
              return r4;
            }(r3, Nt)), s2 = window.devicePixelRatio, a2 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, o2 = a2 ? a2.effectiveType : void 0, l2 = { counters: [], metadata: [], attributes: [] }, u2 = (t4, e22, r4) => {
              null != r4 && t4.push({ name: e22, value: r4.toString() });
            };
            for (const t4 in i3)
              u2(l2.counters, t4, i3[t4]);
            if (t3.interactionRange[0] !== 1 / 0 && t3.interactionRange[1] !== -1 / 0 && (u2(l2.counters, "interactionRangeMin", t3.interactionRange[0]), u2(l2.counters, "interactionRangeMax", t3.interactionRange[1])), n3)
              for (const t4 of Object.keys(Ut)) {
                const e22 = Ut[t4], r4 = n3.find((t5) => t5.name === e22);
                r4 && u2(l2.counters, e22, r4.startTime);
              }
            return u2(l2.counters, "visibilityHidden", t3.visibilityHidden), u2(l2.attributes, "style", function(t4) {
              if (t4)
                for (const e22 of t4) {
                  const t5 = e22.name.split("?")[0];
                  if (At(t5)) {
                    const e3 = t5.split("/").slice(-2);
                    if (2 === e3.length)
                      return `mapbox://styles/${e3[0]}/${e3[1]}`;
                  }
                }
            }(r3)), u2(l2.attributes, "terrainEnabled", t3.terrainEnabled ? "true" : "false"), u2(l2.attributes, "fogEnabled", t3.fogEnabled ? "true" : "false"), u2(l2.attributes, "projection", t3.projection), u2(l2.attributes, "zoom", t3.zoom), u2(l2.metadata, "devicePixelRatio", s2), u2(l2.metadata, "connectionEffectiveType", o2), u2(l2.metadata, "navigatorUserAgent", navigator.userAgent), u2(l2.metadata, "screenWidth", window.screen.width), u2(l2.metadata, "screenHeight", window.screen.height), u2(l2.metadata, "windowWidth", window.innerWidth), u2(l2.metadata, "windowHeight", window.innerHeight), u2(l2.metadata, "mapWidth", t3.width / s2), u2(l2.metadata, "mapHeight", t3.height / s2), u2(l2.metadata, "webglRenderer", t3.renderer), u2(l2.metadata, "webglVendor", t3.vendor), u2(l2.metadata, "sdkVersion", e), u2(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
          }(n2);
          for (const t3 of i2.metadata)
            ;
          for (const t3 of i2.counters)
            ;
          for (const t3 of i2.attributes)
            ;
          this.postEvent(r2, i2, () => {
          }, t2);
        }
      }(), Vt = Lt.postPerformanceEvent.bind(Lt), Ot = new class extends Et {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t2, e22, r2, i2) {
          if (!n.API_URL || !n.SESSION_PATH)
            return;
          const s2 = kt(n.API_URL + n.SESSION_PATH);
          s2.params.push(`sku=${e22 || ""}`), s2.params.push(`access_token=${i2 || n.ACCESS_TOKEN || ""}`);
          const a2 = { url: Tt(s2), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = function(t3, e3) {
            return ft(B(t3, { method: "GET" }), e3);
          }(a2, (t3) => {
            this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(i2);
          });
        }
        getSessionAPI(t2, e22, r2, i2) {
          this.skuToken = e22, this.errorCb = i2, n.SESSION_PATH && n.API_URL && (r2 || n.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(bt)));
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: e22, timestamp: r2 } = this.queue.shift();
          e22 && this.success[e22] || this.getSession(r2, this.skuToken, (t3) => {
            t3 ? this.errorCb(t3) : e22 && (this.success[e22] = true);
          }, t2);
        }
      }(), Ft = Ot.getSessionAPI.bind(Ot), jt = /* @__PURE__ */ new Set(), Ut = { create: "create", load: "load", fullLoad: "fullLoad" };
      function Nt(t2) {
        const e22 = t2.name.split("?")[0];
        return Mt(e22) && e22.includes("mapbox-gl.js") ? "javascript" : Mt(e22) && e22.includes("mapbox-gl.css") ? "css" : function(t3) {
          return n.API_FONTS_REGEX.test(t3);
        }(e22) ? "fontRange" : St(e22) ? "sprite" : At(e22) ? "style" : function(t3) {
          return n.API_TILEJSON_REGEX.test(t3);
        }(e22) ? "tilejson" : "other";
      }
      function $t(t2) {
        const e22 = t2 ? t2.url.toString() : void 0;
        return e22 ? performance.getEntriesByName(e22) : [];
      }
      let qt, Gt, Yt, Zt, Xt;
      function Kt() {
        return null == qt && (qt = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), qt;
      }
      const Wt = { now: () => void 0 !== Zt ? Zt : performance.now(), setNow(t2) {
        Zt = t2;
      }, restoreNow() {
        Zt = void 0;
      }, frame(t2) {
        const e22 = requestAnimationFrame(t2);
        return { cancel: () => cancelAnimationFrame(e22) };
      }, getImageData(t2, e22 = 0) {
        const { width: r2, height: n2 } = t2;
        Xt || (Xt = document.createElement("canvas"));
        const i2 = Xt.getContext("2d", { willReadFrequently: true });
        if (!i2)
          throw new Error("failed to create canvas 2d context");
        return (r2 > Xt.width || n2 > Xt.height) && (Xt.width = r2, Xt.height = n2), i2.clearRect(-e22, -e22, r2 + 2 * e22, n2 + 2 * e22), i2.drawImage(t2, 0, 0, r2, n2), i2.getImageData(-e22, -e22, r2 + 2 * e22, n2 + 2 * e22);
      }, resolveURL: (t2) => (Gt || (Gt = document.createElement("a")), Gt.href = t2, Gt.href), get devicePixelRatio() {
        return window.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!window.matchMedia && (null == Yt && (Yt = window.matchMedia("(prefers-reduced-motion: reduce)")), Yt.matches);
      }, hasCanvasFingerprintNoise() {
        if (!Kt())
          return false;
        const t2 = new OffscreenCanvas(85, 1), e22 = t2.getContext("2d", { willReadFrequently: true });
        let r2 = 0;
        for (let n3 = 0; n3 < t2.width; ++n3)
          e22.fillStyle = `rgba(${r2++},${r2++},${r2++}, 255)`, e22.fillRect(n3, 0, 1, 1);
        const n2 = e22.getImageData(0, 0, t2.width, t2.height);
        r2 = 0;
        for (let t3 = 0; t3 < n2.data.length; ++t3)
          if (t3 % 4 != 3 && r2++ !== n2.data[t3])
            return true;
        return false;
      } };
      function Ht(t2, e22, r2) {
        r2[t2] && -1 !== r2[t2].indexOf(e22) || (r2[t2] = r2[t2] || [], r2[t2].push(e22));
      }
      function Jt(t2, e22, r2) {
        if (r2 && r2[t2]) {
          const n2 = r2[t2].indexOf(e22);
          -1 !== n2 && r2[t2].splice(n2, 1);
        }
      }
      class Qt {
        constructor(t2, e22 = {}) {
          B(this, e22), this.type = t2;
        }
      }
      class te extends Qt {
        constructor(t2, e22 = {}) {
          super("error", B({ error: t2 }, e22));
        }
      }
      class ee {
        on(t2, e22) {
          return this._listeners = this._listeners || {}, Ht(t2, e22, this._listeners), this;
        }
        off(t2, e22) {
          return Jt(t2, e22, this._listeners), Jt(t2, e22, this._oneTimeListeners), this;
        }
        once(t2, e22) {
          return e22 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ht(t2, e22, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
        }
        fire(t2, e22) {
          "string" == typeof t2 && (t2 = new Qt(t2, e22 || {}));
          const r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
            for (const r3 of e3)
              r3.call(this, t2);
            const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
            for (const e4 of n2)
              Jt(r2, e4, this._oneTimeListeners), e4.call(this, t2);
            const i2 = this._eventedParent;
            i2 && (B(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
          } else
            t2 instanceof te && console.error(t2.error);
          return this;
        }
        listens(t2) {
          return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
        }
        setEventedParent(t2, e22) {
          return this._eventedParent = t2, this._eventedParentData = e22, this;
        }
      }
      var re2 = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","default":[0,1],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      class ne {
        constructor(t2, e22, r2, n2) {
          this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e22 && e22.__line__ && (this.line = e22.__line__);
        }
      }
      class ie extends ne {
      }
      function se(t2, ...e22) {
        for (const r2 of e22)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      function ae(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function oe(t2) {
        if (Array.isArray(t2))
          return t2.map(oe);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          const e22 = {};
          for (const r2 in t2)
            e22[r2] = oe(t2[r2]);
          return e22;
        }
        return ae(t2);
      }
      class le extends Error {
        constructor(t2, e22) {
          super(e22), this.message = e22, this.key = t2;
        }
      }
      var ue = le;
      class ce {
        constructor(t2, e22 = []) {
          this.parent = t2, this.bindings = {};
          for (const [t3, r2] of e22)
            this.bindings[t3] = r2;
        }
        concat(t2) {
          return new ce(this, t2);
        }
        get(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(`${t2} not found in scope.`);
        }
        has(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        }
      }
      var he = ce;
      const pe = { kind: "null" }, fe = { kind: "number" }, de = { kind: "string" }, me = { kind: "boolean" }, ye = { kind: "color" }, ge = { kind: "object" }, xe = { kind: "value" }, ve = { kind: "collator" }, be = { kind: "formatted" }, _e = { kind: "resolvedImage" };
      function we(t2, e22) {
        return { kind: "array", itemType: t2, N: e22 };
      }
      function Me(t2) {
        if ("array" === t2.kind) {
          const e22 = Me(t2.itemType);
          return "number" == typeof t2.N ? `array<${e22}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e22}>`;
        }
        return t2.kind;
      }
      const Ae = [pe, fe, de, me, ye, be, ge, we(xe), _e];
      function Se(t2, e22) {
        if ("error" === e22.kind)
          return null;
        if ("array" === t2.kind) {
          if ("array" === e22.kind && (0 === e22.N && "value" === e22.itemType.kind || !Se(t2.itemType, e22.itemType)) && ("number" != typeof t2.N || t2.N === e22.N))
            return null;
        } else {
          if (t2.kind === e22.kind)
            return null;
          if ("value" === t2.kind) {
            for (const t3 of Ae)
              if (!Se(t3, e22))
                return null;
          }
        }
        return `Expected ${Me(t2)} but found ${Me(e22)} instead.`;
      }
      function Ie(t2, e22) {
        return e22.some((e3) => e3.kind === t2.kind);
      }
      function ke(t2, e22) {
        return e22.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
      }
      var Te, Pe = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
      function ze(t2) {
        return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
      }
      function Ee(t2) {
        return ze("%" === t2[t2.length - 1] ? parseFloat(t2) / 100 * 255 : parseInt(t2));
      }
      function Be(t2) {
        return (e22 = "%" === t2[t2.length - 1] ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e22 > 1 ? 1 : e22;
        var e22;
      }
      function De(t2, e22, r2) {
        return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e22 - t2) * r2 * 6 : 2 * r2 < 1 ? e22 : 3 * r2 < 2 ? t2 + (e22 - t2) * (2 / 3 - r2) * 6 : t2;
      }
      try {
        Te = {}.parseCSSColor = function(t2) {
          var e22, r2 = t2.replace(/ /g, "").toLowerCase();
          if (r2 in Pe)
            return Pe[r2].slice();
          if ("#" === r2[0])
            return 4 === r2.length ? (e22 = parseInt(r2.substr(1), 16)) >= 0 && e22 <= 4095 ? [(3840 & e22) >> 4 | (3840 & e22) >> 8, 240 & e22 | (240 & e22) >> 4, 15 & e22 | (15 & e22) << 4, 1] : null : 7 === r2.length && (e22 = parseInt(r2.substr(1), 16)) >= 0 && e22 <= 16777215 ? [(16711680 & e22) >> 16, (65280 & e22) >> 8, 255 & e22, 1] : null;
          var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
          if (-1 !== n2 && i2 + 1 === r2.length) {
            var s2 = r2.substr(0, n2), a2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
            switch (s2) {
              case "rgba":
                if (4 !== a2.length)
                  return null;
                o2 = Be(a2.pop());
              case "rgb":
                return 3 !== a2.length ? null : [Ee(a2[0]), Ee(a2[1]), Ee(a2[2]), o2];
              case "hsla":
                if (4 !== a2.length)
                  return null;
                o2 = Be(a2.pop());
              case "hsl":
                if (3 !== a2.length)
                  return null;
                var l2 = (parseFloat(a2[0]) % 360 + 360) % 360 / 360, u2 = Be(a2[1]), c2 = Be(a2[2]), h22 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h22;
                return [ze(255 * De(p2, h22, l2 + 1 / 3)), ze(255 * De(p2, h22, l2)), ze(255 * De(p2, h22, l2 - 1 / 3)), o2];
              default:
                return null;
            }
          }
          return null;
        };
      } catch (t2) {
      }
      class Ce {
        constructor(t2, e22, r2, n2 = 1) {
          this.r = t2, this.g = e22, this.b = r2, this.a = n2;
        }
        static parse(t2) {
          if (!t2)
            return;
          if (t2 instanceof Ce)
            return t2;
          if ("string" != typeof t2)
            return;
          const e22 = Te(t2);
          return e22 ? new Ce(e22[0] / 255 * e22[3], e22[1] / 255 * e22[3], e22[2] / 255 * e22[3], e22[3]) : void 0;
        }
        toString() {
          const [t2, e22, r2, n2] = this.toArray();
          return `rgba(${Math.round(t2)},${Math.round(e22)},${Math.round(r2)},${n2})`;
        }
        toArray() {
          const { r: t2, g: e22, b: r2, a: n2 } = this;
          return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e22 / n2, 255 * r2 / n2, n2];
        }
        toArray01() {
          const { r: t2, g: e22, b: r2, a: n2 } = this;
          return 0 === n2 ? [0, 0, 0, 0] : [t2 / n2, e22 / n2, r2 / n2, n2];
        }
        toArray01Scaled(t2) {
          const { r: e22, g: r2, b: n2, a: i2 } = this;
          return 0 === i2 ? [0, 0, 0] : [e22 / i2 * t2, r2 / i2 * t2, n2 / i2 * t2];
        }
        toArray01PremultipliedAlpha() {
          const { r: t2, g: e22, b: r2, a: n2 } = this;
          return [t2, e22, r2, n2];
        }
        toArray01Linear() {
          const { r: t2, g: e22, b: r2, a: n2 } = this;
          return 0 === n2 ? [0, 0, 0, 0] : [Math.pow(t2 / n2, 2.2), Math.pow(e22 / n2, 2.2), Math.pow(r2 / n2, 2.2), n2];
        }
      }
      Ce.black = new Ce(0, 0, 0, 1), Ce.white = new Ce(1, 1, 1, 1), Ce.transparent = new Ce(0, 0, 0, 0), Ce.red = new Ce(1, 0, 0, 1), Ce.blue = new Ce(0, 0, 1, 1);
      var Re = Ce;
      class Le {
        constructor(t2, e22, r2) {
          this.sensitivity = t2 ? e22 ? "variant" : "case" : e22 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t2, e22) {
          return this.collator.compare(t2, e22);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Ve {
        constructor(t2, e22, r2, n2, i2) {
          this.text = t2.normalize ? t2.normalize() : t2, this.image = e22, this.scale = r2, this.fontStack = n2, this.textColor = i2;
        }
      }
      class Oe {
        constructor(t2) {
          this.sections = t2;
        }
        static fromString(t2) {
          return new Oe([new Ve(t2, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.namePrimary.length);
        }
        static factory(t2) {
          return t2 instanceof Oe ? t2 : Oe.fromString(t2);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
        }
        serialize() {
          const t2 = ["format"];
          for (const e22 of this.sections) {
            if (e22.image) {
              t2.push(["image", e22.image.namePrimary]);
              continue;
            }
            t2.push(e22.text);
            const r2 = {};
            e22.fontStack && (r2["text-font"] = ["literal", e22.fontStack.split(",")]), e22.scale && (r2["font-scale"] = e22.scale), e22.textColor && (r2["text-color"] = ["rgba"].concat(e22.textColor.toArray())), t2.push(r2);
          }
          return t2;
        }
      }
      class Fe {
        constructor(t2) {
          this.namePrimary = t2.namePrimary, t2.nameSecondary && (this.nameSecondary = t2.nameSecondary), this.available = t2.available;
        }
        toString() {
          return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
        }
        static fromString(t2, e22) {
          return t2 ? new Fe({ namePrimary: t2, nameSecondary: e22, available: false }) : null;
        }
        serialize() {
          return this.nameSecondary ? ["image", this.namePrimary, this.nameSecondary] : ["image", this.namePrimary];
        }
      }
      function je(t2, e22, r2, n2) {
        return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e22 && e22 >= 0 && e22 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e22, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e22, r2, n2] : [t2, e22, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Ue(t2) {
        if (null === t2)
          return true;
        if ("string" == typeof t2)
          return true;
        if ("boolean" == typeof t2)
          return true;
        if ("number" == typeof t2)
          return true;
        if (t2 instanceof Re)
          return true;
        if (t2 instanceof Le)
          return true;
        if (t2 instanceof Oe)
          return true;
        if (t2 instanceof Fe)
          return true;
        if (Array.isArray(t2)) {
          for (const e22 of t2)
            if (!Ue(e22))
              return false;
          return true;
        }
        if ("object" == typeof t2) {
          for (const e22 in t2)
            if (!Ue(t2[e22]))
              return false;
          return true;
        }
        return false;
      }
      function Ne(t2) {
        if (null === t2)
          return pe;
        if ("string" == typeof t2)
          return de;
        if ("boolean" == typeof t2)
          return me;
        if ("number" == typeof t2)
          return fe;
        if (t2 instanceof Re)
          return ye;
        if (t2 instanceof Le)
          return ve;
        if (t2 instanceof Oe)
          return be;
        if (t2 instanceof Fe)
          return _e;
        if (Array.isArray(t2)) {
          const e22 = t2.length;
          let r2;
          for (const e3 of t2) {
            const t3 = Ne(e3);
            if (r2) {
              if (r2 === t3)
                continue;
              r2 = xe;
              break;
            }
            r2 = t3;
          }
          return we(r2 || xe, e22);
        }
        return ge;
      }
      function $e(t2) {
        const e22 = typeof t2;
        return null === t2 ? "" : "string" === e22 || "number" === e22 || "boolean" === e22 ? String(t2) : t2 instanceof Re || t2 instanceof Oe || t2 instanceof Fe ? t2.toString() : JSON.stringify(t2);
      }
      class qe {
        constructor(t2, e22) {
          this.type = t2, this.value = e22;
        }
        static parse(t2, e22) {
          if (2 !== t2.length)
            return e22.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (!Ue(t2[1]))
            return e22.error("invalid value");
          const r2 = t2[1];
          let n2 = Ne(r2);
          const i2 = e22.expectedType;
          return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new qe(n2, r2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Re ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Oe ? this.value.serialize() : this.value;
        }
      }
      var Ge = qe, Ye = class {
        constructor(t2) {
          this.name = "ExpressionEvaluationError", this.message = t2;
        }
        toJSON() {
          return this.message;
        }
      };
      const Ze = { string: de, number: fe, boolean: me, object: ge };
      class Xe {
        constructor(t2, e22) {
          this.type = t2, this.args = e22;
        }
        static parse(t2, e22) {
          if (t2.length < 2)
            return e22.error("Expected at least one argument.");
          let r2, n2 = 1;
          const i2 = t2[0];
          if ("array" === i2) {
            let i3, s3;
            if (t2.length > 2) {
              const r3 = t2[1];
              if ("string" != typeof r3 || !(r3 in Ze) || "object" === r3)
                return e22.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = Ze[r3], n2++;
            } else
              i3 = xe;
            if (t2.length > 3) {
              if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e22.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t2[2], n2++;
            }
            r2 = we(i3, s3);
          } else
            r2 = Ze[i2];
          const s2 = [];
          for (; n2 < t2.length; n2++) {
            const r3 = e22.parse(t2[n2], n2, xe);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new Xe(r2, s2);
        }
        evaluate(t2) {
          for (let e22 = 0; e22 < this.args.length; e22++) {
            const r2 = this.args[e22].evaluate(t2);
            if (!Se(this.type, Ne(r2)))
              return r2;
            if (e22 === this.args.length - 1)
              throw new Ye(`Expected value to be of type ${Me(this.type)}, but found ${Me(Ne(r2))} instead.`);
          }
          return null;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = this.type, e22 = [t2.kind];
          if ("array" === t2.kind) {
            const r2 = t2.itemType;
            if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
              e22.push(r2.kind);
              const n2 = t2.N;
              ("number" == typeof n2 || this.args.length > 1) && e22.push(n2);
            }
          }
          return e22.concat(this.args.map((t3) => t3.serialize()));
        }
      }
      var Ke = Xe;
      class We {
        constructor(t2) {
          this.type = be, this.sections = t2;
        }
        static parse(t2, e22) {
          if (t2.length < 2)
            return e22.error("Expected at least one argument.");
          const r2 = t2[1];
          if (!Array.isArray(r2) && "object" == typeof r2)
            return e22.error("First argument must be an image or text section.");
          const n2 = [];
          let i2 = false;
          for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
            const s2 = t2[r3];
            if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e22.parse(s2["font-scale"], 1, fe), !t3))
                return null;
              let r4 = null;
              if (s2["text-font"] && (r4 = e22.parse(s2["text-font"], 1, we(de)), !r4))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e22.parse(s2["text-color"], 1, ye), !a2))
                return null;
              const o2 = n2[n2.length - 1];
              o2.scale = t3, o2.font = r4, o2.textColor = a2;
            } else {
              const s3 = e22.parse(t2[r3], 1, xe);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                return e22.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new We(n2);
        }
        evaluate(t2) {
          return new Oe(this.sections.map((e22) => {
            const r2 = e22.content.evaluate(t2);
            return Ne(r2) === _e ? new Ve("", r2, null, null, null) : new Ve($e(r2), null, e22.scale ? e22.scale.evaluate(t2) : null, e22.font ? e22.font.evaluate(t2).join(",") : null, e22.textColor ? e22.textColor.evaluate(t2) : null);
          }));
        }
        eachChild(t2) {
          for (const e22 of this.sections)
            t2(e22.content), e22.scale && t2(e22.scale), e22.font && t2(e22.font), e22.textColor && t2(e22.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = ["format"];
          for (const e22 of this.sections) {
            t2.push(e22.content.serialize());
            const r2 = {};
            e22.scale && (r2["font-scale"] = e22.scale.serialize()), e22.font && (r2["text-font"] = e22.font.serialize()), e22.textColor && (r2["text-color"] = e22.textColor.serialize()), t2.push(r2);
          }
          return t2;
        }
      }
      class He {
        constructor(t2, e22) {
          this.type = _e, this.inputPrimary = t2, this.inputSecondary = e22;
        }
        static parse(t2, e22) {
          if (t2.length < 2)
            return e22.error("Expected two or more arguments.");
          const r2 = e22.parse(t2[1], 1, de);
          if (!r2)
            return e22.error("No image name provided.");
          if (2 === t2.length)
            return new He(r2);
          const n2 = e22.parse(t2[2], 1, de);
          return n2 ? new He(r2, n2) : e22.error("Secondary image variant is not a string.");
        }
        evaluate(t2) {
          const e22 = Fe.fromString(this.inputPrimary.evaluate(t2), this.inputSecondary ? this.inputSecondary.evaluate(t2) : void 0);
          return e22 && t2.availableImages && (e22.available = t2.availableImages.indexOf(e22.namePrimary) > -1, e22.nameSecondary && e22.available && t2.availableImages && (e22.available = t2.availableImages.indexOf(e22.nameSecondary) > -1)), e22;
        }
        eachChild(t2) {
          t2(this.inputPrimary), this.inputSecondary && t2(this.inputSecondary);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return this.inputSecondary ? ["image", this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ["image", this.inputPrimary.serialize()];
        }
      }
      function Je(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
      }
      const Qe = { "to-boolean": me, "to-color": ye, "to-number": fe, "to-string": de };
      class tr {
        constructor(t2, e22) {
          this.type = t2, this.args = e22;
        }
        static parse(t2, e22) {
          if (t2.length < 2)
            return e22.error("Expected at least one argument.");
          const r2 = t2[0], n2 = [];
          let i2 = pe;
          if ("to-array" === r2) {
            if (!Array.isArray(t2[1]))
              return null;
            const r3 = t2[1].length;
            if (e22.expectedType) {
              if ("array" !== e22.expectedType.kind)
                return e22.error(`Expected ${e22.expectedType.kind} but found array.`);
              i2 = we(e22.expectedType.itemType, r3);
            } else {
              if (!(r3 > 0 && Ue(t2[1][0])))
                return null;
              i2 = we(Ne(t2[1][0]), r3);
            }
            for (let s2 = 0; s2 < r3; s2++) {
              const r4 = t2[1][s2];
              let a2;
              if ("array" === Je(r4))
                a2 = e22.parse(r4, void 0, i2.itemType);
              else {
                const t3 = Je(r4);
                if (t3 !== i2.itemType.kind)
                  return e22.error(`Expected ${i2.itemType.kind} but found ${t3}.`);
                a2 = e22.registry.literal.parse(["literal", void 0 === r4 ? null : r4], e22);
              }
              if (!a2)
                return null;
              n2.push(a2);
            }
          } else {
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
              return e22.error("Expected one argument.");
            i2 = Qe[r2];
            for (let r3 = 1; r3 < t2.length; r3++) {
              const i3 = e22.parse(t2[r3], r3, xe);
              if (!i3)
                return null;
              n2.push(i3);
            }
          }
          return new tr(i2, n2);
        }
        evaluate(t2) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(t2));
          if ("color" === this.type.kind) {
            let e22, r2;
            for (const n2 of this.args) {
              if (e22 = n2.evaluate(t2), r2 = null, e22 instanceof Re)
                return e22;
              if ("string" == typeof e22) {
                const r3 = t2.parseColor(e22);
                if (r3)
                  return r3;
              } else if (Array.isArray(e22) && (r2 = e22.length < 3 || e22.length > 4 ? `Invalid rbga value ${JSON.stringify(e22)}: expected an array containing either three or four numeric values.` : je(e22[0], e22[1], e22[2], e22[3]), !r2))
                return new Re(e22[0] / 255, e22[1] / 255, e22[2] / 255, e22[3]);
            }
            throw new Ye(r2 || `Could not parse color from value '${"string" == typeof e22 ? e22 : String(JSON.stringify(e22))}'`);
          }
          if ("number" === this.type.kind) {
            let e22 = null;
            for (const r2 of this.args) {
              if (e22 = r2.evaluate(t2), null === e22)
                return 0;
              const n2 = Number(e22);
              if (!isNaN(n2))
                return n2;
            }
            throw new Ye(`Could not convert ${JSON.stringify(e22)} to number.`);
          }
          return "formatted" === this.type.kind ? Oe.fromString($e(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Fe.fromString($e(this.args[0].evaluate(t2))) : "array" === this.type.kind ? this.args.map((e22) => e22.evaluate(t2)) : $e(this.args[0].evaluate(t2));
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          if ("formatted" === this.type.kind)
            return new We([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new He(this.args[0]).serialize();
          const t2 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
          return this.eachChild((e22) => {
            t2.push(e22.serialize());
          }), t2;
        }
      }
      var er = tr;
      const rr = ["Unknown", "Point", "LineString", "Polygon"];
      var nr = class {
        constructor(t2, e22) {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t2, this.options = e22;
        }
        id() {
          return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? rr[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        measureLight(t2) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const t2 = this.featureDistanceData.center, e22 = this.featureDistanceData.scale, { x: r2, y: n2 } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (r2 * e22 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e22 - t2[1]);
          }
          return 0;
        }
        parseColor(t2) {
          let e22 = this._parseColorCache[t2];
          return e22 || (e22 = this._parseColorCache[t2] = Re.parse(t2)), e22;
        }
        getConfig(t2) {
          return this.options ? this.options.get(t2) : null;
        }
      };
      class ir {
        constructor(t2, e22, r2, n2, i2) {
          this.name = t2, this.type = e22, this._evaluate = r2, this.args = n2, this._overloadIndex = i2;
        }
        evaluate(t2) {
          if (!this._evaluate) {
            const t3 = ir.definitions[this.name];
            this._evaluate = Array.isArray(t3) ? t3[2] : t3.overloads[this._overloadIndex][1];
          }
          return this._evaluate(t2, this.args);
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((t2) => t2.serialize()));
        }
        static parse(t2, e22) {
          const r2 = t2[0], n2 = ir.definitions[r2];
          if (!n2)
            return e22.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = [];
          let o2 = null, l2 = -1;
          for (const [n3, u2] of s2) {
            if (Array.isArray(n3) && n3.length !== t2.length - 1)
              continue;
            a2.push(n3), l2++, o2 = new xn(e22.registry, e22.path, null, e22.scope, void 0, e22._scope, e22.options);
            const s3 = [];
            let c2 = false;
            for (let e3 = 1; e3 < t2.length; e3++) {
              const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, a3 = o2.parse(r3, 1 + s3.length, i3);
              if (!a3) {
                c2 = true;
                break;
              }
              s3.push(a3);
            }
            if (!c2)
              if (Array.isArray(n3) && n3.length !== s3.length)
                o2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
              else {
                for (let t3 = 0; t3 < s3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (0 === o2.errors.length)
                  return new ir(r2, i2, u2, s3, l2);
              }
          }
          if (1 === a2.length)
            e22.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2.map(([t3]) => t3)).map(sr).join(" | "), n3 = [];
            for (let r4 = 1; r4 < t2.length; r4++) {
              const i3 = e22.parse(t2[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(Me(i3.type));
            }
            e22.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t2, e22) {
          ir.definitions = e22;
          for (const r2 in e22)
            t2[r2] = ir;
        }
      }
      function sr(t2) {
        return Array.isArray(t2) ? `(${t2.map(Me).join(", ")})` : `(${Me(t2.type)}...)`;
      }
      var ar = ir;
      class or {
        constructor(t2, e22, r2) {
          this.type = ve, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e22;
        }
        static parse(t2, e22) {
          if (2 !== t2.length)
            return e22.error("Expected one argument.");
          const r2 = t2[1];
          if ("object" != typeof r2 || Array.isArray(r2))
            return e22.error("Collator options argument must be an object.");
          const n2 = e22.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, me);
          if (!n2)
            return null;
          const i2 = e22.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, me);
          if (!i2)
            return null;
          let s2 = null;
          return r2.locale && (s2 = e22.parse(r2.locale, 1, de), !s2) ? null : new or(n2, i2, s2);
        }
        evaluate(t2) {
          return new Le(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }
        eachChild(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = {};
          return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
        }
      }
      var lr = { exports: {} };
      lr.exports = /* @__PURE__ */ function() {
        function t2(r3, n2, i2, s2, a2) {
          for (; s2 > i2; ) {
            if (s2 - i2 > 600) {
              var o2 = s2 - i2 + 1, l2 = n2 - i2 + 1, u2 = Math.log(o2), c2 = 0.5 * Math.exp(2 * u2 / 3), h22 = 0.5 * Math.sqrt(u2 * c2 * (o2 - c2) / o2) * (l2 - o2 / 2 < 0 ? -1 : 1);
              t2(r3, n2, Math.max(i2, Math.floor(n2 - l2 * c2 / o2 + h22)), Math.min(s2, Math.floor(n2 + (o2 - l2) * c2 / o2 + h22)), a2);
            }
            var p2 = r3[n2], f2 = i2, d2 = s2;
            for (e22(r3, i2, n2), a2(r3[s2], p2) > 0 && e22(r3, i2, s2); f2 < d2; ) {
              for (e22(r3, f2, d2), f2++, d2--; a2(r3[f2], p2) < 0; )
                f2++;
              for (; a2(r3[d2], p2) > 0; )
                d2--;
            }
            0 === a2(r3[i2], p2) ? e22(r3, i2, d2) : e22(r3, ++d2, s2), d2 <= n2 && (i2 = d2 + 1), n2 <= d2 && (s2 = d2 - 1);
          }
        }
        function e22(t3, e3, r3) {
          var n2 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n2;
        }
        function r2(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        return function(e3, n2, i2, s2, a2) {
          t2(e3, n2, i2 || 0, s2 || e3.length - 1, a2 || r2);
        };
      }();
      var ur = p(lr.exports);
      function cr(t2) {
        let e22 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e22 += (n2.x - r2.x) * (r2.y + n2.y);
        return e22;
      }
      function hr(t2, e22) {
        t2[0] = Math.min(t2[0], e22[0]), t2[1] = Math.min(t2[1], e22[1]), t2[2] = Math.max(t2[2], e22[0]), t2[3] = Math.max(t2[3], e22[1]);
      }
      function pr(t2, e22) {
        return !(t2[0] <= e22[0] || t2[2] >= e22[2] || t2[1] <= e22[1] || t2[3] >= e22[3]);
      }
      function fr(t2, e22, r2) {
        const n2 = t2[0] - e22[0], i2 = t2[1] - e22[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
        return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
      }
      function dr(t2, e22, r2 = false) {
        let n2 = false;
        for (let o2 = 0, l2 = e22.length; o2 < l2; o2++) {
          const l3 = e22[o2];
          for (let e3 = 0, o3 = l3.length, u2 = o3 - 1; e3 < o3; u2 = e3++) {
            const o4 = l3[u2], c2 = l3[e3];
            if (fr(t2, o4, c2))
              return r2;
            (s2 = o4)[1] > (i2 = t2)[1] != (a2 = c2)[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
          }
        }
        var i2, s2, a2;
        return n2;
      }
      function mr(t2, e22, r2, n2) {
        const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e22[0] - r2[0]) * s2 - i2 * (e22[1] - r2[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function yr(t2, e22, r2, n2) {
        return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e22[0] - t2[0], e22[1] - t2[1]])[1] - i2[1] * s2[0] && !(!mr(t2, e22, r2, n2) || !mr(r2, n2, t2, e22));
        var i2, s2;
      }
      const gr = 8192;
      function xr(t2, e22) {
        const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e22.z);
        return [Math.round(r2 * i2 * gr), Math.round(n2 * i2 * gr)];
      }
      function vr(t2, e22) {
        for (let r2 = 0; r2 < e22.length; r2++)
          if (dr(t2, e22[r2]))
            return true;
        return false;
      }
      function br(t2, e22, r2) {
        for (const n2 of r2)
          for (let r3 = 0, i2 = n2.length, s2 = i2 - 1; r3 < i2; s2 = r3++)
            if (yr(t2, e22, n2[s2], n2[r3]))
              return true;
        return false;
      }
      function _r(t2, e22) {
        for (let r2 = 0; r2 < t2.length; ++r2)
          if (!dr(t2[r2], e22))
            return false;
        for (let r2 = 0; r2 < t2.length - 1; ++r2)
          if (br(t2[r2], t2[r2 + 1], e22))
            return false;
        return true;
      }
      function wr(t2, e22) {
        for (let r2 = 0; r2 < e22.length; r2++)
          if (_r(t2, e22[r2]))
            return true;
        return false;
      }
      function Mr(t2, e22, r2) {
        const n2 = [];
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = [];
          for (let n3 = 0; n3 < t2[i2].length; n3++) {
            const a2 = xr(t2[i2][n3], r2);
            hr(e22, a2), s2.push(a2);
          }
          n2.push(s2);
        }
        return n2;
      }
      function Ar(t2, e22, r2) {
        const n2 = [];
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = Mr(t2[i2], e22, r2);
          n2.push(s2);
        }
        return n2;
      }
      function Sr(t2, e22, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          const e3 = 0.5 * n2;
          let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
          0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
        }
        hr(e22, t2);
      }
      function Ir(t2, e22, r2, n2) {
        const i2 = Math.pow(2, n2.z) * gr, s2 = [n2.x * gr, n2.y * gr], a2 = [];
        if (!t2)
          return a2;
        for (const n3 of t2)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            Sr(n4, e22, r2, i2), a2.push(n4);
          }
        return a2;
      }
      function kr(t2, e22, r2, n2) {
        const i2 = Math.pow(2, n2.z) * gr, s2 = [n2.x * gr, n2.y * gr], a2 = [];
        if (!t2)
          return a2;
        for (const r3 of t2) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            hr(e22, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e22[2] - e22[0] <= i2 / 2) {
          (o2 = e22)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              Sr(n3, e22, r2, i2);
        }
        var o2;
        return a2;
      }
      class Tr {
        constructor(t2, e22) {
          this.type = me, this.geojson = t2, this.geometries = e22;
        }
        static parse(t2, e22) {
          if (2 !== t2.length)
            return e22.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (Ue(t2[1])) {
            const e3 = t2[1];
            if ("FeatureCollection" === e3.type)
              for (let t3 = 0; t3 < e3.features.length; ++t3) {
                const r2 = e3.features[t3].geometry.type;
                if ("Polygon" === r2 || "MultiPolygon" === r2)
                  return new Tr(e3, e3.features[t3].geometry);
              }
            else if ("Feature" === e3.type) {
              const t3 = e3.geometry.type;
              if ("Polygon" === t3 || "MultiPolygon" === t3)
                return new Tr(e3, e3.geometry);
            } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
              return new Tr(e3, e3);
          }
          return e22.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (null != t2.geometry() && null != t2.canonicalID()) {
            if ("Point" === t2.geometryType())
              return function(t3, e22) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2)
                  return false;
                if ("Polygon" === e22.type) {
                  const s2 = Mr(e22.coordinates, n2, i2), a2 = Ir(t3.geometry(), r2, n2, i2);
                  if (!pr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!dr(t4, s2))
                      return false;
                }
                if ("MultiPolygon" === e22.type) {
                  const s2 = Ar(e22.coordinates, n2, i2), a2 = Ir(t3.geometry(), r2, n2, i2);
                  if (!pr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!vr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
            if ("LineString" === t2.geometryType())
              return function(t3, e22) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (!i2)
                  return false;
                if ("Polygon" === e22.type) {
                  const s2 = Mr(e22.coordinates, n2, i2), a2 = kr(t3.geometry(), r2, n2, i2);
                  if (!pr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!_r(t4, s2))
                      return false;
                }
                if ("MultiPolygon" === e22.type) {
                  const s2 = Ar(e22.coordinates, n2, i2), a2 = kr(t3.geometry(), r2, n2, i2);
                  if (!pr(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!wr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      var Pr = Tr, zr = { exports: {} };
      zr.exports = function() {
        var t2 = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, e22 = 1 / 298.257223563, r2 = e22 * (2 - e22), n2 = Math.PI / 180, i2 = function(e3, i3) {
          if (void 0 === e3)
            throw new Error("No latitude given.");
          if (i3 && !t2[i3])
            throw new Error("Unknown unit " + i3 + ". Use one of: " + Object.keys(t2).join(", "));
          var s3 = 6378.137 * n2 * (i3 ? t2[i3] : 1), a3 = Math.cos(e3 * n2), o3 = 1 / (1 - r2 * (1 - a3 * a3)), l3 = Math.sqrt(o3);
          this.kx = s3 * l3 * a3, this.ky = s3 * l3 * o3 * (1 - r2);
        }, s2 = { units: { configurable: true } };
        function a2(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1];
        }
        function o2(t3, e3, r3) {
          var n3 = l2(e3[0] - t3[0]);
          return [t3[0] + n3 * r3, t3[1] + (e3[1] - t3[1]) * r3];
        }
        function l2(t3) {
          for (; t3 < -180; )
            t3 += 360;
          for (; t3 > 180; )
            t3 -= 360;
          return t3;
        }
        return i2.fromTile = function(t3, e3, r3) {
          var s3 = Math.PI * (1 - 2 * (t3 + 0.5) / Math.pow(2, e3)), a3 = Math.atan(0.5 * (Math.exp(s3) - Math.exp(-s3))) / n2;
          return new i2(a3, r3);
        }, s2.units.get = function() {
          return t2;
        }, i2.prototype.distance = function(t3, e3) {
          var r3 = l2(t3[0] - e3[0]) * this.kx, n3 = (t3[1] - e3[1]) * this.ky;
          return Math.sqrt(r3 * r3 + n3 * n3);
        }, i2.prototype.bearing = function(t3, e3) {
          var r3 = l2(e3[0] - t3[0]) * this.kx;
          return Math.atan2(r3, (e3[1] - t3[1]) * this.ky) / n2;
        }, i2.prototype.destination = function(t3, e3, r3) {
          var i3 = r3 * n2;
          return this.offset(t3, Math.sin(i3) * e3, Math.cos(i3) * e3);
        }, i2.prototype.offset = function(t3, e3, r3) {
          return [t3[0] + e3 / this.kx, t3[1] + r3 / this.ky];
        }, i2.prototype.lineDistance = function(t3) {
          for (var e3 = 0, r3 = 0; r3 < t3.length - 1; r3++)
            e3 += this.distance(t3[r3], t3[r3 + 1]);
          return e3;
        }, i2.prototype.area = function(t3) {
          for (var e3 = 0, r3 = 0; r3 < t3.length; r3++)
            for (var n3 = t3[r3], i3 = 0, s3 = n3.length, a3 = s3 - 1; i3 < s3; a3 = i3++)
              e3 += l2(n3[i3][0] - n3[a3][0]) * (n3[i3][1] + n3[a3][1]) * (r3 ? -1 : 1);
          return Math.abs(e3) / 2 * this.kx * this.ky;
        }, i2.prototype.along = function(t3, e3) {
          var r3 = 0;
          if (e3 <= 0)
            return t3[0];
          for (var n3 = 0; n3 < t3.length - 1; n3++) {
            var i3 = t3[n3], s3 = t3[n3 + 1], a3 = this.distance(i3, s3);
            if ((r3 += a3) > e3)
              return o2(i3, s3, (e3 - (r3 - a3)) / a3);
          }
          return t3[t3.length - 1];
        }, i2.prototype.pointToSegmentDistance = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = l2(r3[0] - n3) * this.kx, a3 = (r3[1] - i3) * this.ky, o3 = 0;
          return 0 === s3 && 0 === a3 || ((o3 = (l2(t3[0] - n3) * this.kx * s3 + (t3[1] - i3) * this.ky * a3) / (s3 * s3 + a3 * a3)) > 1 ? (n3 = r3[0], i3 = r3[1]) : o3 > 0 && (n3 += s3 / this.kx * o3, i3 += a3 / this.ky * o3)), s3 = l2(t3[0] - n3) * this.kx, a3 = (t3[1] - i3) * this.ky, Math.sqrt(s3 * s3 + a3 * a3);
        }, i2.prototype.pointOnLine = function(t3, e3) {
          for (var r3, n3, i3, s3, a3 = 1 / 0, o3 = 0; o3 < t3.length - 1; o3++) {
            var u2 = t3[o3][0], c2 = t3[o3][1], h22 = l2(t3[o3 + 1][0] - u2) * this.kx, p2 = (t3[o3 + 1][1] - c2) * this.ky, f2 = 0;
            0 === h22 && 0 === p2 || ((f2 = (l2(e3[0] - u2) * this.kx * h22 + (e3[1] - c2) * this.ky * p2) / (h22 * h22 + p2 * p2)) > 1 ? (u2 = t3[o3 + 1][0], c2 = t3[o3 + 1][1]) : f2 > 0 && (u2 += h22 / this.kx * f2, c2 += p2 / this.ky * f2));
            var d2 = (h22 = l2(e3[0] - u2) * this.kx) * h22 + (p2 = (e3[1] - c2) * this.ky) * p2;
            d2 < a3 && (a3 = d2, r3 = u2, n3 = c2, i3 = o3, s3 = f2);
          }
          return { point: [r3, n3], index: i3, t: Math.max(0, Math.min(1, s3)) };
        }, i2.prototype.lineSlice = function(t3, e3, r3) {
          var n3 = this.pointOnLine(r3, t3), i3 = this.pointOnLine(r3, e3);
          if (n3.index > i3.index || n3.index === i3.index && n3.t > i3.t) {
            var s3 = n3;
            n3 = i3, i3 = s3;
          }
          var o3 = [n3.point], l3 = n3.index + 1, u2 = i3.index;
          !a2(r3[l3], o3[0]) && l3 <= u2 && o3.push(r3[l3]);
          for (var c2 = l3 + 1; c2 <= u2; c2++)
            o3.push(r3[c2]);
          return a2(r3[u2], i3.point) || o3.push(i3.point), o3;
        }, i2.prototype.lineSliceAlong = function(t3, e3, r3) {
          for (var n3 = 0, i3 = [], s3 = 0; s3 < r3.length - 1; s3++) {
            var a3 = r3[s3], l3 = r3[s3 + 1], u2 = this.distance(a3, l3);
            if ((n3 += u2) > t3 && 0 === i3.length && i3.push(o2(a3, l3, (t3 - (n3 - u2)) / u2)), n3 >= e3)
              return i3.push(o2(a3, l3, (e3 - (n3 - u2)) / u2)), i3;
            n3 > t3 && i3.push(l3);
          }
          return i3;
        }, i2.prototype.bufferPoint = function(t3, e3) {
          var r3 = e3 / this.ky, n3 = e3 / this.kx;
          return [t3[0] - n3, t3[1] - r3, t3[0] + n3, t3[1] + r3];
        }, i2.prototype.bufferBBox = function(t3, e3) {
          var r3 = e3 / this.ky, n3 = e3 / this.kx;
          return [t3[0] - n3, t3[1] - r3, t3[2] + n3, t3[3] + r3];
        }, i2.prototype.insideBBox = function(t3, e3) {
          return l2(t3[0] - e3[0]) >= 0 && l2(t3[0] - e3[2]) <= 0 && t3[1] >= e3[1] && t3[1] <= e3[3];
        }, Object.defineProperties(i2, s2), i2;
      }();
      var Er = p(zr.exports), Br = { exports: {} };
      Br.exports = function() {
        var t2 = function(t3, r2) {
          if (void 0 === t3 && (t3 = []), void 0 === r2 && (r2 = e22), this.data = t3, this.length = this.data.length, this.compare = r2, this.length > 0)
            for (var n2 = (this.length >> 1) - 1; n2 >= 0; n2--)
              this._down(n2);
        };
        function e22(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        return t2.prototype.push = function(t3) {
          this.data.push(t3), this.length++, this._up(this.length - 1);
        }, t2.prototype.pop = function() {
          if (0 !== this.length) {
            var t3 = this.data[0], e3 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e3, this._down(0)), t3;
          }
        }, t2.prototype.peek = function() {
          return this.data[0];
        }, t2.prototype._up = function(t3) {
          for (var e3 = this.data, r2 = this.compare, n2 = e3[t3]; t3 > 0; ) {
            var i2 = t3 - 1 >> 1, s2 = e3[i2];
            if (r2(n2, s2) >= 0)
              break;
            e3[t3] = s2, t3 = i2;
          }
          e3[t3] = n2;
        }, t2.prototype._down = function(t3) {
          for (var e3 = this.data, r2 = this.compare, n2 = this.length >> 1, i2 = e3[t3]; t3 < n2; ) {
            var s2 = 1 + (t3 << 1), a2 = e3[s2], o2 = s2 + 1;
            if (o2 < this.length && r2(e3[o2], a2) < 0 && (s2 = o2, a2 = e3[o2]), r2(a2, i2) >= 0)
              break;
            e3[t3] = a2, t3 = s2;
          }
          e3[t3] = i2;
        }, t2;
      }();
      var Dr = p(Br.exports), Cr = 8192;
      function Rr(t2, e22) {
        return e22.dist - t2.dist;
      }
      const Lr = 100, Vr = 50;
      function Or(t2) {
        const e22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (e22.length !== t2.length)
          return false;
        for (let r2 = 0; r2 < e22.length; r2++)
          if (e22[r2] !== t2[r2])
            return false;
        return true;
      }
      function Fr(t2) {
        return t2[1] - t2[0] + 1;
      }
      function jr(t2, e22) {
        const r2 = t2[1] >= t2[0] && t2[1] < e22;
        return r2 || console.warn("Distance Expression: Index is out of range"), r2;
      }
      function Ur(t2, e22) {
        if (t2[0] > t2[1])
          return [null, null];
        const r2 = Fr(t2);
        if (e22) {
          if (2 === r2)
            return [t2, null];
          const e3 = Math.floor(r2 / 2);
          return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
        }
        {
          if (1 === r2)
            return [t2, null];
          const e3 = Math.floor(r2 / 2) - 1;
          return [[t2[0], t2[0] + e3], [t2[0] + e3 + 1, t2[1]]];
        }
      }
      function Nr(t2, e22) {
        const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!jr(e22, t2.length))
          return r2;
        for (let n2 = e22[0]; n2 <= e22[1]; ++n2)
          hr(r2, t2[n2]);
        return r2;
      }
      function $r(t2) {
        const e22 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let r2 = 0; r2 < t2.length; ++r2)
          for (let n2 = 0; n2 < t2[r2].length; ++n2)
            hr(e22, t2[r2][n2]);
        return e22;
      }
      function qr(t2, e22, r2) {
        if (Or(t2) || Or(e22))
          return NaN;
        let n2 = 0, i2 = 0;
        return t2[2] < e22[0] && (n2 = e22[0] - t2[2]), t2[0] > e22[2] && (n2 = t2[0] - e22[2]), t2[1] > e22[3] && (i2 = t2[1] - e22[3]), t2[3] < e22[1] && (i2 = e22[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
      }
      function Gr(t2, e22) {
        const r2 = Math.pow(2, e22.z);
        return [(i2 = (t2.x / Cr + e22.x) / r2, 360 * i2 - 180), (n2 = (t2.y / Cr + e22.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
        var n2, i2;
      }
      function Yr(t2, e22) {
        const r2 = [];
        for (let n2 = 0; n2 < t2.length; ++n2)
          r2.push(Gr(t2[n2], e22));
        return r2;
      }
      function Zr(t2, e22, r2) {
        const n2 = r2.pointOnLine(e22, t2).point;
        return r2.distance(t2, n2);
      }
      function Xr(t2, e22, r2, n2, i2) {
        const s2 = r2.slice(n2[0], n2[1] + 1);
        let a2 = 1 / 0;
        for (let r3 = e22[0]; r3 <= e22[1]; ++r3)
          if (0 === (a2 = Math.min(a2, Zr(t2[r3], s2, i2))))
            return 0;
        return a2;
      }
      function Kr(t2, e22, r2, n2, i2) {
        const s2 = Math.min(i2.pointToSegmentDistance(t2, r2, n2), i2.pointToSegmentDistance(e22, r2, n2)), a2 = Math.min(i2.pointToSegmentDistance(r2, t2, e22), i2.pointToSegmentDistance(n2, t2, e22));
        return Math.min(s2, a2);
      }
      function Wr(t2, e22, r2, n2, i2) {
        if (!jr(e22, t2.length) || !jr(n2, r2.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e22[0]; a2 < e22[1]; ++a2)
          for (let e3 = n2[0]; e3 < n2[1]; ++e3) {
            if (yr(t2[a2], t2[a2 + 1], r2[e3], r2[e3 + 1]))
              return 0;
            s2 = Math.min(s2, Kr(t2[a2], t2[a2 + 1], r2[e3], r2[e3 + 1], i2));
          }
        return s2;
      }
      function Hr(t2, e22, r2, n2, i2) {
        if (!jr(e22, t2.length) || !jr(n2, r2.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e22[0]; a2 <= e22[1]; ++a2)
          for (let e3 = n2[0]; e3 <= n2[1]; ++e3)
            if (0 === (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3]))))
              return s2;
        return s2;
      }
      function Jr(t2, e22, r2) {
        if (dr(t2, e22, true))
          return 0;
        let n2 = 1 / 0;
        for (const i2 of e22) {
          const e3 = i2.length;
          if (e3 < 2)
            return console.warn("Distance Expression: Invalid polygon!"), NaN;
          if (i2[0] !== i2[e3 - 1] && 0 === (n2 = Math.min(n2, r2.pointToSegmentDistance(t2, i2[e3 - 1], i2[0]))))
            return n2;
          if (0 === (n2 = Math.min(n2, Zr(t2, i2, r2))))
            return n2;
        }
        return n2;
      }
      function Qr(t2, e22, r2, n2) {
        if (!jr(e22, t2.length))
          return NaN;
        for (let n3 = e22[0]; n3 <= e22[1]; ++n3)
          if (dr(t2[n3], r2, true))
            return 0;
        let i2 = 1 / 0;
        for (let s2 = e22[0]; s2 < e22[1]; ++s2)
          for (const e3 of r2)
            for (let r3 = 0, a2 = e3.length, o2 = a2 - 1; r3 < a2; o2 = r3++) {
              if (yr(t2[s2], t2[s2 + 1], e3[o2], e3[r3]))
                return 0;
              i2 = Math.min(i2, Kr(t2[s2], t2[s2 + 1], e3[o2], e3[r3], n2));
            }
        return i2;
      }
      function tn(t2, e22) {
        for (const r2 of t2)
          for (let t3 = 0; t3 <= r2.length - 1; ++t3)
            if (dr(r2[t3], e22, true))
              return true;
        return false;
      }
      function en(t2, e22, r2, n2 = 1 / 0) {
        const i2 = $r(t2), s2 = $r(e22);
        if (n2 !== 1 / 0 && qr(i2, s2, r2) >= n2)
          return n2;
        if (pr(i2, s2)) {
          if (tn(t2, e22))
            return 0;
        } else if (tn(e22, t2))
          return 0;
        let a2 = n2;
        for (const n3 of t2)
          for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++)
            for (const i4 of e22)
              for (let e3 = 0, o2 = i4.length, l2 = o2 - 1; e3 < o2; l2 = e3++) {
                if (yr(n3[s3], n3[t3], i4[l2], i4[e3]))
                  return 0;
                a2 = Math.min(a2, Kr(n3[s3], n3[t3], i4[l2], i4[e3], r2));
              }
        return a2;
      }
      function rn(t2, e22, r2, n2, i2, s2, a2) {
        if (null === s2 || null === a2)
          return;
        const o2 = qr(Nr(n2, s2), Nr(i2, a2), r2);
        o2 < e22 && t2.push({ dist: o2, range1: s2, range2: a2 });
      }
      function nn(t2, e22, r2, n2, i2 = 1 / 0) {
        let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
        if (0 === s2)
          return s2;
        const a2 = new Dr([{ dist: 0, range1: [0, t2.length - 1], range2: [0, 0] }], Rr), o2 = e22 ? Vr : Lr, l2 = $r(r2);
        for (; a2.length; ) {
          const i3 = a2.pop();
          if (i3.dist >= s2)
            continue;
          const u2 = i3.range1;
          if (Fr(u2) <= o2) {
            if (!jr(u2, t2.length))
              return NaN;
            if (e22) {
              const e3 = Qr(t2, u2, r2, n2);
              if (0 === (s2 = Math.min(s2, e3)))
                return s2;
            } else
              for (let e3 = u2[0]; e3 <= u2[1]; ++e3) {
                const i4 = Jr(t2[e3], r2, n2);
                if (0 === (s2 = Math.min(s2, i4)))
                  return s2;
              }
          } else {
            const r3 = Ur(u2, e22);
            if (null !== r3[0]) {
              const e3 = qr(Nr(t2, r3[0]), l2, n2);
              e3 < s2 && a2.push({ dist: e3, range1: r3[0], range2: [0, 0] });
            }
            if (null !== r3[1]) {
              const e3 = qr(Nr(t2, r3[1]), l2, n2);
              e3 < s2 && a2.push({ dist: e3, range1: r3[1], range2: [0, 0] });
            }
          }
        }
        return s2;
      }
      function sn(t2, e22, r2, n2, i2, s2 = 1 / 0) {
        let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
        if (0 === a2)
          return a2;
        const o2 = new Dr([{ dist: 0, range1: [0, t2.length - 1], range2: [0, r2.length - 1] }], Rr), l2 = e22 ? Vr : Lr, u2 = n2 ? Vr : Lr;
        for (; o2.length; ) {
          const s3 = o2.pop();
          if (s3.dist >= a2)
            continue;
          const c2 = s3.range1, h22 = s3.range2;
          if (Fr(c2) <= l2 && Fr(h22) <= u2) {
            if (!jr(c2, t2.length) || !jr(h22, r2.length))
              return NaN;
            if (e22 && n2 ? a2 = Math.min(a2, Wr(t2, c2, r2, h22, i2)) : e22 || n2 ? e22 && !n2 ? a2 = Math.min(a2, Xr(r2, h22, t2, c2, i2)) : !e22 && n2 && (a2 = Math.min(a2, Xr(t2, c2, r2, h22, i2))) : a2 = Math.min(a2, Hr(t2, c2, r2, h22, i2)), 0 === a2)
              return a2;
          } else {
            const s4 = Ur(c2, e22), l3 = Ur(h22, n2);
            rn(o2, a2, i2, t2, r2, s4[0], l3[0]), rn(o2, a2, i2, t2, r2, s4[0], l3[1]), rn(o2, a2, i2, t2, r2, s4[1], l3[0]), rn(o2, a2, i2, t2, r2, s4[1], l3[1]);
          }
        }
        return a2;
      }
      function an(t2, e22, r2, n2, i2 = 1 / 0) {
        let s2 = i2;
        const a2 = Nr(t2, [0, t2.length - 1]);
        for (const i3 of r2)
          if (!(s2 !== 1 / 0 && qr(a2, Nr(i3, [0, i3.length - 1]), n2) >= s2) && (s2 = Math.min(s2, sn(t2, e22, i3, true, n2, s2)), 0 === s2))
            return s2;
        return s2;
      }
      function on(t2, e22, r2, n2, i2 = 1 / 0) {
        let s2 = i2;
        const a2 = Nr(t2, [0, t2.length - 1]);
        for (const i3 of r2) {
          if (s2 !== 1 / 0 && qr(a2, $r(i3), n2) >= s2)
            continue;
          const r3 = nn(t2, e22, i3, n2, s2);
          if (isNaN(r3))
            return r3;
          if (0 === (s2 = Math.min(s2, r3)))
            return s2;
        }
        return s2;
      }
      function ln(t2) {
        return "Point" === t2 || "MultiPoint" === t2 || "LineString" === t2 || "MultiLineString" === t2 || "Polygon" === t2 || "MultiPolygon" === t2;
      }
      class un {
        constructor(t2, e22) {
          this.type = fe, this.geojson = t2, this.geometries = e22;
        }
        static parse(t2, e22) {
          if (2 !== t2.length)
            return e22.error(`'distance' expression requires either one argument, but found ' ${t2.length - 1} instead.`);
          if (Ue(t2[1])) {
            const e3 = t2[1];
            if ("FeatureCollection" === e3.type) {
              for (let t3 = 0; t3 < e3.features.length; ++t3)
                if (ln(e3.features[t3].geometry.type))
                  return new un(e3, e3.features[t3].geometry);
            } else if ("Feature" === e3.type) {
              if (ln(e3.geometry.type))
                return new un(e3, e3.geometry);
            } else if (ln(e3.type))
              return new un(e3, e3);
          }
          return e22.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(t2) {
          const e22 = t2.geometry(), r2 = t2.canonicalID();
          if (null != e22 && null != r2) {
            if ("Point" === t2.geometryType())
              return function(t3, e3, r3) {
                const n2 = [];
                for (const r4 of t3)
                  for (const t4 of r4)
                    n2.push(Gr(t4, e3));
                const i2 = new Er(n2[0][1], "meters");
                return "Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type ? sn(n2, false, "Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, i2) : "MultiLineString" === r3.type ? an(n2, false, r3.coordinates, i2) : "Polygon" === r3.type || "MultiPolygon" === r3.type ? on(n2, false, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2) : null;
              }(e22, r2, this.geometries);
            if ("LineString" === t2.geometryType())
              return function(t3, e3, r3) {
                const n2 = [];
                for (const r4 of t3) {
                  const t4 = [];
                  for (const n3 of r4)
                    t4.push(Gr(n3, e3));
                  n2.push(t4);
                }
                const i2 = new Er(n2[0][0][1], "meters");
                if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type)
                  return an("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                if ("MultiLineString" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                    const s2 = an(r3.coordinates[e4], true, n2, i2, t4);
                    if (isNaN(s2))
                      return s2;
                    if (0 === (t4 = Math.min(t4, s2)))
                      return t4;
                  }
                  return t4;
                }
                if ("Polygon" === r3.type || "MultiPolygon" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < n2.length; e4++) {
                    const s2 = on(n2[e4], true, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2, t4);
                    if (isNaN(s2))
                      return s2;
                    if (0 === (t4 = Math.min(t4, s2)))
                      return t4;
                  }
                  return t4;
                }
                return null;
              }(e22, r2, this.geometries);
            if ("Polygon" === t2.geometryType())
              return function(t3, e3, r3) {
                const n2 = [];
                for (const r4 of function(t4, e4) {
                  const r5 = t4.length;
                  if (r5 <= 1)
                    return [t4];
                  const n3 = [];
                  let i3, s2;
                  for (let e52 = 0; e52 < r5; e52++) {
                    const r6 = cr(t4[e52]);
                    0 !== r6 && (t4[e52].area = Math.abs(r6), void 0 === s2 && (s2 = r6 < 0), s2 === r6 < 0 ? (i3 && n3.push(i3), i3 = [t4[e52]]) : i3.push(t4[e52]));
                  }
                  return i3 && n3.push(i3), n3;
                }(t3)) {
                  const t4 = [];
                  for (let n3 = 0; n3 < r4.length; ++n3)
                    t4.push(Yr(r4[n3], e3));
                  n2.push(t4);
                }
                const i2 = new Er(n2[0][0][0][1], "meters");
                if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type)
                  return on("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                if ("MultiLineString" === r3.type) {
                  let t4 = 1 / 0;
                  for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                    const s2 = on(r3.coordinates[e4], true, n2, i2, t4);
                    if (isNaN(s2))
                      return s2;
                    if (0 === (t4 = Math.min(t4, s2)))
                      return t4;
                  }
                  return t4;
                }
                return "Polygon" === r3.type || "MultiPolygon" === r3.type ? function(t4, e4, r4) {
                  let n3 = 1 / 0;
                  for (const i3 of t4)
                    for (const t5 of e4) {
                      const e52 = en(i3, t5, r4, n3);
                      if (isNaN(e52))
                        return e52;
                      if (0 === (n3 = Math.min(n3, e52)))
                        return n3;
                    }
                  return n3;
                }("Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, n2, i2) : null;
              }(e22, r2, this.geometries);
            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
          } else
            console.warn("Distance Expression: requirs valid feature and canonical information.");
          return null;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["distance", this.geojson];
        }
      }
      var cn = un;
      function hn(t2) {
        if (t2 instanceof ar) {
          if ("get" === t2.name && 1 === t2.args.length)
            return false;
          if ("feature-state" === t2.name)
            return false;
          if ("has" === t2.name && 1 === t2.args.length)
            return false;
          if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof Pr)
          return false;
        if (t2 instanceof cn)
          return false;
        let e22 = true;
        return t2.eachChild((t3) => {
          e22 && !hn(t3) && (e22 = false);
        }), e22;
      }
      function pn(t2) {
        if (t2 instanceof ar && "feature-state" === t2.name)
          return false;
        let e22 = true;
        return t2.eachChild((t3) => {
          e22 && !pn(t3) && (e22 = false);
        }), e22;
      }
      function fn(t2) {
        if (t2 instanceof ar && "config" === t2.name)
          return false;
        let e22 = true;
        return t2.eachChild((t3) => {
          e22 && !fn(t3) && (e22 = false);
        }), e22;
      }
      function dn(t2, e22) {
        if (t2 instanceof ar && e22.indexOf(t2.name) >= 0)
          return false;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 && !dn(t3, e22) && (r2 = false);
        }), r2;
      }
      class mn {
        constructor(t2, e22) {
          this.type = e22.type, this.name = t2, this.boundExpression = e22;
        }
        static parse(t2, e22) {
          if (2 !== t2.length || "string" != typeof t2[1])
            return e22.error("'var' expression requires exactly one string literal argument.");
          const r2 = t2[1];
          return e22.scope.has(r2) ? new mn(r2, e22.scope.get(r2)) : e22.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t2) {
          return this.boundExpression.evaluate(t2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      var yn = mn;
      class gn {
        constructor(t2, e22 = [], r2, n2 = new he(), i2 = [], s2, a2) {
          this.registry = t2, this.path = e22, this.key = e22.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2, this._scope = s2, this.options = a2;
        }
        parse(t2, e22, r2, n2, i2 = {}) {
          return e22 || r2 ? this.concat(e22, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }
        _parse(t2, e22) {
          function r2(t3, e3, r3) {
            return "assert" === r3 ? new Ke(e3, [t3]) : "coerce" === r3 ? new er(e3, [t3]) : t3;
          }
          if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (0 === t2.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n2 = "string" == typeof t2[0] ? this.registry[t2[0]] : void 0;
            if (n2) {
              let i2 = n2.parse(t2, this);
              if (!i2)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, n3 = i2.type;
                if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== n3.kind)
                  if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                    if (this.checkSubtype(t3, n3))
                      return null;
                  } else
                    i2 = r2(i2, t3, e22.typeAnnotation || "coerce");
                else
                  i2 = r2(i2, t3, e22.typeAnnotation || "assert");
              }
              if (!(i2 instanceof Ge) && "resolvedImage" !== i2.type.kind && vn(i2)) {
                const t3 = new nr(this._scope, this.options);
                try {
                  i2 = new Ge(i2.type, i2.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return i2;
            }
            return er.parse(["to-array", t2], this);
          }
          return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
        }
        concat(t2, e22, r2) {
          const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new gn(this.registry, n2, e22 || null, i2, this.errors, this._scope, this.options);
        }
        error(t2, ...e22) {
          const r2 = `${this.key}${e22.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new ue(r2, t2));
        }
        checkSubtype(t2, e22) {
          const r2 = Se(t2, e22);
          return r2 && this.error(r2), r2;
        }
      }
      var xn = gn;
      function vn(t2) {
        if (t2 instanceof yn)
          return vn(t2.boundExpression);
        if (t2 instanceof ar && "error" === t2.name)
          return false;
        if (t2 instanceof ar && "config" === t2.name)
          return false;
        if (t2 instanceof or)
          return false;
        if (t2 instanceof Pr)
          return false;
        if (t2 instanceof cn)
          return false;
        const e22 = t2 instanceof er || t2 instanceof Ke;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 = e22 ? r2 && vn(t3) : r2 && t3 instanceof Ge;
        }), !!r2 && hn(t2) && dn(t2, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light"]);
      }
      function bn(t2, e22) {
        const r2 = t2.length - 1;
        let n2, i2, s2 = 0, a2 = r2, o2 = 0;
        for (; s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e22) {
            if (o2 === r2 || e22 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e22))
              throw new Ye("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }
      class _n {
        constructor(t2, e22, r2) {
          this.type = t2, this.input = e22, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t2, e22) {
          if (t2.length - 1 < 4)
            return e22.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e22.error("Expected an even number of arguments.");
          const r2 = e22.parse(t2[1], 1, fe);
          if (!r2)
            return null;
          const n2 = [];
          let i2 = null;
          e22.expectedType && "value" !== e22.expectedType.kind && (i2 = e22.expectedType);
          for (let r3 = 1; r3 < t2.length; r3 += 2) {
            const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
            if ("number" != typeof s2)
              return e22.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n2.length && n2[n2.length - 1][0] >= s2)
              return e22.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u2 = e22.parse(a2, l2, i2);
            if (!u2)
              return null;
            i2 = i2 || u2.type, n2.push([s2, u2]);
          }
          return new _n(i2, r2, n2);
        }
        evaluate(t2) {
          const e22 = this.labels, r2 = this.outputs;
          if (1 === e22.length)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e22[0])
            return r2[0].evaluate(t2);
          const i2 = e22.length;
          return n2 >= e22[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[bn(e22, n2)].evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input);
          for (const e22 of this.outputs)
            t2(e22);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = ["step", this.input.serialize()];
          for (let e22 = 0; e22 < this.labels.length; e22++)
            e22 > 0 && t2.push(this.labels[e22]), t2.push(this.outputs[e22].serialize());
          return t2;
        }
      }
      var wn = _n;
      function Mn(t2, e22, r2) {
        return t2 * (1 - r2) + e22 * r2;
      }
      function An(t2, e22, r2) {
        return t2.map((t3, n2) => Mn(t3, e22[n2], r2));
      }
      var Sn = Object.freeze({ __proto__: null, array: An, color: function(t2, e22, r2) {
        return new Re(Mn(t2.r, e22.r, r2), Mn(t2.g, e22.g, r2), Mn(t2.b, e22.b, r2), Mn(t2.a, e22.a, r2));
      }, number: Mn });
      const In = 0.95047, kn = 1.08883, Tn = 4 / 29, Pn = 6 / 29, zn = 3 * Pn * Pn, En = Pn * Pn * Pn, Bn = Math.PI / 180, Dn = 180 / Math.PI;
      function Cn(t2) {
        return t2 > En ? Math.pow(t2, 1 / 3) : t2 / zn + Tn;
      }
      function Rn(t2) {
        return t2 > Pn ? t2 * t2 * t2 : zn * (t2 - Tn);
      }
      function Ln(t2) {
        return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
      }
      function Vn(t2) {
        return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function On(t2) {
        const e22 = Vn(t2.r), r2 = Vn(t2.g), n2 = Vn(t2.b), i2 = Cn((0.4124564 * e22 + 0.3575761 * r2 + 0.1804375 * n2) / In), s2 = Cn((0.2126729 * e22 + 0.7151522 * r2 + 0.072175 * n2) / 1);
        return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Cn((0.0193339 * e22 + 0.119192 * r2 + 0.9503041 * n2) / kn)), alpha: t2.a };
      }
      function Fn(t2) {
        let e22 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e22 : e22 + t2.a / 500, n2 = isNaN(t2.b) ? e22 : e22 - t2.b / 200;
        return e22 = 1 * Rn(e22), r2 = In * Rn(r2), n2 = kn * Rn(n2), new Re(Ln(3.2404542 * r2 - 1.5371385 * e22 - 0.4985314 * n2), Ln(-0.969266 * r2 + 1.8760108 * e22 + 0.041556 * n2), Ln(0.0556434 * r2 - 0.2040259 * e22 + 1.0572252 * n2), t2.alpha);
      }
      function jn(t2, e22, r2) {
        const n2 = e22 - t2;
        return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
      }
      const Un = { forward: On, reverse: Fn, interpolate: function(t2, e22, r2) {
        return { l: Mn(t2.l, e22.l, r2), a: Mn(t2.a, e22.a, r2), b: Mn(t2.b, e22.b, r2), alpha: Mn(t2.alpha, e22.alpha, r2) };
      } }, Nn = { forward: function(t2) {
        const { l: e22, a: r2, b: n2 } = On(t2), i2 = Math.atan2(n2, r2) * Dn;
        return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e22, alpha: t2.a };
      }, reverse: function(t2) {
        const e22 = t2.h * Bn, r2 = t2.c;
        return Fn({ l: t2.l, a: Math.cos(e22) * r2, b: Math.sin(e22) * r2, alpha: t2.alpha });
      }, interpolate: function(t2, e22, r2) {
        return { h: jn(t2.h, e22.h, r2), c: Mn(t2.c, e22.c, r2), l: Mn(t2.l, e22.l, r2), alpha: Mn(t2.alpha, e22.alpha, r2) };
      } };
      var $n = Object.freeze({ __proto__: null, hcl: Nn, lab: Un });
      class qn {
        constructor(t2, e22, r2, n2, i2) {
          this.type = t2, this.operator = e22, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t2, e22, r2, n2) {
          let i2 = 0;
          if ("exponential" === t2.name)
            i2 = Gn(e22, t2.base, r2, n2);
          else if ("linear" === t2.name)
            i2 = Gn(e22, 1, r2, n2);
          else if ("cubic-bezier" === t2.name) {
            const s2 = t2.controlPoints;
            i2 = new m(s2[0], s2[1], s2[2], s2[3]).solve(Gn(e22, 1, r2, n2));
          }
          return i2;
        }
        static parse(t2, e22) {
          let [r2, n2, i2, ...s2] = t2;
          if (!Array.isArray(n2) || 0 === n2.length)
            return e22.error("Expected an interpolation type expression.", 1);
          if ("linear" === n2[0])
            n2 = { name: "linear" };
          else if ("exponential" === n2[0]) {
            const t3 = n2[1];
            if ("number" != typeof t3)
              return e22.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: t3 };
          } else {
            if ("cubic-bezier" !== n2[0])
              return e22.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
            {
              const t3 = n2.slice(1);
              if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                return e22.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t2.length - 1 < 4)
            return e22.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e22.error("Expected an even number of arguments.");
          if (i2 = e22.parse(i2, 2, fe), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = ye : e22.expectedType && "value" !== e22.expectedType.kind && (o2 = e22.expectedType);
          for (let t3 = 0; t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
            if ("number" != typeof r3)
              return e22.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e22.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u2 = e22.parse(n3, l2, o2);
            if (!u2)
              return null;
            o2 = o2 || u2.type, a2.push([r3, u2]);
          }
          return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new qn(o2, r2, n2, i2, a2) : e22.error(`Type ${Me(o2)} is not interpolatable.`);
        }
        evaluate(t2) {
          const e22 = this.labels, r2 = this.outputs;
          if (1 === e22.length)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e22[0])
            return r2[0].evaluate(t2);
          const i2 = e22.length;
          if (n2 >= e22[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          const s2 = bn(e22, n2), a2 = qn.interpolationFactor(this.interpolation, n2, e22[s2], e22[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
          return "interpolate" === this.operator ? Sn[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? Nn.reverse(Nn.interpolate(Nn.forward(o2), Nn.forward(l2), a2)) : Un.reverse(Un.interpolate(Un.forward(o2), Un.forward(l2), a2));
        }
        eachChild(t2) {
          t2(this.input);
          for (const e22 of this.outputs)
            t2(e22);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
        serialize() {
          let t2;
          t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const e22 = [this.operator, t2, this.input.serialize()];
          for (let t3 = 0; t3 < this.labels.length; t3++)
            e22.push(this.labels[t3], this.outputs[t3].serialize());
          return e22;
        }
      }
      function Gn(t2, e22, r2, n2) {
        const i2 = n2 - r2, s2 = t2 - r2;
        return 0 === i2 ? 0 : 1 === e22 ? s2 / i2 : (Math.pow(e22, s2) - 1) / (Math.pow(e22, i2) - 1);
      }
      var Yn = qn;
      class Zn {
        constructor(t2, e22) {
          this.type = t2, this.args = e22;
        }
        static parse(t2, e22) {
          if (t2.length < 2)
            return e22.error("Expectected at least one argument.");
          let r2 = null;
          const n2 = e22.expectedType;
          n2 && "value" !== n2.kind && (r2 = n2);
          const i2 = [];
          for (const n3 of t2.slice(1)) {
            const t3 = e22.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r2 = r2 || t3.type, i2.push(t3);
          }
          const s2 = n2 && i2.some((t3) => Se(n2, t3.type));
          return new Zn(s2 ? xe : r2, i2);
        }
        evaluate(t2) {
          let e22, r2 = null, n2 = 0;
          for (const i2 of this.args) {
            if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Fe && !r2.available && (e22 || (e22 = r2), r2 = null, n2 === this.args.length))
              return e22;
            if (null !== r2)
              break;
          }
          return r2;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = ["coalesce"];
          return this.eachChild((e22) => {
            t2.push(e22.serialize());
          }), t2;
        }
      }
      var Xn = Zn;
      class Kn {
        constructor(t2, e22) {
          this.type = e22.type, this.bindings = [].concat(t2), this.result = e22;
        }
        evaluate(t2) {
          return this.result.evaluate(t2);
        }
        eachChild(t2) {
          for (const e22 of this.bindings)
            t2(e22[1]);
          t2(this.result);
        }
        static parse(t2, e22) {
          if (t2.length < 4)
            return e22.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
          const r2 = [];
          for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
            const i2 = t2[n3];
            if ("string" != typeof i2)
              return e22.error(`Expected string, but found ${typeof i2} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e22.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e22.parse(t2[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r2.push([i2, s2]);
          }
          const n2 = e22.parse(t2[t2.length - 1], t2.length - 1, e22.expectedType, r2);
          return n2 ? new Kn(r2, n2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t2 = ["let"];
          for (const [e22, r2] of this.bindings)
            t2.push(e22, r2.serialize());
          return t2.push(this.result.serialize()), t2;
        }
      }
      var Wn = Kn;
      class Hn {
        constructor(t2, e22, r2) {
          this.type = t2, this.index = e22, this.input = r2;
        }
        static parse(t2, e22) {
          if (3 !== t2.length)
            return e22.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e22.parse(t2[1], 1, fe), n2 = e22.parse(t2[2], 2, we(e22.expectedType || xe));
          return r2 && n2 ? new Hn(n2.type.itemType, r2, n2) : null;
        }
        evaluate(t2) {
          const e22 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e22 < 0)
            throw new Ye(`Array index out of bounds: ${e22} < 0.`);
          if (e22 >= r2.length)
            throw new Ye(`Array index out of bounds: ${e22} > ${r2.length - 1}.`);
          if (e22 !== Math.floor(e22))
            throw new Ye(`Array index must be an integer, but found ${e22} instead.`);
          return r2[e22];
        }
        eachChild(t2) {
          t2(this.index), t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      var Jn = Hn;
      class Qn {
        constructor(t2, e22) {
          this.type = me, this.needle = t2, this.haystack = e22;
        }
        static parse(t2, e22) {
          if (3 !== t2.length)
            return e22.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e22.parse(t2[1], 1, xe), n2 = e22.parse(t2[2], 2, xe);
          return r2 && n2 ? Ie(r2.type, [me, de, fe, pe, xe]) ? new Qn(r2, n2) : e22.error(`Expected first argument to be of type boolean, string, number or null, but found ${Me(r2.type)} instead`) : null;
        }
        evaluate(t2) {
          const e22 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (null == r2)
            return false;
          if (!ke(e22, ["boolean", "string", "number", "null"]))
            throw new Ye(`Expected first argument to be of type boolean, string, number or null, but found ${Me(Ne(e22))} instead.`);
          if (!ke(r2, ["string", "array"]))
            throw new Ye(`Expected second argument to be of type array or string, but found ${Me(Ne(r2))} instead.`);
          return r2.indexOf(e22) >= 0;
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var ti = Qn;
      class ei {
        constructor(t2, e22, r2) {
          this.type = fe, this.needle = t2, this.haystack = e22, this.fromIndex = r2;
        }
        static parse(t2, e22) {
          if (t2.length <= 2 || t2.length >= 5)
            return e22.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e22.parse(t2[1], 1, xe), n2 = e22.parse(t2[2], 2, xe);
          if (!r2 || !n2)
            return null;
          if (!Ie(r2.type, [me, de, fe, pe, xe]))
            return e22.error(`Expected first argument to be of type boolean, string, number or null, but found ${Me(r2.type)} instead`);
          if (4 === t2.length) {
            const i2 = e22.parse(t2[3], 3, fe);
            return i2 ? new ei(r2, n2, i2) : null;
          }
          return new ei(r2, n2);
        }
        evaluate(t2) {
          const e22 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!ke(e22, ["boolean", "string", "number", "null"]))
            throw new Ye(`Expected first argument to be of type boolean, string, number or null, but found ${Me(Ne(e22))} instead.`);
          if (!ke(r2, ["string", "array"]))
            throw new Ye(`Expected second argument to be of type array or string, but found ${Me(Ne(r2))} instead.`);
          if (this.fromIndex) {
            const n2 = this.fromIndex.evaluate(t2);
            return r2.indexOf(e22, n2);
          }
          return r2.indexOf(e22);
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            const t2 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var ri = ei;
      class ni {
        constructor(t2, e22, r2, n2, i2, s2) {
          this.inputType = t2, this.type = e22, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t2, e22) {
          if (t2.length < 5)
            return e22.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 1)
            return e22.error("Expected an even number of arguments.");
          let r2, n2;
          e22.expectedType && "value" !== e22.expectedType.kind && (n2 = e22.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
            let o3 = t2[a3];
            const l2 = t2[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u2 = e22.concat(a3);
            if (0 === o3.length)
              return u2.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if ("number" != typeof t3 && "string" != typeof t3)
                return u2.error("Branch labels must be numbers or strings.");
              if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if ("number" == typeof t3 && Math.floor(t3) !== t3)
                return u2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (u2.checkSubtype(r2, Ne(t3)))
                  return null;
              } else
                r2 = Ne(t3);
              if (void 0 !== i2[String(t3)])
                return u2.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c2 = e22.parse(l2, a3, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, s2.push(c2);
          }
          const a2 = e22.parse(t2[1], 1, xe);
          if (!a2)
            return null;
          const o2 = e22.parse(t2[t2.length - 1], t2.length - 1, n2);
          return o2 ? "value" !== a2.type.kind && e22.concat(1).checkSubtype(r2, a2.type) ? null : new ni(r2, n2, a2, i2, s2, o2) : null;
        }
        evaluate(t2) {
          const e22 = this.input.evaluate(t2);
          return (Ne(e22) === this.inputType && this.outputs[this.cases[e22]] || this.otherwise).evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t2 = ["match", this.input.serialize()], e22 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
          for (const t3 of e22) {
            const e3 = n2[this.cases[t3]];
            void 0 === e3 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
          }
          const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
          for (const [e3, n3] of r2)
            t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
          return t2.push(this.otherwise.serialize()), t2;
        }
      }
      var ii = ni;
      class si {
        constructor(t2, e22, r2) {
          this.type = t2, this.branches = e22, this.otherwise = r2;
        }
        static parse(t2, e22) {
          if (t2.length < 4)
            return e22.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 0)
            return e22.error("Expected an odd number of arguments.");
          let r2;
          e22.expectedType && "value" !== e22.expectedType.kind && (r2 = e22.expectedType);
          const n2 = [];
          for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
            const s2 = e22.parse(t2[i3], i3, me);
            if (!s2)
              return null;
            const a2 = e22.parse(t2[i3 + 1], i3 + 1, r2);
            if (!a2)
              return null;
            n2.push([s2, a2]), r2 = r2 || a2.type;
          }
          const i2 = e22.parse(t2[t2.length - 1], t2.length - 1, r2);
          return i2 ? new si(r2, n2, i2) : null;
        }
        evaluate(t2) {
          for (const [e22, r2] of this.branches)
            if (e22.evaluate(t2))
              return r2.evaluate(t2);
          return this.otherwise.evaluate(t2);
        }
        eachChild(t2) {
          for (const [e22, r2] of this.branches)
            t2(e22), t2(r2);
          t2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t2, e22]) => e22.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t2 = ["case"];
          return this.eachChild((e22) => {
            t2.push(e22.serialize());
          }), t2;
        }
      }
      var ai = si;
      class oi {
        constructor(t2, e22, r2, n2) {
          this.type = t2, this.input = e22, this.beginIndex = r2, this.endIndex = n2;
        }
        static parse(t2, e22) {
          if (t2.length <= 2 || t2.length >= 5)
            return e22.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e22.parse(t2[1], 1, xe), n2 = e22.parse(t2[2], 2, fe);
          if (!r2 || !n2)
            return null;
          if (!Ie(r2.type, [we(xe), de, xe]))
            return e22.error(`Expected first argument to be of type array or string, but found ${Me(r2.type)} instead`);
          if (4 === t2.length) {
            const i2 = e22.parse(t2[3], 3, fe);
            return i2 ? new oi(r2.type, r2, n2, i2) : null;
          }
          return new oi(r2.type, r2, n2);
        }
        evaluate(t2) {
          const e22 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
          if (!ke(e22, ["string", "array"]))
            throw new Ye(`Expected first argument to be of type array or string, but found ${Me(Ne(e22))} instead.`);
          if (this.endIndex) {
            const n2 = this.endIndex.evaluate(t2);
            return e22.slice(r2, n2);
          }
          return e22.slice(r2);
        }
        eachChild(t2) {
          t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            const t2 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var li = oi;
      function ui(t2, e22) {
        return "==" === t2 || "!=" === t2 ? "boolean" === e22.kind || "string" === e22.kind || "number" === e22.kind || "null" === e22.kind || "value" === e22.kind : "string" === e22.kind || "number" === e22.kind || "value" === e22.kind;
      }
      function ci(t2, e22, r2, n2) {
        return 0 === n2.compare(e22, r2);
      }
      function hi(t2, e22, r2) {
        const n2 = "==" !== t2 && "!=" !== t2;
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = me, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
          }
          static parse(t3, e3) {
            if (3 !== t3.length && 4 !== t3.length)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, xe);
            if (!s2)
              return null;
            if (!ui(r3, s2.type))
              return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Me(s2.type)}'.`);
            let a2 = e3.parse(t3[2], 2, xe);
            if (!a2)
              return null;
            if (!ui(r3, a2.type))
              return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Me(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
              return e3.error(`Cannot compare types '${Me(s2.type)}' and '${Me(a2.type)}'.`);
            n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new Ke(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new Ke(s2.type, [a2])));
            let o2 = null;
            if (4 === t3.length) {
              if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, ve), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              const e3 = Ne(s2), r3 = Ne(a2);
              if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                throw new Ye(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              const t3 = Ne(s2), r3 = Ne(a2);
              if ("string" !== t3.kind || "string" !== r3.kind)
                return e22(i3, s2, a2);
            }
            return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e22(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const e3 = [t2];
            return this.eachChild((t3) => {
              e3.push(t3.serialize());
            }), e3;
          }
        };
      }
      const pi = hi("==", function(t2, e22, r2) {
        return e22 === r2;
      }, ci), fi = hi("!=", function(t2, e22, r2) {
        return e22 !== r2;
      }, function(t2, e22, r2, n2) {
        return !ci(0, e22, r2, n2);
      }), di = hi("<", function(t2, e22, r2) {
        return e22 < r2;
      }, function(t2, e22, r2, n2) {
        return n2.compare(e22, r2) < 0;
      }), mi = hi(">", function(t2, e22, r2) {
        return e22 > r2;
      }, function(t2, e22, r2, n2) {
        return n2.compare(e22, r2) > 0;
      }), yi = hi("<=", function(t2, e22, r2) {
        return e22 <= r2;
      }, function(t2, e22, r2, n2) {
        return n2.compare(e22, r2) <= 0;
      }), gi = hi(">=", function(t2, e22, r2) {
        return e22 >= r2;
      }, function(t2, e22, r2, n2) {
        return n2.compare(e22, r2) >= 0;
      });
      class xi {
        constructor(t2, e22, r2, n2, i2, s2) {
          this.type = de, this.number = t2, this.locale = e22, this.currency = r2, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
        }
        static parse(t2, e22) {
          if (3 !== t2.length)
            return e22.error("Expected two arguments.");
          const r2 = e22.parse(t2[1], 1, fe);
          if (!r2)
            return null;
          const n2 = t2[2];
          if ("object" != typeof n2 || Array.isArray(n2))
            return e22.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n2.locale && (i2 = e22.parse(n2.locale, 1, de), !i2))
            return null;
          let s2 = null;
          if (n2.currency && (s2 = e22.parse(n2.currency, 1, de), !s2))
            return null;
          let a2 = null;
          if (n2.unit && (a2 = e22.parse(n2.unit, 1, de), !a2))
            return null;
          let o2 = null;
          if (n2["min-fraction-digits"] && (o2 = e22.parse(n2["min-fraction-digits"], 1, fe), !o2))
            return null;
          let l2 = null;
          return n2["max-fraction-digits"] && (l2 = e22.parse(n2["max-fraction-digits"], 1, fe), !l2) ? null : new xi(r2, i2, s2, a2, o2, l2);
        }
        evaluate(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
        }
        eachChild(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = {};
          return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
        }
      }
      class vi {
        constructor(t2) {
          this.type = fe, this.input = t2;
        }
        static parse(t2, e22) {
          if (2 !== t2.length)
            return e22.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = e22.parse(t2[1], 1);
          return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e22.error(`Expected argument of type string or array, but found ${Me(r2.type)} instead.`) : new vi(r2) : null;
        }
        evaluate(t2) {
          const e22 = this.input.evaluate(t2);
          if ("string" == typeof e22)
            return e22.length;
          if (Array.isArray(e22))
            return e22.length;
          throw new Ye(`Expected value to be of type string or array, but found ${Me(Ne(e22))} instead.`);
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = ["length"];
          return this.eachChild((e22) => {
            t2.push(e22.serialize());
          }), t2;
        }
      }
      function bi(t2) {
        return function() {
          t2 = 1831565813 + (t2 |= 0) | 0;
          let e22 = Math.imul(t2 ^ t2 >>> 15, 1 | t2);
          return e22 = e22 + Math.imul(e22 ^ e22 >>> 7, 61 | e22) ^ e22, ((e22 ^ e22 >>> 14) >>> 0) / 4294967296;
        };
      }
      const _i = { "==": pi, "!=": fi, ">": mi, "<": di, ">=": gi, "<=": yi, array: Ke, at: Jn, boolean: Ke, case: ai, coalesce: Xn, collator: or, format: We, image: He, in: ti, "index-of": ri, interpolate: Yn, "interpolate-hcl": Yn, "interpolate-lab": Yn, length: vi, let: Wn, literal: Ge, match: ii, number: Ke, "number-format": xi, object: Ke, slice: li, step: wn, string: Ke, "to-boolean": er, "to-color": er, "to-number": er, "to-string": er, var: yn, within: Pr, distance: cn };
      function wi(t2, [e22, r2, n2, i2]) {
        e22 = e22.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = je(e22, r2, n2, s2);
        if (a2)
          throw new Ye(a2);
        return new Re(e22 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
      }
      function Mi(t2, [e22, r2, n2, i2]) {
        e22 = e22.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = function(t3, e3, r3, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 360 ? "number" == typeof e3 && e3 >= 0 && e3 <= 100 && "number" == typeof r3 && r3 >= 0 && r3 <= 100 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid hsla value [${[t3, e3, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 'h' must be between 0 and 360.`;
        }(e22, r2, n2, s2);
        if (a2)
          throw new Ye(a2);
        const o2 = `hsla(${e22}, ${r2}%, ${n2}%, ${s2})`, l2 = Re.parse(o2);
        if (!l2)
          throw new Ye(`Failed to parse HSLA color: ${o2}`);
        return l2;
      }
      function Ai(t2, e22) {
        return t2 in e22;
      }
      function Si(t2, e22) {
        const r2 = e22[t2];
        return void 0 === r2 ? null : r2;
      }
      function Ii(t2, e22) {
        switch (t2) {
          case "string":
            return String(e22);
          case "number":
            return +e22;
          case "boolean":
            return !!e22;
          case "color":
            return Re.parse(e22);
        }
        return e22;
      }
      function ki(t2, e22, r2, n2) {
        return void 0 !== n2 && (t2 = n2 * Math.round(t2 / n2)), void 0 !== e22 && t2 < e22 && (t2 = e22), void 0 !== r2 && t2 > r2 && (t2 = r2), t2;
      }
      function Ti(t2, e22, r2) {
        e22 = [e22, r2, t2.scope].filter(Boolean).join("");
        const n2 = t2.getConfig(e22);
        if (!n2)
          return null;
        const { type: i2, value: s2, values: a2, minValue: o2, maxValue: l2, stepValue: u2 } = n2, c2 = n2.default.evaluate(t2);
        let h22 = c2;
        if (s2) {
          const e3 = t2.scope;
          t2.scope = (e3 || "").split("").slice(1).join(""), h22 = s2.evaluate(t2), t2.scope = e3;
        }
        return i2 && (h22 = Ii(i2, h22)), void 0 !== s2 && void 0 !== h22 && a2 && !a2.includes(h22) && (h22 = c2, i2 && (h22 = Ii(i2, h22))), void 0 === h22 || void 0 === o2 && void 0 === l2 && void 0 === u2 || ("number" == typeof h22 ? h22 = ki(h22, o2, l2, u2) : Array.isArray(h22) && (h22 = h22.map((t3) => "number" == typeof t3 ? ki(t3, o2, l2, u2) : t3))), h22;
      }
      function Pi(t2) {
        return { type: t2 };
      }
      ar.register(_i, { error: [{ kind: "error" }, [de], (t2, [e22]) => {
        throw new Ye(e22.evaluate(t2));
      }], typeof: [de, [xe], (t2, [e22]) => Me(Ne(e22.evaluate(t2)))], "to-rgba": [we(fe, 4), [ye], (t2, [e22]) => e22.evaluate(t2).toArray()], rgb: [ye, [fe, fe, fe], wi], rgba: [ye, [fe, fe, fe, fe], wi], hsl: [ye, [fe, fe, fe], Mi], hsla: [ye, [fe, fe, fe, fe], Mi], has: { type: me, overloads: [[[de], (t2, [e22]) => Ai(e22.evaluate(t2), t2.properties())], [[de, ge], (t2, [e22, r2]) => Ai(e22.evaluate(t2), r2.evaluate(t2))]] }, get: { type: xe, overloads: [[[de], (t2, [e22]) => Si(e22.evaluate(t2), t2.properties())], [[de, ge], (t2, [e22, r2]) => Si(e22.evaluate(t2), r2.evaluate(t2))]] }, config: { type: xe, overloads: [[[de], (t2, [e22]) => Ti(t2, e22.evaluate(t2))], [[de, de], (t2, [e22, r2]) => Ti(t2, e22.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [xe, [de], (t2, [e22]) => Si(e22.evaluate(t2), t2.featureState || {})], properties: [ge, [], (t2) => t2.properties()], "geometry-type": [de, [], (t2) => t2.geometryType()], id: [xe, [], (t2) => t2.id()], zoom: [fe, [], (t2) => t2.globals.zoom], pitch: [fe, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [fe, [], (t2) => t2.distanceFromCenter()], "measure-light": [fe, [de], (t2, [e22]) => t2.measureLight(e22.evaluate(t2))], "heatmap-density": [fe, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [fe, [], (t2) => t2.globals.lineProgress || 0], "raster-value": [fe, [], (t2) => t2.globals.rasterValue || 0], "sky-radial-progress": [fe, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [xe, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [fe, Pi(fe), (t2, e22) => {
        let r2 = 0;
        for (const n2 of e22)
          r2 += n2.evaluate(t2);
        return r2;
      }], "*": [fe, Pi(fe), (t2, e22) => {
        let r2 = 1;
        for (const n2 of e22)
          r2 *= n2.evaluate(t2);
        return r2;
      }], "-": { type: fe, overloads: [[[fe, fe], (t2, [e22, r2]) => e22.evaluate(t2) - r2.evaluate(t2)], [[fe], (t2, [e22]) => -e22.evaluate(t2)]] }, "/": [fe, [fe, fe], (t2, [e22, r2]) => e22.evaluate(t2) / r2.evaluate(t2)], "%": [fe, [fe, fe], (t2, [e22, r2]) => e22.evaluate(t2) % r2.evaluate(t2)], ln2: [fe, [], () => Math.LN2], pi: [fe, [], () => Math.PI], e: [fe, [], () => Math.E], "^": [fe, [fe, fe], (t2, [e22, r2]) => Math.pow(e22.evaluate(t2), r2.evaluate(t2))], sqrt: [fe, [fe], (t2, [e22]) => Math.sqrt(e22.evaluate(t2))], log10: [fe, [fe], (t2, [e22]) => Math.log(e22.evaluate(t2)) / Math.LN10], ln: [fe, [fe], (t2, [e22]) => Math.log(e22.evaluate(t2))], log2: [fe, [fe], (t2, [e22]) => Math.log(e22.evaluate(t2)) / Math.LN2], sin: [fe, [fe], (t2, [e22]) => Math.sin(e22.evaluate(t2))], cos: [fe, [fe], (t2, [e22]) => Math.cos(e22.evaluate(t2))], tan: [fe, [fe], (t2, [e22]) => Math.tan(e22.evaluate(t2))], asin: [fe, [fe], (t2, [e22]) => Math.asin(e22.evaluate(t2))], acos: [fe, [fe], (t2, [e22]) => Math.acos(e22.evaluate(t2))], atan: [fe, [fe], (t2, [e22]) => Math.atan(e22.evaluate(t2))], min: [fe, Pi(fe), (t2, e22) => Math.min(...e22.map((e3) => e3.evaluate(t2)))], max: [fe, Pi(fe), (t2, e22) => Math.max(...e22.map((e3) => e3.evaluate(t2)))], abs: [fe, [fe], (t2, [e22]) => Math.abs(e22.evaluate(t2))], round: [fe, [fe], (t2, [e22]) => {
        const r2 = e22.evaluate(t2);
        return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
      }], floor: [fe, [fe], (t2, [e22]) => Math.floor(e22.evaluate(t2))], ceil: [fe, [fe], (t2, [e22]) => Math.ceil(e22.evaluate(t2))], "filter-==": [me, [de, xe], (t2, [e22, r2]) => t2.properties()[e22.value] === r2.value], "filter-id-==": [me, [xe], (t2, [e22]) => t2.id() === e22.value], "filter-type-==": [me, [de], (t2, [e22]) => t2.geometryType() === e22.value], "filter-<": [me, [de, xe], (t2, [e22, r2]) => {
        const n2 = t2.properties()[e22.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 < i2;
      }], "filter-id-<": [me, [xe], (t2, [e22]) => {
        const r2 = t2.id(), n2 = e22.value;
        return typeof r2 == typeof n2 && r2 < n2;
      }], "filter->": [me, [de, xe], (t2, [e22, r2]) => {
        const n2 = t2.properties()[e22.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 > i2;
      }], "filter-id->": [me, [xe], (t2, [e22]) => {
        const r2 = t2.id(), n2 = e22.value;
        return typeof r2 == typeof n2 && r2 > n2;
      }], "filter-<=": [me, [de, xe], (t2, [e22, r2]) => {
        const n2 = t2.properties()[e22.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 <= i2;
      }], "filter-id-<=": [me, [xe], (t2, [e22]) => {
        const r2 = t2.id(), n2 = e22.value;
        return typeof r2 == typeof n2 && r2 <= n2;
      }], "filter->=": [me, [de, xe], (t2, [e22, r2]) => {
        const n2 = t2.properties()[e22.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 >= i2;
      }], "filter-id->=": [me, [xe], (t2, [e22]) => {
        const r2 = t2.id(), n2 = e22.value;
        return typeof r2 == typeof n2 && r2 >= n2;
      }], "filter-has": [me, [xe], (t2, [e22]) => e22.value in t2.properties()], "filter-has-id": [me, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [me, [we(de)], (t2, [e22]) => e22.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [me, [we(xe)], (t2, [e22]) => e22.value.indexOf(t2.id()) >= 0], "filter-in-small": [me, [de, we(xe)], (t2, [e22, r2]) => r2.value.indexOf(t2.properties()[e22.value]) >= 0], "filter-in-large": [me, [de, we(xe)], (t2, [e22, r2]) => function(t3, e3, r3, n2) {
        for (; r3 <= n2; ) {
          const i2 = r3 + n2 >> 1;
          if (e3[i2] === t3)
            return true;
          e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
        }
        return false;
      }(t2.properties()[e22.value], r2.value, 0, r2.value.length - 1)], all: { type: me, overloads: [[[me, me], (t2, [e22, r2]) => e22.evaluate(t2) && r2.evaluate(t2)], [Pi(me), (t2, e22) => {
        for (const r2 of e22)
          if (!r2.evaluate(t2))
            return false;
        return true;
      }]] }, any: { type: me, overloads: [[[me, me], (t2, [e22, r2]) => e22.evaluate(t2) || r2.evaluate(t2)], [Pi(me), (t2, e22) => {
        for (const r2 of e22)
          if (r2.evaluate(t2))
            return true;
        return false;
      }]] }, "!": [me, [me], (t2, [e22]) => !e22.evaluate(t2)], "is-supported-script": [me, [de], (t2, [e22]) => {
        const r2 = t2.globals && t2.globals.isSupportedScript;
        return !r2 || r2(e22.evaluate(t2));
      }], upcase: [de, [de], (t2, [e22]) => e22.evaluate(t2).toUpperCase()], downcase: [de, [de], (t2, [e22]) => e22.evaluate(t2).toLowerCase()], concat: [de, Pi(xe), (t2, e22) => e22.map((e3) => $e(e3.evaluate(t2))).join("")], "resolved-locale": [de, [ve], (t2, [e22]) => e22.evaluate(t2).resolvedLocale()], random: [fe, [fe, fe, xe], (t2, e22) => {
        const [r2, n2, i2] = e22.map((e3) => e3.evaluate(t2));
        if (r2 > n2)
          return r2;
        if (r2 === n2)
          return r2;
        let s2;
        if ("string" == typeof i2)
          s2 = function(t3) {
            let e3 = 0;
            if (0 === t3.length)
              return e3;
            for (let r3 = 0; r3 < t3.length; r3++)
              e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 &= e3;
            return e3;
          }(i2);
        else {
          if ("number" != typeof i2)
            throw new Ye(`Invalid seed input: ${i2}`);
          s2 = i2;
        }
        return r2 + bi(s2)() * (n2 - r2);
      }] });
      var zi = _i;
      function Ei(t2) {
        return { result: "success", value: t2 };
      }
      function Bi(t2) {
        return { result: "error", value: t2 };
      }
      function Di(t2, e22) {
        return !!t2 && !!t2.parameters && t2.parameters.indexOf(e22) > -1;
      }
      function Ci(t2) {
        return "data-driven" === t2["property-type"];
      }
      function Ri(t2) {
        return Di(t2.expression, "measure-light");
      }
      function Li(t2) {
        return Di(t2.expression, "zoom");
      }
      function Vi(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function Oi(t2) {
        return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
      }
      function Fi(t2) {
        return t2;
      }
      function ji(t2, e22) {
        const r2 = "color" === e22.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Vi(e22) ? "exponential" : "interval");
        if (r2 && ((t2 = se({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], Re.parse(t3[1])])), t2.default = Re.parse(t2.default ? t2.default : e22.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !$n[t2.colorSpace])
          throw new Error(`Unknown color space: ${t2.colorSpace}`);
        let a2, o2, l2;
        if ("exponential" === s2)
          a2 = qi;
        else if ("interval" === s2)
          a2 = $i;
        else if ("categorical" === s2) {
          a2 = Ni, o2 = /* @__PURE__ */ Object.create(null);
          for (const e3 of t2.stops)
            o2[e3[0]] = e3[1];
          l2 = typeof t2.stops[0][0];
        } else {
          if ("identity" !== s2)
            throw new Error(`Unknown function type "${s2}"`);
          a2 = Gi;
        }
        if (n2) {
          const r3 = {}, n3 = [];
          for (let e3 = 0; e3 < t2.stops.length; e3++) {
            const i4 = t2.stops[e3], s4 = i4[0].zoom;
            void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, ji(r3[t3], e22)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: Yn.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => qi({ stops: i3, base: t2.base }, e22, r4).evaluate(r4, n4) };
        }
        if (i2) {
          const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: Yn.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e22, r4, o2, l2) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
          return void 0 === i3 ? Ui(t2.default, e22.default) : a2(t2, e22, i3, o2, l2);
        } };
      }
      function Ui(t2, e22, r2) {
        return void 0 !== t2 ? t2 : void 0 !== e22 ? e22 : void 0 !== r2 ? r2 : void 0;
      }
      function Ni(t2, e22, r2, n2, i2) {
        return Ui(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e22.default);
      }
      function $i(t2, e22, r2) {
        if ("number" !== Je(r2))
          return Ui(t2.default, e22.default);
        const n2 = t2.stops.length;
        if (1 === n2)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        const i2 = bn(t2.stops.map((t3) => t3[0]), r2);
        return t2.stops[i2][1];
      }
      function qi(t2, e22, r2) {
        const n2 = void 0 !== t2.base ? t2.base : 1;
        if ("number" !== Je(r2))
          return Ui(t2.default, e22.default);
        const i2 = t2.stops.length;
        if (1 === i2)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        const s2 = bn(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
        let u2 = Sn[e22.type] || Fi;
        if (t2.colorSpace && "rgb" !== t2.colorSpace) {
          const e3 = $n[t2.colorSpace];
          u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
        }
        return "function" == typeof o2.evaluate ? { evaluate(...t3) {
          const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
          if (void 0 !== e3 && void 0 !== r3)
            return u2(e3, r3, a2);
        } } : u2(o2, l2, a2);
      }
      function Gi(t2, e22, r2) {
        return "color" === e22.type ? r2 = Re.parse(r2) : "formatted" === e22.type ? r2 = Oe.fromString(r2.toString()) : "resolvedImage" === e22.type ? r2 = Fe.fromString(r2.toString()) : Je(r2) === e22.type || "enum" === e22.type && e22.values[r2] || (r2 = void 0), Ui(r2, t2.default, e22.default);
      }
      class Yi {
        constructor(t2, e22, r2, n2) {
          this.expression = t2, this._warningHistory = {}, this._evaluator = new nr(r2, n2), this._defaultValue = e22 ? function(t3) {
            return "color" === t3.type && (Oi(t3.default) || Array.isArray(t3.default)) ? new Re(0, 0, 0, 0) : "color" === t3.type ? Re.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
          }(e22) : null, this._enumValues = e22 && "enum" === e22.type ? e22.values : null;
        }
        evaluateWithoutErrorHandling(t2, e22, r2, n2, i2, s2, a2, o2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e22, this._evaluator.featureState = r2, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(t2, e22, r2, n2, i2, s2, a2, o2) {
          this._evaluator.globals = t2, this._evaluator.feature = e22 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = a2 || null, this._evaluator.featureDistanceData = o2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (null == t3 || "number" == typeof t3 && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new Ye(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
          }
        }
      }
      function Zi(t2) {
        return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in zi;
      }
      function Xi(t2, e22, r2, n2) {
        const i2 = new xn(zi, [], e22 ? function(t3) {
          const e3 = { color: ye, string: de, number: fe, enum: de, boolean: me, formatted: be, resolvedImage: _e };
          return "array" === t3.type ? we(e3[t3.value] || xe, t3.length) : e3[t3.type];
        }(e22) : void 0, void 0, void 0, r2, n2), s2 = i2.parse(t2, void 0, void 0, void 0, e22 && "string" === e22.type ? { typeAnnotation: "coerce" } : void 0);
        return s2 ? Ei(new Yi(s2, e22, r2, n2)) : Bi(i2.errors);
      }
      class Ki {
        constructor(t2, e22, r2) {
          this.kind = t2, this._styleExpression = e22, this.isLightConstant = r2, this.isStateDependent = "constant" !== t2 && !pn(e22.expression), this.isConfigDependent = !fn(e22.expression);
        }
        evaluateWithoutErrorHandling(t2, e22, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e22, r2, n2, i2, s2);
        }
        evaluate(t2, e22, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e22, r2, n2, i2, s2);
        }
      }
      class Wi {
        constructor(t2, e22, r2, n2, i2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e22, this.isStateDependent = "camera" !== t2 && !pn(e22.expression), this.isLightConstant = i2, this.isConfigDependent = !fn(e22.expression), this.interpolationType = n2;
        }
        evaluateWithoutErrorHandling(t2, e22, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e22, r2, n2, i2, s2);
        }
        evaluate(t2, e22, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e22, r2, n2, i2, s2);
        }
        interpolationFactor(t2, e22, r2) {
          return this.interpolationType ? Yn.interpolationFactor(this.interpolationType, t2, e22, r2) : 0;
        }
      }
      function Hi(t2, e22, r2, n2) {
        if ("error" === (t2 = Xi(t2, e22, r2, n2)).result)
          return t2;
        const i2 = t2.value.expression, s2 = hn(i2);
        if (!s2 && !Ci(e22))
          return Bi([new ue("", "data expressions not supported")]);
        const a2 = dn(i2, ["zoom", "pitch", "distance-from-center"]);
        if (!a2 && !Li(e22))
          return Bi([new ue("", "zoom expressions not supported")]);
        const o2 = dn(i2, ["measure-light"]);
        if (!o2 && !Ri(e22))
          return Bi([new ue("", "measure-light expression not supported")]);
        const l2 = e22.expression && e22.expression.relaxZoomRestriction, u2 = Qi(i2);
        return u2 || a2 || l2 ? u2 instanceof ue ? Bi([u2]) : u2 instanceof Yn && !Vi(e22) ? Bi([new ue("", '"interpolate" expressions cannot be used with this property')]) : Ei(u2 ? new Wi(s2 ? "camera" : "composite", t2.value, u2.labels, u2 instanceof Yn ? u2.interpolation : void 0, o2) : new Ki(s2 ? "constant" : "source", t2.value, o2)) : Bi([new ue("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class Ji {
        constructor(t2, e22) {
          this._parameters = t2, this._specification = e22, se(this, ji(this._parameters, this._specification));
        }
        static deserialize(t2) {
          return new Ji(t2._parameters, t2._specification);
        }
        static serialize(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        }
      }
      function Qi(t2) {
        let e22 = null;
        if (t2 instanceof Wn)
          e22 = Qi(t2.result);
        else if (t2 instanceof Xn) {
          for (const r2 of t2.args)
            if (e22 = Qi(r2), e22)
              break;
        } else
          (t2 instanceof wn || t2 instanceof Yn) && t2.input instanceof ar && "zoom" === t2.input.name && (e22 = t2);
        return e22 instanceof ue || t2.eachChild((t3) => {
          const r2 = Qi(t3);
          r2 instanceof ue ? e22 = r2 : e22 && r2 && e22 !== r2 && (e22 = new ue("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e22;
      }
      function ts(t2) {
        const e22 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
        let o2 = [];
        const l2 = Je(r2);
        if ("object" !== l2)
          return [new ne(e22, r2, `object expected, ${l2} found`)];
        for (const t3 in r2) {
          const l3 = t3.split(".")[0];
          let u2;
          i2[l3] ? u2 = i2[l3] : n2[l3] ? u2 = Ls : i2["*"] ? u2 = i2["*"] : n2["*"] && (u2 = Ls), u2 ? o2 = o2.concat(u2({ key: (e22 ? `${e22}.` : e22) + t3, value: r2[t3], valueSpec: n2[l3] || n2["*"], style: s2, styleSpec: a2, object: r2, objectKey: t3 }, r2)) : o2.push(new ie(e22, r2[t3], `unknown property "${t3}"`));
        }
        for (const t3 in n2)
          i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && o2.push(new ne(e22, r2, `missing required property "${t3}"`));
        return o2;
      }
      function es(t2) {
        const e22 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || Ls;
        if ("array" !== Je(e22))
          return [new ne(s2, e22, `array expected, ${Je(e22)} found`)];
        if (r2.length && e22.length !== r2.length)
          return [new ne(s2, e22, `array length ${r2.length} expected, length ${e22.length} found`)];
        if (r2["min-length"] && e22.length < r2["min-length"])
          return [new ne(s2, e22, `array length at least ${r2["min-length"]} expected, length ${e22.length} found`)];
        let o2 = { type: r2.value, values: r2.values, minimum: r2.minimum, maximum: r2.maximum, function: void 0 };
        i2.$version < 7 && (o2.function = r2.function), "object" === Je(r2.value) && (o2 = r2.value);
        let l2 = [];
        for (let t3 = 0; t3 < e22.length; t3++)
          l2 = l2.concat(a2({ array: e22, arrayIndex: t3, value: e22[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }, true));
        return l2;
      }
      function rs(t2) {
        const e22 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
        let i2 = Je(r2);
        if ("number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2)
          return [new ne(e22, r2, `number expected, ${i2} found`)];
        if ("minimum" in n2) {
          let i3 = n2.minimum;
          if ("array" === Je(n2.minimum) && (i3 = n2.minimum[t2.arrayIndex]), r2 < i3)
            return [new ne(e22, r2, `${r2} is less than the minimum value ${i3}`)];
        }
        if ("maximum" in n2) {
          let i3 = n2.maximum;
          if ("array" === Je(n2.maximum) && (i3 = n2.maximum[t2.arrayIndex]), r2 > i3)
            return [new ne(e22, r2, `${r2} is greater than the maximum value ${i3}`)];
        }
        return [];
      }
      function ns(t2) {
        const e22 = t2.valueSpec, r2 = ae(t2.value.type);
        let n2, i2, s2, a2 = {};
        const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === Je(t2.value.stops) && "array" === Je(t2.value.stops[0]) && "object" === Je(t2.value.stops[0][0]), c2 = ts({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
          if ("identity" === r2)
            return [new ne(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n3 = t3.value;
          return e3 = e3.concat(es({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h22 })), "array" === Je(n3) && 0 === n3.length && e3.push(new ne(t3.key, n3, "array must have at least one stop")), e3;
        }, default: function(t3) {
          return Ls({ key: t3.key, value: t3.value, valueSpec: e22, style: t3.style, styleSpec: t3.styleSpec });
        } } });
        return "identity" === r2 && o2 && c2.push(new ne(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new ne(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Vi(t2.valueSpec) && c2.push(new ne(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !Ci(t2.valueSpec) ? c2.push(new ne(t2.key, t2.value, "property functions not supported")) : o2 && !Li(t2.valueSpec) && c2.push(new ne(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new ne(t2.key, t2.value, '"property" property is required')), c2;
        function h22(t3) {
          let r3 = [];
          const n3 = t3.value, o3 = t3.key;
          if ("array" !== Je(n3))
            return [new ne(o3, n3, `array expected, ${Je(n3)} found`)];
          if (2 !== n3.length)
            return [new ne(o3, n3, `array length 2 expected, length ${n3.length} found`)];
          if (u2) {
            if ("object" !== Je(n3[0]))
              return [new ne(o3, n3, `object expected, ${Je(n3[0])} found`)];
            if (void 0 === n3[0].zoom)
              return [new ne(o3, n3, "object stop key must have zoom")];
            if (void 0 === n3[0].value)
              return [new ne(o3, n3, "object stop key must have value")];
            const e3 = ae(n3[0].zoom);
            if ("number" != typeof e3)
              return [new ne(o3, n3[0].zoom, "stop zoom values must be numbers")];
            if (s2 && s2 > e3)
              return [new ne(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
            e3 !== s2 && (s2 = e3, i2 = void 0, a2 = {}), r3 = r3.concat(ts({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: rs, value: p2 } }));
          } else
            r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
          return Zi(oe(n3[1])) ? r3.concat([new ne(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(Ls({ key: `${o3}[1]`, value: n3[1], valueSpec: e22, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function p2(t3, s3) {
          const o3 = Je(t3.value), l3 = ae(t3.value), u3 = null !== t3.value ? t3.value : s3;
          if (n2) {
            if (o3 !== n2)
              return [new ne(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
          } else
            n2 = o3;
          if ("number" !== o3 && "string" !== o3 && "boolean" !== o3 && "number" != typeof l3 && "string" != typeof l3 && "boolean" != typeof l3)
            return [new ne(t3.key, u3, "stop domain value must be a number, string, or boolean")];
          if ("number" !== o3 && "categorical" !== r2) {
            let n3 = `number expected, ${o3} found`;
            return Ci(e22) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ne(t3.key, u3, n3)];
          }
          return "categorical" !== r2 || "number" !== o3 || "number" == typeof l3 && isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && "number" == typeof l3 && "number" == typeof i2 && void 0 !== i2 && l3 < i2 ? [new ne(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new ne(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new ne(t3.key, u3, `integer expected, found ${String(l3)}`)];
        }
      }
      function is(t2) {
        const e22 = ("property" === t2.expressionContext ? Hi : Xi)(oe(t2.value), t2.valueSpec);
        if ("error" === e22.result)
          return e22.value.map((e3) => new ne(`${t2.key}${e3.key}`, t2.value, e3.message));
        const r2 = e22.value.expression || e22.value._styleExpression.expression;
        if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
          return [new ne(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
        if ("property" === t2.expressionContext && "layout" === t2.propertyType && !pn(r2))
          return [new ne(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === t2.expressionContext)
          return ss(r2, t2);
        if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
          if (!dn(r2, ["zoom", "feature-state"]))
            return [new ne(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === t2.expressionContext && !hn(r2))
            return [new ne(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function ss(t2, e22) {
        const r2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (e22.valueSpec && e22.valueSpec.expression)
          for (const t3 of e22.valueSpec.expression.parameters)
            r2.delete(t3);
        if (0 === r2.size)
          return [];
        const n2 = [];
        return t2 instanceof ar && r2.has(t2.name) ? [new ne(e22.key, e22.value, `["${t2.name}"] expression is not supported in a filter for a ${e22.object.type} layer with id: ${e22.object.id}`)] : (t2.eachChild((t3) => {
          n2.push(...ss(t3, e22));
        }), n2);
      }
      function as(t2) {
        const e22 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
        return Array.isArray(n2.values) ? -1 === n2.values.indexOf(ae(r2)) && i2.push(new ne(e22, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(ae(r2)) && i2.push(new ne(e22, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
      }
      function os(t2) {
        if (true === t2 || false === t2)
          return true;
        if (!Array.isArray(t2) || 0 === t2.length)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
          case "in":
            return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (const e22 of t2.slice(1))
              if (!os(e22) && "boolean" != typeof e22)
                return false;
            return true;
          default:
            return true;
        }
      }
      function ls(t2, e22 = "fill") {
        if (null == t2)
          return { filter: () => true, needGeometry: false, needFeature: false };
        os(t2) || (t2 = ms(t2));
        const r2 = t2;
        let n2 = true;
        try {
          n2 = function(t3) {
            if (!hs(t3))
              return t3;
            let e3 = oe(t3);
            return cs(e3), e3 = us(e3), e3;
          }(r2);
        } catch (t3) {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r2, null, 2)}
        `);
        }
        const i2 = re2[`filter_${e22}`], s2 = Xi(n2, i2);
        let a2 = null;
        if ("error" === s2.result)
          throw new Error(s2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
        a2 = (t3, e3, r3) => s2.value.evaluate(t3, e3, {}, r3);
        let o2 = null, l2 = null;
        if (n2 !== r2) {
          const t3 = Xi(r2, i2);
          if ("error" === t3.result)
            throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          o2 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), l2 = !hn(t3.value.expression);
        }
        return { filter: a2, dynamicFilter: o2 || void 0, needGeometry: ds(n2), needFeature: !!l2 };
      }
      function us(t2) {
        if (!Array.isArray(t2))
          return t2;
        const e22 = function(t3) {
          if (ps.has(t3[0])) {
            for (let e3 = 1; e3 < t3.length; e3++)
              if (hs(t3[e3]))
                return true;
          }
          return t3;
        }(t2);
        return true === e22 ? e22 : e22.map((t3) => us(t3));
      }
      function cs(t2) {
        let e22 = false;
        const r2 = [];
        if ("case" === t2[0]) {
          for (let n2 = 1; n2 < t2.length - 1; n2 += 2)
            e22 = e22 || hs(t2[n2]), r2.push(t2[n2 + 1]);
          r2.push(t2[t2.length - 1]);
        } else if ("match" === t2[0]) {
          e22 = e22 || hs(t2[1]);
          for (let e3 = 2; e3 < t2.length - 1; e3 += 2)
            r2.push(t2[e3 + 1]);
          r2.push(t2[t2.length - 1]);
        } else if ("step" === t2[0]) {
          e22 = e22 || hs(t2[1]);
          for (let e3 = 1; e3 < t2.length - 1; e3 += 2)
            r2.push(t2[e3 + 1]);
        }
        e22 && (t2.length = 0, t2.push("any", ...r2));
        for (let e3 = 1; e3 < t2.length; e3++)
          cs(t2[e3]);
      }
      function hs(t2) {
        if (!Array.isArray(t2))
          return false;
        if ("pitch" === (e22 = t2[0]) || "distance-from-center" === e22)
          return true;
        var e22;
        for (let e3 = 1; e3 < t2.length; e3++)
          if (hs(t2[e3]))
            return true;
        return false;
      }
      const ps = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function fs(t2, e22) {
        return t2 < e22 ? -1 : t2 > e22 ? 1 : 0;
      }
      function ds(t2) {
        if (!Array.isArray(t2))
          return false;
        if ("within" === t2[0] || "distance" === t2[0])
          return true;
        for (let e22 = 1; e22 < t2.length; e22++)
          if (ds(t2[e22]))
            return true;
        return false;
      }
      function ms(t2) {
        if (!t2)
          return true;
        const e22 = t2[0];
        return t2.length <= 1 ? "any" !== e22 : "==" === e22 ? ys(t2[1], t2[2], "==") : "!=" === e22 ? vs(ys(t2[1], t2[2], "==")) : "<" === e22 || ">" === e22 || "<=" === e22 || ">=" === e22 ? ys(t2[1], t2[2], e22) : "any" === e22 ? (r2 = t2.slice(1), ["any"].concat(r2.map(ms))) : "all" === e22 ? ["all"].concat(t2.slice(1).map(ms)) : "none" === e22 ? ["all"].concat(t2.slice(1).map(ms).map(vs)) : "in" === e22 ? gs(t2[1], t2.slice(2)) : "!in" === e22 ? vs(gs(t2[1], t2.slice(2))) : "has" === e22 ? xs(t2[1]) : "!has" !== e22 || vs(xs(t2[1]));
        var r2;
      }
      function ys(t2, e22, r2) {
        switch (t2) {
          case "$type":
            return [`filter-type-${r2}`, e22];
          case "$id":
            return [`filter-id-${r2}`, e22];
          default:
            return [`filter-${r2}`, t2, e22];
        }
      }
      function gs(t2, e22) {
        if (0 === e22.length)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e22]];
          case "$id":
            return ["filter-id-in", ["literal", e22]];
          default:
            return e22.length > 200 && !e22.some((t3) => typeof t3 != typeof e22[0]) ? ["filter-in-large", t2, ["literal", e22.sort(fs)]] : ["filter-in-small", t2, ["literal", e22]];
        }
      }
      function xs(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function vs(t2) {
        return ["!", t2];
      }
      function bs(t2) {
        return os(oe(t2.value)) ? is(se({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : _s(t2);
      }
      function _s(t2) {
        const e22 = t2.value, r2 = t2.key;
        if ("array" !== Je(e22))
          return [new ne(r2, e22, `array expected, ${Je(e22)} found`)];
        const n2 = t2.styleSpec;
        let i2, s2 = [];
        if (e22.length < 1)
          return [new ne(r2, e22, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(as({ key: `${r2}[0]`, value: e22[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), ae(e22[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e22.length >= 2 && "$type" === ae(e22[1]) && s2.push(new ne(r2, e22, `"$type" cannot be use with operator "${e22[0]}"`));
          case "==":
          case "!=":
            3 !== e22.length && s2.push(new ne(r2, e22, `filter array for operator "${e22[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e22.length >= 2 && (i2 = Je(e22[1]), "string" !== i2 && s2.push(new ne(`${r2}[1]`, e22[1], `string expected, ${i2} found`)));
            for (let a2 = 2; a2 < e22.length; a2++)
              i2 = Je(e22[a2]), "$type" === ae(e22[1]) ? s2 = s2.concat(as({ key: `${r2}[${a2}]`, value: e22[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new ne(`${r2}[${a2}]`, e22[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n3 = 1; n3 < e22.length; n3++)
              s2 = s2.concat(_s({ key: `${r2}[${n3}]`, value: e22[n3], style: t2.style, styleSpec: t2.styleSpec }));
            break;
          case "has":
          case "!has":
            i2 = Je(e22[1]), 2 !== e22.length ? s2.push(new ne(r2, e22, `filter array for "${e22[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new ne(`${r2}[1]`, e22[1], `string expected, ${i2} found`));
        }
        return s2;
      }
      function ws(t2, e22) {
        const r2 = t2.key, n2 = t2.style, i2 = t2.layer, s2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, l2 = s2[`${e22}_${t2.layerType}`];
        if (!l2)
          return [];
        const u2 = o2.match(/^(.*)-transition$/);
        if ("paint" === e22 && u2 && l2[u2[1]] && l2[u2[1]].transition)
          return Ls({ key: r2, value: a2, valueSpec: s2.transition, style: n2, styleSpec: s2 });
        const c2 = t2.valueSpec || l2[o2];
        if (!c2)
          return [new ie(r2, a2, `unknown property "${o2}"`)];
        let h22;
        if ("string" === Je(a2) && Ci(c2) && !c2.tokens && (h22 = /^{([^}]+)}$/.exec(a2))) {
          const t3 = `\`{ "type": "identity", "property": ${h22 ? JSON.stringify(h22[1]) : '"_"'} }\``;
          return [new ne(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
        }
        const p2 = [];
        if ("symbol" === t2.layerType)
          "text-field" !== o2 || !n2 || n2.glyphs || n2.imports || p2.push(new ne(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Oi(oe(a2)) && "identity" === ae(a2.type) && p2.push(new ne(r2, a2, '"text-font" does not support identity functions'));
        else if ("model" === t2.layerType && "paint" === e22 && i2 && i2.layout && i2.layout.hasOwnProperty("model-id") && Ci(c2) && (Ri(c2) || Li(c2))) {
          const t3 = Hi(oe(a2), c2), e3 = t3.value.expression || t3.value._styleExpression.expression;
          e3 && !dn(e3, ["measure-light"]) && ("model-emissive-strength" === o2 && hn(e3) && pn(e3) || p2.push(new ne(r2, a2, `${o2} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
        }
        return p2.concat(Ls({ key: t2.key, value: a2, valueSpec: c2, style: n2, styleSpec: s2, expressionContext: "property", propertyType: e22, propertyKey: o2 }));
      }
      function Ms(t2) {
        return ws(t2, "paint");
      }
      function As(t2) {
        return ws(t2, "layout");
      }
      function Ss(t2) {
        let e22 = [];
        const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
        r2.type || r2.ref || e22.push(new ne(n2, r2, 'either "type" or "ref" is required'));
        let a2 = ae(r2.type);
        const o2 = ae(r2.ref);
        if (r2.id) {
          const s3 = ae(r2.id);
          for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
            const t3 = i2.layers[a3];
            ae(t3.id) === s3 && e22.push(new ne(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in r2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in r2 && e22.push(new ne(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            ae(e3.id) === o2 && (t3 = e3);
          }), t3 ? t3.ref ? e22.push(new ne(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = ae(t3.type) : "string" == typeof o2 && e22.push(new ne(n2, r2.ref, `ref layer "${o2}" not found`));
        } else if ("background" !== a2 && "sky" !== a2 && "slot" !== a2)
          if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && ae(t3.type);
            t3 ? "vector" === s3 && "raster" === a2 ? e22.push(new ne(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === s3 && "raster" !== a2 ? e22.push(new ne(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e22.push(new ne(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] && !r2.paint["line-trim-offset"] || "geojson" === s3 && t3.lineMetrics || e22.push(new ne(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e22.push(new ne(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e22.push(new ne(n2, r2.source, `source "${r2.source}" not found`));
          } else
            e22.push(new ne(n2, r2, 'missing required property "source"'));
        return e22 = e22.concat(ts({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Ls({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: (t3) => bs(se({ layerType: a2 }, t3)), layout: (t3) => ts({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => As(se({ layerType: a2 }, t4)) } }), paint: (t3) => ts({ layer: r2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Ms(se({ layerType: a2, layer: r2 }, t4)) } }) } })), e22;
      }
      function Is(t2) {
        const e22 = t2.value, r2 = t2.key, n2 = Je(e22);
        return "string" !== n2 ? [new ne(r2, e22, `string expected, ${n2} found`)] : [];
      }
      const ks = { promoteId: function({ key: t2, value: e22 }) {
        if ("string" === Je(e22))
          return Is({ key: t2, value: e22 });
        {
          const r2 = [];
          for (const n2 in e22)
            r2.push(...Is({ key: `${t2}.${n2}`, value: e22[n2] }));
          return r2;
        }
      } };
      function Ts(t2) {
        const e22 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
        if (!e22.type)
          return [new ne(r2, e22, '"type" is required')];
        const s2 = ae(e22.type);
        let a2 = [];
        switch (["vector", "raster", "raster-dem"].includes(s2) && (e22.url || e22.tiles || a2.push(new ie(r2, e22, 'Either "url" or "tiles" is required.'))), s2) {
          case "vector":
          case "raster":
          case "raster-dem":
            return a2 = a2.concat(ts({ key: r2, value: e22, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ks })), a2;
          case "geojson":
            if (a2 = ts({ key: r2, value: e22, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: ks }), e22.cluster)
              for (const t3 in e22.clusterProperties) {
                const [n3, i3] = e22.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                a2.push(...is({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...is({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
            return a2;
          case "video":
            return ts({ key: r2, value: e22, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
          case "image":
            return ts({ key: r2, value: e22, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
          case "canvas":
            return [new ne(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return as({ key: `${r2}.type`, value: e22.type, valueSpec: { values: Ps(n2) }, style: i2, styleSpec: n2 });
        }
      }
      function Ps(t2) {
        return t2.source.reduce((e22, r2) => {
          const n2 = t2[r2];
          return "enum" === n2.type.type && (e22 = e22.concat(Object.keys(n2.type.values))), e22;
        }, []);
      }
      function zs(t2) {
        const e22 = t2.value;
        let r2 = [];
        if (!e22)
          return r2;
        const n2 = Je(e22);
        return "string" !== n2 ? (r2 = r2.concat([new ne(t2.key, e22, `string expected, "${n2}" found`)]), r2) : (function(t3) {
          const e3 = -1 === t3.indexOf("://");
          try {
            return new URL(t3, e3 ? "http://example.com" : void 0), true;
          } catch (t4) {
            return false;
          }
        }(e22) || (r2 = r2.concat([new ne(t2.key, e22, `invalid url "${e22}"`)])), r2);
      }
      function Es(t2) {
        const e22 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
        let s2 = [];
        const a2 = Je(e22);
        if (void 0 === e22)
          return s2;
        if ("object" !== a2)
          return s2 = s2.concat([new ne("light", e22, `object expected, ${a2} found`)]), s2;
        for (const t3 in e22) {
          const a3 = t3.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Ls({ key: t3, value: e22[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? Ls({ key: t3, value: e22[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new ne(t3, e22[t3], `unknown property "${t3}"`)]);
        }
        return s2;
      }
      function Bs(t2) {
        const e22 = t2.value;
        let r2 = [];
        if (!e22)
          return r2;
        const n2 = Je(e22);
        if ("object" !== n2)
          return r2 = r2.concat([new ne("light-3d", e22, `object expected, ${n2} found`)]), r2;
        const i2 = t2.styleSpec, s2 = i2["light-3d"], a2 = t2.key, o2 = t2.style, l2 = t2.style.lights;
        for (const t3 of ["type", "id"])
          if (!(t3 in e22))
            return r2 = r2.concat([new ne("light-3d", e22, `missing property ${t3} on light`)]), r2;
        if (e22.type && l2)
          for (let n3 = 0; n3 < t2.arrayIndex; n3++) {
            const t3 = ae(e22.type), i3 = l2[n3];
            ae(i3.type) === t3 && r2.push(new ne(a2, e22.id, `duplicate light type "${e22.type}", previously defined at line ${i3.id.__line__}`));
          }
        const u2 = `properties_light_${e22.type}`;
        if (!(u2 in i2))
          return r2 = r2.concat([new ne("light-3d", e22, `Invalid light type ${e22.type}`)]), r2;
        const c2 = i2[u2];
        for (const n3 in e22)
          if ("properties" === n3) {
            const s3 = e22[n3], a3 = Je(s3);
            if ("object" !== a3)
              return r2 = r2.concat([new ne("properties", s3, `object expected, ${a3} found`)]), r2;
            for (const e3 in s3)
              r2 = r2.concat(c2[e3] ? Ls({ key: e3, value: s3[e3], valueSpec: c2[e3], style: o2, styleSpec: i2 }) : [new ie(t2.key, s3[e3], `unknown property "${e3}"`)]);
          } else {
            const t3 = n3.match(/^(.*)-transition$/);
            r2 = r2.concat(t3 && s2[t3[1]] && s2[t3[1]].transition ? Ls({ key: n3, value: e22[n3], valueSpec: i2.transition, style: o2, styleSpec: i2 }) : s2[n3] ? Ls({ key: n3, value: e22[n3], valueSpec: s2[n3], style: o2, styleSpec: i2 }) : [new ie(n3, e22[n3], `unknown property "${n3}"`)]);
          }
        return r2;
      }
      function Ds(t2) {
        const e22 = t2.value, r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = i2.terrain;
        let a2 = [];
        const o2 = Je(e22);
        if (void 0 === e22)
          return a2;
        if ("null" === o2)
          return a2;
        if ("object" !== o2)
          return a2 = a2.concat([new ne("terrain", e22, `object expected, ${o2} found`)]), a2;
        for (const t3 in e22) {
          const r3 = t3.match(/^(.*)-transition$/);
          a2 = a2.concat(r3 && s2[r3[1]] && s2[r3[1]].transition ? Ls({ key: t3, value: e22[t3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : s2[t3] ? Ls({ key: t3, value: e22[t3], valueSpec: s2[t3], style: n2, styleSpec: i2 }) : [new ie(t3, e22[t3], `unknown property "${t3}"`)]);
        }
        if (e22.source) {
          const t3 = n2.sources && n2.sources[e22.source], i3 = t3 && ae(t3.type);
          t3 ? "raster-dem" !== i3 && a2.push(new ne(r2, e22.source, `terrain cannot be used with a source of type ${String(i3)}, it only be used with a "raster-dem" source type`)) : a2.push(new ne(r2, e22.source, `source "${e22.source}" not found`));
        } else
          a2.push(new ne(r2, e22, 'terrain is missing required property "source"'));
        return a2;
      }
      function Cs(t2) {
        const e22 = t2.value, r2 = t2.style, n2 = t2.styleSpec, i2 = n2.fog;
        let s2 = [];
        const a2 = Je(e22);
        if (void 0 === e22)
          return s2;
        if ("object" !== a2)
          return s2 = s2.concat([new ne("fog", e22, `object expected, ${a2} found`)]), s2;
        for (const t3 in e22) {
          const a3 = t3.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Ls({ key: t3, value: e22[t3], valueSpec: n2.transition, style: r2, styleSpec: n2 }) : i2[t3] ? Ls({ key: t3, value: e22[t3], valueSpec: i2[t3], style: r2, styleSpec: n2 }) : [new ie(t3, e22[t3], `unknown property "${t3}"`)]);
        }
        return s2;
      }
      const Rs = { "*": () => [], array: es, boolean: function(t2) {
        const e22 = t2.value, r2 = t2.key, n2 = Je(e22);
        return "boolean" !== n2 ? [new ne(r2, e22, `boolean expected, ${n2} found`)] : [];
      }, number: rs, color: function(t2) {
        const e22 = t2.key, r2 = t2.value, n2 = Je(r2);
        return "string" !== n2 ? [new ne(e22, r2, `color expected, ${n2} found`)] : null === Te(r2) ? [new ne(e22, r2, `color expected, "${r2}" found`)] : [];
      }, enum: as, filter: bs, function: ns, layer: Ss, object: ts, source: Ts, model: zs, light: Es, "light-3d": Bs, terrain: Ds, fog: Cs, string: Is, formatted: function(t2) {
        return 0 === Is(t2).length ? [] : is(t2);
      }, resolvedImage: function(t2) {
        return 0 === Is(t2).length ? [] : is(t2);
      }, projection: function(t2) {
        const e22 = t2.value, r2 = t2.styleSpec, n2 = r2.projection, i2 = t2.style;
        let s2 = [];
        const a2 = Je(e22);
        if ("object" === a2)
          for (const t3 in e22)
            s2 = s2.concat(Ls({ key: t3, value: e22[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }));
        else
          "string" !== a2 && (s2 = s2.concat([new ne("projection", e22, `object or string expected, ${a2} found`)]));
        return s2;
      }, import: function(t2) {
        const { value: e22, styleSpec: r2 } = t2, { data: n2, ...i2 } = e22;
        Object.defineProperty(i2, "__line__", { value: e22.__line__, enumerable: false });
        let s2 = ts(se({}, t2, { value: i2, valueSpec: r2.import }));
        return "" === ae(i2.id) && s2.push(new ne(`${t2.key}.id`, i2, "import id can't be an empty string")), n2 && (s2 = s2.concat(Os(n2, r2, { key: `${t2.key}.data` }))), s2;
      } };
      function Ls(t2, e22 = false) {
        const r2 = t2.value, n2 = t2.valueSpec, i2 = t2.styleSpec;
        if (n2.expression && Oi(ae(r2)))
          return ns(t2);
        if (n2.expression && Zi(oe(r2)))
          return is(t2);
        if (n2.type && Rs[n2.type]) {
          const r3 = Rs[n2.type](t2);
          return true === e22 && r3.length > 0 && "array" === Je(t2.value) ? is(t2) : r3;
        }
        return ts(se({}, t2, { valueSpec: n2.type ? i2[n2.type] : n2 }));
      }
      function Vs(t2) {
        const e22 = t2.value, r2 = t2.key, n2 = Is(t2);
        return n2.length || (-1 === e22.indexOf("{fontstack}") && n2.push(new ne(r2, e22, '"glyphs" url must include a "{fontstack}" token')), -1 === e22.indexOf("{range}") && n2.push(new ne(r2, e22, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function Os(t2, e22 = re2, r2 = {}) {
        return Ls({ key: r2.key || "", value: t2, valueSpec: e22.$root, styleSpec: e22, style: t2, objectElementValidators: { glyphs: Vs, "*": () => [] } });
      }
      function Fs(t2, e22 = re2) {
        return Ns(Os(t2, e22));
      }
      const js = (t2) => Ns(Ms(t2)), Us = (t2) => Ns(As(t2));
      function Ns(t2) {
        return t2.slice().sort((t3, e22) => t3.line && e22.line ? t3.line - e22.line : 0);
      }
      function $s(t2, e22) {
        let r2 = false;
        if (e22 && e22.length)
          for (const n2 of e22)
            n2 instanceof ie ? q(n2.message) : (t2.fire(new te(new Error(n2.message))), r2 = true);
        return r2;
      }
      var qs2 = Ys, Gs = 3;
      function Ys(t2, e22, r2) {
        var n2 = this.cells = [];
        if (t2 instanceof ArrayBuffer) {
          this.arrayBuffer = t2;
          var i2 = new Int32Array(this.arrayBuffer);
          t2 = i2[0], this.d = (e22 = i2[1]) + 2 * (r2 = i2[2]);
          for (var s2 = 0; s2 < this.d * this.d; s2++) {
            var a2 = i2[Gs + s2], o2 = i2[Gs + s2 + 1];
            n2.push(a2 === o2 ? null : i2.subarray(a2, o2));
          }
          var l2 = i2[Gs + n2.length + 1];
          this.keys = i2.subarray(i2[Gs + n2.length], l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
        } else {
          this.d = e22 + 2 * r2;
          for (var u2 = 0; u2 < this.d * this.d; u2++)
            n2.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = e22, this.extent = t2, this.padding = r2, this.scale = e22 / t2, this.uid = 0;
        var c2 = r2 / e22 * t2;
        this.min = -c2, this.max = t2 + c2;
      }
      Ys.prototype.insert = function(t2, e22, r2, n2, i2) {
        this._forEachCell(e22, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e22), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
      }, Ys.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, Ys.prototype._insertCell = function(t2, e22, r2, n2, i2, s2) {
        this.cells[i2].push(s2);
      }, Ys.prototype.query = function(t2, e22, r2, n2, i2) {
        var s2 = this.min, a2 = this.max;
        if (t2 <= s2 && e22 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
          return Array.prototype.slice.call(this.keys);
        var o2 = [];
        return this._forEachCell(t2, e22, r2, n2, this._queryCell, o2, {}, i2), o2;
      }, Ys.prototype._queryCell = function(t2, e22, r2, n2, i2, s2, a2, o2) {
        var l2 = this.cells[i2];
        if (null !== l2)
          for (var u2 = this.keys, c2 = this.bboxes, h22 = 0; h22 < l2.length; h22++) {
            var p2 = l2[h22];
            if (void 0 === a2[p2]) {
              var f2 = 4 * p2;
              (o2 ? o2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t2 <= c2[f2 + 2] && e22 <= c2[f2 + 3] && r2 >= c2[f2 + 0] && n2 >= c2[f2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
            }
          }
      }, Ys.prototype._forEachCell = function(t2, e22, r2, n2, i2, s2, a2, o2) {
        for (var l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e22), c2 = this._convertToCellCoord(r2), h22 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
          for (var f2 = u2; f2 <= h22; f2++) {
            var d2 = this.d * f2 + p2;
            if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(f2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e22, r2, n2, d2, s2, a2, o2))
              return;
          }
      }, Ys.prototype._convertFromCellCoord = function(t2) {
        return (t2 - this.padding) / this.scale;
      }, Ys.prototype._convertToCellCoord = function(t2) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
      }, Ys.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var t2 = this.cells, e22 = Gs + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
          r2 += this.cells[n2].length;
        var i2 = new Int32Array(e22 + r2 + this.keys.length + this.bboxes.length);
        i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
        for (var s2 = e22, a2 = 0; a2 < t2.length; a2++) {
          var o2 = t2[a2];
          i2[Gs + a2] = s2, i2.set(o2, s2), s2 += o2.length;
        }
        return i2[Gs + t2.length] = s2, i2.set(this.keys, s2), i2[Gs + t2.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
      };
      var Zs = p(qs2);
      const Xs = {};
      function Ks(t2, e22, r2 = {}) {
        Object.defineProperty(t2, "_classRegistryKey", { value: e22, writeable: false }), Xs[e22] = { klass: t2, omit: r2.omit || [] };
      }
      Ks(Object, "Object"), Zs.serialize = function(t2, e22) {
        const r2 = t2.toArrayBuffer();
        return e22 && e22.add(r2), { buffer: r2 };
      }, Zs.deserialize = function(t2) {
        return new Zs(t2.buffer);
      }, Object.defineProperty(Zs, "name", { value: "Grid" }), Ks(Zs, "Grid"), Ks(Re, "Color"), Ks(Error, "Error"), Ks(Oe, "Formatted"), Ks(Ve, "FormattedSection"), Ks(ht, "AJAXError"), Ks(Fe, "ResolvedImage"), Ks(Ji, "StylePropertyFunction"), Ks(Yi, "StyleExpression", { omit: ["_evaluator"] }), Ks(Wi, "ZoomDependentExpression"), Ks(Ki, "ZoomConstantExpression"), Ks(ar, "CompoundExpression", { omit: ["_evaluate"] });
      for (const t2 in zi)
        Xs[zi[t2]._classRegistryKey] || Ks(zi[t2], `Expression${t2}`);
      function Ws(t2) {
        return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
      }
      function Hs(t2) {
        return self.ImageBitmap && t2 instanceof ImageBitmap;
      }
      function Js(t2, e22) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
          return t2;
        if (Ws(t2) || Hs(t2))
          return e22 && e22.add(t2), t2;
        if (ArrayBuffer.isView(t2)) {
          const r2 = t2;
          return e22 && e22.add(r2.buffer), r2;
        }
        if (t2 instanceof ImageData)
          return e22 && e22.add(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const r2 = [];
          for (const n2 of t2)
            r2.push(Js(n2, e22));
          return r2;
        }
        if (t2 instanceof Map) {
          const e3 = { $name: "Map" };
          for (const [r2, n2] of t2.entries())
            e3[r2] = Js(n2);
          return e3;
        }
        if ("object" == typeof t2) {
          const r2 = t2.constructor, n2 = r2._classRegistryKey;
          if (!n2)
            throw new Error(`can't serialize object of unregistered class ${n2}`);
          const i2 = r2.serialize ? r2.serialize(t2, e22) : {};
          if (!r2.serialize) {
            for (const r3 in t2)
              t2.hasOwnProperty(r3) && (Xs[n2].omit.indexOf(r3) >= 0 || (i2[r3] = Js(t2[r3], e22)));
            t2 instanceof Error && (i2.message = t2.message);
          }
          if (i2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== n2 && (i2.$name = n2), i2;
        }
        throw new Error("can't serialize object of type " + typeof t2);
      }
      function Qs(t2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || Ws(t2) || Hs(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
          return t2;
        if (Array.isArray(t2))
          return t2.map(Qs);
        if ("object" == typeof t2) {
          const e22 = t2.$name || "Object";
          if ("Map" === e22) {
            const e3 = /* @__PURE__ */ new Map();
            for (const r3 of Object.keys(t2))
              "$name" !== r3 && e3.set(r3, Qs(t2[r3]));
            return e3;
          }
          const { klass: r2 } = Xs[e22];
          if (!r2)
            throw new Error(`can't deserialize unregistered class ${e22}`);
          if (r2.deserialize)
            return r2.deserialize(t2);
          const n2 = Object.create(r2.prototype);
          for (const e3 of Object.keys(t2))
            "$name" !== e3 && (n2[e3] = Qs(t2[e3]));
          return n2;
        }
        throw new Error("can't deserialize object of type " + typeof t2);
      }
      const ta = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519, "CJK Unified Ideographs Extension B": (t2) => t2 >= 131072 && t2 <= 173791 };
      function ea(t2) {
        for (const e22 of t2)
          if (ia(e22.charCodeAt(0)))
            return true;
        return false;
      }
      function ra(t2) {
        for (const e22 of t2)
          if (!na(e22.charCodeAt(0)))
            return false;
        return true;
      }
      function na(t2) {
        return !(ta.Arabic(t2) || ta["Arabic Supplement"](t2) || ta["Arabic Extended-A"](t2) || ta["Arabic Presentation Forms-A"](t2) || ta["Arabic Presentation Forms-B"](t2));
      }
      function ia(t2) {
        return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(ta["Bopomofo Extended"](t2) || ta.Bopomofo(t2) || ta["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || ta["CJK Compatibility Ideographs"](t2) || ta["CJK Compatibility"](t2) || ta["CJK Radicals Supplement"](t2) || ta["CJK Strokes"](t2) || !(!ta["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || ta["CJK Unified Ideographs Extension A"](t2) || ta["CJK Unified Ideographs"](t2) || ta["Enclosed CJK Letters and Months"](t2) || ta["Hangul Compatibility Jamo"](t2) || ta["Hangul Jamo Extended-A"](t2) || ta["Hangul Jamo Extended-B"](t2) || ta["Hangul Jamo"](t2) || ta["Hangul Syllables"](t2) || ta.Hiragana(t2) || ta["Ideographic Description Characters"](t2) || ta.Kanbun(t2) || ta["Kangxi Radicals"](t2) || ta["Katakana Phonetic Extensions"](t2) || ta.Katakana(t2) && 12540 !== t2 || !(!ta["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!ta["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ta["Unified Canadian Aboriginal Syllabics"](t2) || ta["Unified Canadian Aboriginal Syllabics Extended"](t2) || ta["Vertical Forms"](t2) || ta["Yijing Hexagram Symbols"](t2) || ta["Yi Syllables"](t2) || ta["Yi Radicals"](t2))));
      }
      function sa(t2) {
        return !(ia(t2) || function(t3) {
          return !!(ta["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ta["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ta["Letterlike Symbols"](t3) || ta["Number Forms"](t3) || ta["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ta["Control Pictures"](t3) && 9251 !== t3 || ta["Optical Character Recognition"](t3) || ta["Enclosed Alphanumerics"](t3) || ta["Geometric Shapes"](t3) || ta["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || ta["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || ta["CJK Symbols and Punctuation"](t3) || ta.Katakana(t3) || ta["Private Use Area"](t3) || ta["CJK Compatibility Forms"](t3) || ta["Small Form Variants"](t3) || ta["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
        }(t2));
      }
      function aa(t2) {
        return t2 >= 1424 && t2 <= 2303 || ta["Arabic Presentation Forms-A"](t2) || ta["Arabic Presentation Forms-B"](t2);
      }
      function oa(t2, e22) {
        return !(!e22 && aa(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ta.Khmer(t2));
      }
      function la(t2) {
        for (const e22 of t2)
          if (aa(e22.charCodeAt(0)))
            return true;
        return false;
      }
      const ua = "deferred", ca = "loading", ha = "loaded";
      let pa = null, fa = "unavailable", da = null;
      const ma = function(t2) {
        t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (fa = "error"), pa && pa(t2);
      };
      function ya() {
        ga.fire(new Qt("pluginStateChange", { pluginStatus: fa, pluginURL: da }));
      }
      const ga = new ee(), xa = function() {
        return fa;
      }, va = function() {
        if (fa !== ua || !da)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        fa = ca, ya(), da && dt({ url: da }, (t2) => {
          t2 ? ma(t2) : (fa = ha, ya());
        });
      }, ba = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => fa === ha || null != ba.applyArabicShaping, isLoading: () => fa === ca, setState(t2) {
        fa = t2.pluginStatus, da = t2.pluginURL;
      }, isParsed: () => null != ba.applyArabicShaping && null != ba.processBidirectionalText && null != ba.processStyledBidirectionalText, getPluginURL: () => da };
      class _a2 {
        constructor(t2, e22) {
          this.zoom = t2, e22 ? (this.now = e22.now, this.fadeDuration = e22.fadeDuration, this.transition = e22.transition, this.pitch = e22.pitch, this.brightness = e22.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
        }
        isSupportedScript(t2) {
          return function(t3, e22) {
            for (const r2 of t3)
              if (!oa(r2.charCodeAt(0), e22))
                return false;
            return true;
          }(t2, ba.isLoaded());
        }
      }
      class wa {
        constructor(t2, e22, r2, n2) {
          this.property = t2, this.value = e22, this.expression = function(t3, e3, r3, n3) {
            if (Oi(t3))
              return new Ji(t3, e3);
            if (Zi(t3) || Array.isArray(t3) && t3.length > 0) {
              const i2 = Hi(t3, e3, r3, n3);
              if ("error" === i2.result)
                throw new Error(i2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return i2.value;
            }
            {
              let r4 = t3;
              return "string" == typeof t3 && "color" === e3.type && (r4 = Re.parse(t3)), { kind: "constant", isConfigDependent: false, evaluate: () => r4 };
            }
          }(void 0 === e22 ? t2.specification.default : e22, t2.specification, r2, n2);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(t2, e22, r2) {
          return this.property.possiblyEvaluate(this, t2, e22, r2);
        }
      }
      class Ma {
        constructor(t2, e22, r2) {
          this.property = t2, this.value = new wa(t2, void 0, e22, r2);
        }
        transitioned(t2, e22) {
          return new Sa(this.property, this.value, e22, B({}, t2.transition, this.transition), t2.now);
        }
        untransitioned() {
          return new Sa(this.property, this.value, null, {}, 0);
        }
      }
      class Aa {
        constructor(t2, e22, r2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues), this._scope = e22, this._options = r2, this.isConfigDependent = false;
        }
        getValue(t2) {
          return N(this._values[t2].value.value);
        }
        setValue(t2, e22) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new Ma(this._values[t2].property, this._scope, this._options)), this._values[t2].value = new wa(this._values[t2].property, null === e22 ? void 0 : N(e22), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t2].value.expression.isConfigDependent;
        }
        setTransitionOrValue(t2, e22) {
          e22 && (this._options = e22);
          const r2 = this._properties.properties;
          if (t2)
            for (const e3 in t2) {
              const n2 = t2[e3];
              if (F(e3, "-transition")) {
                const t3 = e3.slice(0, -11);
                r2[t3] && this.setTransition(t3, n2);
              } else
                r2[e3] && this.setValue(e3, n2);
            }
        }
        getTransition(t2) {
          return N(this._values[t2].transition);
        }
        setTransition(t2, e22) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new Ma(this._values[t2].property)), this._values[t2].transition = N(e22) || void 0;
        }
        serialize() {
          const t2 = {};
          for (const e22 of Object.keys(this._values)) {
            const r2 = this.getValue(e22);
            void 0 !== r2 && (t2[e22] = r2);
            const n2 = this.getTransition(e22);
            void 0 !== n2 && (t2[`${e22}-transition`] = n2);
          }
          return t2;
        }
        transitioned(t2, e22) {
          const r2 = new Ia(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].transitioned(t2, e22._values[n2]);
          return r2;
        }
        untransitioned() {
          const t2 = new Ia(this._properties);
          for (const e22 of Object.keys(this._values))
            t2._values[e22] = this._values[e22].untransitioned();
          return t2;
        }
      }
      class Sa {
        constructor(t2, e22, r2, n2, i2) {
          const s2 = n2.delay || 0, a2 = n2.duration || 0;
          i2 = i2 || 0, this.property = t2, this.value = e22, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        }
        possiblyEvaluate(t2, e22, r2) {
          const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e22, r2), s2 = this.prior;
          if (s2) {
            if (n2 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n2 < this.begin)
              return s2.possiblyEvaluate(t2, e22, r2);
            {
              const a2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t2, e22, r2), i2, A(a2));
            }
          }
          return i2;
        }
      }
      class Ia {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t2, e22, r2) {
          const n2 = new Pa(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e22, r2);
          return n2;
        }
        hasTransition() {
          for (const t2 of Object.keys(this._values))
            if (this._values[t2].prior)
              return true;
          return false;
        }
      }
      class ka {
        constructor(t2, e22, r2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues), this._scope = e22, this._options = r2, this.isConfigDependent = false;
        }
        getValue(t2) {
          return N(this._values[t2].value);
        }
        setValue(t2, e22) {
          this._values[t2] = new wa(this._values[t2].property, null === e22 ? void 0 : N(e22), this._scope, this._options), this.isConfigDependent = this.isConfigDependent || this._values[t2].expression.isConfigDependent;
        }
        serialize() {
          const t2 = {};
          for (const e22 of Object.keys(this._values)) {
            const r2 = this.getValue(e22);
            void 0 !== r2 && (t2[e22] = r2);
          }
          return t2;
        }
        possiblyEvaluate(t2, e22, r2) {
          const n2 = new Pa(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e22, r2);
          return n2;
        }
      }
      class Ta {
        constructor(t2, e22, r2) {
          this.property = t2, this.value = e22, this.parameters = r2;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(t2) {
          return "constant" === this.value.kind ? this.value.value : t2;
        }
        evaluate(t2, e22, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t2, e22, r2, n2);
        }
      }
      class Pa {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        }
        get(t2) {
          return this._values[t2];
        }
      }
      class za {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e22) {
          return t2.expression.evaluate(e22);
        }
        interpolate(t2, e22, r2) {
          const n2 = Sn[this.specification.type];
          return n2 ? n2(t2, e22, r2) : t2;
        }
      }
      class Ea {
        constructor(t2, e22) {
          this.specification = t2, this.overrides = e22;
        }
        possiblyEvaluate(t2, e22, r2, n2) {
          return new Ta(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e22, null, {}, r2, n2) } : t2.expression, e22);
        }
        interpolate(t2, e22, r2) {
          if ("constant" !== t2.value.kind || "constant" !== e22.value.kind)
            return t2;
          if (void 0 === t2.value.value || void 0 === e22.value.value)
            return new Ta(this, { kind: "constant", value: void 0 }, t2.parameters);
          const n2 = Sn[this.specification.type];
          return n2 ? new Ta(this, { kind: "constant", value: n2(t2.value.value, e22.value.value, r2) }, t2.parameters) : t2;
        }
        evaluate(t2, e22, r2, n2, i2, s2) {
          return "constant" === t2.kind ? t2.value : t2.evaluate(e22, r2, n2, i2, s2);
        }
      }
      class Ba {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e22, r2, n2) {
          return !!t2.expression.evaluate(e22, null, {}, r2, n2);
        }
        interpolate() {
          return false;
        }
      }
      class Da {
        constructor(t2) {
          this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const e22 = new _a2(0, {});
          for (const r2 in t2) {
            const n2 = t2[r2];
            n2.specification.overridable && this.overridableProperties.push(r2);
            const i2 = this.defaultPropertyValues[r2] = new wa(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r2] = new Ma(n2);
            this.defaultTransitioningPropertyValues[r2] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e22);
          }
        }
      }
      Ks(Ea, "DataDrivenProperty"), Ks(za, "DataConstantProperty"), Ks(Ba, "ColorRampProperty");
      const Ca = "";
      function Ra(t2, e22) {
        return e22 ? `${t2}${Ca}${e22}` : t2;
      }
      const La = "-transition";
      class Va extends ee {
        constructor(t2, e22, r2, n2) {
          if (super(), this.id = t2.id, this.fqid = Ra(this.id, r2), this.type = t2.type, this.scope = r2, this.options = n2, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.isConfigDependent = false, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && "sky" !== t2.type && "slot" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), t2.slot && (this.slot = t2.slot), e22.layout && (this._unevaluatedLayout = new ka(e22.layout, this.scope, n2), this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent), e22.paint)) {
            this._transitionablePaint = new Aa(e22.paint, this.scope, n2);
            for (const e3 in t2.paint)
              this.setPaintProperty(e3, t2.paint[e3], { validate: false });
            for (const e3 in t2.layout)
              this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
            this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent, this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Pa(e22.paint);
          }
        }
        getLayoutProperty(t2) {
          return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
        }
        setLayoutProperty(t2, e22, r2 = {}) {
          if (null != e22 && this._validate(Us, `layers.${this.id}.layout.${t2}`, t2, e22, r2))
            return;
          if ("custom" === this.type && "visibility" === t2)
            return void (this.visibility = e22);
          const n2 = this._unevaluatedLayout;
          n2._properties.properties[t2] && (n2.setValue(t2, e22), this.isConfigDependent = this.isConfigDependent || n2.isConfigDependent, "visibility" === t2 && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
        }
        getPaintProperty(t2) {
          return F(t2, La) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
        }
        setPaintProperty(t2, e22, r2 = {}) {
          if (null != e22 && this._validate(js, `layers.${this.id}.paint.${t2}`, t2, e22, r2))
            return false;
          const n2 = this._transitionablePaint, i2 = n2._properties.properties;
          if (F(t2, La)) {
            const r3 = t2.slice(0, -11);
            return i2[r3] && n2.setTransition(r3, e22 || void 0), false;
          }
          if (!i2[t2])
            return false;
          const s2 = n2._values[t2], a2 = s2.value.isDataDriven(), o2 = s2.value;
          n2.setValue(t2, e22), this.isConfigDependent = this.isConfigDependent || n2.isConfigDependent, this._handleSpecialPaintPropertyUpdate(t2);
          const l2 = n2._values[t2].value, u2 = l2.isDataDriven(), c2 = F(t2, "pattern") || "line-dasharray" === t2;
          return u2 || a2 || c2 || this._handleOverridablePaintPropertyUpdate(t2, o2, l2);
        }
        _handleSpecialPaintPropertyUpdate(t2) {
        }
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(t2, e22) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t2, e22, r2) {
          return false;
        }
        isHidden(t2) {
          return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(t2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t2, e22) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e22)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e22);
        }
        serialize() {
          return U({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t2, e22) => !(void 0 === t2 || "layout" === e22 && !Object.keys(t2).length || "paint" === e22 && !Object.keys(t2).length));
        }
        _validate(t2, e22, r2, n2, i2 = {}) {
          return (!i2 || false !== i2.validate) && $s(this, t2.call(Fs, { key: e22, layerType: this.type, objectKey: r2, value: n2, styleSpec: re2, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        hasShadowPass() {
          return false;
        }
        canCastShadows() {
          return false;
        }
        hasLightBeamPass() {
          return false;
        }
        cutoffRange() {
          return 0;
        }
        resize() {
        }
        isStateDependent() {
          for (const t2 in this.paint._values) {
            const e22 = this.paint.get(t2);
            if (e22 instanceof Ta && Ci(e22.property.specification) && ("source" === e22.value.kind || "composite" === e22.value.kind) && e22.value.isStateDependent)
              return true;
          }
          return false;
        }
        compileFilter() {
          this._filterCompiled || (this._featureFilter = ls(this.filter), this._filterCompiled = true);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = false;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats() {
          this._stats && (this._stats.numRenderedVerticesInShadowPass = 0, this._stats.numRenderedVerticesInTransparentPass = 0);
        }
      }
      const Oa = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Fa {
        constructor(t2, e22) {
          this._structArray = t2, this._pos1 = e22 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class ja {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t2, e22) {
          return t2._trim(), e22 && (t2.isTransferred = true, e22.add(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }
        static deserialize(t2) {
          const e22 = Object.create(this.prototype);
          return e22.arrayBuffer = t2.arrayBuffer, e22.length = t2.length, e22.capacity = t2.arrayBuffer.byteLength / e22.bytesPerElement, e22._refreshViews(), e22;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t2) {
          this.reserve(t2), this.length = t2;
        }
        reserve(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e22 = this.uint8;
            this._refreshViews(), e22 && this.uint8.set(e22);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function Ua(t2, e22 = 1) {
        let r2 = 0, n2 = 0;
        return { members: t2.map((t3) => {
          const i2 = Oa[t3.type].BYTES_PER_ELEMENT, s2 = r2 = Na(r2, Math.max(e22, i2)), a2 = t3.components || 1;
          return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
        }), size: Na(r2, Math.max(n2, e22)), alignment: e22 };
      }
      function Na(t2, e22) {
        return Math.ceil(t2 / e22) * e22;
      }
      class $a extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e22);
        }
        emplace(t2, e22, r2) {
          const n2 = 2 * t2;
          return this.int16[n2 + 0] = e22, this.int16[n2 + 1] = r2, t2;
        }
      }
      $a.prototype.bytesPerElement = 4, Ks($a, "StructArrayLayout2i4");
      class qa extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e22, r2);
        }
        emplace(t2, e22, r2, n2) {
          const i2 = 3 * t2;
          return this.int16[i2 + 0] = e22, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
        }
      }
      qa.prototype.bytesPerElement = 6, Ks(qa, "StructArrayLayout3i6");
      class Ga extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e22, r2, n2);
        }
        emplace(t2, e22, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.int16[s2 + 0] = e22, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
        }
      }
      Ga.prototype.bytesPerElement = 8, Ks(Ga, "StructArrayLayout4i8");
      class Ya extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e22, r2, n2, i2);
        }
        emplace(t2, e22, r2, n2, i2, s2) {
          const a2 = 5 * t2;
          return this.int16[a2 + 0] = e22, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, t2;
        }
      }
      Ya.prototype.bytesPerElement = 10, Ks(Ya, "StructArrayLayout5i10");
      class Za extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e22, r2, n2, i2, s2, a2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
          return this.int16[l2 + 0] = e22, this.int16[l2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
        }
      }
      Za.prototype.bytesPerElement = 12, Ks(Za, "StructArrayLayout2i4ub1f12");
      class Xa extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e22, r2, n2);
        }
        emplace(t2, e22, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.float32[s2 + 0] = e22, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
        }
      }
      Xa.prototype.bytesPerElement = 16, Ks(Xa, "StructArrayLayout4f16");
      class Ka extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e22, r2, n2, i2);
        }
        emplace(t2, e22, r2, n2, i2, s2) {
          const a2 = 6 * t2, o2 = 3 * t2;
          return this.uint16[a2 + 0] = e22, this.uint16[a2 + 1] = r2, this.uint16[a2 + 2] = n2, this.uint16[a2 + 3] = i2, this.float32[o2 + 2] = s2, t2;
        }
      }
      Ka.prototype.bytesPerElement = 12, Ks(Ka, "StructArrayLayout4ui1f12");
      class Wa extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e22, r2, n2);
        }
        emplace(t2, e22, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.uint16[s2 + 0] = e22, this.uint16[s2 + 1] = r2, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
        }
      }
      Wa.prototype.bytesPerElement = 8, Ks(Wa, "StructArrayLayout4ui8");
      class Ha extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e22, r2, n2, i2, s2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e22, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      Ha.prototype.bytesPerElement = 12, Ks(Ha, "StructArrayLayout6i12");
      class Ja extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22) {
          const p2 = this.length;
          return this.resize(p2 + 1), this.emplace(p2, t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2) {
          const f2 = 12 * t2;
          return this.int16[f2 + 0] = e22, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h22, this.int16[f2 + 11] = p2, t2;
        }
      }
      Ja.prototype.bytesPerElement = 24, Ks(Ja, "StructArrayLayout4i4ui4i24");
      class Qa extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e22, r2, n2, i2, s2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = 10 * t2, l2 = 5 * t2;
          return this.int16[o2 + 0] = e22, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = a2, t2;
        }
      }
      Qa.prototype.bytesPerElement = 20, Ks(Qa, "StructArrayLayout3i3f20");
      class to2 extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t2);
        }
        emplace(t2, e22) {
          return this.uint32[1 * t2 + 0] = e22, t2;
        }
      }
      to2.prototype.bytesPerElement = 4, Ks(to2, "StructArrayLayout1ul4");
      class eo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e22);
        }
        emplace(t2, e22, r2) {
          const n2 = 2 * t2;
          return this.uint16[n2 + 0] = e22, this.uint16[n2 + 1] = r2, t2;
        }
      }
      eo.prototype.bytesPerElement = 4, Ks(eo, "StructArrayLayout2ui4");
      class ro extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2) {
          const f2 = this.length;
          return this.resize(f2 + 1), this.emplace(f2, t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2) {
          const d2 = 20 * t2, m2 = 10 * t2;
          return this.int16[d2 + 0] = e22, this.int16[d2 + 1] = r2, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[m2 + 3] = a2, this.float32[m2 + 4] = o2, this.float32[m2 + 5] = l2, this.float32[m2 + 6] = u2, this.int16[d2 + 14] = c2, this.uint32[m2 + 8] = h22, this.uint16[d2 + 18] = p2, this.uint16[d2 + 19] = f2, t2;
        }
      }
      ro.prototype.bytesPerElement = 40, Ks(ro, "StructArrayLayout5i4f1i1ul2ui40");
      class no extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e22, r2, n2, i2, s2, a2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = 8 * t2;
          return this.int16[l2 + 0] = e22, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
        }
      }
      no.prototype.bytesPerElement = 16, Ks(no, "StructArrayLayout3i2i2i16");
      class io extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e22, r2, n2, i2);
        }
        emplace(t2, e22, r2, n2, i2, s2) {
          const a2 = 4 * t2, o2 = 8 * t2;
          return this.float32[a2 + 0] = e22, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
        }
      }
      io.prototype.bytesPerElement = 16, Ks(io, "StructArrayLayout2f1f2i16");
      class so extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e22, r2, n2);
        }
        emplace(t2, e22, r2, n2, i2) {
          const s2 = 12 * t2, a2 = 3 * t2;
          return this.uint8[s2 + 0] = e22, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
        }
      }
      so.prototype.bytesPerElement = 12, Ks(so, "StructArrayLayout2ub2f12");
      class ao extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e22, r2);
        }
        emplace(t2, e22, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[i2 + 0] = e22, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
        }
      }
      ao.prototype.bytesPerElement = 6, Ks(ao, "StructArrayLayout3ui6");
      class oo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2) {
          const _2 = this.length;
          return this.resize(_2 + 1), this.emplace(_2, t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2, _2) {
          const w2 = 30 * t2, M2 = 15 * t2, A2 = 60 * t2;
          return this.int16[w2 + 0] = e22, this.int16[w2 + 1] = r2, this.int16[w2 + 2] = n2, this.float32[M2 + 2] = i2, this.float32[M2 + 3] = s2, this.uint16[w2 + 8] = a2, this.uint16[w2 + 9] = o2, this.uint32[M2 + 5] = l2, this.uint32[M2 + 6] = u2, this.uint32[M2 + 7] = c2, this.uint16[w2 + 16] = h22, this.uint16[w2 + 17] = p2, this.uint16[w2 + 18] = f2, this.float32[M2 + 10] = d2, this.float32[M2 + 11] = m2, this.uint8[A2 + 48] = y2, this.uint8[A2 + 49] = g2, this.uint8[A2 + 50] = x2, this.uint32[M2 + 13] = v2, this.int16[w2 + 28] = b2, this.uint8[A2 + 58] = _2, t2;
        }
      }
      oo.prototype.bytesPerElement = 60, Ks(oo, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class lo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2, _2, w2, M2, A2, S2, I2, k2, T2, P2, z2, E2) {
          const B2 = this.length;
          return this.resize(B2 + 1), this.emplace(B2, t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2, _2, w2, M2, A2, S2, I2, k2, T2, P2, z2, E2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2, _2, w2, M2, A2, S2, I2, k2, T2, P2, z2, E2, B2) {
          const D2 = 20 * t2, C2 = 40 * t2, R2 = 80 * t2;
          return this.float32[D2 + 0] = e22, this.float32[D2 + 1] = r2, this.int16[C2 + 4] = n2, this.int16[C2 + 5] = i2, this.int16[C2 + 6] = s2, this.int16[C2 + 7] = a2, this.int16[C2 + 8] = o2, this.int16[C2 + 9] = l2, this.int16[C2 + 10] = u2, this.int16[C2 + 11] = c2, this.int16[C2 + 12] = h22, this.uint16[C2 + 13] = p2, this.uint16[C2 + 14] = f2, this.uint16[C2 + 15] = d2, this.uint16[C2 + 16] = m2, this.uint16[C2 + 17] = y2, this.uint16[C2 + 18] = g2, this.uint16[C2 + 19] = x2, this.uint16[C2 + 20] = v2, this.uint16[C2 + 21] = b2, this.uint16[C2 + 22] = _2, this.uint16[C2 + 23] = w2, this.uint16[C2 + 24] = M2, this.uint16[C2 + 25] = A2, this.uint16[C2 + 26] = S2, this.uint16[C2 + 27] = I2, this.uint32[D2 + 14] = k2, this.float32[D2 + 15] = T2, this.float32[D2 + 16] = P2, this.float32[D2 + 17] = z2, this.float32[D2 + 18] = E2, this.uint8[R2 + 76] = B2, t2;
        }
      }
      lo.prototype.bytesPerElement = 80, Ks(lo, "StructArrayLayout2f9i15ui1ul4f1ub80");
      class uo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t2);
        }
        emplace(t2, e22) {
          return this.float32[1 * t2 + 0] = e22, t2;
        }
      }
      uo.prototype.bytesPerElement = 4, Ks(uo, "StructArrayLayout1f4");
      class co extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e22, r2, n2, i2);
        }
        emplace(t2, e22, r2, n2, i2, s2) {
          const a2 = 5 * t2;
          return this.float32[a2 + 0] = e22, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
        }
      }
      co.prototype.bytesPerElement = 20, Ks(co, "StructArrayLayout5f20");
      class ho extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e22, r2, n2, i2, s2, a2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = 7 * t2;
          return this.float32[l2 + 0] = e22, this.float32[l2 + 1] = r2, this.float32[l2 + 2] = n2, this.float32[l2 + 3] = i2, this.float32[l2 + 4] = s2, this.float32[l2 + 5] = a2, this.float32[l2 + 6] = o2, t2;
        }
      }
      ho.prototype.bytesPerElement = 28, Ks(ho, "StructArrayLayout7f28");
      class po extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e22, r2, n2);
        }
        emplace(t2, e22, r2, n2, i2) {
          const s2 = 6 * t2;
          return this.uint32[3 * t2 + 0] = e22, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
        }
      }
      po.prototype.bytesPerElement = 12, Ks(po, "StructArrayLayout1ul3ui12");
      class fo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t2);
        }
        emplace(t2, e22) {
          return this.uint16[1 * t2 + 0] = e22, t2;
        }
      }
      fo.prototype.bytesPerElement = 2, Ks(fo, "StructArrayLayout1ui2");
      class mo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e22, r2);
        }
        emplace(t2, e22, r2, n2) {
          const i2 = 3 * t2;
          return this.float32[i2 + 0] = e22, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      mo.prototype.bytesPerElement = 12, Ks(mo, "StructArrayLayout3f12");
      class yo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e22);
        }
        emplace(t2, e22, r2) {
          const n2 = 2 * t2;
          return this.float32[n2 + 0] = e22, this.float32[n2 + 1] = r2, t2;
        }
      }
      yo.prototype.bytesPerElement = 8, Ks(yo, "StructArrayLayout2f8");
      class go extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2) {
          const y2 = this.length;
          return this.resize(y2 + 1), this.emplace(y2, t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2) {
          const g2 = 16 * t2;
          return this.float32[g2 + 0] = e22, this.float32[g2 + 1] = r2, this.float32[g2 + 2] = n2, this.float32[g2 + 3] = i2, this.float32[g2 + 4] = s2, this.float32[g2 + 5] = a2, this.float32[g2 + 6] = o2, this.float32[g2 + 7] = l2, this.float32[g2 + 8] = u2, this.float32[g2 + 9] = c2, this.float32[g2 + 10] = h22, this.float32[g2 + 11] = p2, this.float32[g2 + 12] = f2, this.float32[g2 + 13] = d2, this.float32[g2 + 14] = m2, this.float32[g2 + 15] = y2, t2;
        }
      }
      go.prototype.bytesPerElement = 64, Ks(go, "StructArrayLayout16f64");
      class xo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e22, r2, n2, i2, s2, a2);
        }
        emplace(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = 10 * t2, u2 = 5 * t2;
          return this.uint16[l2 + 0] = e22, this.uint16[l2 + 1] = r2, this.uint16[l2 + 2] = n2, this.uint16[l2 + 3] = i2, this.float32[u2 + 2] = s2, this.float32[u2 + 3] = a2, this.float32[u2 + 4] = o2, t2;
        }
      }
      xo.prototype.bytesPerElement = 20, Ks(xo, "StructArrayLayout4ui3f20");
      class vo extends ja {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e22 = this.length;
          return this.resize(e22 + 1), this.emplace(e22, t2);
        }
        emplace(t2, e22) {
          return this.uint8[1 * t2 + 0] = e22, t2;
        }
      }
      vo.prototype.bytesPerElement = 1, Ks(vo, "StructArrayLayout1ub1");
      class bo extends Fa {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      bo.prototype.size = 40;
      class _o extends ro {
        get(t2) {
          return new bo(this, t2);
        }
      }
      Ks(_o, "CollisionBoxArray");
      class wo extends Fa {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t2) {
          this._structArray.uint8[this._pos1 + 49] = t2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t2) {
          this._structArray.uint8[this._pos1 + 50] = t2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 13] = t2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t2) {
          this._structArray.uint8[this._pos1 + 58] = t2;
        }
      }
      wo.prototype.size = 60;
      class Mo extends oo {
        get(t2) {
          return new wo(this, t2);
        }
      }
      Ks(Mo, "PlacedSymbolArray");
      class Ao extends Fa {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 14] = t2;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(t2) {
          this._structArray.float32[this._pos4 + 18] = t2;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
      }
      Ao.prototype.size = 80;
      class So extends lo {
        get(t2) {
          return new Ao(this, t2);
        }
      }
      Ks(So, "SymbolInstanceArray");
      class Io extends uo {
        getoffsetX(t2) {
          return this.float32[1 * t2 + 0];
        }
      }
      Ks(Io, "GlyphOffsetArray");
      class ko extends $a {
        getx(t2) {
          return this.int16[2 * t2 + 0];
        }
        gety(t2) {
          return this.int16[2 * t2 + 1];
        }
      }
      Ks(ko, "SymbolLineVertexArray");
      class To extends Fa {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      To.prototype.size = 12;
      class Po extends po {
        get(t2) {
          return new To(this, t2);
        }
      }
      Ks(Po, "FeatureIndexArray");
      class zo extends eo {
        geta_centroid_pos0(t2) {
          return this.uint16[2 * t2 + 0];
        }
        geta_centroid_pos1(t2) {
          return this.uint16[2 * t2 + 1];
        }
      }
      Ks(zo, "FillExtrusionCentroidArray");
      const Eo = Ua([{ name: "a_pos", components: 2, type: "Int16" }], 4), Bo = Ua([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class Do {
        constructor(t2 = []) {
          this.segments = t2;
        }
        _prepareSegment(t2, e22, r2, n2) {
          let i2 = this.segments[this.segments.length - 1];
          return t2 > Do.MAX_VERTEX_ARRAY_LENGTH && q(`Max vertices per segment is ${Do.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > Do.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e22, primitiveOffset: r2, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
        }
        prepareSegment(t2, e22, r2, n2) {
          return this._prepareSegment(t2, e22.length, r2.length, n2);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t2 of this.segments)
            for (const e22 in t2.vaos)
              t2.vaos[e22].destroy();
        }
        static simpleSegment(t2, e22, r2, n2) {
          return new Do([{ vertexOffset: t2, primitiveOffset: e22, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }
      }
      function Co(t2, e22) {
        return 256 * (t2 = k(Math.floor(t2), 0, 255)) + k(Math.floor(e22), 0, 255);
      }
      Do.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ks(Do, "SegmentVector");
      const Ro = Ua([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Lo = Ua([{ name: "a_dash", components: 4, type: "Uint16" }]);
      var Vo = { exports: {} }, Oo = { exports: {} };
      !function(t2) {
        t2.exports = function(t3, e22) {
          var r2, n2, i2, s2, a2, o2, l2, u2;
          for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e22, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
            l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r2) {
            case 3:
              l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
      }(Oo);
      var Fo = Oo.exports, jo = { exports: {} };
      !function(t2) {
        t2.exports = function(t3, e22) {
          for (var r2, n2 = t3.length, i2 = e22 ^ n2, s2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
      }(jo);
      var Uo = Fo, No = jo.exports;
      Vo.exports = Uo, Vo.exports.murmur3 = Uo, Vo.exports.murmur2 = No;
      var $o = p(Vo.exports);
      class qo {
        constructor() {
          this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
        }
        add(t2, e22, r2, n2) {
          this.ids.push(Go(t2)), this.positions.push(e22, r2, n2);
        }
        eachPosition(t2, e22) {
          const r2 = Go(t2);
          let n2 = 0, i2 = this.ids.length - 1;
          for (; n2 < i2; ) {
            const t3 = n2 + i2 >> 1;
            this.ids[t3] >= r2 ? i2 = t3 : n2 = t3 + 1;
          }
          for (; this.ids[n2] === r2; )
            e22(this.positions[3 * n2], this.positions[3 * n2 + 1], this.positions[3 * n2 + 2]), n2++;
        }
        static serialize(t2, e22) {
          const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return Yo(r2, n2, 0, r2.length - 1), e22 && (e22.add(r2.buffer), e22.add(n2.buffer)), { ids: r2, positions: n2 };
        }
        static deserialize(t2) {
          const e22 = new qo();
          let r2;
          e22.ids = t2.ids, e22.positions = t2.positions;
          for (const t3 of e22.ids)
            t3 !== r2 && e22.uniqueIds.push(t3), r2 = t3;
          return e22.indexed = true, e22;
        }
      }
      function Go(t2) {
        const e22 = +t2;
        return !isNaN(e22) && Number.MIN_SAFE_INTEGER <= e22 && e22 <= Number.MAX_SAFE_INTEGER ? e22 : $o(String(t2));
      }
      function Yo(t2, e22, r2, n2) {
        for (; r2 < n2; ) {
          const i2 = t2[r2 + n2 >> 1];
          let s2 = r2 - 1, a2 = n2 + 1;
          for (; ; ) {
            do {
              s2++;
            } while (t2[s2] < i2);
            do {
              a2--;
            } while (t2[a2] > i2);
            if (s2 >= a2)
              break;
            Zo(t2, s2, a2), Zo(e22, 3 * s2, 3 * a2), Zo(e22, 3 * s2 + 1, 3 * a2 + 1), Zo(e22, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r2 < n2 - a2 ? (Yo(t2, e22, r2, a2), r2 = a2 + 1) : (Yo(t2, e22, a2 + 1, n2), n2 = a2);
        }
      }
      function Zo(t2, e22, r2) {
        const n2 = t2[e22];
        t2[e22] = t2[r2], t2[r2] = n2;
      }
      Ks(qo, "FeaturePositionMap");
      class Xo {
        constructor(t2) {
          this.gl = t2.gl, this.initialized = false;
        }
        fetchUniformLocation(t2, e22) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e22), this.initialized = true), !!this.location;
        }
      }
      class Ko extends Xo {
        constructor(t2) {
          super(t2), this.current = 0;
        }
        set(t2, e22, r2) {
          this.fetchUniformLocation(t2, e22) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
        }
      }
      class Wo extends Xo {
        constructor(t2) {
          super(t2), this.current = 0;
        }
        set(t2, e22, r2) {
          this.fetchUniformLocation(t2, e22) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
        }
      }
      class Ho extends Xo {
        constructor(t2) {
          super(t2), this.current = [0, 0];
        }
        set(t2, e22, r2) {
          this.fetchUniformLocation(t2, e22) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
        }
      }
      class Jo extends Xo {
        constructor(t2) {
          super(t2), this.current = [0, 0, 0];
        }
        set(t2, e22, r2) {
          this.fetchUniformLocation(t2, e22) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
        }
      }
      class Qo extends Xo {
        constructor(t2) {
          super(t2), this.current = [0, 0, 0, 0];
        }
        set(t2, e22, r2) {
          this.fetchUniformLocation(t2, e22) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
        }
      }
      class tl extends Xo {
        constructor(t2) {
          super(t2), this.current = Re.transparent;
        }
        set(t2, e22, r2) {
          this.fetchUniformLocation(t2, e22) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
        }
      }
      const el = new Float32Array(16);
      class rl extends Xo {
        constructor(t2) {
          super(t2), this.current = el;
        }
        set(t2, e22, r2) {
          if (this.fetchUniformLocation(t2, e22)) {
            if (r2[12] !== this.current[12] || r2[0] !== this.current[0])
              return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
            for (let t3 = 1; t3 < 16; t3++)
              if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                break;
              }
          }
        }
      }
      const nl = new Float32Array(9), il = new Float32Array(4);
      class sl extends Xo {
        constructor(t2) {
          super(t2), this.current = il;
        }
        set(t2, e22, r2) {
          if (this.fetchUniformLocation(t2, e22)) {
            for (let t3 = 0; t3 < 4; t3++)
              if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                break;
              }
          }
        }
      }
      function al(t2) {
        return [Co(255 * t2.r, 255 * t2.g), Co(255 * t2.b, 255 * t2.a)];
      }
      class ol {
        constructor(t2, e22, r2) {
          this.value = t2, this.uniformNames = e22.map((t3) => `u_${t3}`), this.type = r2;
        }
        setUniform(t2, e22, r2, n2, i2) {
          e22.set(t2, i2, n2.constantOr(this.value));
        }
        getBinding(t2, e22) {
          return "color" === this.type ? new tl(t2) : new Wo(t2);
        }
      }
      class ll {
        constructor(t2, e22) {
          this.uniformNames = e22.map((t3) => `u_${t3}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(t2) {
          this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br);
        }
        setUniform(t2, e22, r2, n2, i2) {
          const s2 = "u_pattern" === i2 || "u_dash" === i2 ? this.pattern : "u_pixel_ratio" === i2 ? this.pixelRatio : null;
          s2 && e22.set(t2, i2, s2);
        }
        getBinding(t2, e22) {
          return "u_pattern" === e22 || "u_dash" === e22 ? new Qo(t2) : new Wo(t2);
        }
      }
      class ul {
        constructor(t2, e22, r2, n2) {
          this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e22.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
        }
        populatePaintArray(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.paintVertexArray.length, l2 = this.expression.evaluate(new _a2(0, { brightness: s2 }), e22, {}, i2, n2, a2);
          this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, l2);
        }
        updatePaintArray(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.expression.evaluate({ zoom: 0, brightness: a2 }, r2, n2, void 0, i2);
          this._setPaintValue(t2, e22, o2);
        }
        _setPaintValue(t2, e22, r2) {
          if ("color" === this.type) {
            const n2 = al(r2);
            for (let r3 = t2; r3 < e22; r3++)
              this.paintVertexArray.emplace(r3, n2[0], n2[1]);
          } else {
            for (let n2 = t2; n2 < e22; n2++)
              this.paintVertexArray.emplace(n2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class cl {
        constructor(t2, e22, r2, n2, i2, s2) {
          this.expression = t2, this.uniformNames = e22.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e22.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
        }
        populatePaintArray(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.expression.evaluate(new _a2(this.zoom, { brightness: s2 }), e22, {}, i2, n2, a2), l2 = this.expression.evaluate(new _a2(this.zoom + 1, { brightness: s2 }), e22, {}, i2, n2, a2), u2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValue(u2, t2, o2, l2);
        }
        updatePaintArray(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.expression.evaluate({ zoom: this.zoom, brightness: a2 }, r2, n2, void 0, i2), l2 = this.expression.evaluate({ zoom: this.zoom + 1, brightness: a2 }, r2, n2, void 0, i2);
          this._setPaintValue(t2, e22, o2, l2);
        }
        _setPaintValue(t2, e22, r2, n2) {
          if ("color" === this.type) {
            const i2 = al(r2), s2 = al(n2);
            for (let r3 = t2; r3 < e22; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t2; i2 < e22; i2++)
              this.paintVertexArray.emplace(i2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t2, e22, r2, n2, i2) {
          const s2 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, a2 = k(this.expression.interpolationFactor(s2, this.zoom, this.zoom + 1), 0, 1);
          e22.set(t2, i2, a2);
        }
        getBinding(t2, e22) {
          return new Wo(t2);
        }
      }
      class hl {
        constructor(t2, e22, r2, n2, i2) {
          this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r2 ? Lo : Ro).members;
          for (let t3 = 0; t3 < e22.length; ++t3)
            ;
          this.paintVertexArray = new n2();
        }
        populatePaintArray(t2, e22, r2) {
          const n2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValues(n2, t2, e22.patterns && e22.patterns[this.layerId], r2);
        }
        updatePaintArray(t2, e22, r2, n2, i2, s2, a2) {
          this._setPaintValues(t2, e22, r2.patterns && r2.patterns[this.layerId], s2);
        }
        _setPaintValues(t2, e22, r2, n2) {
          if (!n2 || !r2)
            return;
          const i2 = n2[r2];
          if (!i2)
            return;
          const { tl: s2, br: a2, pixelRatio: o2 } = i2;
          for (let r3 = t2; r3 < e22; r3++)
            this.paintVertexArray.emplace(r3, s2[0], s2[1], a2[0], a2[1], o2);
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class pl {
        constructor(t2, e22, r2 = () => true) {
          this.binders = {}, this._buffers = [];
          const n2 = [];
          for (const i2 in t2.paint._values) {
            const s2 = t2.paint.get(i2);
            if (!r2(i2))
              continue;
            if (!(s2 instanceof Ta && Ci(s2.property.specification)))
              continue;
            const a2 = ml(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = !!s2.property.useIntegerZoom, c2 = "line-dasharray" === i2 || i2.endsWith("pattern"), h22 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind;
            if ("constant" !== o2.kind || h22)
              if ("source" === o2.kind || h22 || c2) {
                const e3 = xl(i2, l2, "source");
                this.binders[i2] = c2 ? new hl(o2, a2, l2, e3, t2.id) : new ul(o2, a2, l2, e3), n2.push(`/a_${i2}`);
              } else {
                const t3 = xl(i2, l2, "composite");
                this.binders[i2] = new cl(o2, a2, l2, u2, e22, t3), n2.push(`/z_${i2}`);
              }
            else
              this.binders[i2] = c2 ? new ll(o2.value, a2) : new ol(o2.value, a2, l2), n2.push(`/u_${i2}`);
          }
          this.cacheKey = n2.sort().join("");
        }
        getMaxValue(t2) {
          const e22 = this.binders[t2];
          return e22 instanceof ul || e22 instanceof cl ? e22.maxValue : 0;
        }
        populatePaintArrays(t2, e22, r2, n2, i2, s2, a2) {
          for (const o2 in this.binders) {
            const l2 = this.binders[o2];
            (l2 instanceof ul || l2 instanceof cl || l2 instanceof hl) && l2.populatePaintArray(t2, e22, r2, n2, i2, s2, a2);
          }
        }
        setConstantPatternPositions(t2) {
          for (const e22 in this.binders) {
            const r2 = this.binders[e22];
            r2 instanceof ll && r2.setConstantPatternPositions(t2);
          }
        }
        updatePaintArrays(t2, e22, r2, n2, i2, s2, a2, o2) {
          let l2 = false;
          const u2 = Object.keys(t2), c2 = 0 !== u2.length, h22 = c2 ? u2 : e22.uniqueIds;
          for (const u3 in this.binders) {
            const p2 = this.binders[u3];
            if ((p2 instanceof ul || p2 instanceof cl || p2 instanceof hl) && (true === p2.expression.isStateDependent || false === p2.expression.isLightConstant)) {
              const f2 = i2.paint.get(u3);
              p2.expression = f2.value;
              for (const r3 of h22) {
                const i3 = t2[r3.toString()];
                e22.eachPosition(r3, (t3, e3, r4) => {
                  const l3 = n2.feature(t3);
                  p2.updatePaintArray(e3, r4, l3, i3, s2, a2, o2);
                });
              }
              if (!c2)
                for (const e3 of r2.uniqueIds) {
                  const i3 = t2[e3.toString()];
                  r2.eachPosition(e3, (t3, e4, r3) => {
                    const l3 = n2.feature(t3);
                    p2.updatePaintArray(e4, r3, l3, i3, s2, a2, o2);
                  });
                }
              l2 = true;
            }
          }
          return l2;
        }
        defines() {
          const t2 = [];
          for (const e22 in this.binders) {
            const r2 = this.binders[e22];
            (r2 instanceof ol || r2 instanceof ll) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t2;
        }
        getBinderAttributes() {
          const t2 = [];
          for (const e22 in this.binders) {
            const r2 = this.binders[e22];
            if (r2 instanceof ul || r2 instanceof cl || r2 instanceof hl)
              for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                t2.push(r2.paintVertexAttributes[e3].name);
          }
          return t2;
        }
        getBinderUniforms() {
          const t2 = [];
          for (const e22 in this.binders) {
            const r2 = this.binders[e22];
            if (r2 instanceof ol || r2 instanceof ll || r2 instanceof cl)
              for (const e3 of r2.uniformNames)
                t2.push(e3);
          }
          return t2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t2) {
          const e22 = [];
          for (const r2 in this.binders) {
            const n2 = this.binders[r2];
            if (n2 instanceof ol || n2 instanceof ll || n2 instanceof cl)
              for (const i2 of n2.uniformNames)
                e22.push({ name: i2, property: r2, binding: n2.getBinding(t2, i2) });
          }
          return e22;
        }
        setUniforms(t2, e22, r2, n2, i2) {
          for (const { name: e3, property: s2, binding: a2 } of r2)
            this.binders[s2].setUniform(t2, a2, i2, n2.get(s2), e3);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const t2 in this.binders) {
            const e22 = this.binders[t2];
            (e22 instanceof ul || e22 instanceof cl || e22 instanceof hl) && e22.paintVertexBuffer && this._buffers.push(e22.paintVertexBuffer);
          }
        }
        upload(t2) {
          for (const e22 in this.binders) {
            const r2 = this.binders[e22];
            (r2 instanceof ul || r2 instanceof cl || r2 instanceof hl) && r2.upload(t2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t2 in this.binders) {
            const e22 = this.binders[t2];
            (e22 instanceof ul || e22 instanceof cl || e22 instanceof hl) && e22.destroy();
          }
        }
      }
      class fl {
        constructor(t2, e22, r2 = () => true) {
          this.programConfigurations = {};
          for (const n2 of t2)
            this.programConfigurations[n2.id] = new pl(n2, e22, r2);
          this.needsUpload = false, this._featureMap = new qo(), this._featureMapWithoutIds = new qo(), this._bufferOffset = 0, this._idlessCounter = 0;
        }
        populatePaintArrays(t2, e22, r2, n2, i2, s2, a2, o2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t2, e22, n2, i2, s2, a2, o2);
          void 0 !== e22.id ? this._featureMap.add(e22.id, r2, this._bufferOffset, t2) : (this._featureMapWithoutIds.add(this._idlessCounter, r2, this._bufferOffset, t2), this._idlessCounter += 1), this._bufferOffset = t2, this.needsUpload = true;
        }
        updatePaintArrays(t2, e22, r2, n2, i2, s2) {
          for (const a2 of r2)
            this.needsUpload = this.programConfigurations[a2.id].updatePaintArrays(t2, this._featureMap, this._featureMapWithoutIds, e22, a2, n2, i2, s2 || 0) || this.needsUpload;
        }
        get(t2) {
          return this.programConfigurations[t2];
        }
        upload(t2) {
          if (this.needsUpload) {
            for (const e22 in this.programConfigurations)
              this.programConfigurations[e22].upload(t2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }
      }
      const dl = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function ml(t2, e22) {
        return dl[t2] || [t2.replace(`${e22}-`, "").replace(/-/g, "_")];
      }
      const yl = { "line-pattern": { source: Ka, composite: Ka }, "fill-pattern": { source: Ka, composite: Ka }, "fill-extrusion-pattern": { source: Ka, composite: Ka }, "line-dasharray": { source: Wa, composite: Wa } }, gl = { color: { source: yo, composite: Xa }, number: { source: uo, composite: yo } };
      function xl(t2, e22, r2) {
        const n2 = yl[t2];
        return n2 && n2[r2] || gl[e22][r2];
      }
      Ks(ol, "ConstantBinder"), Ks(ll, "PatternConstantBinder"), Ks(ul, "SourceExpressionBinder"), Ks(hl, "PatternCompositeBinder"), Ks(cl, "CompositeExpressionBinder"), Ks(pl, "ProgramConfiguration", { omit: ["_buffers"] }), Ks(fl, "ProgramConfigurationSet");
      class vl {
        constructor(t2, e22) {
          t2 && (e22 ? this.setSouthWest(t2).setNorthEast(e22) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
        }
        setNorthEast(t2) {
          return this._ne = t2 instanceof Zh ? new Zh(t2.lng, t2.lat) : Zh.convert(t2), this;
        }
        setSouthWest(t2) {
          return this._sw = t2 instanceof Zh ? new Zh(t2.lng, t2.lat) : Zh.convert(t2), this;
        }
        extend(t2) {
          const e22 = this._sw, r2 = this._ne;
          let n2, i2;
          if (t2 instanceof Zh)
            n2 = t2, i2 = t2;
          else {
            if (!(t2 instanceof vl))
              return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(vl.convert(t2)) : this.extend(Zh.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend(Zh.convert(t2)) : this;
            if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
              return this;
          }
          return e22 || r2 ? (e22.lng = Math.min(n2.lng, e22.lng), e22.lat = Math.min(n2.lat, e22.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Zh(n2.lng, n2.lat), this._ne = new Zh(i2.lng, i2.lat)), this;
        }
        getCenter() {
          return new Zh((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Zh(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Zh(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t2) {
          const { lng: e22, lat: r2 } = Zh.convert(t2);
          let n2 = this._sw.lng <= e22 && e22 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e22 && e22 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
        }
        static convert(t2) {
          return !t2 || t2 instanceof vl ? t2 : new vl(t2);
        }
      }
      var bl = {}, _l = {};
      Object.defineProperty(_l, "__esModule", { value: true }), _l.setMatrixArrayType = function(t2) {
        _l.ARRAY_TYPE = Ml = t2;
      }, _l.toRadian = function(t2) {
        return t2 * Sl;
      }, _l.equals = function(t2, e22) {
        return Math.abs(t2 - e22) <= wl * Math.max(1, Math.abs(t2), Math.abs(e22));
      }, _l.RANDOM = _l.ARRAY_TYPE = _l.EPSILON = void 0;
      var wl = 1e-6;
      _l.EPSILON = wl;
      var Ml = "undefined" != typeof Float32Array ? Float32Array : Array;
      _l.ARRAY_TYPE = Ml;
      var Al = Math.random;
      _l.RANDOM = Al;
      var Sl = Math.PI / 180;
      Math.hypot || (Math.hypot = function() {
        for (var t2 = 0, e22 = arguments.length; e22--; )
          t2 += arguments[e22] * arguments[e22];
        return Math.sqrt(t2);
      });
      var Il = {};
      function kl(t2) {
        return kl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, kl(t2);
      }
      Object.defineProperty(Il, "__esModule", { value: true }), Il.create = function() {
        var t2 = new Tl.ARRAY_TYPE(4);
        return Tl.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
      }, Il.clone = function(t2) {
        var e22 = new Tl.ARRAY_TYPE(4);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22[3] = t2[3], e22;
      }, Il.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2;
      }, Il.identity = function(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
      }, Il.fromValues = function(t2, e22, r2, n2) {
        var i2 = new Tl.ARRAY_TYPE(4);
        return i2[0] = t2, i2[1] = e22, i2[2] = r2, i2[3] = n2, i2;
      }, Il.set = function(t2, e22, r2, n2, i2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2[3] = i2, t2;
      }, Il.transpose = function(t2, e22) {
        if (t2 === e22) {
          var r2 = e22[1];
          t2[1] = e22[2], t2[2] = r2;
        } else
          t2[0] = e22[0], t2[1] = e22[2], t2[2] = e22[1], t2[3] = e22[3];
        return t2;
      }, Il.invert = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = r2 * s2 - i2 * n2;
        return a2 ? (t2[0] = s2 * (a2 = 1 / a2), t2[1] = -n2 * a2, t2[2] = -i2 * a2, t2[3] = r2 * a2, t2) : null;
      }, Il.adjoint = function(t2, e22) {
        var r2 = e22[0];
        return t2[0] = e22[3], t2[1] = -e22[1], t2[2] = -e22[2], t2[3] = r2, t2;
      }, Il.determinant = function(t2) {
        return t2[0] * t2[3] - t2[2] * t2[1];
      }, Il.multiply = zl, Il.rotate = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = n2 * -o2 + s2 * l2, t2[3] = i2 * -o2 + a2 * l2, t2;
      }, Il.scale = function(t2, e22, r2) {
        var n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = r2[0], o2 = r2[1];
        return t2[0] = e22[0] * a2, t2[1] = n2 * a2, t2[2] = i2 * o2, t2[3] = s2 * o2, t2;
      }, Il.fromRotation = function(t2, e22) {
        var r2 = Math.sin(e22), n2 = Math.cos(e22);
        return t2[0] = n2, t2[1] = r2, t2[2] = -r2, t2[3] = n2, t2;
      }, Il.fromScaling = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = 0, t2[2] = 0, t2[3] = e22[1], t2;
      }, Il.str = function(t2) {
        return "mat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
      }, Il.frob = function(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
      }, Il.LDU = function(t2, e22, r2, n2) {
        return t2[2] = n2[2] / n2[0], r2[0] = n2[0], r2[1] = n2[1], r2[3] = n2[3] - t2[2] * r2[1], [t2, e22, r2];
      }, Il.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2[3] = e22[3] + r2[3], t2;
      }, Il.subtract = El, Il.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2] && t2[3] === e22[3];
      }, Il.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = e22[0], o2 = e22[1], l2 = e22[2], u2 = e22[3];
        return Math.abs(r2 - a2) <= Tl.EPSILON * Math.max(1, Math.abs(r2), Math.abs(a2)) && Math.abs(n2 - o2) <= Tl.EPSILON * Math.max(1, Math.abs(n2), Math.abs(o2)) && Math.abs(i2 - l2) <= Tl.EPSILON * Math.max(1, Math.abs(i2), Math.abs(l2)) && Math.abs(s2 - u2) <= Tl.EPSILON * Math.max(1, Math.abs(s2), Math.abs(u2));
      }, Il.multiplyScalar = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2[3] = e22[3] * r2, t2;
      }, Il.multiplyScalarAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2[2] = e22[2] + r2[2] * n2, t2[3] = e22[3] + r2[3] * n2, t2;
      }, Il.sub = Il.mul = void 0;
      var Tl = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== kl(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = Pl(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function Pl(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (Pl = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function zl(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = r2[0], l2 = r2[1], u2 = r2[2], c2 = r2[3];
        return t2[0] = n2 * o2 + s2 * l2, t2[1] = i2 * o2 + a2 * l2, t2[2] = n2 * u2 + s2 * c2, t2[3] = i2 * u2 + a2 * c2, t2;
      }
      function El(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2[2] = e22[2] - r2[2], t2[3] = e22[3] - r2[3], t2;
      }
      Il.mul = zl, Il.sub = El;
      var Bl = {};
      function Dl(t2) {
        return Dl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, Dl(t2);
      }
      Object.defineProperty(Bl, "__esModule", { value: true }), Bl.create = function() {
        var t2 = new Cl.ARRAY_TYPE(6);
        return Cl.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0), t2[0] = 1, t2[3] = 1, t2;
      }, Bl.clone = function(t2) {
        var e22 = new Cl.ARRAY_TYPE(6);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22[3] = t2[3], e22[4] = t2[4], e22[5] = t2[5], e22;
      }, Bl.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2[4] = e22[4], t2[5] = e22[5], t2;
      }, Bl.identity = function(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2;
      }, Bl.fromValues = function(t2, e22, r2, n2, i2, s2) {
        var a2 = new Cl.ARRAY_TYPE(6);
        return a2[0] = t2, a2[1] = e22, a2[2] = r2, a2[3] = n2, a2[4] = i2, a2[5] = s2, a2;
      }, Bl.set = function(t2, e22, r2, n2, i2, s2, a2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2[3] = i2, t2[4] = s2, t2[5] = a2, t2;
      }, Bl.invert = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = r2 * s2 - n2 * i2;
        return l2 ? (t2[0] = s2 * (l2 = 1 / l2), t2[1] = -n2 * l2, t2[2] = -i2 * l2, t2[3] = r2 * l2, t2[4] = (i2 * o2 - s2 * a2) * l2, t2[5] = (n2 * a2 - r2 * o2) * l2, t2) : null;
      }, Bl.determinant = function(t2) {
        return t2[0] * t2[3] - t2[1] * t2[2];
      }, Bl.multiply = Ll, Bl.rotate = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = Math.sin(r2), c2 = Math.cos(r2);
        return t2[0] = n2 * c2 + s2 * u2, t2[1] = i2 * c2 + a2 * u2, t2[2] = n2 * -u2 + s2 * c2, t2[3] = i2 * -u2 + a2 * c2, t2[4] = o2, t2[5] = l2, t2;
      }, Bl.scale = function(t2, e22, r2) {
        var n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = r2[0], u2 = r2[1];
        return t2[0] = e22[0] * l2, t2[1] = n2 * l2, t2[2] = i2 * u2, t2[3] = s2 * u2, t2[4] = a2, t2[5] = o2, t2;
      }, Bl.translate = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = r2[0], c2 = r2[1];
        return t2[0] = n2, t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = n2 * u2 + s2 * c2 + o2, t2[5] = i2 * u2 + a2 * c2 + l2, t2;
      }, Bl.fromRotation = function(t2, e22) {
        var r2 = Math.sin(e22), n2 = Math.cos(e22);
        return t2[0] = n2, t2[1] = r2, t2[2] = -r2, t2[3] = n2, t2[4] = 0, t2[5] = 0, t2;
      }, Bl.fromScaling = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = 0, t2[2] = 0, t2[3] = e22[1], t2[4] = 0, t2[5] = 0, t2;
      }, Bl.fromTranslation = function(t2, e22) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = e22[0], t2[5] = e22[1], t2;
      }, Bl.str = function(t2) {
        return "mat2d(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ")";
      }, Bl.frob = function(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], 1);
      }, Bl.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2[3] = e22[3] + r2[3], t2[4] = e22[4] + r2[4], t2[5] = e22[5] + r2[5], t2;
      }, Bl.subtract = Vl, Bl.multiplyScalar = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2[3] = e22[3] * r2, t2[4] = e22[4] * r2, t2[5] = e22[5] * r2, t2;
      }, Bl.multiplyScalarAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2[2] = e22[2] + r2[2] * n2, t2[3] = e22[3] + r2[3] * n2, t2[4] = e22[4] + r2[4] * n2, t2[5] = e22[5] + r2[5] * n2, t2;
      }, Bl.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2] && t2[3] === e22[3] && t2[4] === e22[4] && t2[5] === e22[5];
      }, Bl.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = e22[0], u2 = e22[1], c2 = e22[2], h22 = e22[3], p2 = e22[4], f2 = e22[5];
        return Math.abs(r2 - l2) <= Cl.EPSILON * Math.max(1, Math.abs(r2), Math.abs(l2)) && Math.abs(n2 - u2) <= Cl.EPSILON * Math.max(1, Math.abs(n2), Math.abs(u2)) && Math.abs(i2 - c2) <= Cl.EPSILON * Math.max(1, Math.abs(i2), Math.abs(c2)) && Math.abs(s2 - h22) <= Cl.EPSILON * Math.max(1, Math.abs(s2), Math.abs(h22)) && Math.abs(a2 - p2) <= Cl.EPSILON * Math.max(1, Math.abs(a2), Math.abs(p2)) && Math.abs(o2 - f2) <= Cl.EPSILON * Math.max(1, Math.abs(o2), Math.abs(f2));
      }, Bl.sub = Bl.mul = void 0;
      var Cl = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== Dl(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = Rl(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function Rl(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (Rl = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function Ll(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = r2[0], c2 = r2[1], h22 = r2[2], p2 = r2[3], f2 = r2[4], d2 = r2[5];
        return t2[0] = n2 * u2 + s2 * c2, t2[1] = i2 * u2 + a2 * c2, t2[2] = n2 * h22 + s2 * p2, t2[3] = i2 * h22 + a2 * p2, t2[4] = n2 * f2 + s2 * d2 + o2, t2[5] = i2 * f2 + a2 * d2 + l2, t2;
      }
      function Vl(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2[2] = e22[2] - r2[2], t2[3] = e22[3] - r2[3], t2[4] = e22[4] - r2[4], t2[5] = e22[5] - r2[5], t2;
      }
      Bl.mul = Ll, Bl.sub = Vl;
      var Ol = {};
      function Fl(t2) {
        return Fl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, Fl(t2);
      }
      Object.defineProperty(Ol, "__esModule", { value: true }), Ol.create = function() {
        var t2 = new jl.ARRAY_TYPE(9);
        return jl.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
      }, Ol.fromMat4 = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[4], t2[4] = e22[5], t2[5] = e22[6], t2[6] = e22[8], t2[7] = e22[9], t2[8] = e22[10], t2;
      }, Ol.clone = function(t2) {
        var e22 = new jl.ARRAY_TYPE(9);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22[3] = t2[3], e22[4] = t2[4], e22[5] = t2[5], e22[6] = t2[6], e22[7] = t2[7], e22[8] = t2[8], e22;
      }, Ol.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2[4] = e22[4], t2[5] = e22[5], t2[6] = e22[6], t2[7] = e22[7], t2[8] = e22[8], t2;
      }, Ol.fromValues = function(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        var u2 = new jl.ARRAY_TYPE(9);
        return u2[0] = t2, u2[1] = e22, u2[2] = r2, u2[3] = n2, u2[4] = i2, u2[5] = s2, u2[6] = a2, u2[7] = o2, u2[8] = l2, u2;
      }, Ol.set = function(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2[3] = i2, t2[4] = s2, t2[5] = a2, t2[6] = o2, t2[7] = l2, t2[8] = u2, t2;
      }, Ol.identity = function(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, Ol.transpose = function(t2, e22) {
        if (t2 === e22) {
          var r2 = e22[1], n2 = e22[2], i2 = e22[5];
          t2[1] = e22[3], t2[2] = e22[6], t2[3] = r2, t2[5] = e22[7], t2[6] = n2, t2[7] = i2;
        } else
          t2[0] = e22[0], t2[1] = e22[3], t2[2] = e22[6], t2[3] = e22[1], t2[4] = e22[4], t2[5] = e22[7], t2[6] = e22[2], t2[7] = e22[5], t2[8] = e22[8];
        return t2;
      }, Ol.invert = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = e22[6], u2 = e22[7], c2 = e22[8], h22 = c2 * a2 - o2 * u2, p2 = -c2 * s2 + o2 * l2, f2 = u2 * s2 - a2 * l2, d2 = r2 * h22 + n2 * p2 + i2 * f2;
        return d2 ? (t2[0] = h22 * (d2 = 1 / d2), t2[1] = (-c2 * n2 + i2 * u2) * d2, t2[2] = (o2 * n2 - i2 * a2) * d2, t2[3] = p2 * d2, t2[4] = (c2 * r2 - i2 * l2) * d2, t2[5] = (-o2 * r2 + i2 * s2) * d2, t2[6] = f2 * d2, t2[7] = (-u2 * r2 + n2 * l2) * d2, t2[8] = (a2 * r2 - n2 * s2) * d2, t2) : null;
      }, Ol.adjoint = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = e22[6], u2 = e22[7], c2 = e22[8];
        return t2[0] = a2 * c2 - o2 * u2, t2[1] = i2 * u2 - n2 * c2, t2[2] = n2 * o2 - i2 * a2, t2[3] = o2 * l2 - s2 * c2, t2[4] = r2 * c2 - i2 * l2, t2[5] = i2 * s2 - r2 * o2, t2[6] = s2 * u2 - a2 * l2, t2[7] = n2 * l2 - r2 * u2, t2[8] = r2 * a2 - n2 * s2, t2;
      }, Ol.determinant = function(t2) {
        var e22 = t2[3], r2 = t2[4], n2 = t2[5], i2 = t2[6], s2 = t2[7], a2 = t2[8];
        return t2[0] * (a2 * r2 - n2 * s2) + t2[1] * (-a2 * e22 + n2 * i2) + t2[2] * (s2 * e22 - r2 * i2);
      }, Ol.multiply = Nl, Ol.translate = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = e22[8], p2 = r2[0], f2 = r2[1];
        return t2[0] = n2, t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = p2 * n2 + f2 * a2 + u2, t2[7] = p2 * i2 + f2 * o2 + c2, t2[8] = p2 * s2 + f2 * l2 + h22, t2;
      }, Ol.rotate = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = e22[8], p2 = Math.sin(r2), f2 = Math.cos(r2);
        return t2[0] = f2 * n2 + p2 * a2, t2[1] = f2 * i2 + p2 * o2, t2[2] = f2 * s2 + p2 * l2, t2[3] = f2 * a2 - p2 * n2, t2[4] = f2 * o2 - p2 * i2, t2[5] = f2 * l2 - p2 * s2, t2[6] = u2, t2[7] = c2, t2[8] = h22, t2;
      }, Ol.scale = function(t2, e22, r2) {
        var n2 = r2[0], i2 = r2[1];
        return t2[0] = n2 * e22[0], t2[1] = n2 * e22[1], t2[2] = n2 * e22[2], t2[3] = i2 * e22[3], t2[4] = i2 * e22[4], t2[5] = i2 * e22[5], t2[6] = e22[6], t2[7] = e22[7], t2[8] = e22[8], t2;
      }, Ol.fromTranslation = function(t2, e22) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = e22[0], t2[7] = e22[1], t2[8] = 1, t2;
      }, Ol.fromRotation = function(t2, e22) {
        var r2 = Math.sin(e22), n2 = Math.cos(e22);
        return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, Ol.fromScaling = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = e22[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, Ol.fromMat2d = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = 0, t2[3] = e22[2], t2[4] = e22[3], t2[5] = 0, t2[6] = e22[4], t2[7] = e22[5], t2[8] = 1, t2;
      }, Ol.fromQuat = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = r2 + r2, o2 = n2 + n2, l2 = i2 + i2, u2 = r2 * a2, c2 = n2 * a2, h22 = n2 * o2, p2 = i2 * a2, f2 = i2 * o2, d2 = i2 * l2, m2 = s2 * a2, y2 = s2 * o2, g2 = s2 * l2;
        return t2[0] = 1 - h22 - d2, t2[3] = c2 - g2, t2[6] = p2 + y2, t2[1] = c2 + g2, t2[4] = 1 - u2 - d2, t2[7] = f2 - m2, t2[2] = p2 - y2, t2[5] = f2 + m2, t2[8] = 1 - u2 - h22, t2;
      }, Ol.normalFromMat4 = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = e22[6], u2 = e22[7], c2 = e22[8], h22 = e22[9], p2 = e22[10], f2 = e22[11], d2 = e22[12], m2 = e22[13], y2 = e22[14], g2 = e22[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, _2 = n2 * l2 - i2 * o2, w2 = n2 * u2 - s2 * o2, M2 = i2 * u2 - s2 * l2, A2 = c2 * m2 - h22 * d2, S2 = c2 * y2 - p2 * d2, I2 = c2 * g2 - f2 * d2, k2 = h22 * y2 - p2 * m2, T2 = h22 * g2 - f2 * m2, P2 = p2 * g2 - f2 * y2, z2 = x2 * P2 - v2 * T2 + b2 * k2 + _2 * I2 - w2 * S2 + M2 * A2;
        return z2 ? (t2[0] = (o2 * P2 - l2 * T2 + u2 * k2) * (z2 = 1 / z2), t2[1] = (l2 * I2 - a2 * P2 - u2 * S2) * z2, t2[2] = (a2 * T2 - o2 * I2 + u2 * A2) * z2, t2[3] = (i2 * T2 - n2 * P2 - s2 * k2) * z2, t2[4] = (r2 * P2 - i2 * I2 + s2 * S2) * z2, t2[5] = (n2 * I2 - r2 * T2 - s2 * A2) * z2, t2[6] = (m2 * M2 - y2 * w2 + g2 * _2) * z2, t2[7] = (y2 * b2 - d2 * M2 - g2 * v2) * z2, t2[8] = (d2 * w2 - m2 * b2 + g2 * x2) * z2, t2) : null;
      }, Ol.projection = function(t2, e22, r2) {
        return t2[0] = 2 / e22, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = -2 / r2, t2[5] = 0, t2[6] = -1, t2[7] = 1, t2[8] = 1, t2;
      }, Ol.str = function(t2) {
        return "mat3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ")";
      }, Ol.frob = function(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6], t2[7], t2[8]);
      }, Ol.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2[3] = e22[3] + r2[3], t2[4] = e22[4] + r2[4], t2[5] = e22[5] + r2[5], t2[6] = e22[6] + r2[6], t2[7] = e22[7] + r2[7], t2[8] = e22[8] + r2[8], t2;
      }, Ol.subtract = $l, Ol.multiplyScalar = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2[3] = e22[3] * r2, t2[4] = e22[4] * r2, t2[5] = e22[5] * r2, t2[6] = e22[6] * r2, t2[7] = e22[7] * r2, t2[8] = e22[8] * r2, t2;
      }, Ol.multiplyScalarAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2[2] = e22[2] + r2[2] * n2, t2[3] = e22[3] + r2[3] * n2, t2[4] = e22[4] + r2[4] * n2, t2[5] = e22[5] + r2[5] * n2, t2[6] = e22[6] + r2[6] * n2, t2[7] = e22[7] + r2[7] * n2, t2[8] = e22[8] + r2[8] * n2, t2;
      }, Ol.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2] && t2[3] === e22[3] && t2[4] === e22[4] && t2[5] === e22[5] && t2[6] === e22[6] && t2[7] === e22[7] && t2[8] === e22[8];
      }, Ol.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h22 = e22[0], p2 = e22[1], f2 = e22[2], d2 = e22[3], m2 = e22[4], y2 = e22[5], g2 = e22[6], x2 = e22[7], v2 = e22[8];
        return Math.abs(r2 - h22) <= jl.EPSILON * Math.max(1, Math.abs(r2), Math.abs(h22)) && Math.abs(n2 - p2) <= jl.EPSILON * Math.max(1, Math.abs(n2), Math.abs(p2)) && Math.abs(i2 - f2) <= jl.EPSILON * Math.max(1, Math.abs(i2), Math.abs(f2)) && Math.abs(s2 - d2) <= jl.EPSILON * Math.max(1, Math.abs(s2), Math.abs(d2)) && Math.abs(a2 - m2) <= jl.EPSILON * Math.max(1, Math.abs(a2), Math.abs(m2)) && Math.abs(o2 - y2) <= jl.EPSILON * Math.max(1, Math.abs(o2), Math.abs(y2)) && Math.abs(l2 - g2) <= jl.EPSILON * Math.max(1, Math.abs(l2), Math.abs(g2)) && Math.abs(u2 - x2) <= jl.EPSILON * Math.max(1, Math.abs(u2), Math.abs(x2)) && Math.abs(c2 - v2) <= jl.EPSILON * Math.max(1, Math.abs(c2), Math.abs(v2));
      }, Ol.sub = Ol.mul = void 0;
      var jl = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== Fl(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = Ul(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function Ul(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (Ul = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function Nl(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = e22[8], p2 = r2[0], f2 = r2[1], d2 = r2[2], m2 = r2[3], y2 = r2[4], g2 = r2[5], x2 = r2[6], v2 = r2[7], b2 = r2[8];
        return t2[0] = p2 * n2 + f2 * a2 + d2 * u2, t2[1] = p2 * i2 + f2 * o2 + d2 * c2, t2[2] = p2 * s2 + f2 * l2 + d2 * h22, t2[3] = m2 * n2 + y2 * a2 + g2 * u2, t2[4] = m2 * i2 + y2 * o2 + g2 * c2, t2[5] = m2 * s2 + y2 * l2 + g2 * h22, t2[6] = x2 * n2 + v2 * a2 + b2 * u2, t2[7] = x2 * i2 + v2 * o2 + b2 * c2, t2[8] = x2 * s2 + v2 * l2 + b2 * h22, t2;
      }
      function $l(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2[2] = e22[2] - r2[2], t2[3] = e22[3] - r2[3], t2[4] = e22[4] - r2[4], t2[5] = e22[5] - r2[5], t2[6] = e22[6] - r2[6], t2[7] = e22[7] - r2[7], t2[8] = e22[8] - r2[8], t2;
      }
      Ol.mul = Nl, Ol.sub = $l;
      var ql = {};
      function Gl(t2) {
        return Gl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, Gl(t2);
      }
      Object.defineProperty(ql, "__esModule", { value: true }), ql.create = function() {
        var t2 = new Yl.ARRAY_TYPE(16);
        return Yl.ARRAY_TYPE != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, ql.clone = function(t2) {
        var e22 = new Yl.ARRAY_TYPE(16);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22[3] = t2[3], e22[4] = t2[4], e22[5] = t2[5], e22[6] = t2[6], e22[7] = t2[7], e22[8] = t2[8], e22[9] = t2[9], e22[10] = t2[10], e22[11] = t2[11], e22[12] = t2[12], e22[13] = t2[13], e22[14] = t2[14], e22[15] = t2[15], e22;
      }, ql.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2[4] = e22[4], t2[5] = e22[5], t2[6] = e22[6], t2[7] = e22[7], t2[8] = e22[8], t2[9] = e22[9], t2[10] = e22[10], t2[11] = e22[11], t2[12] = e22[12], t2[13] = e22[13], t2[14] = e22[14], t2[15] = e22[15], t2;
      }, ql.fromValues = function(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2) {
        var y2 = new Yl.ARRAY_TYPE(16);
        return y2[0] = t2, y2[1] = e22, y2[2] = r2, y2[3] = n2, y2[4] = i2, y2[5] = s2, y2[6] = a2, y2[7] = o2, y2[8] = l2, y2[9] = u2, y2[10] = c2, y2[11] = h22, y2[12] = p2, y2[13] = f2, y2[14] = d2, y2[15] = m2, y2;
      }, ql.set = function(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2[3] = i2, t2[4] = s2, t2[5] = a2, t2[6] = o2, t2[7] = l2, t2[8] = u2, t2[9] = c2, t2[10] = h22, t2[11] = p2, t2[12] = f2, t2[13] = d2, t2[14] = m2, t2[15] = y2, t2;
      }, ql.identity = Xl, ql.transpose = function(t2, e22) {
        if (t2 === e22) {
          var r2 = e22[1], n2 = e22[2], i2 = e22[3], s2 = e22[6], a2 = e22[7], o2 = e22[11];
          t2[1] = e22[4], t2[2] = e22[8], t2[3] = e22[12], t2[4] = r2, t2[6] = e22[9], t2[7] = e22[13], t2[8] = n2, t2[9] = s2, t2[11] = e22[14], t2[12] = i2, t2[13] = a2, t2[14] = o2;
        } else
          t2[0] = e22[0], t2[1] = e22[4], t2[2] = e22[8], t2[3] = e22[12], t2[4] = e22[1], t2[5] = e22[5], t2[6] = e22[9], t2[7] = e22[13], t2[8] = e22[2], t2[9] = e22[6], t2[10] = e22[10], t2[11] = e22[14], t2[12] = e22[3], t2[13] = e22[7], t2[14] = e22[11], t2[15] = e22[15];
        return t2;
      }, ql.invert = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = e22[6], u2 = e22[7], c2 = e22[8], h22 = e22[9], p2 = e22[10], f2 = e22[11], d2 = e22[12], m2 = e22[13], y2 = e22[14], g2 = e22[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, _2 = n2 * l2 - i2 * o2, w2 = n2 * u2 - s2 * o2, M2 = i2 * u2 - s2 * l2, A2 = c2 * m2 - h22 * d2, S2 = c2 * y2 - p2 * d2, I2 = c2 * g2 - f2 * d2, k2 = h22 * y2 - p2 * m2, T2 = h22 * g2 - f2 * m2, P2 = p2 * g2 - f2 * y2, z2 = x2 * P2 - v2 * T2 + b2 * k2 + _2 * I2 - w2 * S2 + M2 * A2;
        return z2 ? (t2[0] = (o2 * P2 - l2 * T2 + u2 * k2) * (z2 = 1 / z2), t2[1] = (i2 * T2 - n2 * P2 - s2 * k2) * z2, t2[2] = (m2 * M2 - y2 * w2 + g2 * _2) * z2, t2[3] = (p2 * w2 - h22 * M2 - f2 * _2) * z2, t2[4] = (l2 * I2 - a2 * P2 - u2 * S2) * z2, t2[5] = (r2 * P2 - i2 * I2 + s2 * S2) * z2, t2[6] = (y2 * b2 - d2 * M2 - g2 * v2) * z2, t2[7] = (c2 * M2 - p2 * b2 + f2 * v2) * z2, t2[8] = (a2 * T2 - o2 * I2 + u2 * A2) * z2, t2[9] = (n2 * I2 - r2 * T2 - s2 * A2) * z2, t2[10] = (d2 * w2 - m2 * b2 + g2 * x2) * z2, t2[11] = (h22 * b2 - c2 * w2 - f2 * x2) * z2, t2[12] = (o2 * S2 - a2 * k2 - l2 * A2) * z2, t2[13] = (r2 * k2 - n2 * S2 + i2 * A2) * z2, t2[14] = (m2 * v2 - d2 * _2 - y2 * x2) * z2, t2[15] = (c2 * _2 - h22 * v2 + p2 * x2) * z2, t2) : null;
      }, ql.adjoint = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = e22[4], o2 = e22[5], l2 = e22[6], u2 = e22[7], c2 = e22[8], h22 = e22[9], p2 = e22[10], f2 = e22[11], d2 = e22[12], m2 = e22[13], y2 = e22[14], g2 = e22[15];
        return t2[0] = o2 * (p2 * g2 - f2 * y2) - h22 * (l2 * g2 - u2 * y2) + m2 * (l2 * f2 - u2 * p2), t2[1] = -(n2 * (p2 * g2 - f2 * y2) - h22 * (i2 * g2 - s2 * y2) + m2 * (i2 * f2 - s2 * p2)), t2[2] = n2 * (l2 * g2 - u2 * y2) - o2 * (i2 * g2 - s2 * y2) + m2 * (i2 * u2 - s2 * l2), t2[3] = -(n2 * (l2 * f2 - u2 * p2) - o2 * (i2 * f2 - s2 * p2) + h22 * (i2 * u2 - s2 * l2)), t2[4] = -(a2 * (p2 * g2 - f2 * y2) - c2 * (l2 * g2 - u2 * y2) + d2 * (l2 * f2 - u2 * p2)), t2[5] = r2 * (p2 * g2 - f2 * y2) - c2 * (i2 * g2 - s2 * y2) + d2 * (i2 * f2 - s2 * p2), t2[6] = -(r2 * (l2 * g2 - u2 * y2) - a2 * (i2 * g2 - s2 * y2) + d2 * (i2 * u2 - s2 * l2)), t2[7] = r2 * (l2 * f2 - u2 * p2) - a2 * (i2 * f2 - s2 * p2) + c2 * (i2 * u2 - s2 * l2), t2[8] = a2 * (h22 * g2 - f2 * m2) - c2 * (o2 * g2 - u2 * m2) + d2 * (o2 * f2 - u2 * h22), t2[9] = -(r2 * (h22 * g2 - f2 * m2) - c2 * (n2 * g2 - s2 * m2) + d2 * (n2 * f2 - s2 * h22)), t2[10] = r2 * (o2 * g2 - u2 * m2) - a2 * (n2 * g2 - s2 * m2) + d2 * (n2 * u2 - s2 * o2), t2[11] = -(r2 * (o2 * f2 - u2 * h22) - a2 * (n2 * f2 - s2 * h22) + c2 * (n2 * u2 - s2 * o2)), t2[12] = -(a2 * (h22 * y2 - p2 * m2) - c2 * (o2 * y2 - l2 * m2) + d2 * (o2 * p2 - l2 * h22)), t2[13] = r2 * (h22 * y2 - p2 * m2) - c2 * (n2 * y2 - i2 * m2) + d2 * (n2 * p2 - i2 * h22), t2[14] = -(r2 * (o2 * y2 - l2 * m2) - a2 * (n2 * y2 - i2 * m2) + d2 * (n2 * l2 - i2 * o2)), t2[15] = r2 * (o2 * p2 - l2 * h22) - a2 * (n2 * p2 - i2 * h22) + c2 * (n2 * l2 - i2 * o2), t2;
      }, ql.determinant = function(t2) {
        var e22 = t2[0], r2 = t2[1], n2 = t2[2], i2 = t2[3], s2 = t2[4], a2 = t2[5], o2 = t2[6], l2 = t2[7], u2 = t2[8], c2 = t2[9], h22 = t2[10], p2 = t2[11], f2 = t2[12], d2 = t2[13], m2 = t2[14], y2 = t2[15];
        return (e22 * a2 - r2 * s2) * (h22 * y2 - p2 * m2) - (e22 * o2 - n2 * s2) * (c2 * y2 - p2 * d2) + (e22 * l2 - i2 * s2) * (c2 * m2 - h22 * d2) + (r2 * o2 - n2 * a2) * (u2 * y2 - p2 * f2) - (r2 * l2 - i2 * a2) * (u2 * m2 - h22 * f2) + (n2 * l2 - i2 * o2) * (u2 * d2 - c2 * f2);
      }, ql.multiply = Kl, ql.translate = function(t2, e22, r2) {
        var n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2 = r2[0], y2 = r2[1], g2 = r2[2];
        return e22 === t2 ? (t2[12] = e22[0] * m2 + e22[4] * y2 + e22[8] * g2 + e22[12], t2[13] = e22[1] * m2 + e22[5] * y2 + e22[9] * g2 + e22[13], t2[14] = e22[2] * m2 + e22[6] * y2 + e22[10] * g2 + e22[14], t2[15] = e22[3] * m2 + e22[7] * y2 + e22[11] * g2 + e22[15]) : (i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = e22[8], p2 = e22[9], f2 = e22[10], d2 = e22[11], t2[0] = n2 = e22[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h22, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * m2 + o2 * y2 + h22 * g2 + e22[12], t2[13] = i2 * m2 + l2 * y2 + p2 * g2 + e22[13], t2[14] = s2 * m2 + u2 * y2 + f2 * g2 + e22[14], t2[15] = a2 * m2 + c2 * y2 + d2 * g2 + e22[15]), t2;
      }, ql.scale = function(t2, e22, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2];
        return t2[0] = e22[0] * n2, t2[1] = e22[1] * n2, t2[2] = e22[2] * n2, t2[3] = e22[3] * n2, t2[4] = e22[4] * i2, t2[5] = e22[5] * i2, t2[6] = e22[6] * i2, t2[7] = e22[7] * i2, t2[8] = e22[8] * s2, t2[9] = e22[9] * s2, t2[10] = e22[10] * s2, t2[11] = e22[11] * s2, t2[12] = e22[12], t2[13] = e22[13], t2[14] = e22[14], t2[15] = e22[15], t2;
      }, ql.rotate = function(t2, e22, r2, n2) {
        var i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2, x2, v2, b2, _2, w2, M2, A2, S2, I2, k2, T2 = n2[0], P2 = n2[1], z2 = n2[2], E2 = Math.hypot(T2, P2, z2);
        return E2 < Yl.EPSILON ? null : (T2 *= E2 = 1 / E2, P2 *= E2, z2 *= E2, i2 = Math.sin(r2), s2 = Math.cos(r2), l2 = e22[1], u2 = e22[2], c2 = e22[3], p2 = e22[5], f2 = e22[6], d2 = e22[7], y2 = e22[9], g2 = e22[10], x2 = e22[11], w2 = T2 * P2 * (a2 = 1 - s2) - z2 * i2, M2 = P2 * P2 * a2 + s2, A2 = z2 * P2 * a2 + T2 * i2, S2 = T2 * z2 * a2 + P2 * i2, I2 = P2 * z2 * a2 - T2 * i2, k2 = z2 * z2 * a2 + s2, t2[0] = (o2 = e22[0]) * (v2 = T2 * T2 * a2 + s2) + (h22 = e22[4]) * (b2 = P2 * T2 * a2 + z2 * i2) + (m2 = e22[8]) * (_2 = z2 * T2 * a2 - P2 * i2), t2[1] = l2 * v2 + p2 * b2 + y2 * _2, t2[2] = u2 * v2 + f2 * b2 + g2 * _2, t2[3] = c2 * v2 + d2 * b2 + x2 * _2, t2[4] = o2 * w2 + h22 * M2 + m2 * A2, t2[5] = l2 * w2 + p2 * M2 + y2 * A2, t2[6] = u2 * w2 + f2 * M2 + g2 * A2, t2[7] = c2 * w2 + d2 * M2 + x2 * A2, t2[8] = o2 * S2 + h22 * I2 + m2 * k2, t2[9] = l2 * S2 + p2 * I2 + y2 * k2, t2[10] = u2 * S2 + f2 * I2 + g2 * k2, t2[11] = c2 * S2 + d2 * I2 + x2 * k2, e22 !== t2 && (t2[12] = e22[12], t2[13] = e22[13], t2[14] = e22[14], t2[15] = e22[15]), t2);
      }, ql.rotateX = function(t2, e22, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e22[4], a2 = e22[5], o2 = e22[6], l2 = e22[7], u2 = e22[8], c2 = e22[9], h22 = e22[10], p2 = e22[11];
        return e22 !== t2 && (t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2[12] = e22[12], t2[13] = e22[13], t2[14] = e22[14], t2[15] = e22[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h22 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h22 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
      }, ql.rotateY = function(t2, e22, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e22[0], a2 = e22[1], o2 = e22[2], l2 = e22[3], u2 = e22[8], c2 = e22[9], h22 = e22[10], p2 = e22[11];
        return e22 !== t2 && (t2[4] = e22[4], t2[5] = e22[5], t2[6] = e22[6], t2[7] = e22[7], t2[12] = e22[12], t2[13] = e22[13], t2[14] = e22[14], t2[15] = e22[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h22 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h22 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
      }, ql.rotateZ = function(t2, e22, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e22[0], a2 = e22[1], o2 = e22[2], l2 = e22[3], u2 = e22[4], c2 = e22[5], h22 = e22[6], p2 = e22[7];
        return e22 !== t2 && (t2[8] = e22[8], t2[9] = e22[9], t2[10] = e22[10], t2[11] = e22[11], t2[12] = e22[12], t2[13] = e22[13], t2[14] = e22[14], t2[15] = e22[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h22 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h22 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
      }, ql.fromTranslation = function(t2, e22) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = e22[0], t2[13] = e22[1], t2[14] = e22[2], t2[15] = 1, t2;
      }, ql.fromScaling = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e22[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e22[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, ql.fromRotation = function(t2, e22, r2) {
        var n2, i2, s2, a2 = r2[0], o2 = r2[1], l2 = r2[2], u2 = Math.hypot(a2, o2, l2);
        return u2 < Yl.EPSILON ? null : (a2 *= u2 = 1 / u2, o2 *= u2, l2 *= u2, n2 = Math.sin(e22), i2 = Math.cos(e22), t2[0] = a2 * a2 * (s2 = 1 - i2) + i2, t2[1] = o2 * a2 * s2 + l2 * n2, t2[2] = l2 * a2 * s2 - o2 * n2, t2[3] = 0, t2[4] = a2 * o2 * s2 - l2 * n2, t2[5] = o2 * o2 * s2 + i2, t2[6] = l2 * o2 * s2 + a2 * n2, t2[7] = 0, t2[8] = a2 * l2 * s2 + o2 * n2, t2[9] = o2 * l2 * s2 - a2 * n2, t2[10] = l2 * l2 * s2 + i2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
      }, ql.fromXRotation = function(t2, e22) {
        var r2 = Math.sin(e22), n2 = Math.cos(e22);
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = n2, t2[6] = r2, t2[7] = 0, t2[8] = 0, t2[9] = -r2, t2[10] = n2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, ql.fromYRotation = function(t2, e22) {
        var r2 = Math.sin(e22), n2 = Math.cos(e22);
        return t2[0] = n2, t2[1] = 0, t2[2] = -r2, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = r2, t2[9] = 0, t2[10] = n2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, ql.fromZRotation = function(t2, e22) {
        var r2 = Math.sin(e22), n2 = Math.cos(e22);
        return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = 0, t2[4] = -r2, t2[5] = n2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, ql.fromRotationTranslation = Wl, ql.fromQuat2 = function(t2, e22) {
        var r2 = new Yl.ARRAY_TYPE(3), n2 = -e22[0], i2 = -e22[1], s2 = -e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = n2 * n2 + i2 * i2 + s2 * s2 + a2 * a2;
        return h22 > 0 ? (r2[0] = 2 * (o2 * a2 + c2 * n2 + l2 * s2 - u2 * i2) / h22, r2[1] = 2 * (l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2) / h22, r2[2] = 2 * (u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2) / h22) : (r2[0] = 2 * (o2 * a2 + c2 * n2 + l2 * s2 - u2 * i2), r2[1] = 2 * (l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2), r2[2] = 2 * (u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2)), Wl(t2, e22, r2), t2;
      }, ql.getTranslation = function(t2, e22) {
        return t2[0] = e22[12], t2[1] = e22[13], t2[2] = e22[14], t2;
      }, ql.getScaling = Hl, ql.getRotation = function(t2, e22) {
        var r2 = new Yl.ARRAY_TYPE(3);
        Hl(r2, e22);
        var n2 = 1 / r2[0], i2 = 1 / r2[1], s2 = 1 / r2[2], a2 = e22[0] * n2, o2 = e22[1] * i2, l2 = e22[2] * s2, u2 = e22[4] * n2, c2 = e22[5] * i2, h22 = e22[6] * s2, p2 = e22[8] * n2, f2 = e22[9] * i2, d2 = e22[10] * s2, m2 = a2 + c2 + d2, y2 = 0;
        return m2 > 0 ? (y2 = 2 * Math.sqrt(m2 + 1), t2[3] = 0.25 * y2, t2[0] = (h22 - f2) / y2, t2[1] = (p2 - l2) / y2, t2[2] = (o2 - u2) / y2) : a2 > c2 && a2 > d2 ? (y2 = 2 * Math.sqrt(1 + a2 - c2 - d2), t2[3] = (h22 - f2) / y2, t2[0] = 0.25 * y2, t2[1] = (o2 + u2) / y2, t2[2] = (p2 + l2) / y2) : c2 > d2 ? (y2 = 2 * Math.sqrt(1 + c2 - a2 - d2), t2[3] = (p2 - l2) / y2, t2[0] = (o2 + u2) / y2, t2[1] = 0.25 * y2, t2[2] = (h22 + f2) / y2) : (y2 = 2 * Math.sqrt(1 + d2 - a2 - c2), t2[3] = (o2 - u2) / y2, t2[0] = (p2 + l2) / y2, t2[1] = (h22 + f2) / y2, t2[2] = 0.25 * y2), t2;
      }, ql.fromRotationTranslationScale = function(t2, e22, r2, n2) {
        var i2 = e22[0], s2 = e22[1], a2 = e22[2], o2 = e22[3], l2 = i2 + i2, u2 = s2 + s2, c2 = a2 + a2, h22 = i2 * l2, p2 = i2 * u2, f2 = i2 * c2, d2 = s2 * u2, m2 = s2 * c2, y2 = a2 * c2, g2 = o2 * l2, x2 = o2 * u2, v2 = o2 * c2, b2 = n2[0], _2 = n2[1], w2 = n2[2];
        return t2[0] = (1 - (d2 + y2)) * b2, t2[1] = (p2 + v2) * b2, t2[2] = (f2 - x2) * b2, t2[3] = 0, t2[4] = (p2 - v2) * _2, t2[5] = (1 - (h22 + y2)) * _2, t2[6] = (m2 + g2) * _2, t2[7] = 0, t2[8] = (f2 + x2) * w2, t2[9] = (m2 - g2) * w2, t2[10] = (1 - (h22 + d2)) * w2, t2[11] = 0, t2[12] = r2[0], t2[13] = r2[1], t2[14] = r2[2], t2[15] = 1, t2;
      }, ql.fromRotationTranslationScaleOrigin = function(t2, e22, r2, n2, i2) {
        var s2 = e22[0], a2 = e22[1], o2 = e22[2], l2 = e22[3], u2 = s2 + s2, c2 = a2 + a2, h22 = o2 + o2, p2 = s2 * u2, f2 = s2 * c2, d2 = s2 * h22, m2 = a2 * c2, y2 = a2 * h22, g2 = o2 * h22, x2 = l2 * u2, v2 = l2 * c2, b2 = l2 * h22, _2 = n2[0], w2 = n2[1], M2 = n2[2], A2 = i2[0], S2 = i2[1], I2 = i2[2], k2 = (1 - (m2 + g2)) * _2, T2 = (f2 + b2) * _2, P2 = (d2 - v2) * _2, z2 = (f2 - b2) * w2, E2 = (1 - (p2 + g2)) * w2, B2 = (y2 + x2) * w2, D2 = (d2 + v2) * M2, C2 = (y2 - x2) * M2, R2 = (1 - (p2 + m2)) * M2;
        return t2[0] = k2, t2[1] = T2, t2[2] = P2, t2[3] = 0, t2[4] = z2, t2[5] = E2, t2[6] = B2, t2[7] = 0, t2[8] = D2, t2[9] = C2, t2[10] = R2, t2[11] = 0, t2[12] = r2[0] + A2 - (k2 * A2 + z2 * S2 + D2 * I2), t2[13] = r2[1] + S2 - (T2 * A2 + E2 * S2 + C2 * I2), t2[14] = r2[2] + I2 - (P2 * A2 + B2 * S2 + R2 * I2), t2[15] = 1, t2;
      }, ql.fromQuat = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = r2 + r2, o2 = n2 + n2, l2 = i2 + i2, u2 = r2 * a2, c2 = n2 * a2, h22 = n2 * o2, p2 = i2 * a2, f2 = i2 * o2, d2 = i2 * l2, m2 = s2 * a2, y2 = s2 * o2, g2 = s2 * l2;
        return t2[0] = 1 - h22 - d2, t2[1] = c2 + g2, t2[2] = p2 - y2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - d2, t2[6] = f2 + m2, t2[7] = 0, t2[8] = p2 + y2, t2[9] = f2 - m2, t2[10] = 1 - u2 - h22, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, ql.frustum = function(t2, e22, r2, n2, i2, s2, a2) {
        var o2 = 1 / (r2 - e22), l2 = 1 / (i2 - n2), u2 = 1 / (s2 - a2);
        return t2[0] = 2 * s2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 2 * s2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = (r2 + e22) * o2, t2[9] = (i2 + n2) * l2, t2[10] = (a2 + s2) * u2, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = a2 * s2 * 2 * u2, t2[15] = 0, t2;
      }, ql.perspectiveNO = Jl, ql.perspectiveZO = function(t2, e22, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e22 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = i2 * (s2 = 1 / (n2 - i2)), t2[14] = i2 * n2 * s2) : (t2[10] = -1, t2[14] = -n2), t2;
      }, ql.perspectiveFromFieldOfView = function(t2, e22, r2, n2) {
        var i2 = Math.tan(e22.upDegrees * Math.PI / 180), s2 = Math.tan(e22.downDegrees * Math.PI / 180), a2 = Math.tan(e22.leftDegrees * Math.PI / 180), o2 = Math.tan(e22.rightDegrees * Math.PI / 180), l2 = 2 / (a2 + o2), u2 = 2 / (i2 + s2);
        return t2[0] = l2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = u2, t2[6] = 0, t2[7] = 0, t2[8] = -(a2 - o2) * l2 * 0.5, t2[9] = (i2 - s2) * u2 * 0.5, t2[10] = n2 / (r2 - n2), t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = n2 * r2 / (r2 - n2), t2[15] = 0, t2;
      }, ql.orthoNO = Ql, ql.orthoZO = function(t2, e22, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e22 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = u2, t2[11] = 0, t2[12] = (e22 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = s2 * u2, t2[15] = 1, t2;
      }, ql.lookAt = function(t2, e22, r2, n2) {
        var i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2 = e22[0], m2 = e22[1], y2 = e22[2], g2 = n2[0], x2 = n2[1], v2 = n2[2], b2 = r2[0], _2 = r2[1], w2 = r2[2];
        return Math.abs(d2 - b2) < Yl.EPSILON && Math.abs(m2 - _2) < Yl.EPSILON && Math.abs(y2 - w2) < Yl.EPSILON ? Xl(t2) : (c2 = d2 - b2, h22 = m2 - _2, p2 = y2 - w2, i2 = x2 * (p2 *= f2 = 1 / Math.hypot(c2, h22, p2)) - v2 * (h22 *= f2), s2 = v2 * (c2 *= f2) - g2 * p2, a2 = g2 * h22 - x2 * c2, (f2 = Math.hypot(i2, s2, a2)) ? (i2 *= f2 = 1 / f2, s2 *= f2, a2 *= f2) : (i2 = 0, s2 = 0, a2 = 0), o2 = h22 * a2 - p2 * s2, l2 = p2 * i2 - c2 * a2, u2 = c2 * s2 - h22 * i2, (f2 = Math.hypot(o2, l2, u2)) ? (o2 *= f2 = 1 / f2, l2 *= f2, u2 *= f2) : (o2 = 0, l2 = 0, u2 = 0), t2[0] = i2, t2[1] = o2, t2[2] = c2, t2[3] = 0, t2[4] = s2, t2[5] = l2, t2[6] = h22, t2[7] = 0, t2[8] = a2, t2[9] = u2, t2[10] = p2, t2[11] = 0, t2[12] = -(i2 * d2 + s2 * m2 + a2 * y2), t2[13] = -(o2 * d2 + l2 * m2 + u2 * y2), t2[14] = -(c2 * d2 + h22 * m2 + p2 * y2), t2[15] = 1, t2);
      }, ql.targetTo = function(t2, e22, r2, n2) {
        var i2 = e22[0], s2 = e22[1], a2 = e22[2], o2 = n2[0], l2 = n2[1], u2 = n2[2], c2 = i2 - r2[0], h22 = s2 - r2[1], p2 = a2 - r2[2], f2 = c2 * c2 + h22 * h22 + p2 * p2;
        f2 > 0 && (c2 *= f2 = 1 / Math.sqrt(f2), h22 *= f2, p2 *= f2);
        var d2 = l2 * p2 - u2 * h22, m2 = u2 * c2 - o2 * p2, y2 = o2 * h22 - l2 * c2;
        return (f2 = d2 * d2 + m2 * m2 + y2 * y2) > 0 && (d2 *= f2 = 1 / Math.sqrt(f2), m2 *= f2, y2 *= f2), t2[0] = d2, t2[1] = m2, t2[2] = y2, t2[3] = 0, t2[4] = h22 * y2 - p2 * m2, t2[5] = p2 * d2 - c2 * y2, t2[6] = c2 * m2 - h22 * d2, t2[7] = 0, t2[8] = c2, t2[9] = h22, t2[10] = p2, t2[11] = 0, t2[12] = i2, t2[13] = s2, t2[14] = a2, t2[15] = 1, t2;
      }, ql.str = function(t2) {
        return "mat4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ", " + t2[9] + ", " + t2[10] + ", " + t2[11] + ", " + t2[12] + ", " + t2[13] + ", " + t2[14] + ", " + t2[15] + ")";
      }, ql.frob = function(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6], t2[7], t2[8], t2[9], t2[10], t2[11], t2[12], t2[13], t2[14], t2[15]);
      }, ql.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2[3] = e22[3] + r2[3], t2[4] = e22[4] + r2[4], t2[5] = e22[5] + r2[5], t2[6] = e22[6] + r2[6], t2[7] = e22[7] + r2[7], t2[8] = e22[8] + r2[8], t2[9] = e22[9] + r2[9], t2[10] = e22[10] + r2[10], t2[11] = e22[11] + r2[11], t2[12] = e22[12] + r2[12], t2[13] = e22[13] + r2[13], t2[14] = e22[14] + r2[14], t2[15] = e22[15] + r2[15], t2;
      }, ql.subtract = tu, ql.multiplyScalar = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2[3] = e22[3] * r2, t2[4] = e22[4] * r2, t2[5] = e22[5] * r2, t2[6] = e22[6] * r2, t2[7] = e22[7] * r2, t2[8] = e22[8] * r2, t2[9] = e22[9] * r2, t2[10] = e22[10] * r2, t2[11] = e22[11] * r2, t2[12] = e22[12] * r2, t2[13] = e22[13] * r2, t2[14] = e22[14] * r2, t2[15] = e22[15] * r2, t2;
      }, ql.multiplyScalarAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2[2] = e22[2] + r2[2] * n2, t2[3] = e22[3] + r2[3] * n2, t2[4] = e22[4] + r2[4] * n2, t2[5] = e22[5] + r2[5] * n2, t2[6] = e22[6] + r2[6] * n2, t2[7] = e22[7] + r2[7] * n2, t2[8] = e22[8] + r2[8] * n2, t2[9] = e22[9] + r2[9] * n2, t2[10] = e22[10] + r2[10] * n2, t2[11] = e22[11] + r2[11] * n2, t2[12] = e22[12] + r2[12] * n2, t2[13] = e22[13] + r2[13] * n2, t2[14] = e22[14] + r2[14] * n2, t2[15] = e22[15] + r2[15] * n2, t2;
      }, ql.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2] && t2[3] === e22[3] && t2[4] === e22[4] && t2[5] === e22[5] && t2[6] === e22[6] && t2[7] === e22[7] && t2[8] === e22[8] && t2[9] === e22[9] && t2[10] === e22[10] && t2[11] === e22[11] && t2[12] === e22[12] && t2[13] === e22[13] && t2[14] === e22[14] && t2[15] === e22[15];
      }, ql.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h22 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], m2 = t2[13], y2 = t2[14], g2 = t2[15], x2 = e22[0], v2 = e22[1], b2 = e22[2], _2 = e22[3], w2 = e22[4], M2 = e22[5], A2 = e22[6], S2 = e22[7], I2 = e22[8], k2 = e22[9], T2 = e22[10], P2 = e22[11], z2 = e22[12], E2 = e22[13], B2 = e22[14], D2 = e22[15];
        return Math.abs(r2 - x2) <= Yl.EPSILON * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v2) <= Yl.EPSILON * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= Yl.EPSILON * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(s2 - _2) <= Yl.EPSILON * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(a2 - w2) <= Yl.EPSILON * Math.max(1, Math.abs(a2), Math.abs(w2)) && Math.abs(o2 - M2) <= Yl.EPSILON * Math.max(1, Math.abs(o2), Math.abs(M2)) && Math.abs(l2 - A2) <= Yl.EPSILON * Math.max(1, Math.abs(l2), Math.abs(A2)) && Math.abs(u2 - S2) <= Yl.EPSILON * Math.max(1, Math.abs(u2), Math.abs(S2)) && Math.abs(c2 - I2) <= Yl.EPSILON * Math.max(1, Math.abs(c2), Math.abs(I2)) && Math.abs(h22 - k2) <= Yl.EPSILON * Math.max(1, Math.abs(h22), Math.abs(k2)) && Math.abs(p2 - T2) <= Yl.EPSILON * Math.max(1, Math.abs(p2), Math.abs(T2)) && Math.abs(f2 - P2) <= Yl.EPSILON * Math.max(1, Math.abs(f2), Math.abs(P2)) && Math.abs(d2 - z2) <= Yl.EPSILON * Math.max(1, Math.abs(d2), Math.abs(z2)) && Math.abs(m2 - E2) <= Yl.EPSILON * Math.max(1, Math.abs(m2), Math.abs(E2)) && Math.abs(y2 - B2) <= Yl.EPSILON * Math.max(1, Math.abs(y2), Math.abs(B2)) && Math.abs(g2 - D2) <= Yl.EPSILON * Math.max(1, Math.abs(g2), Math.abs(D2));
      }, ql.sub = ql.mul = ql.ortho = ql.perspective = void 0;
      var Yl = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== Gl(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = Zl(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function Zl(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (Zl = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function Xl(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function Kl(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = e22[8], p2 = e22[9], f2 = e22[10], d2 = e22[11], m2 = e22[12], y2 = e22[13], g2 = e22[14], x2 = e22[15], v2 = r2[0], b2 = r2[1], _2 = r2[2], w2 = r2[3];
        return t2[0] = v2 * n2 + b2 * o2 + _2 * h22 + w2 * m2, t2[1] = v2 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[2] = v2 * s2 + b2 * u2 + _2 * f2 + w2 * g2, t2[3] = v2 * a2 + b2 * c2 + _2 * d2 + w2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (_2 = r2[6]) * h22 + (w2 = r2[7]) * m2, t2[5] = v2 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[6] = v2 * s2 + b2 * u2 + _2 * f2 + w2 * g2, t2[7] = v2 * a2 + b2 * c2 + _2 * d2 + w2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (_2 = r2[10]) * h22 + (w2 = r2[11]) * m2, t2[9] = v2 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[10] = v2 * s2 + b2 * u2 + _2 * f2 + w2 * g2, t2[11] = v2 * a2 + b2 * c2 + _2 * d2 + w2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (_2 = r2[14]) * h22 + (w2 = r2[15]) * m2, t2[13] = v2 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[14] = v2 * s2 + b2 * u2 + _2 * f2 + w2 * g2, t2[15] = v2 * a2 + b2 * c2 + _2 * d2 + w2 * x2, t2;
      }
      function Wl(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = n2 + n2, l2 = i2 + i2, u2 = s2 + s2, c2 = n2 * o2, h22 = n2 * l2, p2 = n2 * u2, f2 = i2 * l2, d2 = i2 * u2, m2 = s2 * u2, y2 = a2 * o2, g2 = a2 * l2, x2 = a2 * u2;
        return t2[0] = 1 - (f2 + m2), t2[1] = h22 + x2, t2[2] = p2 - g2, t2[3] = 0, t2[4] = h22 - x2, t2[5] = 1 - (c2 + m2), t2[6] = d2 + y2, t2[7] = 0, t2[8] = p2 + g2, t2[9] = d2 - y2, t2[10] = 1 - (c2 + f2), t2[11] = 0, t2[12] = r2[0], t2[13] = r2[1], t2[14] = r2[2], t2[15] = 1, t2;
      }
      function Hl(t2, e22) {
        var r2 = e22[4], n2 = e22[5], i2 = e22[6], s2 = e22[8], a2 = e22[9], o2 = e22[10];
        return t2[0] = Math.hypot(e22[0], e22[1], e22[2]), t2[1] = Math.hypot(r2, n2, i2), t2[2] = Math.hypot(s2, a2, o2), t2;
      }
      function Jl(t2, e22, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e22 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }
      function Ql(t2, e22, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e22 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e22 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
      }
      function tu(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2[2] = e22[2] - r2[2], t2[3] = e22[3] - r2[3], t2[4] = e22[4] - r2[4], t2[5] = e22[5] - r2[5], t2[6] = e22[6] - r2[6], t2[7] = e22[7] - r2[7], t2[8] = e22[8] - r2[8], t2[9] = e22[9] - r2[9], t2[10] = e22[10] - r2[10], t2[11] = e22[11] - r2[11], t2[12] = e22[12] - r2[12], t2[13] = e22[13] - r2[13], t2[14] = e22[14] - r2[14], t2[15] = e22[15] - r2[15], t2;
      }
      ql.perspective = Jl, ql.ortho = Ql, ql.mul = Kl, ql.sub = tu;
      var eu = {}, ru = {};
      function nu(t2) {
        return nu = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, nu(t2);
      }
      Object.defineProperty(ru, "__esModule", { value: true }), ru.create = au, ru.clone = function(t2) {
        var e22 = new iu.ARRAY_TYPE(3);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22;
      }, ru.length = ou, ru.fromValues = function(t2, e22, r2) {
        var n2 = new iu.ARRAY_TYPE(3);
        return n2[0] = t2, n2[1] = e22, n2[2] = r2, n2;
      }, ru.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2;
      }, ru.set = function(t2, e22, r2, n2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2;
      }, ru.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2;
      }, ru.subtract = lu, ru.multiply = uu, ru.divide = cu, ru.ceil = function(t2, e22) {
        return t2[0] = Math.ceil(e22[0]), t2[1] = Math.ceil(e22[1]), t2[2] = Math.ceil(e22[2]), t2;
      }, ru.floor = function(t2, e22) {
        return t2[0] = Math.floor(e22[0]), t2[1] = Math.floor(e22[1]), t2[2] = Math.floor(e22[2]), t2;
      }, ru.min = function(t2, e22, r2) {
        return t2[0] = Math.min(e22[0], r2[0]), t2[1] = Math.min(e22[1], r2[1]), t2[2] = Math.min(e22[2], r2[2]), t2;
      }, ru.max = function(t2, e22, r2) {
        return t2[0] = Math.max(e22[0], r2[0]), t2[1] = Math.max(e22[1], r2[1]), t2[2] = Math.max(e22[2], r2[2]), t2;
      }, ru.round = function(t2, e22) {
        return t2[0] = Math.round(e22[0]), t2[1] = Math.round(e22[1]), t2[2] = Math.round(e22[2]), t2;
      }, ru.scale = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2;
      }, ru.scaleAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2[2] = e22[2] + r2[2] * n2, t2;
      }, ru.distance = hu, ru.squaredDistance = pu, ru.squaredLength = fu, ru.negate = function(t2, e22) {
        return t2[0] = -e22[0], t2[1] = -e22[1], t2[2] = -e22[2], t2;
      }, ru.inverse = function(t2, e22) {
        return t2[0] = 1 / e22[0], t2[1] = 1 / e22[1], t2[2] = 1 / e22[2], t2;
      }, ru.normalize = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e22[0] * s2, t2[1] = e22[1] * s2, t2[2] = e22[2] * s2, t2;
      }, ru.dot = du, ru.cross = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
        return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
      }, ru.lerp = function(t2, e22, r2, n2) {
        var i2 = e22[0], s2 = e22[1], a2 = e22[2];
        return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2[2] = a2 + n2 * (r2[2] - a2), t2;
      }, ru.hermite = function(t2, e22, r2, n2, i2, s2) {
        var a2 = s2 * s2, o2 = a2 * (2 * s2 - 3) + 1, l2 = a2 * (s2 - 2) + s2, u2 = a2 * (s2 - 1), c2 = a2 * (3 - 2 * s2);
        return t2[0] = e22[0] * o2 + r2[0] * l2 + n2[0] * u2 + i2[0] * c2, t2[1] = e22[1] * o2 + r2[1] * l2 + n2[1] * u2 + i2[1] * c2, t2[2] = e22[2] * o2 + r2[2] * l2 + n2[2] * u2 + i2[2] * c2, t2;
      }, ru.bezier = function(t2, e22, r2, n2, i2, s2) {
        var a2 = 1 - s2, o2 = a2 * a2, l2 = s2 * s2, u2 = o2 * a2, c2 = 3 * s2 * o2, h22 = 3 * l2 * a2, p2 = l2 * s2;
        return t2[0] = e22[0] * u2 + r2[0] * c2 + n2[0] * h22 + i2[0] * p2, t2[1] = e22[1] * u2 + r2[1] * c2 + n2[1] * h22 + i2[1] * p2, t2[2] = e22[2] * u2 + r2[2] * c2 + n2[2] * h22 + i2[2] * p2, t2;
      }, ru.random = function(t2, e22) {
        e22 = e22 || 1;
        var r2 = 2 * iu.RANDOM() * Math.PI, n2 = 2 * iu.RANDOM() - 1, i2 = Math.sqrt(1 - n2 * n2) * e22;
        return t2[0] = Math.cos(r2) * i2, t2[1] = Math.sin(r2) * i2, t2[2] = n2 * e22, t2;
      }, ru.transformMat4 = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
        return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
      }, ru.transformMat3 = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2];
        return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
      }, ru.transformQuat = function(t2, e22, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = e22[0], o2 = e22[1], l2 = e22[2], u2 = i2 * l2 - s2 * o2, c2 = s2 * a2 - n2 * l2, h22 = n2 * o2 - i2 * a2, p2 = i2 * h22 - s2 * c2, f2 = s2 * u2 - n2 * h22, d2 = n2 * c2 - i2 * u2, m2 = 2 * r2[3];
        return c2 *= m2, h22 *= m2, f2 *= 2, d2 *= 2, t2[0] = a2 + (u2 *= m2) + (p2 *= 2), t2[1] = o2 + c2 + f2, t2[2] = l2 + h22 + d2, t2;
      }, ru.rotateX = function(t2, e22, r2, n2) {
        var i2 = [], s2 = [];
        return i2[0] = e22[0] - r2[0], i2[1] = e22[1] - r2[1], i2[2] = e22[2] - r2[2], s2[0] = i2[0], s2[1] = i2[1] * Math.cos(n2) - i2[2] * Math.sin(n2), s2[2] = i2[1] * Math.sin(n2) + i2[2] * Math.cos(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
      }, ru.rotateY = function(t2, e22, r2, n2) {
        var i2 = [], s2 = [];
        return i2[0] = e22[0] - r2[0], i2[1] = e22[1] - r2[1], i2[2] = e22[2] - r2[2], s2[0] = i2[2] * Math.sin(n2) + i2[0] * Math.cos(n2), s2[1] = i2[1], s2[2] = i2[2] * Math.cos(n2) - i2[0] * Math.sin(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
      }, ru.rotateZ = function(t2, e22, r2, n2) {
        var i2 = [], s2 = [];
        return i2[0] = e22[0] - r2[0], i2[1] = e22[1] - r2[1], i2[2] = e22[2] - r2[2], s2[0] = i2[0] * Math.cos(n2) - i2[1] * Math.sin(n2), s2[1] = i2[0] * Math.sin(n2) + i2[1] * Math.cos(n2), s2[2] = i2[2], t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
      }, ru.angle = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = e22[0], a2 = e22[1], o2 = e22[2], l2 = Math.sqrt(r2 * r2 + n2 * n2 + i2 * i2) * Math.sqrt(s2 * s2 + a2 * a2 + o2 * o2), u2 = l2 && du(t2, e22) / l2;
        return Math.acos(Math.min(Math.max(u2, -1), 1));
      }, ru.zero = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
      }, ru.str = function(t2) {
        return "vec3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ")";
      }, ru.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2];
      }, ru.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = e22[0], a2 = e22[1], o2 = e22[2];
        return Math.abs(r2 - s2) <= iu.EPSILON * Math.max(1, Math.abs(r2), Math.abs(s2)) && Math.abs(n2 - a2) <= iu.EPSILON * Math.max(1, Math.abs(n2), Math.abs(a2)) && Math.abs(i2 - o2) <= iu.EPSILON * Math.max(1, Math.abs(i2), Math.abs(o2));
      }, ru.forEach = ru.sqrLen = ru.len = ru.sqrDist = ru.dist = ru.div = ru.mul = ru.sub = void 0;
      var iu = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== nu(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = su(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function su(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (su = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function au() {
        var t2 = new iu.ARRAY_TYPE(3);
        return iu.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
      }
      function ou(t2) {
        return Math.hypot(t2[0], t2[1], t2[2]);
      }
      function lu(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2[2] = e22[2] - r2[2], t2;
      }
      function uu(t2, e22, r2) {
        return t2[0] = e22[0] * r2[0], t2[1] = e22[1] * r2[1], t2[2] = e22[2] * r2[2], t2;
      }
      function cu(t2, e22, r2) {
        return t2[0] = e22[0] / r2[0], t2[1] = e22[1] / r2[1], t2[2] = e22[2] / r2[2], t2;
      }
      function hu(t2, e22) {
        return Math.hypot(e22[0] - t2[0], e22[1] - t2[1], e22[2] - t2[2]);
      }
      function pu(t2, e22) {
        var r2 = e22[0] - t2[0], n2 = e22[1] - t2[1], i2 = e22[2] - t2[2];
        return r2 * r2 + n2 * n2 + i2 * i2;
      }
      function fu(t2) {
        var e22 = t2[0], r2 = t2[1], n2 = t2[2];
        return e22 * e22 + r2 * r2 + n2 * n2;
      }
      function du(t2, e22) {
        return t2[0] * e22[0] + t2[1] * e22[1] + t2[2] * e22[2];
      }
      ru.sub = lu, ru.mul = uu, ru.div = cu, ru.dist = hu, ru.sqrDist = pu, ru.len = ou, ru.sqrLen = fu;
      var mu, yu = (mu = au(), function(t2, e22, r2, n2, i2, s2) {
        var a2, o2;
        for (e22 || (e22 = 3), r2 || (r2 = 0), o2 = n2 ? Math.min(n2 * e22 + r2, t2.length) : t2.length, a2 = r2; a2 < o2; a2 += e22)
          mu[0] = t2[a2], mu[1] = t2[a2 + 1], mu[2] = t2[a2 + 2], i2(mu, mu, s2), t2[a2] = mu[0], t2[a2 + 1] = mu[1], t2[a2 + 2] = mu[2];
        return t2;
      });
      ru.forEach = yu;
      var gu = {};
      function xu(t2) {
        return xu = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, xu(t2);
      }
      Object.defineProperty(gu, "__esModule", { value: true }), gu.create = _u, gu.clone = function(t2) {
        var e22 = new vu.ARRAY_TYPE(4);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22[3] = t2[3], e22;
      }, gu.fromValues = function(t2, e22, r2, n2) {
        var i2 = new vu.ARRAY_TYPE(4);
        return i2[0] = t2, i2[1] = e22, i2[2] = r2, i2[3] = n2, i2;
      }, gu.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2;
      }, gu.set = function(t2, e22, r2, n2, i2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2[3] = i2, t2;
      }, gu.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2[3] = e22[3] + r2[3], t2;
      }, gu.subtract = wu, gu.multiply = Mu, gu.divide = Au, gu.ceil = function(t2, e22) {
        return t2[0] = Math.ceil(e22[0]), t2[1] = Math.ceil(e22[1]), t2[2] = Math.ceil(e22[2]), t2[3] = Math.ceil(e22[3]), t2;
      }, gu.floor = function(t2, e22) {
        return t2[0] = Math.floor(e22[0]), t2[1] = Math.floor(e22[1]), t2[2] = Math.floor(e22[2]), t2[3] = Math.floor(e22[3]), t2;
      }, gu.min = function(t2, e22, r2) {
        return t2[0] = Math.min(e22[0], r2[0]), t2[1] = Math.min(e22[1], r2[1]), t2[2] = Math.min(e22[2], r2[2]), t2[3] = Math.min(e22[3], r2[3]), t2;
      }, gu.max = function(t2, e22, r2) {
        return t2[0] = Math.max(e22[0], r2[0]), t2[1] = Math.max(e22[1], r2[1]), t2[2] = Math.max(e22[2], r2[2]), t2[3] = Math.max(e22[3], r2[3]), t2;
      }, gu.round = function(t2, e22) {
        return t2[0] = Math.round(e22[0]), t2[1] = Math.round(e22[1]), t2[2] = Math.round(e22[2]), t2[3] = Math.round(e22[3]), t2;
      }, gu.scale = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2[3] = e22[3] * r2, t2;
      }, gu.scaleAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2[2] = e22[2] + r2[2] * n2, t2[3] = e22[3] + r2[3] * n2, t2;
      }, gu.distance = Su, gu.squaredDistance = Iu, gu.length = ku, gu.squaredLength = Tu, gu.negate = function(t2, e22) {
        return t2[0] = -e22[0], t2[1] = -e22[1], t2[2] = -e22[2], t2[3] = -e22[3], t2;
      }, gu.inverse = function(t2, e22) {
        return t2[0] = 1 / e22[0], t2[1] = 1 / e22[1], t2[2] = 1 / e22[2], t2[3] = 1 / e22[3], t2;
      }, gu.normalize = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
        return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r2 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
      }, gu.dot = function(t2, e22) {
        return t2[0] * e22[0] + t2[1] * e22[1] + t2[2] * e22[2] + t2[3] * e22[3];
      }, gu.cross = function(t2, e22, r2, n2) {
        var i2 = r2[0] * n2[1] - r2[1] * n2[0], s2 = r2[0] * n2[2] - r2[2] * n2[0], a2 = r2[0] * n2[3] - r2[3] * n2[0], o2 = r2[1] * n2[2] - r2[2] * n2[1], l2 = r2[1] * n2[3] - r2[3] * n2[1], u2 = r2[2] * n2[3] - r2[3] * n2[2], c2 = e22[0], h22 = e22[1], p2 = e22[2], f2 = e22[3];
        return t2[0] = h22 * u2 - p2 * l2 + f2 * o2, t2[1] = -c2 * u2 + p2 * a2 - f2 * s2, t2[2] = c2 * l2 - h22 * a2 + f2 * i2, t2[3] = -c2 * o2 + h22 * s2 - p2 * i2, t2;
      }, gu.lerp = function(t2, e22, r2, n2) {
        var i2 = e22[0], s2 = e22[1], a2 = e22[2], o2 = e22[3];
        return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2[2] = a2 + n2 * (r2[2] - a2), t2[3] = o2 + n2 * (r2[3] - o2), t2;
      }, gu.random = function(t2, e22) {
        var r2, n2, i2, s2, a2, o2;
        e22 = e22 || 1;
        do {
          a2 = (r2 = 2 * vu.RANDOM() - 1) * r2 + (n2 = 2 * vu.RANDOM() - 1) * n2;
        } while (a2 >= 1);
        do {
          o2 = (i2 = 2 * vu.RANDOM() - 1) * i2 + (s2 = 2 * vu.RANDOM() - 1) * s2;
        } while (o2 >= 1);
        var l2 = Math.sqrt((1 - a2) / o2);
        return t2[0] = e22 * r2, t2[1] = e22 * n2, t2[2] = e22 * i2 * l2, t2[3] = e22 * s2 * l2, t2;
      }, gu.transformMat4 = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
      }, gu.transformQuat = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = r2[0], o2 = r2[1], l2 = r2[2], u2 = r2[3], c2 = u2 * n2 + o2 * s2 - l2 * i2, h22 = u2 * i2 + l2 * n2 - a2 * s2, p2 = u2 * s2 + a2 * i2 - o2 * n2, f2 = -a2 * n2 - o2 * i2 - l2 * s2;
        return t2[0] = c2 * u2 + f2 * -a2 + h22 * -l2 - p2 * -o2, t2[1] = h22 * u2 + f2 * -o2 + p2 * -a2 - c2 * -l2, t2[2] = p2 * u2 + f2 * -l2 + c2 * -o2 - h22 * -a2, t2[3] = e22[3], t2;
      }, gu.zero = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2;
      }, gu.str = function(t2) {
        return "vec4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
      }, gu.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2] && t2[3] === e22[3];
      }, gu.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = e22[0], o2 = e22[1], l2 = e22[2], u2 = e22[3];
        return Math.abs(r2 - a2) <= vu.EPSILON * Math.max(1, Math.abs(r2), Math.abs(a2)) && Math.abs(n2 - o2) <= vu.EPSILON * Math.max(1, Math.abs(n2), Math.abs(o2)) && Math.abs(i2 - l2) <= vu.EPSILON * Math.max(1, Math.abs(i2), Math.abs(l2)) && Math.abs(s2 - u2) <= vu.EPSILON * Math.max(1, Math.abs(s2), Math.abs(u2));
      }, gu.forEach = gu.sqrLen = gu.len = gu.sqrDist = gu.dist = gu.div = gu.mul = gu.sub = void 0;
      var vu = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== xu(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = bu(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function bu(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (bu = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function _u() {
        var t2 = new vu.ARRAY_TYPE(4);
        return vu.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
      }
      function wu(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2[2] = e22[2] - r2[2], t2[3] = e22[3] - r2[3], t2;
      }
      function Mu(t2, e22, r2) {
        return t2[0] = e22[0] * r2[0], t2[1] = e22[1] * r2[1], t2[2] = e22[2] * r2[2], t2[3] = e22[3] * r2[3], t2;
      }
      function Au(t2, e22, r2) {
        return t2[0] = e22[0] / r2[0], t2[1] = e22[1] / r2[1], t2[2] = e22[2] / r2[2], t2[3] = e22[3] / r2[3], t2;
      }
      function Su(t2, e22) {
        return Math.hypot(e22[0] - t2[0], e22[1] - t2[1], e22[2] - t2[2], e22[3] - t2[3]);
      }
      function Iu(t2, e22) {
        var r2 = e22[0] - t2[0], n2 = e22[1] - t2[1], i2 = e22[2] - t2[2], s2 = e22[3] - t2[3];
        return r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
      }
      function ku(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
      }
      function Tu(t2) {
        var e22 = t2[0], r2 = t2[1], n2 = t2[2], i2 = t2[3];
        return e22 * e22 + r2 * r2 + n2 * n2 + i2 * i2;
      }
      gu.sub = wu, gu.mul = Mu, gu.div = Au, gu.dist = Su, gu.sqrDist = Iu, gu.len = ku, gu.sqrLen = Tu;
      var Pu = function() {
        var t2 = _u();
        return function(e22, r2, n2, i2, s2, a2) {
          var o2, l2;
          for (r2 || (r2 = 4), n2 || (n2 = 0), l2 = i2 ? Math.min(i2 * r2 + n2, e22.length) : e22.length, o2 = n2; o2 < l2; o2 += r2)
            t2[0] = e22[o2], t2[1] = e22[o2 + 1], t2[2] = e22[o2 + 2], t2[3] = e22[o2 + 3], s2(t2, t2, a2), e22[o2] = t2[0], e22[o2 + 1] = t2[1], e22[o2 + 2] = t2[2], e22[o2 + 3] = t2[3];
          return e22;
        };
      }();
      function zu(t2) {
        return zu = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, zu(t2);
      }
      gu.forEach = Pu, Object.defineProperty(eu, "__esModule", { value: true }), eu.create = Vu, eu.identity = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
      }, eu.setAxisAngle = Ou, eu.getAxisAngle = function(t2, e22) {
        var r2 = 2 * Math.acos(e22[3]), n2 = Math.sin(r2 / 2);
        return n2 > Eu.EPSILON ? (t2[0] = e22[0] / n2, t2[1] = e22[1] / n2, t2[2] = e22[2] / n2) : (t2[0] = 1, t2[1] = 0, t2[2] = 0), r2;
      }, eu.getAngle = function(t2, e22) {
        var r2 = Gu(t2, e22);
        return Math.acos(2 * r2 * r2 - 1);
      }, eu.multiply = Fu, eu.rotateX = function(t2, e22, r2) {
        r2 *= 0.5;
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
      }, eu.rotateY = function(t2, e22, r2) {
        r2 *= 0.5;
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 - s2 * o2, t2[1] = i2 * l2 + a2 * o2, t2[2] = s2 * l2 + n2 * o2, t2[3] = a2 * l2 - i2 * o2, t2;
      }, eu.rotateZ = function(t2, e22, r2) {
        r2 *= 0.5;
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
      }, eu.calculateW = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2];
        return t2[0] = r2, t2[1] = n2, t2[2] = i2, t2[3] = Math.sqrt(Math.abs(1 - r2 * r2 - n2 * n2 - i2 * i2)), t2;
      }, eu.exp = ju, eu.ln = Uu, eu.pow = function(t2, e22, r2) {
        return Uu(t2, e22), qu(t2, t2, r2), ju(t2, t2), t2;
      }, eu.slerp = Nu, eu.random = function(t2) {
        var e22 = Eu.RANDOM(), r2 = Eu.RANDOM(), n2 = Eu.RANDOM(), i2 = Math.sqrt(1 - e22), s2 = Math.sqrt(e22);
        return t2[0] = i2 * Math.sin(2 * Math.PI * r2), t2[1] = i2 * Math.cos(2 * Math.PI * r2), t2[2] = s2 * Math.sin(2 * Math.PI * n2), t2[3] = s2 * Math.cos(2 * Math.PI * n2), t2;
      }, eu.invert = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2, o2 = a2 ? 1 / a2 : 0;
        return t2[0] = -r2 * o2, t2[1] = -n2 * o2, t2[2] = -i2 * o2, t2[3] = s2 * o2, t2;
      }, eu.conjugate = function(t2, e22) {
        return t2[0] = -e22[0], t2[1] = -e22[1], t2[2] = -e22[2], t2[3] = e22[3], t2;
      }, eu.fromMat3 = $u, eu.fromEuler = function(t2, e22, r2, n2) {
        var i2 = 0.5 * Math.PI / 180;
        e22 *= i2, r2 *= i2, n2 *= i2;
        var s2 = Math.sin(e22), a2 = Math.cos(e22), o2 = Math.sin(r2), l2 = Math.cos(r2), u2 = Math.sin(n2), c2 = Math.cos(n2);
        return t2[0] = s2 * l2 * c2 - a2 * o2 * u2, t2[1] = a2 * o2 * c2 + s2 * l2 * u2, t2[2] = a2 * l2 * u2 - s2 * o2 * c2, t2[3] = a2 * l2 * c2 + s2 * o2 * u2, t2;
      }, eu.str = function(t2) {
        return "quat(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
      }, eu.setAxes = eu.sqlerp = eu.rotationTo = eu.equals = eu.exactEquals = eu.normalize = eu.sqrLen = eu.squaredLength = eu.len = eu.length = eu.lerp = eu.dot = eu.scale = eu.mul = eu.add = eu.set = eu.copy = eu.fromValues = eu.clone = void 0;
      var Eu = Lu(_l), Bu = Lu(Ol), Du = Lu(ru), Cu = Lu(gu);
      function Ru(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (Ru = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function Lu(t2, e22) {
        if (!e22 && t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== zu(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = Ru(e22);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }
      function Vu() {
        var t2 = new Eu.ARRAY_TYPE(4);
        return Eu.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
      }
      function Ou(t2, e22, r2) {
        r2 *= 0.5;
        var n2 = Math.sin(r2);
        return t2[0] = n2 * e22[0], t2[1] = n2 * e22[1], t2[2] = n2 * e22[2], t2[3] = Math.cos(r2), t2;
      }
      function Fu(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = r2[0], l2 = r2[1], u2 = r2[2], c2 = r2[3];
        return t2[0] = n2 * c2 + a2 * o2 + i2 * u2 - s2 * l2, t2[1] = i2 * c2 + a2 * l2 + s2 * o2 - n2 * u2, t2[2] = s2 * c2 + a2 * u2 + n2 * l2 - i2 * o2, t2[3] = a2 * c2 - n2 * o2 - i2 * l2 - s2 * u2, t2;
      }
      function ju(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = Math.sqrt(r2 * r2 + n2 * n2 + i2 * i2), o2 = Math.exp(s2), l2 = a2 > 0 ? o2 * Math.sin(a2) / a2 : 0;
        return t2[0] = r2 * l2, t2[1] = n2 * l2, t2[2] = i2 * l2, t2[3] = o2 * Math.cos(a2), t2;
      }
      function Uu(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = e22[2], s2 = e22[3], a2 = Math.sqrt(r2 * r2 + n2 * n2 + i2 * i2), o2 = a2 > 0 ? Math.atan2(a2, s2) / a2 : 0;
        return t2[0] = r2 * o2, t2[1] = n2 * o2, t2[2] = i2 * o2, t2[3] = 0.5 * Math.log(r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2), t2;
      }
      function Nu(t2, e22, r2, n2) {
        var i2, s2, a2, o2, l2, u2 = e22[0], c2 = e22[1], h22 = e22[2], p2 = e22[3], f2 = r2[0], d2 = r2[1], m2 = r2[2], y2 = r2[3];
        return (s2 = u2 * f2 + c2 * d2 + h22 * m2 + p2 * y2) < 0 && (s2 = -s2, f2 = -f2, d2 = -d2, m2 = -m2, y2 = -y2), 1 - s2 > Eu.EPSILON ? (i2 = Math.acos(s2), a2 = Math.sin(i2), o2 = Math.sin((1 - n2) * i2) / a2, l2 = Math.sin(n2 * i2) / a2) : (o2 = 1 - n2, l2 = n2), t2[0] = o2 * u2 + l2 * f2, t2[1] = o2 * c2 + l2 * d2, t2[2] = o2 * h22 + l2 * m2, t2[3] = o2 * p2 + l2 * y2, t2;
      }
      function $u(t2, e22) {
        var r2, n2 = e22[0] + e22[4] + e22[8];
        if (n2 > 0)
          r2 = Math.sqrt(n2 + 1), t2[3] = 0.5 * r2, t2[0] = (e22[5] - e22[7]) * (r2 = 0.5 / r2), t2[1] = (e22[6] - e22[2]) * r2, t2[2] = (e22[1] - e22[3]) * r2;
        else {
          var i2 = 0;
          e22[4] > e22[0] && (i2 = 1), e22[8] > e22[3 * i2 + i2] && (i2 = 2);
          var s2 = (i2 + 1) % 3, a2 = (i2 + 2) % 3;
          r2 = Math.sqrt(e22[3 * i2 + i2] - e22[3 * s2 + s2] - e22[3 * a2 + a2] + 1), t2[i2] = 0.5 * r2, t2[3] = (e22[3 * s2 + a2] - e22[3 * a2 + s2]) * (r2 = 0.5 / r2), t2[s2] = (e22[3 * s2 + i2] + e22[3 * i2 + s2]) * r2, t2[a2] = (e22[3 * a2 + i2] + e22[3 * i2 + a2]) * r2;
        }
        return t2;
      }
      eu.clone = Cu.clone, eu.fromValues = Cu.fromValues, eu.copy = Cu.copy, eu.set = Cu.set, eu.add = Cu.add, eu.mul = Fu;
      var qu = Cu.scale;
      eu.scale = qu;
      var Gu = Cu.dot;
      eu.dot = Gu, eu.lerp = Cu.lerp;
      var Yu = Cu.length;
      eu.length = Yu, eu.len = Yu;
      var Zu = Cu.squaredLength;
      eu.squaredLength = Zu, eu.sqrLen = Zu;
      var Xu = Cu.normalize;
      eu.normalize = Xu, eu.exactEquals = Cu.exactEquals, eu.equals = Cu.equals;
      var Ku, Wu, Hu, Ju = (Ku = Du.create(), Wu = Du.fromValues(1, 0, 0), Hu = Du.fromValues(0, 1, 0), function(t2, e22, r2) {
        var n2 = Du.dot(e22, r2);
        return n2 < -0.999999 ? (Du.cross(Ku, Wu, e22), Du.len(Ku) < 1e-6 && Du.cross(Ku, Hu, e22), Du.normalize(Ku, Ku), Ou(t2, Ku, Math.PI), t2) : n2 > 0.999999 ? (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2) : (Du.cross(Ku, e22, r2), t2[0] = Ku[0], t2[1] = Ku[1], t2[2] = Ku[2], t2[3] = 1 + n2, Xu(t2, t2));
      });
      eu.rotationTo = Ju;
      var Qu, tc, ec = (Qu = Vu(), tc = Vu(), function(t2, e22, r2, n2, i2, s2) {
        return Nu(Qu, e22, i2, s2), Nu(tc, r2, n2, s2), Nu(t2, Qu, tc, 2 * s2 * (1 - s2)), t2;
      });
      eu.sqlerp = ec;
      var rc, nc = (rc = Bu.create(), function(t2, e22, r2, n2) {
        return rc[0] = r2[0], rc[3] = r2[1], rc[6] = r2[2], rc[1] = n2[0], rc[4] = n2[1], rc[7] = n2[2], rc[2] = -e22[0], rc[5] = -e22[1], rc[8] = -e22[2], Xu(t2, $u(t2, rc));
      });
      eu.setAxes = nc;
      var ic = {};
      function sc(t2) {
        return sc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, sc(t2);
      }
      Object.defineProperty(ic, "__esModule", { value: true }), ic.create = function() {
        var t2 = new ac.ARRAY_TYPE(8);
        return ac.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[3] = 1, t2;
      }, ic.clone = function(t2) {
        var e22 = new ac.ARRAY_TYPE(8);
        return e22[0] = t2[0], e22[1] = t2[1], e22[2] = t2[2], e22[3] = t2[3], e22[4] = t2[4], e22[5] = t2[5], e22[6] = t2[6], e22[7] = t2[7], e22;
      }, ic.fromValues = function(t2, e22, r2, n2, i2, s2, a2, o2) {
        var l2 = new ac.ARRAY_TYPE(8);
        return l2[0] = t2, l2[1] = e22, l2[2] = r2, l2[3] = n2, l2[4] = i2, l2[5] = s2, l2[6] = a2, l2[7] = o2, l2;
      }, ic.fromRotationTranslationValues = function(t2, e22, r2, n2, i2, s2, a2) {
        var o2 = new ac.ARRAY_TYPE(8);
        o2[0] = t2, o2[1] = e22, o2[2] = r2, o2[3] = n2;
        var l2 = 0.5 * i2, u2 = 0.5 * s2, c2 = 0.5 * a2;
        return o2[4] = l2 * n2 + u2 * r2 - c2 * e22, o2[5] = u2 * n2 + c2 * t2 - l2 * r2, o2[6] = c2 * n2 + l2 * e22 - u2 * t2, o2[7] = -l2 * t2 - u2 * e22 - c2 * r2, o2;
      }, ic.fromRotationTranslation = hc, ic.fromTranslation = function(t2, e22) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0.5 * e22[0], t2[5] = 0.5 * e22[1], t2[6] = 0.5 * e22[2], t2[7] = 0, t2;
      }, ic.fromRotation = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
      }, ic.fromMat4 = function(t2, e22) {
        var r2 = oc.create();
        lc.getRotation(r2, e22);
        var n2 = new ac.ARRAY_TYPE(3);
        return lc.getTranslation(n2, e22), hc(t2, r2, n2), t2;
      }, ic.copy = pc, ic.identity = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2;
      }, ic.set = function(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        return t2[0] = e22, t2[1] = r2, t2[2] = n2, t2[3] = i2, t2[4] = s2, t2[5] = a2, t2[6] = o2, t2[7] = l2, t2;
      }, ic.getDual = function(t2, e22) {
        return t2[0] = e22[4], t2[1] = e22[5], t2[2] = e22[6], t2[3] = e22[7], t2;
      }, ic.setDual = function(t2, e22) {
        return t2[4] = e22[0], t2[5] = e22[1], t2[6] = e22[2], t2[7] = e22[3], t2;
      }, ic.getTranslation = function(t2, e22) {
        var r2 = e22[4], n2 = e22[5], i2 = e22[6], s2 = e22[7], a2 = -e22[0], o2 = -e22[1], l2 = -e22[2], u2 = e22[3];
        return t2[0] = 2 * (r2 * u2 + s2 * a2 + n2 * l2 - i2 * o2), t2[1] = 2 * (n2 * u2 + s2 * o2 + i2 * a2 - r2 * l2), t2[2] = 2 * (i2 * u2 + s2 * l2 + r2 * o2 - n2 * a2), t2;
      }, ic.translate = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = 0.5 * r2[0], l2 = 0.5 * r2[1], u2 = 0.5 * r2[2], c2 = e22[4], h22 = e22[5], p2 = e22[6], f2 = e22[7];
        return t2[0] = n2, t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = a2 * o2 + i2 * u2 - s2 * l2 + c2, t2[5] = a2 * l2 + s2 * o2 - n2 * u2 + h22, t2[6] = a2 * u2 + n2 * l2 - i2 * o2 + p2, t2[7] = -n2 * o2 - i2 * l2 - s2 * u2 + f2, t2;
      }, ic.rotateX = function(t2, e22, r2) {
        var n2 = -e22[0], i2 = -e22[1], s2 = -e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = o2 * a2 + c2 * n2 + l2 * s2 - u2 * i2, p2 = l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2, f2 = u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2, d2 = c2 * a2 - o2 * n2 - l2 * i2 - u2 * s2;
        return oc.rotateX(t2, e22, r2), t2[4] = h22 * (a2 = t2[3]) + d2 * (n2 = t2[0]) + p2 * (s2 = t2[2]) - f2 * (i2 = t2[1]), t2[5] = p2 * a2 + d2 * i2 + f2 * n2 - h22 * s2, t2[6] = f2 * a2 + d2 * s2 + h22 * i2 - p2 * n2, t2[7] = d2 * a2 - h22 * n2 - p2 * i2 - f2 * s2, t2;
      }, ic.rotateY = function(t2, e22, r2) {
        var n2 = -e22[0], i2 = -e22[1], s2 = -e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = o2 * a2 + c2 * n2 + l2 * s2 - u2 * i2, p2 = l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2, f2 = u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2, d2 = c2 * a2 - o2 * n2 - l2 * i2 - u2 * s2;
        return oc.rotateY(t2, e22, r2), t2[4] = h22 * (a2 = t2[3]) + d2 * (n2 = t2[0]) + p2 * (s2 = t2[2]) - f2 * (i2 = t2[1]), t2[5] = p2 * a2 + d2 * i2 + f2 * n2 - h22 * s2, t2[6] = f2 * a2 + d2 * s2 + h22 * i2 - p2 * n2, t2[7] = d2 * a2 - h22 * n2 - p2 * i2 - f2 * s2, t2;
      }, ic.rotateZ = function(t2, e22, r2) {
        var n2 = -e22[0], i2 = -e22[1], s2 = -e22[2], a2 = e22[3], o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = o2 * a2 + c2 * n2 + l2 * s2 - u2 * i2, p2 = l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2, f2 = u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2, d2 = c2 * a2 - o2 * n2 - l2 * i2 - u2 * s2;
        return oc.rotateZ(t2, e22, r2), t2[4] = h22 * (a2 = t2[3]) + d2 * (n2 = t2[0]) + p2 * (s2 = t2[2]) - f2 * (i2 = t2[1]), t2[5] = p2 * a2 + d2 * i2 + f2 * n2 - h22 * s2, t2[6] = f2 * a2 + d2 * s2 + h22 * i2 - p2 * n2, t2[7] = d2 * a2 - h22 * n2 - p2 * i2 - f2 * s2, t2;
      }, ic.rotateByQuatAppend = function(t2, e22, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = r2[3], o2 = e22[0], l2 = e22[1], u2 = e22[2], c2 = e22[3];
        return t2[0] = o2 * a2 + c2 * n2 + l2 * s2 - u2 * i2, t2[1] = l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2, t2[2] = u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2, t2[3] = c2 * a2 - o2 * n2 - l2 * i2 - u2 * s2, t2[4] = (o2 = e22[4]) * a2 + (c2 = e22[7]) * n2 + (l2 = e22[5]) * s2 - (u2 = e22[6]) * i2, t2[5] = l2 * a2 + c2 * i2 + u2 * n2 - o2 * s2, t2[6] = u2 * a2 + c2 * s2 + o2 * i2 - l2 * n2, t2[7] = c2 * a2 - o2 * n2 - l2 * i2 - u2 * s2, t2;
      }, ic.rotateByQuatPrepend = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = r2[0], l2 = r2[1], u2 = r2[2], c2 = r2[3];
        return t2[0] = n2 * c2 + a2 * o2 + i2 * u2 - s2 * l2, t2[1] = i2 * c2 + a2 * l2 + s2 * o2 - n2 * u2, t2[2] = s2 * c2 + a2 * u2 + n2 * l2 - i2 * o2, t2[3] = a2 * c2 - n2 * o2 - i2 * l2 - s2 * u2, t2[4] = n2 * (c2 = r2[7]) + a2 * (o2 = r2[4]) + i2 * (u2 = r2[6]) - s2 * (l2 = r2[5]), t2[5] = i2 * c2 + a2 * l2 + s2 * o2 - n2 * u2, t2[6] = s2 * c2 + a2 * u2 + n2 * l2 - i2 * o2, t2[7] = a2 * c2 - n2 * o2 - i2 * l2 - s2 * u2, t2;
      }, ic.rotateAroundAxis = function(t2, e22, r2, n2) {
        if (Math.abs(n2) < ac.EPSILON)
          return pc(t2, e22);
        var i2 = Math.hypot(r2[0], r2[1], r2[2]);
        n2 *= 0.5;
        var s2 = Math.sin(n2), a2 = s2 * r2[0] / i2, o2 = s2 * r2[1] / i2, l2 = s2 * r2[2] / i2, u2 = Math.cos(n2), c2 = e22[0], h22 = e22[1], p2 = e22[2], f2 = e22[3];
        t2[0] = c2 * u2 + f2 * a2 + h22 * l2 - p2 * o2, t2[1] = h22 * u2 + f2 * o2 + p2 * a2 - c2 * l2, t2[2] = p2 * u2 + f2 * l2 + c2 * o2 - h22 * a2, t2[3] = f2 * u2 - c2 * a2 - h22 * o2 - p2 * l2;
        var d2 = e22[4], m2 = e22[5], y2 = e22[6], g2 = e22[7];
        return t2[4] = d2 * u2 + g2 * a2 + m2 * l2 - y2 * o2, t2[5] = m2 * u2 + g2 * o2 + y2 * a2 - d2 * l2, t2[6] = y2 * u2 + g2 * l2 + d2 * o2 - m2 * a2, t2[7] = g2 * u2 - d2 * a2 - m2 * o2 - y2 * l2, t2;
      }, ic.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2[2] = e22[2] + r2[2], t2[3] = e22[3] + r2[3], t2[4] = e22[4] + r2[4], t2[5] = e22[5] + r2[5], t2[6] = e22[6] + r2[6], t2[7] = e22[7] + r2[7], t2;
      }, ic.multiply = fc, ic.scale = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2[2] = e22[2] * r2, t2[3] = e22[3] * r2, t2[4] = e22[4] * r2, t2[5] = e22[5] * r2, t2[6] = e22[6] * r2, t2[7] = e22[7] * r2, t2;
      }, ic.lerp = function(t2, e22, r2, n2) {
        var i2 = 1 - n2;
        return dc(e22, r2) < 0 && (n2 = -n2), t2[0] = e22[0] * i2 + r2[0] * n2, t2[1] = e22[1] * i2 + r2[1] * n2, t2[2] = e22[2] * i2 + r2[2] * n2, t2[3] = e22[3] * i2 + r2[3] * n2, t2[4] = e22[4] * i2 + r2[4] * n2, t2[5] = e22[5] * i2 + r2[5] * n2, t2[6] = e22[6] * i2 + r2[6] * n2, t2[7] = e22[7] * i2 + r2[7] * n2, t2;
      }, ic.invert = function(t2, e22) {
        var r2 = yc(e22);
        return t2[0] = -e22[0] / r2, t2[1] = -e22[1] / r2, t2[2] = -e22[2] / r2, t2[3] = e22[3] / r2, t2[4] = -e22[4] / r2, t2[5] = -e22[5] / r2, t2[6] = -e22[6] / r2, t2[7] = e22[7] / r2, t2;
      }, ic.conjugate = function(t2, e22) {
        return t2[0] = -e22[0], t2[1] = -e22[1], t2[2] = -e22[2], t2[3] = e22[3], t2[4] = -e22[4], t2[5] = -e22[5], t2[6] = -e22[6], t2[7] = e22[7], t2;
      }, ic.normalize = function(t2, e22) {
        var r2 = yc(e22);
        if (r2 > 0) {
          r2 = Math.sqrt(r2);
          var n2 = e22[0] / r2, i2 = e22[1] / r2, s2 = e22[2] / r2, a2 = e22[3] / r2, o2 = e22[4], l2 = e22[5], u2 = e22[6], c2 = e22[7], h22 = n2 * o2 + i2 * l2 + s2 * u2 + a2 * c2;
          t2[0] = n2, t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = (o2 - n2 * h22) / r2, t2[5] = (l2 - i2 * h22) / r2, t2[6] = (u2 - s2 * h22) / r2, t2[7] = (c2 - a2 * h22) / r2;
        }
        return t2;
      }, ic.str = function(t2) {
        return "quat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ")";
      }, ic.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1] && t2[2] === e22[2] && t2[3] === e22[3] && t2[4] === e22[4] && t2[5] === e22[5] && t2[6] === e22[6] && t2[7] === e22[7];
      }, ic.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = e22[0], h22 = e22[1], p2 = e22[2], f2 = e22[3], d2 = e22[4], m2 = e22[5], y2 = e22[6], g2 = e22[7];
        return Math.abs(r2 - c2) <= ac.EPSILON * Math.max(1, Math.abs(r2), Math.abs(c2)) && Math.abs(n2 - h22) <= ac.EPSILON * Math.max(1, Math.abs(n2), Math.abs(h22)) && Math.abs(i2 - p2) <= ac.EPSILON * Math.max(1, Math.abs(i2), Math.abs(p2)) && Math.abs(s2 - f2) <= ac.EPSILON * Math.max(1, Math.abs(s2), Math.abs(f2)) && Math.abs(a2 - d2) <= ac.EPSILON * Math.max(1, Math.abs(a2), Math.abs(d2)) && Math.abs(o2 - m2) <= ac.EPSILON * Math.max(1, Math.abs(o2), Math.abs(m2)) && Math.abs(l2 - y2) <= ac.EPSILON * Math.max(1, Math.abs(l2), Math.abs(y2)) && Math.abs(u2 - g2) <= ac.EPSILON * Math.max(1, Math.abs(u2), Math.abs(g2));
      }, ic.sqrLen = ic.squaredLength = ic.len = ic.length = ic.dot = ic.mul = ic.setReal = ic.getReal = void 0;
      var ac = cc(_l), oc = cc(eu), lc = cc(ql);
      function uc(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (uc = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function cc(t2, e22) {
        if (!e22 && t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== sc(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = uc(e22);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }
      function hc(t2, e22, r2) {
        var n2 = 0.5 * r2[0], i2 = 0.5 * r2[1], s2 = 0.5 * r2[2], a2 = e22[0], o2 = e22[1], l2 = e22[2], u2 = e22[3];
        return t2[0] = a2, t2[1] = o2, t2[2] = l2, t2[3] = u2, t2[4] = n2 * u2 + i2 * l2 - s2 * o2, t2[5] = i2 * u2 + s2 * a2 - n2 * l2, t2[6] = s2 * u2 + n2 * o2 - i2 * a2, t2[7] = -n2 * a2 - i2 * o2 - s2 * l2, t2;
      }
      function pc(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2[2] = e22[2], t2[3] = e22[3], t2[4] = e22[4], t2[5] = e22[5], t2[6] = e22[6], t2[7] = e22[7], t2;
      }
      function fc(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1], s2 = e22[2], a2 = e22[3], o2 = r2[4], l2 = r2[5], u2 = r2[6], c2 = r2[7], h22 = e22[4], p2 = e22[5], f2 = e22[6], d2 = e22[7], m2 = r2[0], y2 = r2[1], g2 = r2[2], x2 = r2[3];
        return t2[0] = n2 * x2 + a2 * m2 + i2 * g2 - s2 * y2, t2[1] = i2 * x2 + a2 * y2 + s2 * m2 - n2 * g2, t2[2] = s2 * x2 + a2 * g2 + n2 * y2 - i2 * m2, t2[3] = a2 * x2 - n2 * m2 - i2 * y2 - s2 * g2, t2[4] = n2 * c2 + a2 * o2 + i2 * u2 - s2 * l2 + h22 * x2 + d2 * m2 + p2 * g2 - f2 * y2, t2[5] = i2 * c2 + a2 * l2 + s2 * o2 - n2 * u2 + p2 * x2 + d2 * y2 + f2 * m2 - h22 * g2, t2[6] = s2 * c2 + a2 * u2 + n2 * l2 - i2 * o2 + f2 * x2 + d2 * g2 + h22 * y2 - p2 * m2, t2[7] = a2 * c2 - n2 * o2 - i2 * l2 - s2 * u2 + d2 * x2 - h22 * m2 - p2 * y2 - f2 * g2, t2;
      }
      ic.getReal = oc.copy, ic.setReal = oc.copy, ic.mul = fc;
      var dc = oc.dot;
      ic.dot = dc;
      var mc = oc.length;
      ic.length = mc, ic.len = mc;
      var yc = oc.squaredLength;
      ic.squaredLength = yc, ic.sqrLen = yc;
      var gc = {};
      function xc(t2) {
        return xc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, xc(t2);
      }
      Object.defineProperty(gc, "__esModule", { value: true }), gc.create = _c, gc.clone = function(t2) {
        var e22 = new vc.ARRAY_TYPE(2);
        return e22[0] = t2[0], e22[1] = t2[1], e22;
      }, gc.fromValues = function(t2, e22) {
        var r2 = new vc.ARRAY_TYPE(2);
        return r2[0] = t2, r2[1] = e22, r2;
      }, gc.copy = function(t2, e22) {
        return t2[0] = e22[0], t2[1] = e22[1], t2;
      }, gc.set = function(t2, e22, r2) {
        return t2[0] = e22, t2[1] = r2, t2;
      }, gc.add = function(t2, e22, r2) {
        return t2[0] = e22[0] + r2[0], t2[1] = e22[1] + r2[1], t2;
      }, gc.subtract = wc, gc.multiply = Mc, gc.divide = Ac, gc.ceil = function(t2, e22) {
        return t2[0] = Math.ceil(e22[0]), t2[1] = Math.ceil(e22[1]), t2;
      }, gc.floor = function(t2, e22) {
        return t2[0] = Math.floor(e22[0]), t2[1] = Math.floor(e22[1]), t2;
      }, gc.min = function(t2, e22, r2) {
        return t2[0] = Math.min(e22[0], r2[0]), t2[1] = Math.min(e22[1], r2[1]), t2;
      }, gc.max = function(t2, e22, r2) {
        return t2[0] = Math.max(e22[0], r2[0]), t2[1] = Math.max(e22[1], r2[1]), t2;
      }, gc.round = function(t2, e22) {
        return t2[0] = Math.round(e22[0]), t2[1] = Math.round(e22[1]), t2;
      }, gc.scale = function(t2, e22, r2) {
        return t2[0] = e22[0] * r2, t2[1] = e22[1] * r2, t2;
      }, gc.scaleAndAdd = function(t2, e22, r2, n2) {
        return t2[0] = e22[0] + r2[0] * n2, t2[1] = e22[1] + r2[1] * n2, t2;
      }, gc.distance = Sc, gc.squaredDistance = Ic, gc.length = kc, gc.squaredLength = Tc, gc.negate = function(t2, e22) {
        return t2[0] = -e22[0], t2[1] = -e22[1], t2;
      }, gc.inverse = function(t2, e22) {
        return t2[0] = 1 / e22[0], t2[1] = 1 / e22[1], t2;
      }, gc.normalize = function(t2, e22) {
        var r2 = e22[0], n2 = e22[1], i2 = r2 * r2 + n2 * n2;
        return i2 > 0 && (i2 = 1 / Math.sqrt(i2)), t2[0] = e22[0] * i2, t2[1] = e22[1] * i2, t2;
      }, gc.dot = function(t2, e22) {
        return t2[0] * e22[0] + t2[1] * e22[1];
      }, gc.cross = function(t2, e22, r2) {
        var n2 = e22[0] * r2[1] - e22[1] * r2[0];
        return t2[0] = t2[1] = 0, t2[2] = n2, t2;
      }, gc.lerp = function(t2, e22, r2, n2) {
        var i2 = e22[0], s2 = e22[1];
        return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2;
      }, gc.random = function(t2, e22) {
        e22 = e22 || 1;
        var r2 = 2 * vc.RANDOM() * Math.PI;
        return t2[0] = Math.cos(r2) * e22, t2[1] = Math.sin(r2) * e22, t2;
      }, gc.transformMat2 = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1];
        return t2[0] = r2[0] * n2 + r2[2] * i2, t2[1] = r2[1] * n2 + r2[3] * i2, t2;
      }, gc.transformMat2d = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1];
        return t2[0] = r2[0] * n2 + r2[2] * i2 + r2[4], t2[1] = r2[1] * n2 + r2[3] * i2 + r2[5], t2;
      }, gc.transformMat3 = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1];
        return t2[0] = r2[0] * n2 + r2[3] * i2 + r2[6], t2[1] = r2[1] * n2 + r2[4] * i2 + r2[7], t2;
      }, gc.transformMat4 = function(t2, e22, r2) {
        var n2 = e22[0], i2 = e22[1];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], t2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], t2;
      }, gc.rotate = function(t2, e22, r2, n2) {
        var i2 = e22[0] - r2[0], s2 = e22[1] - r2[1], a2 = Math.sin(n2), o2 = Math.cos(n2);
        return t2[0] = i2 * o2 - s2 * a2 + r2[0], t2[1] = i2 * a2 + s2 * o2 + r2[1], t2;
      }, gc.angle = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = e22[0], s2 = e22[1], a2 = Math.sqrt(r2 * r2 + n2 * n2) * Math.sqrt(i2 * i2 + s2 * s2);
        return Math.acos(Math.min(Math.max(a2 && (r2 * i2 + n2 * s2) / a2, -1), 1));
      }, gc.zero = function(t2) {
        return t2[0] = 0, t2[1] = 0, t2;
      }, gc.str = function(t2) {
        return "vec2(" + t2[0] + ", " + t2[1] + ")";
      }, gc.exactEquals = function(t2, e22) {
        return t2[0] === e22[0] && t2[1] === e22[1];
      }, gc.equals = function(t2, e22) {
        var r2 = t2[0], n2 = t2[1], i2 = e22[0], s2 = e22[1];
        return Math.abs(r2 - i2) <= vc.EPSILON * Math.max(1, Math.abs(r2), Math.abs(i2)) && Math.abs(n2 - s2) <= vc.EPSILON * Math.max(1, Math.abs(n2), Math.abs(s2));
      }, gc.forEach = gc.sqrLen = gc.sqrDist = gc.dist = gc.div = gc.mul = gc.sub = gc.len = void 0;
      var vc = function(t2, e22) {
        if (t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== xc(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = bc(void 0);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }(_l);
      function bc(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (bc = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function _c() {
        var t2 = new vc.ARRAY_TYPE(2);
        return vc.ARRAY_TYPE != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
      }
      function wc(t2, e22, r2) {
        return t2[0] = e22[0] - r2[0], t2[1] = e22[1] - r2[1], t2;
      }
      function Mc(t2, e22, r2) {
        return t2[0] = e22[0] * r2[0], t2[1] = e22[1] * r2[1], t2;
      }
      function Ac(t2, e22, r2) {
        return t2[0] = e22[0] / r2[0], t2[1] = e22[1] / r2[1], t2;
      }
      function Sc(t2, e22) {
        return Math.hypot(e22[0] - t2[0], e22[1] - t2[1]);
      }
      function Ic(t2, e22) {
        var r2 = e22[0] - t2[0], n2 = e22[1] - t2[1];
        return r2 * r2 + n2 * n2;
      }
      function kc(t2) {
        return Math.hypot(t2[0], t2[1]);
      }
      function Tc(t2) {
        var e22 = t2[0], r2 = t2[1];
        return e22 * e22 + r2 * r2;
      }
      gc.len = kc, gc.sub = wc, gc.mul = Mc, gc.div = Ac, gc.dist = Sc, gc.sqrDist = Ic, gc.sqrLen = Tc;
      var Pc = function() {
        var t2 = _c();
        return function(e22, r2, n2, i2, s2, a2) {
          var o2, l2;
          for (r2 || (r2 = 2), n2 || (n2 = 0), l2 = i2 ? Math.min(i2 * r2 + n2, e22.length) : e22.length, o2 = n2; o2 < l2; o2 += r2)
            t2[0] = e22[o2], t2[1] = e22[o2 + 1], s2(t2, t2, a2), e22[o2] = t2[0], e22[o2 + 1] = t2[1];
          return e22;
        };
      }();
      function zc(t2) {
        return zc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        }, zc(t2);
      }
      gc.forEach = Pc, Object.defineProperty(bl, "__esModule", { value: true }), t.e = bl.vec4 = t.v = bl.vec3 = bl.vec2 = bl.quat2 = t.q = bl.quat = t.m = bl.mat4 = t.bx = bl.mat3 = bl.mat2d = t.h = bl.mat2 = bl.glMatrix = void 0;
      var Ec = Nc(_l);
      bl.glMatrix = Ec;
      var Bc = Nc(Il);
      t.h = bl.mat2 = Bc;
      var Dc = Nc(Bl);
      bl.mat2d = Dc;
      var Cc = Nc(Ol);
      t.bx = bl.mat3 = Cc;
      var Rc = Nc(ql);
      t.m = bl.mat4 = Rc;
      var Lc = Nc(eu);
      t.q = bl.quat = Lc;
      var Vc = Nc(ic);
      bl.quat2 = Vc;
      var Oc = Nc(gc);
      bl.vec2 = Oc;
      var Fc = Nc(ru);
      t.v = bl.vec3 = Fc;
      var jc = Nc(gu);
      function Uc(t2) {
        if ("function" != typeof WeakMap)
          return null;
        var e22 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
        return (Uc = function(t3) {
          return t3 ? r2 : e22;
        })(t2);
      }
      function Nc(t2, e22) {
        if (!e22 && t2 && t2.__esModule)
          return t2;
        if (null === t2 || "object" !== zc(t2) && "function" != typeof t2)
          return { default: t2 };
        var r2 = Uc(e22);
        if (r2 && r2.has(t2))
          return r2.get(t2);
        var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var s2 in t2)
          if ("default" !== s2 && Object.prototype.hasOwnProperty.call(t2, s2)) {
            var a2 = i2 ? Object.getOwnPropertyDescriptor(t2, s2) : null;
            a2 && (a2.get || a2.set) ? Object.defineProperty(n2, s2, a2) : n2[s2] = t2[s2];
          }
        return n2.default = t2, r2 && r2.set(t2, n2), n2;
      }
      t.e = bl.vec4 = jc;
      const $c = Ua([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: qc } = $c, Gc = Ua([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var Yc = Ua([{ name: "a_pos", type: "Int16", components: 2 }]), Zc = {};
      !function(t2, e22) {
        !function(t3) {
          function e3(t4, e4, n2) {
            var i2 = r2(256 * t4, 256 * (e4 = Math.pow(2, n2) - e4 - 1), n2), s2 = r2(256 * (t4 + 1), 256 * (e4 + 1), n2);
            return i2[0] + "," + i2[1] + "," + s2[0] + "," + s2[1];
          }
          function r2(t4, e4, r3) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
            return [t4 * n2 - 2 * Math.PI * 6378137 / 2, e4 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          t3.getURL = function(t4, r3, n2, i2, s2, a2) {
            return a2 = a2 || {}, t4 + "?" + ["bbox=" + e3(n2, i2, s2), "format=" + (a2.format || "image/png"), "service=" + (a2.service || "WMS"), "version=" + (a2.version || "1.1.1"), "request=" + (a2.request || "GetMap"), "srs=" + (a2.srs || "EPSG:3857"), "width=" + (a2.width || 256), "height=" + (a2.height || 256), "layers=" + r3].join("&");
          }, t3.getTileBBox = e3, t3.getMercCoords = r2, Object.defineProperty(t3, "__esModule", { value: true });
        }(e22);
      }(0, Zc);
      var Xc = Zc;
      class Kc {
        constructor(t2, e22, r2) {
          this.z = t2, this.x = e22, this.y = r2, this.key = Jc(0, t2, t2, e22, r2);
        }
        equals(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }
        url(t2, e22) {
          const r2 = Xc.getTileBBox(this.x, this.y, this.z), n2 = function(t3, e3, r3) {
            let n3, i2 = "";
            for (let s2 = t3; s2 > 0; s2--)
              n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i2;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e22 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r2);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Wc {
        constructor(t2, e22) {
          this.wrap = t2, this.canonical = e22, this.key = Jc(t2, e22.z, e22.z, e22.x, e22.y);
        }
      }
      class Hc {
        constructor(t2, e22, r2, n2, i2) {
          this.overscaledZ = t2, this.wrap = e22, this.canonical = new Kc(r2, +n2, +i2), this.key = 0 === e22 && t2 === r2 ? this.canonical.key : Jc(e22, t2, r2, n2, i2);
        }
        equals(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }
        scaledTo(t2) {
          const e22 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new Hc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Hc(t2, this.wrap, t2, this.canonical.x >> e22, this.canonical.y >> e22);
        }
        calculateScaledKey(t2, e22 = true) {
          if (this.overscaledZ === t2 && e22)
            return this.key;
          if (t2 > this.canonical.z)
            return Jc(this.wrap * +e22, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r2 = this.canonical.z - t2;
            return Jc(this.wrap * +e22, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
        }
        isChildOf(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          const e22 = this.canonical.z - t2.canonical.z;
          return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.z < this.canonical.z && t2.canonical.x === this.canonical.x >> e22 && t2.canonical.y === this.canonical.y >> e22;
        }
        children(t2) {
          if (this.overscaledZ >= t2)
            return [new Hc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e22 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new Hc(e22, this.wrap, e22, r2, n2), new Hc(e22, this.wrap, e22, r2 + 1, n2), new Hc(e22, this.wrap, e22, r2, n2 + 1), new Hc(e22, this.wrap, e22, r2 + 1, n2 + 1)];
        }
        isLessThan(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }
        wrapped() {
          return new Hc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t2) {
          return new Hc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Wc(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function Jc(t2, e22, r2, n2, i2) {
        const s2 = 1 << Math.min(r2, 22);
        let a2 = s2 * (i2 % s2) + n2 % s2;
        return t2 && r2 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e22 - r2);
      }
      const Qc = [(t2) => {
        let e22 = t2.canonical.x - 1, r2 = t2.wrap;
        return e22 < 0 && (e22 = (1 << t2.canonical.z) - 1, r2--), new Hc(t2.overscaledZ, r2, t2.canonical.z, e22, t2.canonical.y);
      }, (t2) => {
        let e22 = t2.canonical.x + 1, r2 = t2.wrap;
        return e22 === 1 << t2.canonical.z && (e22 = 0, r2++), new Hc(t2.overscaledZ, r2, t2.canonical.z, e22, t2.canonical.y);
      }, (t2) => new Hc(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, (0 === t2.canonical.y ? 1 << t2.canonical.z : t2.canonical.y) - 1), (t2) => new Hc(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, t2.canonical.y === (1 << t2.canonical.z) - 1 ? 0 : t2.canonical.y + 1)];
      Ks(Kc, "CanonicalTileID"), Ks(Hc, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
      class th {
        constructor(t2, e22) {
          this.pos = t2, this.dir = e22;
        }
        intersectsPlane(e22, r2, n2) {
          const i2 = t.v.dot(r2, this.dir);
          if (Math.abs(i2) < 1e-6)
            return false;
          const s2 = ((e22[0] - this.pos[0]) * r2[0] + (e22[1] - this.pos[1]) * r2[1] + (e22[2] - this.pos[2]) * r2[2]) / i2;
          return n2[0] = this.pos[0] + this.dir[0] * s2, n2[1] = this.pos[1] + this.dir[1] * s2, n2[2] = this.pos[2] + this.dir[2] * s2, true;
        }
        closestPointOnSphere(e22, r2, n2) {
          if (t.v.equals(this.pos, e22) || 0 === r2)
            return n2[0] = n2[1] = n2[2] = 0, false;
          const [i2, s2, a2] = this.dir, o2 = this.pos[0] - e22[0], l2 = this.pos[1] - e22[1], u2 = this.pos[2] - e22[2], c2 = i2 * i2 + s2 * s2 + a2 * a2, h22 = 2 * (o2 * i2 + l2 * s2 + u2 * a2), p2 = h22 * h22 - 4 * c2 * (o2 * o2 + l2 * l2 + u2 * u2 - r2 * r2);
          if (p2 < 0) {
            const t2 = Math.max(-h22 / 2, 0), e3 = o2 + i2 * t2, c3 = l2 + s2 * t2, p3 = u2 + a2 * t2, f2 = Math.hypot(e3, c3, p3);
            return n2[0] = e3 * r2 / f2, n2[1] = c3 * r2 / f2, n2[2] = p3 * r2 / f2, false;
          }
          {
            const t2 = (-h22 - Math.sqrt(p2)) / (2 * c2);
            if (t2 < 0) {
              const t3 = Math.hypot(o2, l2, u2);
              return n2[0] = o2 * r2 / t3, n2[1] = l2 * r2 / t3, n2[2] = u2 * r2 / t3, false;
            }
            return n2[0] = o2 + i2 * t2, n2[1] = l2 + s2 * t2, n2[2] = u2 + a2 * t2, true;
          }
        }
      }
      class eh {
        constructor(t2, e22, r2, n2, i2) {
          this.TL = t2, this.TR = e22, this.BR = r2, this.BL = n2, this.horizon = i2;
        }
        static fromInvProjectionMatrix(e22, r2, n2) {
          const i2 = [-1, 1, 1], s2 = [1, 1, 1], a2 = [1, -1, 1], o2 = [-1, -1, 1], l2 = t.v.transformMat4(i2, i2, e22), u2 = t.v.transformMat4(s2, s2, e22), c2 = t.v.transformMat4(a2, a2, e22), h22 = t.v.transformMat4(o2, o2, e22);
          return new eh(l2, u2, c2, h22, r2 / n2);
        }
      }
      function rh(e22, r2, n2) {
        let i2 = 1 / 0, s2 = -1 / 0;
        const a2 = [];
        for (const o2 of e22) {
          t.v.sub(a2, o2, r2);
          const e3 = t.v.dot(a2, n2);
          i2 = Math.min(i2, e3), s2 = Math.max(s2, e3);
        }
        return [i2, s2];
      }
      function nh(e22, r2) {
        let n2 = true;
        for (let i2 = 0; i2 < e22.planes.length; i2++) {
          const s2 = e22.planes[i2];
          let a2 = 0;
          for (let e3 = 0; e3 < r2.length; e3++)
            a2 += t.v.dot(s2, r2[e3]) + s2[3] >= 0;
          if (0 === a2)
            return 0;
          a2 !== r2.length && (n2 = false);
        }
        return n2 ? 2 : 1;
      }
      function ih(t2, e22) {
        for (const r2 of t2.projections) {
          const n2 = rh(e22, t2.points[0], r2.axis);
          if (r2.projection[1] < n2[0] || r2.projection[0] > n2[1])
            return 0;
        }
        return 1;
      }
      function sh(e22, r2) {
        let n2 = 0;
        const i2 = [0, 0, 0, 0];
        for (let s2 = 0; s2 < e22.length; s2++)
          i2[0] = e22[s2][0], i2[1] = e22[s2][1], i2[2] = e22[s2][2], i2[3] = 1, t.e.dot(i2, r2) >= 0 && n2++;
        return n2;
      }
      class ah {
        constructor(e22, r2) {
          this.points = e22 || new Array(8).fill([0, 0, 0]), this.planes = r2 || new Array(6).fill([0, 0, 0, 0]), this.bounds = oh.fromPoints(this.points), this.projections = [], this.frustumEdges = [t.v.sub([], this.points[2], this.points[3]), t.v.sub([], this.points[0], this.points[3]), t.v.sub([], this.points[4], this.points[0]), t.v.sub([], this.points[5], this.points[1]), t.v.sub([], this.points[6], this.points[2]), t.v.sub([], this.points[7], this.points[3])];
          for (const t2 of this.frustumEdges) {
            const e3 = [0, -t2[2], t2[1]], r3 = [t2[2], 0, -t2[0]];
            this.projections.push({ axis: e3, projection: rh(this.points, this.points[0], e3) }), this.projections.push({ axis: r3, projection: rh(this.points, this.points[0], r3) });
          }
        }
        static fromInvProjectionMatrix(e22, r2, n2, i2) {
          const s2 = Math.pow(2, n2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((n3) => {
            const a3 = t.e.transformMat4([], n3, e22), o3 = 1 / a3[3] / r2 * s2;
            return t.e.mul(a3, a3, [o3, o3, i2 ? 1 / a3[3] : o3, o3]);
          }), o2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e3) => {
            const r3 = t.v.sub([], a2[e3[0]], a2[e3[1]]), n3 = t.v.sub([], a2[e3[2]], a2[e3[1]]), i3 = t.v.normalize([], t.v.cross([], r3, n3)), s3 = -t.v.dot(i3, a2[e3[1]]);
            return i3.concat(s3);
          }), l2 = [];
          for (let t2 = 0; t2 < a2.length; t2++)
            l2.push([a2[t2][0], a2[t2][1], a2[t2][2]]);
          return new ah(l2, o2);
        }
        intersectsPrecise(e22, r2, n2) {
          for (let t2 = 0; t2 < r2.length; t2++)
            if (!sh(e22, r2[t2]))
              return 0;
          for (let t2 = 0; t2 < this.planes.length; t2++)
            if (!sh(e22, this.planes[t2]))
              return 0;
          for (const r3 of n2)
            for (const n3 of this.frustumEdges) {
              const i2 = t.v.cross([], r3, n3), s2 = t.v.length(i2);
              if (0 === s2)
                continue;
              t.v.scale(i2, i2, 1 / s2);
              const a2 = rh(this.points, this.points[0], i2), o2 = rh(e22, this.points[0], i2);
              if (a2[0] > o2[1] || o2[0] > a2[1])
                return 0;
            }
          return 1;
        }
      }
      class oh {
        static fromPoints(e22) {
          const r2 = [1 / 0, 1 / 0, 1 / 0], n2 = [-1 / 0, -1 / 0, -1 / 0];
          for (const i2 of e22)
            t.v.min(r2, r2, i2), t.v.max(n2, n2, i2);
          return new oh(r2, n2);
        }
        static fromTileIdAndHeight(t2, e22, r2) {
          const n2 = 1 << t2.canonical.z, i2 = t2.canonical.x, s2 = t2.canonical.y;
          return new oh([i2 / n2, s2 / n2, e22], [(i2 + 1) / n2, (s2 + 1) / n2, r2]);
        }
        static applyTransform(e22, r2) {
          const n2 = e22.getCorners();
          for (let e3 = 0; e3 < n2.length; ++e3)
            t.v.transformMat4(n2[e3], n2[e3], r2);
          return oh.fromPoints(n2);
        }
        static projectAabbCorners(e22, r2) {
          const n2 = e22.getCorners();
          for (let e3 = 0; e3 < n2.length; ++e3)
            t.v.transformMat4(n2[e3], n2[e3], r2);
          return n2;
        }
        constructor(e22, r2) {
          this.min = e22, this.max = r2, this.center = t.v.scale([], t.v.add([], this.min, this.max), 0.5);
        }
        quadrant(e22) {
          const r2 = [e22 % 2 == 0, e22 < 2], n2 = t.v.clone(this.min), i2 = t.v.clone(this.max);
          for (let t2 = 0; t2 < r2.length; t2++)
            n2[t2] = r2[t2] ? this.min[t2] : this.center[t2], i2[t2] = r2[t2] ? this.center[t2] : this.max[t2];
          return i2[2] = this.max[2], new oh(n2, i2);
        }
        distanceX(t2) {
          return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
        }
        distanceY(t2) {
          return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
        }
        distanceZ(t2) {
          return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
        }
        getCorners() {
          const t2 = this.min, e22 = this.max;
          return [[t2[0], t2[1], t2[2]], [e22[0], t2[1], t2[2]], [e22[0], e22[1], t2[2]], [t2[0], e22[1], t2[2]], [t2[0], t2[1], e22[2]], [e22[0], t2[1], e22[2]], [e22[0], e22[1], e22[2]], [t2[0], e22[1], e22[2]]];
        }
        intersects(t2) {
          return this.intersectsAabb(t2.bounds) ? nh(t2, this.getCorners()) : 0;
        }
        intersectsFlat(t2) {
          return this.intersectsAabb(t2.bounds) ? nh(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsPrecise(t2, e22) {
          return e22 || this.intersects(t2) ? ih(t2, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(t2, e22) {
          return e22 || this.intersectsFlat(t2) ? ih(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsAabb(t2) {
          for (let e22 = 0; e22 < 3; ++e22)
            if (this.min[e22] > t2.max[e22] || t2.min[e22] > this.max[e22])
              return false;
          return true;
        }
        intersectsAabbXY(t2) {
          return !(this.min[0] > t2.max[0] || t2.min[0] > this.max[0] || this.min[1] > t2.max[1] || t2.min[1] > this.max[1]);
        }
        encapsulate(t2) {
          for (let e22 = 0; e22 < 3; e22++)
            this.min[e22] = Math.min(this.min[e22], t2.min[e22]), this.max[e22] = Math.max(this.max[e22], t2.max[e22]);
        }
        encapsulatePoint(t2) {
          for (let e22 = 0; e22 < 3; e22++)
            this.min[e22] = Math.min(this.min[e22], t2[e22]), this.max[e22] = Math.max(this.max[e22], t2[e22]);
        }
        closestPoint(t2) {
          return [Math.max(Math.min(this.max[0], t2[0]), this.min[0]), Math.max(Math.min(this.max[1], t2[1]), this.min[1]), Math.max(Math.min(this.max[2], t2[2]), this.min[2])];
        }
      }
      Ks(oh, "Aabb");
      const lh = 5, uh = 6, ch = Cr / Math.PI / 2, hh = 16383, ph = 64, fh = [ph, 32, 16], dh = -ch, mh = ch, yh = [new oh([dh, dh, dh], [mh, mh, mh]), new oh([dh, dh, dh], [0, 0, mh]), new oh([0, dh, dh], [mh, 0, mh]), new oh([dh, 0, dh], [0, mh, mh]), new oh([0, 0, dh], [mh, mh, mh])];
      function gh(t2) {
        return t2 * ch / qh;
      }
      function xh(e22, r2, n2, i2 = true) {
        const s2 = t.v.scale([], e22._camera.position, e22.worldSize), a2 = [r2, n2, 1, 1];
        t.e.transformMat4(a2, a2, e22.pixelMatrixInverse), t.e.scale(a2, a2, 1 / a2[3]);
        const o2 = t.v.sub([], a2, s2), l2 = t.v.normalize([], o2), u2 = e22.globeMatrix, c2 = [u2[12], u2[13], u2[14]], h22 = t.v.sub([], c2, s2), p2 = t.v.length(h22), f2 = t.v.normalize([], h22), d2 = e22.worldSize / (2 * Math.PI), m2 = t.v.dot(f2, l2), y2 = Math.asin(d2 / p2);
        if (y2 < Math.acos(m2)) {
          if (!i2)
            return null;
          const e3 = [], r3 = [];
          t.v.scale(e3, l2, p2 / m2), t.v.normalize(r3, t.v.sub(r3, e3, h22)), t.v.normalize(l2, t.v.add(l2, h22, t.v.scale(l2, r3, Math.tan(y2) * p2)));
        }
        const g2 = [];
        new th(s2, l2).closestPointOnSphere(c2, d2, g2);
        const x2 = t.v.normalize([], J(u2, 0)), v2 = t.v.normalize([], J(u2, 1)), b2 = t.v.normalize([], J(u2, 2)), _2 = t.v.dot(x2, g2), M2 = t.v.dot(v2, g2), A2 = t.v.dot(b2, g2), S2 = w(Math.asin(-M2 / d2));
        let I2 = w(Math.atan2(_2, A2));
        I2 = e22.center.lng + function(t2, e3) {
          const r3 = (e3 - t2 + 180) % 360 - 180;
          return r3 < -180 ? r3 + 360 : r3;
        }(e22.center.lng, I2);
        const T2 = Hh(I2), P2 = k(Jh(S2), 0, 1);
        return new lp(T2, P2);
      }
      class vh {
        constructor(e22, r2, n2) {
          this.a = t.v.sub([], e22, n2), this.b = t.v.sub([], r2, n2), this.center = n2;
          const i2 = t.v.normalize([], this.a), s2 = t.v.normalize([], this.b);
          this.angle = Math.acos(t.v.dot(i2, s2));
        }
      }
      function bh(t2, e22) {
        if (0 === t2.angle)
          return null;
        let r2;
        return r2 = 0 === t2.a[e22] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e22] / t2.a[e22] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n2) {
          const i2 = Math.sin(r3);
          return t3 * (Math.sin((1 - n2) * r3) / i2) + e3 * (Math.sin(n2 * r3) / i2);
        }(t2.a[e22], t2.b[e22], t2.angle, k(r2, 0, 1)) + t2.center[e22];
      }
      function _h(t2) {
        if (t2.z <= 1)
          return yh[t2.z + 2 * t2.y + t2.x];
        const e22 = kh(Ih(t2));
        return oh.fromPoints(e22);
      }
      function wh(e22, r2, n2) {
        return t.v.scale(e22, e22, 1 - n2), t.v.scaleAndAdd(e22, e22, r2, n2);
      }
      function Mh(e22, r2) {
        const n2 = Oh(r2.zoom);
        if (0 === n2)
          return _h(e22);
        const i2 = Ih(e22), s2 = kh(i2), a2 = Hh(i2.getWest()) * r2.worldSize, o2 = Hh(i2.getEast()) * r2.worldSize, l2 = Jh(i2.getNorth()) * r2.worldSize, u2 = Jh(i2.getSouth()) * r2.worldSize, c2 = [a2, l2, 0], h22 = [o2, l2, 0], p2 = [a2, u2, 0], f2 = [o2, u2, 0], d2 = t.m.invert([], r2.globeMatrix);
        return t.v.transformMat4(c2, c2, d2), t.v.transformMat4(h22, h22, d2), t.v.transformMat4(p2, p2, d2), t.v.transformMat4(f2, f2, d2), s2[0] = wh(s2[0], p2, n2), s2[1] = wh(s2[1], f2, n2), s2[2] = wh(s2[2], h22, n2), s2[3] = wh(s2[3], c2, n2), oh.fromPoints(s2);
      }
      function Ah(e22, r2, n2) {
        for (const i2 of e22)
          t.v.transformMat4(i2, i2, r2), t.v.scale(i2, i2, n2);
      }
      function Sh(e22, r2, n2, i2) {
        const s2 = r2 / e22.worldSize, a2 = e22.globeMatrix;
        if (n2.z <= 1) {
          const t2 = _h(n2).getCorners();
          return Ah(t2, a2, s2), oh.fromPoints(t2);
        }
        const o2 = Ih(n2, i2), l2 = kh(o2);
        Ah(l2, a2, s2);
        const u2 = Number.MAX_VALUE, c2 = [-u2, -u2, -u2], h22 = [u2, u2, u2];
        if (o2.contains(e22.center)) {
          for (const e3 of l2)
            t.v.min(h22, h22, e3), t.v.max(c2, c2, e3);
          c2[2] = 0;
          const r3 = e22.point, n3 = [r3.x * s2, r3.y * s2, 0];
          return t.v.min(h22, h22, n3), t.v.max(c2, c2, n3), new oh(h22, c2);
        }
        const p2 = [a2[12] * s2, a2[13] * s2, a2[14] * s2], f2 = o2.getCenter(), d2 = k(e22.center.lat, -np, np), m2 = k(f2.lat, -np, np), y2 = Hh(e22.center.lng), g2 = Jh(d2);
        let x2 = y2 - Hh(f2.lng);
        const v2 = g2 - Jh(m2);
        x2 > 0.5 ? x2 -= 1 : x2 < -0.5 && (x2 += 1);
        let b2 = 0;
        if (Math.abs(x2) > Math.abs(v2))
          b2 = x2 >= 0 ? 1 : 3;
        else {
          b2 = v2 >= 0 ? 0 : 2;
          const e3 = [a2[4] * s2, a2[5] * s2, a2[6] * s2], r3 = -Math.sin(_(v2 >= 0 ? o2.getSouth() : o2.getNorth())) * ch;
          t.v.scaleAndAdd(p2, p2, e3, r3);
        }
        const w2 = l2[b2], M2 = l2[(b2 + 1) % 4], A2 = new vh(w2, M2, p2), S2 = [bh(A2, 0) || w2[0], bh(A2, 1) || w2[1], bh(A2, 2) || w2[2]], I2 = Oh(e22.zoom);
        if (I2 > 0) {
          const i3 = function({ x: t2, y: e3, z: r3 }, n3, i4, s4, a3) {
            const o3 = 1 / (1 << r3);
            let l3 = t2 * o3, u3 = l3 + o3, c3 = e3 * o3, h3 = c3 + o3, p3 = 0;
            const f3 = (l3 + u3) / 2 - s4;
            return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n3 - (s4 *= n3)) * i4 + s4, u3 = ((u3 + p3) * n3 - s4) * i4 + s4, c3 = (c3 * n3 - (a3 *= n3)) * i4 + a3, h3 = (h3 * n3 - a3) * i4 + a3, [[l3, h3, 0], [u3, h3, 0], [u3, c3, 0], [l3, c3, 0]];
          }(n2, r2, e22._pixelsPerMercatorPixel, y2, g2);
          for (let t2 = 0; t2 < l2.length; t2++)
            wh(l2[t2], i3[t2], I2);
          const s3 = t.v.add([], i3[b2], i3[(b2 + 1) % 4]);
          t.v.scale(s3, s3, 0.5), wh(S2, s3, I2);
        }
        for (const e3 of l2)
          t.v.min(h22, h22, e3), t.v.max(c2, c2, e3);
        return h22[2] = Math.min(w2[2], M2[2]), t.v.min(h22, h22, S2), t.v.max(c2, c2, S2), new oh(h22, c2);
      }
      function Ih({ x: t2, y: e22, z: r2 }, n2 = false) {
        const i2 = 1 / (1 << r2), s2 = new Zh(tp(t2 * i2), e22 === (1 << r2) - 1 && n2 ? -90 : ep((e22 + 1) * i2)), a2 = new Zh(tp((t2 + 1) * i2), 0 === e22 && n2 ? 90 : ep(e22 * i2));
        return new vl(s2, a2);
      }
      function kh(t2) {
        const e22 = _(t2.getNorth()), r2 = _(t2.getSouth()), n2 = Math.cos(e22), i2 = Math.cos(r2), s2 = Math.sin(e22), a2 = Math.sin(r2), o2 = t2.getWest(), l2 = t2.getEast();
        return [Th(i2, a2, o2), Th(i2, a2, l2), Th(n2, s2, l2), Th(n2, s2, o2)];
      }
      function Th(t2, e22, r2, n2 = ch) {
        return r2 = _(r2), [t2 * Math.sin(r2) * n2, -e22 * n2, t2 * Math.cos(r2) * n2];
      }
      function Ph(t2, e22, r2) {
        return Th(Math.cos(_(t2)), Math.sin(_(t2)), e22, r2);
      }
      function zh(t2, e22, r2, n2) {
        const i2 = 1 << r2.z, s2 = (t2 / Cr + r2.x) / i2;
        return Ph(ep((e22 / Cr + r2.y) / i2), tp(s2), n2);
      }
      function Eh({ min: t2, max: e22 }) {
        return hh / Math.max(e22[0] - t2[0], e22[1] - t2[1], e22[2] - t2[2]);
      }
      const Bh = new Float64Array(16);
      function Dh(e22) {
        const r2 = Eh(e22), n2 = t.m.fromScaling(Bh, [r2, r2, r2]);
        return t.m.translate(n2, n2, t.v.negate([], e22.min));
      }
      function Ch(e22) {
        const r2 = t.m.fromTranslation(Bh, e22.min), n2 = 1 / Eh(e22);
        return t.m.scale(r2, r2, [n2, n2, n2]);
      }
      function Rh(t2) {
        const e22 = Cr / (2 * Math.PI);
        return t2 / (2 * Math.PI) / e22;
      }
      function Lh(t2, e22) {
        return Cr / (512 * Math.pow(2, t2)) * Eh(_h(e22));
      }
      function Vh(e22, r2, n2, i2, s2) {
        const a2 = Rh(n2), o2 = [e22, r2, -n2 / (2 * Math.PI)], l2 = t.m.identity(new Float64Array(16));
        return t.m.translate(l2, l2, o2), t.m.scale(l2, l2, [a2, a2, a2]), t.m.rotateX(l2, l2, _(-s2)), t.m.rotateY(l2, l2, _(-i2)), l2;
      }
      function Oh(t2) {
        return T(lh, uh, t2);
      }
      function Fh(e22, r2) {
        const n2 = Ph(r2.lat, r2.lng), i2 = function(e3) {
          const r3 = Ph(e3._center.lat, e3._center.lng), n3 = t.v.fromValues(0, 1, 0);
          let i3 = t.v.cross([], n3, r3);
          const s3 = t.m.fromRotation([], -e3.angle, r3);
          i3 = t.v.transformMat4(i3, i3, s3), t.m.fromRotation(s3, -e3._pitch, i3);
          const a2 = t.v.normalize([], r3);
          return t.v.scale(a2, a2, gh(e3.cameraToCenterDistance / e3.pixelsPerMeter)), t.v.transformMat4(a2, a2, s3), t.v.add([], r3, a2);
        }(e22), s2 = t.v.subtract([], i2, n2);
        return t.v.angle(s2, n2);
      }
      function jh(t2, e22) {
        return Fh(t2, e22) > Math.PI / 2 * 1.01;
      }
      const Uh = _(85), Nh = Math.cos(Uh), $h = Math.sin(Uh), qh = 63710088e-1, Gh = 2 * Math.PI * qh;
      class Yh {
        constructor(t2, e22) {
          if (isNaN(t2) || isNaN(e22))
            throw new Error(`Invalid LngLat object: (${t2}, ${e22})`);
          if (this.lng = +t2, this.lat = +e22, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Yh(P(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t2) {
          const e22 = Math.PI / 180, r2 = this.lat * e22, n2 = t2.lat * e22, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e22);
          return qh * Math.acos(Math.min(i2, 1));
        }
        toBounds(t2 = 0) {
          const e22 = 360 * t2 / 40075017, r2 = e22 / Math.cos(Math.PI / 180 * this.lat);
          return new vl(new Yh(this.lng - r2, this.lat - e22), new Yh(this.lng + r2, this.lat + e22));
        }
        toEcef(t2) {
          const e22 = gh(t2);
          return Ph(this.lat, this.lng, ch + e22);
        }
        static convert(t2) {
          if (t2 instanceof Yh)
            return t2;
          if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
            return new Yh(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
            return new Yh(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      var Zh = Yh;
      const Xh = 0, Kh = 25.5;
      function Wh(t2) {
        return Gh * Math.cos(t2 * Math.PI / 180);
      }
      function Hh(t2) {
        return (180 + t2) / 360;
      }
      function Jh(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function Qh(t2, e22) {
        return t2 / Wh(e22);
      }
      function tp(t2) {
        return 360 * t2 - 180;
      }
      function ep(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }
      function rp(t2, e22) {
        return t2 * Wh(ep(e22));
      }
      const np = 85.051129;
      function ip(t2) {
        return Math.cos(_(k(t2, -np, np)));
      }
      function sp(t2, e22) {
        const r2 = k(e22, Xh, Kh), n2 = Math.pow(2, r2);
        return ip(t2) * Gh / (512 * n2);
      }
      function ap(t2) {
        return 1 / Math.cos(t2 * Math.PI / 180);
      }
      function op(t2, e22 = 0) {
        const r2 = Math.exp(Math.PI * (1 - (t2.y + e22 / Cr) / (1 << t2.z) * 2));
        return 80150034 * r2 / (r2 * r2 + 1) / Cr / (1 << t2.z);
      }
      class lp {
        constructor(t2, e22, r2 = 0) {
          this.x = +t2, this.y = +e22, this.z = +r2;
        }
        static fromLngLat(t2, e22 = 0) {
          const r2 = Zh.convert(t2);
          return new lp(Hh(r2.lng), Jh(r2.lat), Qh(e22, r2.lat));
        }
        toLngLat() {
          return new Zh(tp(this.x), ep(this.y));
        }
        toAltitude() {
          return rp(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Gh * ap(ep(this.y));
        }
      }
      function up(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = (e22 + n2) / 2, c2 = (r2 + i2) / 2, h22 = new x(u2, c2);
        o2(h22), function(t3, e3, r3, n3, i3, s3) {
          const a3 = r3 - i3, o3 = n3 - s3;
          return Math.abs((n3 - e3) * a3 - (r3 - t3) * o3) / Math.hypot(a3, o3);
        }(h22.x, h22.y, s2.x, s2.y, a2.x, a2.y) >= l2 ? (up(t2, e22, r2, u2, c2, s2, h22, o2, l2), up(t2, u2, c2, n2, i2, h22, a2, o2, l2)) : t2.push(a2);
      }
      function cp(t2, e22, r2) {
        let n2 = t2[0], i2 = n2.x, s2 = n2.y;
        e22(n2);
        const a2 = [n2];
        for (let o2 = 1; o2 < t2.length; o2++) {
          const l2 = t2[o2], { x: u2, y: c2 } = l2;
          e22(l2), up(a2, i2, s2, u2, c2, n2, l2, e22, r2), i2 = u2, s2 = c2, n2 = l2;
        }
        return a2;
      }
      function hp(t2, e22, r2, n2) {
        if (n2(e22, r2)) {
          const i2 = e22.add(r2)._mult(0.5);
          hp(t2, e22, i2, n2), hp(t2, i2, r2, n2);
        } else
          t2.push(r2);
      }
      function pp(t2, e22) {
        let r2 = t2[0];
        const n2 = [r2];
        for (let i2 = 1; i2 < t2.length; i2++) {
          const s2 = t2[i2];
          hp(n2, r2, s2, e22), r2 = s2;
        }
        return n2;
      }
      const fp = Math.pow(2, 14) - 1, dp = -fp - 1;
      function mp(t2, e22) {
        const r2 = Math.round(t2.x * e22), n2 = Math.round(t2.y * e22);
        return t2.x = k(r2, dp, fp), t2.y = k(n2, dp, fp), (r2 < t2.x || r2 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && q("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
      }
      function yp(t2, e22, r2) {
        const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = Cr / i2;
        if (e22 && r2 && r2.projection.isReprojectedInTileSpace) {
          const s3 = 1 << e22.z, { scale: a2, x: o2, y: l2, projection: u2 } = r2, c2 = (t3) => {
            const r3 = tp((e22.x + t3.x / i2) / s3), n3 = ep((e22.y + t3.y / i2) / s3), c3 = u2.project(r3, n3);
            t3.x = (c3.x * a2 - o2) * i2, t3.y = (c3.y * a2 - l2) * i2;
          };
          for (let e3 = 0; e3 < n2.length; e3++)
            if (1 !== t2.type)
              n2[e3] = cp(n2[e3], c2, 1);
            else {
              const t3 = [];
              for (const r3 of n2[e3])
                r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c2(r3), t3.push(r3));
              n2[e3] = t3;
            }
        }
        for (const t3 of n2)
          for (const e3 of t3)
            mp(e3, s2);
        return n2;
      }
      function gp(t2, e22) {
        return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e22 ? yp(t2) : [] };
      }
      function xp(t2, e22, r2, n2, i2) {
        t2.emplaceBack(2 * e22 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
      }
      function vp(t2, e22, r2) {
        const n2 = 16384;
        t2.emplaceBack(e22.x, e22.y, e22.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
      }
      class bp {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new $a(), this.indexArray = new ao(), this.segments = new Do(), this.programConfigurations = new fl(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e22, r2, n2) {
          const i2 = this.layers[0], s2 = [];
          let a2 = null;
          "circle" === i2.type && (a2 = i2.layout.get("circle-sort-key"));
          for (const { feature: e3, id: i3, index: o3, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = gp(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new _a2(this.zoom), u2, r2))
              continue;
            const c2 = a2 ? a2.evaluate(u2, {}, r2) : void 0, h22 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o3, geometry: t3 ? u2.geometry : yp(e3, r2, n2), patterns: {}, sortKey: c2 };
            s2.push(h22);
          }
          a2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          let o2 = null;
          "globe" === n2.projection.name && (this.globeExtVertexArray = new Ha(), o2 = n2.projection);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, l2 = t2[s3].feature;
            this.addFeature(n3, i3, s3, e22.availableImages, r2, o2, e22.brightness), e22.featureIndex.insert(l2, i3, s3, a3, this.index);
          }
        }
        update(t2, e22, r2, n2, i2) {
          const s2 = 0 !== Object.keys(t2).length;
          s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t2, e22, s2 ? this.stateDependentLayers : this.layers, r2, n2, i2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Eo.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Bo.members))), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(t2, e22, r2, n2, i2, s2, a2) {
          for (const r3 of e22)
            for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= Cr || n3 < 0 || n3 >= Cr)
                continue;
              if (s2) {
                const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3), a4 = this.globeExtVertexArray;
                vp(a4, t3, e4), vp(a4, t3, e4), vp(a4, t3, e4), vp(a4, t3, e4);
              }
              const a3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = a3.vertexLength;
              xp(this.layoutVertexArray, r4, n3, -1, -1), xp(this.layoutVertexArray, r4, n3, 1, -1), xp(this.layoutVertexArray, r4, n3, 1, 1), xp(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(o2, o2 + 1, o2 + 2), this.indexArray.emplaceBack(o2, o2 + 2, o2 + 3), a3.vertexLength += 4, a3.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2, i2, a2);
        }
      }
      function _p(t2, e22) {
        for (let r2 = 0; r2 < t2.length; r2++)
          if (zp(e22, t2[r2]))
            return true;
        for (let r2 = 0; r2 < e22.length; r2++)
          if (zp(t2, e22[r2]))
            return true;
        return !!Sp(t2, e22);
      }
      function wp(t2, e22, r2) {
        return !!zp(t2, e22) || !!kp(e22, t2, r2);
      }
      function Mp(t2, e22) {
        if (1 === t2.length)
          return Pp(e22, t2[0]);
        for (let r2 = 0; r2 < e22.length; r2++) {
          const n2 = e22[r2];
          for (let e3 = 0; e3 < n2.length; e3++)
            if (zp(t2, n2[e3]))
              return true;
        }
        for (let r2 = 0; r2 < t2.length; r2++)
          if (Pp(e22, t2[r2]))
            return true;
        for (let r2 = 0; r2 < e22.length; r2++)
          if (Sp(t2, e22[r2]))
            return true;
        return false;
      }
      function Ap(t2, e22, r2) {
        if (t2.length > 1) {
          if (Sp(t2, e22))
            return true;
          for (let n2 = 0; n2 < e22.length; n2++)
            if (kp(e22[n2], t2, r2))
              return true;
        }
        for (let n2 = 0; n2 < t2.length; n2++)
          if (kp(t2[n2], e22, r2))
            return true;
        return false;
      }
      function Sp(t2, e22) {
        if (0 === t2.length || 0 === e22.length)
          return false;
        for (let r2 = 0; r2 < t2.length - 1; r2++) {
          const n2 = t2[r2], i2 = t2[r2 + 1];
          for (let t3 = 0; t3 < e22.length - 1; t3++)
            if (Ip(n2, i2, e22[t3], e22[t3 + 1]))
              return true;
        }
        return false;
      }
      function Ip(t2, e22, r2, n2) {
        return G(t2, r2, n2) !== G(e22, r2, n2) && G(t2, e22, r2) !== G(t2, e22, n2);
      }
      function kp(t2, e22, r2) {
        const n2 = r2 * r2;
        if (1 === e22.length)
          return t2.distSqr(e22[0]) < n2;
        for (let r3 = 1; r3 < e22.length; r3++)
          if (Tp(t2, e22[r3 - 1], e22[r3]) < n2)
            return true;
        return false;
      }
      function Tp(t2, e22, r2) {
        const n2 = e22.distSqr(r2);
        if (0 === n2)
          return t2.distSqr(e22);
        const i2 = ((t2.x - e22.x) * (r2.x - e22.x) + (t2.y - e22.y) * (r2.y - e22.y)) / n2;
        return t2.distSqr(i2 < 0 ? e22 : i2 > 1 ? r2 : r2.sub(e22)._mult(i2)._add(e22));
      }
      function Pp(t2, e22) {
        let r2, n2, i2, s2 = false;
        for (let a2 = 0; a2 < t2.length; a2++) {
          r2 = t2[a2];
          for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
            n2 = r2[t3], i2 = r2[a3], n2.y > e22.y != i2.y > e22.y && e22.x < (i2.x - n2.x) * (e22.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
        }
        return s2;
      }
      function zp(t2, e22) {
        let r2 = false;
        for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
          const s2 = t2[n2], a2 = t2[i2];
          s2.y > e22.y != a2.y > e22.y && e22.x < (a2.x - s2.x) * (e22.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
        }
        return r2;
      }
      function Ep(t2, e22, r2, n2, i2) {
        for (const s3 of t2)
          if (e22 <= s3.x && r2 <= s3.y && n2 >= s3.x && i2 >= s3.y)
            return true;
        const s2 = [new x(e22, r2), new x(e22, i2), new x(n2, i2), new x(n2, r2)];
        if (t2.length > 2) {
          for (const e3 of s2)
            if (zp(t2, e3))
              return true;
        }
        for (let e3 = 0; e3 < t2.length - 1; e3++)
          if (Bp(t2[e3], t2[e3 + 1], s2))
            return true;
        return false;
      }
      function Bp(t2, e22, r2) {
        const n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e22.x < n2.x || t2.x > i2.x && e22.x > i2.x || t2.y < n2.y && e22.y < n2.y || t2.y > i2.y && e22.y > i2.y)
          return false;
        const s2 = G(t2, e22, r2[0]);
        return s2 !== G(t2, e22, r2[1]) || s2 !== G(t2, e22, r2[2]) || s2 !== G(t2, e22, r2[3]);
      }
      function Dp(t2, e22, r2, n2, i2, s2) {
        let a2 = e22.y - t2.y, o2 = t2.x - e22.x;
        if (s2 = s2 || 0) {
          const t3 = a2 * a2 + o2 * o2;
          if (0 === t3)
            return true;
          const e3 = Math.sqrt(t3);
          a2 /= e3, o2 /= e3;
        }
        return !((r2.x - t2.x) * a2 + (r2.y - t2.y) * o2 - s2 < 0 || (n2.x - t2.x) * a2 + (n2.y - t2.y) * o2 - s2 < 0 || (i2.x - t2.x) * a2 + (i2.y - t2.y) * o2 - s2 < 0);
      }
      function Cp(t2, e22, r2, n2, i2, s2, a2) {
        return !(Dp(t2, e22, n2, i2, s2, a2) || Dp(e22, r2, n2, i2, s2, a2) || Dp(r2, t2, n2, i2, s2, a2) || Dp(n2, i2, t2, e22, r2, a2) || Dp(i2, s2, t2, e22, r2, a2) || Dp(s2, n2, t2, e22, r2, a2));
      }
      function Rp(t2, e22, r2) {
        const n2 = e22.paint.get(t2).value;
        return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e22.id).getMaxValue(t2);
      }
      function Lp(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function Vp(t2, e22, r2, n2, i2) {
        if (!e22[0] && !e22[1])
          return t2;
        const s2 = x.convert(e22)._mult(i2);
        "viewport" === r2 && s2._rotate(-n2);
        const a2 = [];
        for (let e3 = 0; e3 < t2.length; e3++)
          a2.push(t2[e3].sub(s2));
        return a2;
      }
      function Op(t2, e22, r2, n2) {
        const i2 = x.convert(t2)._mult(n2);
        return "viewport" === e22 && i2._rotate(-r2), i2;
      }
      Ks(bp, "CircleBucket", { omit: ["layers"] });
      const Fp = new Da({ "circle-sort-key": new Ea(re2.layout_circle["circle-sort-key"]), visibility: new za(re2.layout_circle.visibility) });
      var jp = { paint: new Da({ "circle-radius": new Ea(re2.paint_circle["circle-radius"]), "circle-color": new Ea(re2.paint_circle["circle-color"]), "circle-blur": new Ea(re2.paint_circle["circle-blur"]), "circle-opacity": new Ea(re2.paint_circle["circle-opacity"]), "circle-translate": new za(re2.paint_circle["circle-translate"]), "circle-translate-anchor": new za(re2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new za(re2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new za(re2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ea(re2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ea(re2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ea(re2.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new za(re2.paint_circle["circle-emissive-strength"]) }), layout: Fp };
      const Up = t.m.create(), Np = (t2) => {
        const e22 = [];
        return "map" === t2.paint.get("circle-pitch-alignment") && e22.push("PITCH_WITH_MAP"), "map" === t2.paint.get("circle-pitch-scale") && e22.push("SCALE_WITH_MAP"), e22;
      };
      function $p(e22, r2, n2, i2, s2, a2, o2, l2, u2) {
        if (a2 && e22.queryGeometry.isAboveHorizon)
          return false;
        a2 && (u2 *= e22.pixelToTileUnitsFactor);
        const c2 = e22.tileID.canonical, h22 = n2.projection.upVectorScale(c2, n2.center.lat, n2.worldSize).metersToTile;
        for (const p2 of r2)
          for (const r3 of p2) {
            const p3 = r3.add(l2), f2 = s2 && n2.elevation ? n2.elevation.exaggeration() * s2.getElevationAt(p3.x, p3.y, true) : 0, d2 = n2.projection.projectTilePoint(p3.x, p3.y, c2);
            if (f2 > 0) {
              const t2 = n2.projection.upVector(c2, p3.x, p3.y);
              d2.x += t2[0] * h22 * f2, d2.y += t2[1] * h22 * f2, d2.z += t2[2] * h22 * f2;
            }
            const m2 = a2 ? p3 : qp(d2.x, d2.y, d2.z, i2), y2 = a2 ? e22.tilespaceRays.map((t2) => Zp(t2, f2)) : e22.queryGeometry.screenGeometry, g2 = t.e.transformMat4([], [d2.x, d2.y, d2.z, 1], i2);
            if (!o2 && a2 ? u2 *= g2[3] / n2.cameraToCenterDistance : o2 && !a2 && (u2 *= n2.cameraToCenterDistance / g2[3]), a2) {
              const t2 = ep((r3.y / Cr + c2.y) / (1 << c2.z));
              u2 /= n2.projection.pixelsPerMeter(t2, 1) / Qh(1, t2);
            }
            if (wp(y2, m2, u2))
              return true;
          }
        return false;
      }
      function qp(e22, r2, n2, i2) {
        const s2 = t.e.transformMat4([], [e22, r2, n2, 1], i2);
        return new x(s2[0] / s2[3], s2[1] / s2[3]);
      }
      const Gp = t.v.fromValues(0, 0, 0), Yp = t.v.fromValues(0, 0, 1);
      function Zp(e22, r2) {
        const n2 = t.v.create();
        return Gp[2] = r2, e22.intersectsPlane(Gp, Yp, n2), new x(n2[0], n2[1]);
      }
      class Xp extends bp {
      }
      function Kp(t2, { width: e22, height: r2 }, n2, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e22 * r2 * n2)
            throw new RangeError("mismatched image size");
        } else
          i2 = new Uint8Array(e22 * r2 * n2);
        return t2.width = e22, t2.height = r2, t2.data = i2, t2;
      }
      function Wp(t2, e22, r2) {
        const { width: n2, height: i2 } = e22;
        n2 === t2.width && i2 === t2.height || (Hp(t2, e22, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2), t2.width = n2, t2.height = i2, t2.data = e22.data);
      }
      function Hp(t2, e22, r2, n2, i2, s2, a2) {
        if (0 === i2.width || 0 === i2.height)
          return e22;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e22.width || i2.height > e22.height || n2.x > e22.width - i2.width || n2.y > e22.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const o2 = t2.data, l2 = e22.data, u2 = 4 === s2 && a2;
        for (let a3 = 0; a3 < i2.height; a3++) {
          const c2 = ((r2.y + a3) * t2.width + r2.x) * s2, h22 = ((n2.y + a3) * e22.width + n2.x) * s2;
          if (u2)
            for (let t3 = 0; t3 < i2.width; t3++) {
              const e3 = c2 + t3 * s2 + 3, r3 = h22 + t3 * s2;
              l2[r3 + 0] = 255, l2[r3 + 1] = 255, l2[r3 + 2] = 255, l2[r3 + 3] = o2[e3];
            }
          else
            for (let t3 = 0; t3 < i2.width * s2; t3++)
              l2[h22 + t3] = o2[c2 + t3];
        }
        return e22;
      }
      Ks(Xp, "HeatmapBucket", { omit: ["layers"] });
      class Jp {
        constructor(t2, e22) {
          Kp(this, t2, 1, e22);
        }
        resize(t2) {
          Wp(this, new Jp(t2), 1);
        }
        clone() {
          return new Jp({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e22, r2, n2, i2) {
          Hp(t2, e22, r2, n2, i2, 1);
        }
      }
      class Qp {
        constructor(t2, e22) {
          Kp(this, t2, 4, e22);
        }
        resize(t2) {
          Wp(this, new Qp(t2), 4);
        }
        replace(t2, e22) {
          e22 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
        }
        clone() {
          return new Qp({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e22, r2, n2, i2, s2) {
          Hp(t2, e22, r2, n2, i2, 4, s2);
        }
      }
      class tf {
        constructor(t2, e22) {
          this.width = t2.width, this.height = t2.height, this.data = e22 instanceof Uint8Array ? new Float32Array(e22.buffer) : e22;
        }
      }
      Ks(Jp, "AlphaImage"), Ks(Qp, "RGBAImage");
      const ef = new Da({ visibility: new za(re2.layout_heatmap.visibility) });
      var rf = { paint: new Da({ "heatmap-radius": new Ea(re2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ea(re2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new za(re2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ba(re2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new za(re2.paint_heatmap["heatmap-opacity"]) }), layout: ef };
      function nf(t2) {
        const e22 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Qp({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
          e22[t2.evaluationKey] = s3;
          const a2 = t2.expression.evaluate(e22);
          a2 && (i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a));
        };
        if (t2.clips)
          for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
            for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
              s2(i3, a2, l2 * (1 - o2) + u2 * o2);
            }
        else
          for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
            s2(0, e3, t3 / (r2 - 1));
        return i2;
      }
      const sf = new Da({ visibility: new za(re2.layout_hillshade.visibility) });
      var af = { paint: new Da({ "hillshade-illumination-direction": new za(re2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new za(re2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new za(re2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new za(re2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new za(re2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new za(re2.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new za(re2.paint_hillshade["hillshade-emissive-strength"]) }), layout: sf };
      const of = Ua([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: lf } = of;
      var uf = { exports: {} };
      function cf(t2, e22, r2) {
        r2 = r2 || 2;
        var n2, i2, s2, a2, o2, l2, u2, c2 = e22 && e22.length, h22 = c2 ? e22[0] * r2 : t2.length, p2 = hf(t2, 0, h22, r2, true), f2 = [];
        if (!p2 || p2.next === p2.prev)
          return f2;
        if (c2 && (p2 = function(t3, e3, r3, n3) {
          var i3, s3, a3, o3 = [];
          for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
            (a3 = hf(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(wf(a3));
          for (o3.sort(xf), i3 = 0; i3 < o3.length; i3++)
            r3 = vf(o3[i3], r3);
          return r3;
        }(t2, e22, p2, r2)), t2.length > 80 * r2) {
          n2 = s2 = t2[0], i2 = a2 = t2[1];
          for (var d2 = r2; d2 < h22; d2 += r2)
            (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
          u2 = 0 !== (u2 = Math.max(s2 - n2, a2 - i2)) ? 32767 / u2 : 0;
        }
        return ff(p2, f2, r2, n2, i2, u2, 0), f2;
      }
      function hf(t2, e22, r2, n2, i2) {
        var s2, a2;
        if (i2 === Rf(t2, e22, r2, n2) > 0)
          for (s2 = e22; s2 < r2; s2 += n2)
            a2 = Bf(s2, t2[s2], t2[s2 + 1], a2);
        else
          for (s2 = r2 - n2; s2 >= e22; s2 -= n2)
            a2 = Bf(s2, t2[s2], t2[s2 + 1], a2);
        return a2 && If(a2, a2.next) && (Df(a2), a2 = a2.next), a2;
      }
      function pf(t2, e22) {
        if (!t2)
          return t2;
        e22 || (e22 = t2);
        var r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !If(n2, n2.next) && 0 !== Sf(n2.prev, n2, n2.next))
            n2 = n2.next;
          else {
            if (Df(n2), (n2 = e22 = n2.prev) === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e22);
        return e22;
      }
      function ff(t2, e22, r2, n2, i2, s2, a2) {
        if (t2) {
          !a2 && s2 && function(t3, e3, r3, n3) {
            var i3 = t3;
            do {
              0 === i3.z && (i3.z = _f(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
              var e4, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
              do {
                for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                  for (a3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                    ;
                  for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                    0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                  r4 = n4;
                }
                s3.nextZ = null, u3 *= 2;
              } while (a3 > 1);
            }(i3);
          }(t2, n2, i2, s2);
          for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
            if (o2 = t2.prev, l2 = t2.next, s2 ? mf(t2, n2, i2, s2) : df(t2))
              e22.push(o2.i / r2 | 0), e22.push(t2.i / r2 | 0), e22.push(l2.i / r2 | 0), Df(t2), t2 = l2.next, u2 = l2.next;
            else if ((t2 = l2) === u2) {
              a2 ? 1 === a2 ? ff(t2 = yf(pf(t2), e22, r2), e22, r2, n2, i2, s2, 2) : 2 === a2 && gf(t2, e22, r2, n2, i2, s2) : ff(pf(t2), e22, r2, n2, i2, s2, 1);
              break;
            }
        }
      }
      function df(t2) {
        var e22 = t2.prev, r2 = t2, n2 = t2.next;
        if (Sf(e22, r2, n2) >= 0)
          return false;
        for (var i2 = e22.x, s2 = r2.x, a2 = n2.x, o2 = e22.y, l2 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h22 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e22; ) {
          if (d2.x >= c2 && d2.x <= p2 && d2.y >= h22 && d2.y <= f2 && Mf(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && Sf(d2.prev, d2, d2.next) >= 0)
            return false;
          d2 = d2.next;
        }
        return true;
      }
      function mf(t2, e22, r2, n2) {
        var i2 = t2.prev, s2 = t2, a2 = t2.next;
        if (Sf(i2, s2, a2) >= 0)
          return false;
        for (var o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h22 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h22 ? c2 < p2 ? c2 : p2 : h22 < p2 ? h22 : p2, m2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, y2 = c2 > h22 ? c2 > p2 ? c2 : p2 : h22 > p2 ? h22 : p2, g2 = _f(f2, d2, e22, r2, n2), x2 = _f(m2, y2, e22, r2, n2), v2 = t2.prevZ, b2 = t2.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
          if (v2.x >= f2 && v2.x <= m2 && v2.y >= d2 && v2.y <= y2 && v2 !== i2 && v2 !== a2 && Mf(o2, c2, l2, h22, u2, p2, v2.x, v2.y) && Sf(v2.prev, v2, v2.next) >= 0)
            return false;
          if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y2 && b2 !== i2 && b2 !== a2 && Mf(o2, c2, l2, h22, u2, p2, b2.x, b2.y) && Sf(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        for (; v2 && v2.z >= g2; ) {
          if (v2.x >= f2 && v2.x <= m2 && v2.y >= d2 && v2.y <= y2 && v2 !== i2 && v2 !== a2 && Mf(o2, c2, l2, h22, u2, p2, v2.x, v2.y) && Sf(v2.prev, v2, v2.next) >= 0)
            return false;
          v2 = v2.prevZ;
        }
        for (; b2 && b2.z <= x2; ) {
          if (b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y2 && b2 !== i2 && b2 !== a2 && Mf(o2, c2, l2, h22, u2, p2, b2.x, b2.y) && Sf(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        return true;
      }
      function yf(t2, e22, r2) {
        var n2 = t2;
        do {
          var i2 = n2.prev, s2 = n2.next.next;
          !If(i2, s2) && kf(i2, n2, n2.next, s2) && zf(i2, s2) && zf(s2, i2) && (e22.push(i2.i / r2 | 0), e22.push(n2.i / r2 | 0), e22.push(s2.i / r2 | 0), Df(n2), Df(n2.next), n2 = t2 = s2), n2 = n2.next;
        } while (n2 !== t2);
        return pf(n2);
      }
      function gf(t2, e22, r2, n2, i2, s2) {
        var a2 = t2;
        do {
          for (var o2 = a2.next.next; o2 !== a2.prev; ) {
            if (a2.i !== o2.i && Af(a2, o2)) {
              var l2 = Ef(a2, o2);
              return a2 = pf(a2, a2.next), l2 = pf(l2, l2.next), ff(a2, e22, r2, n2, i2, s2, 0), void ff(l2, e22, r2, n2, i2, s2, 0);
            }
            o2 = o2.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function xf(t2, e22) {
        return t2.x - e22.x;
      }
      function vf(t2, e22) {
        var r2 = function(t3, e3) {
          var r3, n3 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
          do {
            if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
              var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
              if (o2 <= i2 && o2 > a2 && (a2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2))
                return r3;
            }
            n3 = n3.next;
          } while (n3 !== e3);
          if (!r3)
            return null;
          var l2, u2 = r3, c2 = r3.x, h22 = r3.y, p2 = 1 / 0;
          n3 = r3;
          do {
            i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && Mf(s2 < h22 ? i2 : a2, s2, c2, h22, s2 < h22 ? a2 : i2, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (i2 - n3.x), zf(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && bf(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
          } while (n3 !== u2);
          return r3;
        }(t2, e22);
        if (!r2)
          return e22;
        var n2 = Ef(r2, t2);
        return pf(n2, n2.next), pf(r2, r2.next);
      }
      function bf(t2, e22) {
        return Sf(t2.prev, t2, e22.prev) < 0 && Sf(e22.next, t2, t2.next) < 0;
      }
      function _f(t2, e22, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e22 = 1431655765 & ((e22 = 858993459 & ((e22 = 252645135 & ((e22 = 16711935 & ((e22 = (e22 - n2) * i2 | 0) | e22 << 8)) | e22 << 4)) | e22 << 2)) | e22 << 1)) << 1;
      }
      function wf(t2) {
        var e22 = t2, r2 = t2;
        do {
          (e22.x < r2.x || e22.x === r2.x && e22.y < r2.y) && (r2 = e22), e22 = e22.next;
        } while (e22 !== t2);
        return r2;
      }
      function Mf(t2, e22, r2, n2, i2, s2, a2, o2) {
        return (i2 - a2) * (e22 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e22 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
      }
      function Af(t2, e22) {
        return t2.next.i !== e22.i && t2.prev.i !== e22.i && !function(t3, e3) {
          var r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && kf(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e22) && (zf(t2, e22) && zf(e22, t2) && function(t3, e3) {
          var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e22) && (Sf(t2.prev, t2, e22.prev) || Sf(t2, e22.prev, e22)) || If(t2, e22) && Sf(t2.prev, t2, t2.next) > 0 && Sf(e22.prev, e22, e22.next) > 0);
      }
      function Sf(t2, e22, r2) {
        return (e22.y - t2.y) * (r2.x - e22.x) - (e22.x - t2.x) * (r2.y - e22.y);
      }
      function If(t2, e22) {
        return t2.x === e22.x && t2.y === e22.y;
      }
      function kf(t2, e22, r2, n2) {
        var i2 = Pf(Sf(t2, e22, r2)), s2 = Pf(Sf(t2, e22, n2)), a2 = Pf(Sf(r2, n2, t2)), o2 = Pf(Sf(r2, n2, e22));
        return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Tf(t2, r2, e22)) || !(0 !== s2 || !Tf(t2, n2, e22)) || !(0 !== a2 || !Tf(r2, t2, n2)) || !(0 !== o2 || !Tf(r2, e22, n2));
      }
      function Tf(t2, e22, r2) {
        return e22.x <= Math.max(t2.x, r2.x) && e22.x >= Math.min(t2.x, r2.x) && e22.y <= Math.max(t2.y, r2.y) && e22.y >= Math.min(t2.y, r2.y);
      }
      function Pf(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function zf(t2, e22) {
        return Sf(t2.prev, t2, t2.next) < 0 ? Sf(t2, e22, t2.next) >= 0 && Sf(t2, t2.prev, e22) >= 0 : Sf(t2, e22, t2.prev) < 0 || Sf(t2, t2.next, e22) < 0;
      }
      function Ef(t2, e22) {
        var r2 = new Cf(t2.i, t2.x, t2.y), n2 = new Cf(e22.i, e22.x, e22.y), i2 = t2.next, s2 = e22.prev;
        return t2.next = e22, e22.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function Bf(t2, e22, r2, n2) {
        var i2 = new Cf(t2, e22, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function Df(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function Cf(t2, e22, r2) {
        this.i = t2, this.x = e22, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function Rf(t2, e22, r2, n2) {
        for (var i2 = 0, s2 = e22, a2 = r2 - n2; s2 < r2; s2 += n2)
          i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
        return i2;
      }
      uf.exports = cf, uf.exports.default = cf, cf.deviation = function(t2, e22, r2, n2) {
        var i2 = e22 && e22.length, s2 = Math.abs(Rf(t2, 0, i2 ? e22[0] * r2 : t2.length, r2));
        if (i2)
          for (var a2 = 0, o2 = e22.length; a2 < o2; a2++)
            s2 -= Math.abs(Rf(t2, e22[a2] * r2, a2 < o2 - 1 ? e22[a2 + 1] * r2 : t2.length, r2));
        var l2 = 0;
        for (a2 = 0; a2 < n2.length; a2 += 3) {
          var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h22 = n2[a2 + 2] * r2;
          l2 += Math.abs((t2[u2] - t2[h22]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h22 + 1] - t2[u2 + 1]));
        }
        return 0 === s2 && 0 === l2 ? 0 : Math.abs((l2 - s2) / s2);
      }, cf.flatten = function(t2) {
        for (var e22 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e22 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
          for (var s2 = 0; s2 < t2[i2].length; s2++)
            for (var a2 = 0; a2 < e22; a2++)
              r2.vertices.push(t2[i2][s2][a2]);
          i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
        }
        return r2;
      };
      var Lf = p(uf.exports);
      function Vf(t2, e22) {
        const r2 = t2.length;
        if (r2 <= 1)
          return [t2];
        const n2 = [];
        let i2, s2;
        for (let e3 = 0; e3 < r2; e3++) {
          const r3 = Y(t2[e3]);
          0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
        }
        if (i2 && n2.push(i2), e22 > 1)
          for (let t3 = 0; t3 < n2.length; t3++)
            n2[t3].length <= e22 || (ur(n2[t3], e22, 1, n2[t3].length - 1, Of), n2[t3] = n2[t3].slice(0, e22));
        return n2;
      }
      function Of(t2, e22) {
        return e22.area - t2.area;
      }
      function Ff(t2, e22, r2) {
        const n2 = r2.patternDependencies;
        let i2 = false;
        for (const r3 of e22) {
          const e3 = r3.paint.get(`${t2}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n2[s2] = true);
        }
        return i2;
      }
      function jf(t2, e22, r2, n2, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e22) {
          const e3 = a2.paint.get(`${t2}-pattern`).value;
          if ("constant" !== e3.kind) {
            let t3 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, s2[t3] = true, r2.patterns[a2.id] = t3;
          }
        }
        return r2;
      }
      class Uf {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new $a(), this.indexArray = new ao(), this.indexArray2 = new eo(), this.programConfigurations = new fl(t2.layers, t2.zoom), this.segments = new Do(), this.segments2 = new Do(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection;
        }
        populate(t2, e22, r2, n2) {
          this.hasPattern = Ff("fill", this.layers, e22);
          const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
          for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c2 = gp(a2, t3);
            if (!this.layers[0]._featureFilter.filter(new _a2(this.zoom), c2, r2))
              continue;
            const h22 = i2 ? i2.evaluate(c2, {}, r2, e22.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : yp(a2, r2, n2), patterns: {}, sortKey: h22 };
            s2.push(p2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = jf("fill", this.layers, n3, this.zoom, e22);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {}, e22.availableImages, e22.brightness);
            e22.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e22, r2, n2, i2) {
          const s2 = 0 !== Object.keys(t2).length;
          s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t2, e22, s2 ? this.stateDependentLayers : this.layers, r2, n2, i2);
        }
        addFeatures(t2, e22, r2, n2, i2, s2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e22, r2, n2, s2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, lf), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t2, e22, r2, n2, i2, s2 = [], a2) {
          for (const t3 of Vf(e22, 500)) {
            let e3 = 0;
            for (const r4 of t3)
              e3 += r4.length;
            const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s3 = [];
            for (const e4 of t3) {
              if (0 === e4.length)
                continue;
              e4 !== t3[0] && s3.push(i3.length / 2);
              const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t4 = 1; t4 < e4.length; t4++)
                this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
              r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
            }
            const a3 = Lf(i3, s3);
            for (let t4 = 0; t4 < a3.length; t4 += 3)
              this.indexArray.emplaceBack(n3 + a3[t4], n3 + a3[t4 + 1], n3 + a3[t4 + 2]);
            r3.vertexLength += e3, r3.primitiveLength += a3.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, a2);
        }
      }
      Ks(Uf, "FillBucket", { omit: ["layers", "patternFeatures"] });
      const Nf = new Da({ "fill-sort-key": new Ea(re2.layout_fill["fill-sort-key"]), visibility: new za(re2.layout_fill.visibility) });
      var $f = { paint: new Da({ "fill-antialias": new za(re2.paint_fill["fill-antialias"]), "fill-opacity": new Ea(re2.paint_fill["fill-opacity"]), "fill-color": new Ea(re2.paint_fill["fill-color"]), "fill-outline-color": new Ea(re2.paint_fill["fill-outline-color"]), "fill-translate": new za(re2.paint_fill["fill-translate"]), "fill-translate-anchor": new za(re2.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ea(re2.paint_fill["fill-pattern"]), "fill-emissive-strength": new za(re2.paint_fill["fill-emissive-strength"]) }), layout: Nf };
      const qf = Ua([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Gf = Ua([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Yf = Ua([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Zf = Ua([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Xf = Ua([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Kf } = qf;
      var Wf = {}, Hf = y, Jf = Qf;
      function Qf(t2, e22, r2, n2, i2) {
        this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(td, this, e22);
      }
      function td(t2, e22, r2) {
        1 == t2 ? e22.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
          for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
            e3.properties[n2] = i2;
          }
        }(r2, e22) : 3 == t2 ? e22.type = r2.readVarint() : 4 == t2 && (e22._geometry = r2.pos);
      }
      function ed(t2) {
        for (var e22, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          n2 += ((r2 = t2[a2]).x - (e22 = t2[i2]).x) * (e22.y + r2.y);
        return n2;
      }
      Qf.types = ["Unknown", "Point", "LineString", "Polygon"], Qf.prototype.loadGeometry = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e22, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = []; t2.pos < r2; ) {
          if (i2 <= 0) {
            var l2 = t2.readVarint();
            n2 = 7 & l2, i2 = l2 >> 3;
          }
          if (i2--, 1 === n2 || 2 === n2)
            s2 += t2.readSVarint(), a2 += t2.readSVarint(), 1 === n2 && (e22 && o2.push(e22), e22 = []), e22.push(new Hf(s2, a2));
          else {
            if (7 !== n2)
              throw new Error("unknown command " + n2);
            e22 && e22.push(e22[0].clone());
          }
        }
        return e22 && o2.push(e22), o2;
      }, Qf.prototype.bbox = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e22 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e22; ) {
          if (n2 <= 0) {
            var c2 = t2.readVarint();
            r2 = 7 & c2, n2 = c2 >> 3;
          }
          if (n2--, 1 === r2 || 2 === r2)
            (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
          else if (7 !== r2)
            throw new Error("unknown command " + r2);
        }
        return [a2, l2, o2, u2];
      }, Qf.prototype.toGeoJSON = function(t2, e22, r2) {
        var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e22, l2 = this.loadGeometry(), u2 = Qf.types[this.type];
        function c2(t3) {
          for (var e3 = 0; e3 < t3.length; e3++) {
            var r3 = t3[e3];
            t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h22 = [];
            for (n2 = 0; n2 < l2.length; n2++)
              h22[n2] = l2[n2][0];
            c2(l2 = h22);
            break;
          case 2:
            for (n2 = 0; n2 < l2.length; n2++)
              c2(l2[n2]);
            break;
          case 3:
            for (l2 = function(t3) {
              var e3 = t3.length;
              if (e3 <= 1)
                return [t3];
              for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                var a3 = ed(t3[s3]);
                0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
              }
              return r3 && i3.push(r3), i3;
            }(l2), n2 = 0; n2 < l2.length; n2++)
              for (i2 = 0; i2 < l2[n2].length; i2++)
                c2(l2[n2][i2]);
        }
        1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
        var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
        return "id" in this && (p2.id = this.id), p2;
      };
      var rd = Jf, nd = id2;
      function id2(t2, e22) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(sd, this, e22), this.length = this._features.length;
      }
      function sd(t2, e22, r2) {
        15 === t2 ? e22.version = r2.readVarint() : 1 === t2 ? e22.name = r2.readString() : 5 === t2 ? e22.extent = r2.readVarint() : 2 === t2 ? e22._features.push(r2.pos) : 3 === t2 ? e22._keys.push(r2.readString()) : 4 === t2 && e22._values.push(function(t3) {
          for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = t3.readVarint() >> 3;
            e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
          }
          return e3;
        }(r2));
      }
      id2.prototype.feature = function(t2) {
        if (t2 < 0 || t2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t2];
        var e22 = this._pbf.readVarint() + this._pbf.pos;
        return new rd(this._pbf, e22, this.extent, this._keys, this._values);
      };
      var ad = nd;
      function od(t2, e22, r2) {
        if (3 === t2) {
          var n2 = new ad(r2, r2.readVarint() + r2.pos);
          n2.length && (e22[n2.name] = n2);
        }
      }
      var ld = Wf.VectorTile = function(t2, e22) {
        this.layers = t2.readFields(od, {}, e22);
      }, ud = Wf.VectorTileFeature = Jf;
      function cd(t2, e22, r2, n2) {
        const i2 = [], s2 = 0 === n2 ? (t3, e3, r3, n3, i3, s3) => {
          t3.push(new x(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
        } : (t3, e3, r3, n3, i3, s3) => {
          t3.push(new x(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
        };
        for (const a2 of t2) {
          const t3 = [];
          for (const i3 of a2) {
            if (i3.length <= 2)
              continue;
            const a3 = [];
            for (let t4 = 0; t4 < i3.length - 1; t4++) {
              const o3 = i3[t4].x, l3 = i3[t4].y, u2 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h22 = 0 === n2 ? o3 : l3, p2 = 0 === n2 ? u2 : c2;
              h22 < e22 ? p2 > e22 && s2(a3, o3, l3, u2, c2, e22) : h22 > r2 ? p2 < r2 && s2(a3, o3, l3, u2, c2, r2) : a3.push(i3[t4]), p2 < e22 && h22 >= e22 && s2(a3, o3, l3, u2, c2, e22), p2 > r2 && h22 <= r2 && s2(a3, o3, l3, u2, c2, r2);
            }
            let o2 = i3[i3.length - 1];
            const l2 = 0 === n2 ? o2.x : o2.y;
            l2 >= e22 && l2 <= r2 && a3.push(o2), a3.length && (o2 = a3[a3.length - 1], a3[0].x === o2.x && a3[0].y === o2.y || a3.push(a3[0]), t3.push(a3));
          }
          t3.length && i2.push(t3);
        }
        return i2;
      }
      Wf.VectorTileLayer = nd;
      class hd {
        constructor(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e22 = 0; e22 < t2.length; e22++) {
            const r2 = t2[e22];
            this._stringToNumber[r2] = e22, this._numberToString[e22] = r2;
          }
        }
        encode(t2) {
          return this._stringToNumber[t2];
        }
        decode(t2) {
          return this._numberToString[t2];
        }
      }
      var pd = {
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        read: function(t2, e22, r2, n2, i2) {
          var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h22 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e22 + h22];
          for (h22 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e22 + h22], h22 += p2, c2 -= 8)
            ;
          for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e22 + h22], h22 += p2, c2 -= 8)
            ;
          if (0 === s2)
            s2 = 1 - u2;
          else {
            if (s2 === l2)
              return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
            a2 += Math.pow(2, n2), s2 -= u2;
          }
          return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
        },
        write: function(t2, e22, r2, n2, i2, s2) {
          var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h22 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, m2 = e22 < 0 || 0 === e22 && 1 / e22 < 0 ? 1 : 0;
          for (e22 = Math.abs(e22), isNaN(e22) || e22 === 1 / 0 ? (o2 = isNaN(e22) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e22) / Math.LN2), e22 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e22 += a2 + h22 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h22)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h22 >= c2 ? (o2 = 0, a2 = c2) : a2 + h22 >= 1 ? (o2 = (e22 * l2 - 1) * Math.pow(2, i2), a2 += h22) : (o2 = e22 * Math.pow(2, h22 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
            ;
          for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
            ;
          t2[r2 + f2 - d2] |= 128 * m2;
        }
      }, fd = md, dd = pd;
      function md(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      md.Varint = 0, md.Fixed64 = 1, md.Bytes = 2, md.Fixed32 = 5;
      var yd = 4294967296, gd = 1 / yd, xd = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function vd(t2) {
        return t2.type === md.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function bd(t2, e22, r2) {
        return r2 ? 4294967296 * e22 + (t2 >>> 0) : 4294967296 * (e22 >>> 0) + (t2 >>> 0);
      }
      function _d(t2, e22, r2) {
        var n2 = e22 <= 16383 ? 1 : e22 <= 2097151 ? 2 : e22 <= 268435455 ? 3 : Math.floor(Math.log(e22) / (7 * Math.LN2));
        r2.realloc(n2);
        for (var i2 = r2.pos - 1; i2 >= t2; i2--)
          r2.buf[i2 + n2] = r2.buf[i2];
      }
      function wd(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeVarint(t2[r2]);
      }
      function Md(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeSVarint(t2[r2]);
      }
      function Ad(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeFloat(t2[r2]);
      }
      function Sd(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeDouble(t2[r2]);
      }
      function Id(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeBoolean(t2[r2]);
      }
      function kd(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeFixed32(t2[r2]);
      }
      function Td(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeSFixed32(t2[r2]);
      }
      function Pd(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeFixed64(t2[r2]);
      }
      function zd(t2, e22) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e22.writeSFixed64(t2[r2]);
      }
      function Ed(t2, e22) {
        return (t2[e22] | t2[e22 + 1] << 8 | t2[e22 + 2] << 16) + 16777216 * t2[e22 + 3];
      }
      function Bd(t2, e22, r2) {
        t2[r2] = e22, t2[r2 + 1] = e22 >>> 8, t2[r2 + 2] = e22 >>> 16, t2[r2 + 3] = e22 >>> 24;
      }
      function Dd(t2, e22) {
        return (t2[e22] | t2[e22 + 1] << 8 | t2[e22 + 2] << 16) + (t2[e22 + 3] << 24);
      }
      md.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t2, e22, r2) {
        for (r2 = r2 || this.length; this.pos < r2; ) {
          var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
          this.type = 7 & n2, t2(i2, e22, this), this.pos === s2 && this.skip(n2);
        }
        return e22;
      }, readMessage: function(t2, e22) {
        return this.readFields(t2, e22, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t2 = Ed(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readSFixed32: function() {
        var t2 = Dd(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readFixed64: function() {
        var t2 = Ed(this.buf, this.pos) + Ed(this.buf, this.pos + 4) * yd;
        return this.pos += 8, t2;
      }, readSFixed64: function() {
        var t2 = Ed(this.buf, this.pos) + Dd(this.buf, this.pos + 4) * yd;
        return this.pos += 8, t2;
      }, readFloat: function() {
        var t2 = dd.read(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t2;
      }, readDouble: function() {
        var t2 = dd.read(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t2;
      }, readVarint: function(t2) {
        var e22, r2, n2 = this.buf;
        return e22 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e22 : (e22 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e22 : (e22 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e22 : (e22 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e22 : function(t3, e3, r3) {
          var n3, i2, s2 = r3.buf;
          if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
            return bd(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
            return bd(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
            return bd(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
            return bd(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
            return bd(t3, n3, e3);
          if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
            return bd(t3, n3, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e22 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t2 = this.readVarint();
        return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t2 = this.readVarint() + this.pos, e22 = this.pos;
        return this.pos = t2, t2 - e22 >= 12 && xd ? function(t3, e3, r2) {
          return xd.decode(t3.subarray(e3, r2));
        }(this.buf, e22, t2) : function(t3, e3, r2) {
          for (var n2 = "", i2 = e3; i2 < r2; ) {
            var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
            if (i2 + c2 > r2)
              break;
            1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
          }
          return n2;
        }(this.buf, e22, t2);
      }, readBytes: function() {
        var t2 = this.readVarint() + this.pos, e22 = this.buf.subarray(this.pos, t2);
        return this.pos = t2, e22;
      }, readPackedVarint: function(t2, e22) {
        if (this.type !== md.Bytes)
          return t2.push(this.readVarint(e22));
        var r2 = vd(this);
        for (t2 = t2 || []; this.pos < r2; )
          t2.push(this.readVarint(e22));
        return t2;
      }, readPackedSVarint: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readSVarint());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readSVarint());
        return t2;
      }, readPackedBoolean: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readBoolean());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readBoolean());
        return t2;
      }, readPackedFloat: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readFloat());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readFloat());
        return t2;
      }, readPackedDouble: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readDouble());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readDouble());
        return t2;
      }, readPackedFixed32: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readFixed32());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readFixed32());
        return t2;
      }, readPackedSFixed32: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readSFixed32());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readSFixed32());
        return t2;
      }, readPackedFixed64: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readFixed64());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readFixed64());
        return t2;
      }, readPackedSFixed64: function(t2) {
        if (this.type !== md.Bytes)
          return t2.push(this.readSFixed64());
        var e22 = vd(this);
        for (t2 = t2 || []; this.pos < e22; )
          t2.push(this.readSFixed64());
        return t2;
      }, skip: function(t2) {
        var e22 = 7 & t2;
        if (e22 === md.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (e22 === md.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e22 === md.Fixed32)
          this.pos += 4;
        else {
          if (e22 !== md.Fixed64)
            throw new Error("Unimplemented type: " + e22);
          this.pos += 8;
        }
      }, writeTag: function(t2, e22) {
        this.writeVarint(t2 << 3 | e22);
      }, realloc: function(t2) {
        for (var e22 = this.length || 16; e22 < this.pos + t2; )
          e22 *= 2;
        if (e22 !== this.length) {
          var r2 = new Uint8Array(e22);
          r2.set(this.buf), this.buf = r2, this.length = e22;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t2) {
        this.realloc(4), Bd(this.buf, t2, this.pos), this.pos += 4;
      }, writeSFixed32: function(t2) {
        this.realloc(4), Bd(this.buf, t2, this.pos), this.pos += 4;
      }, writeFixed64: function(t2) {
        this.realloc(8), Bd(this.buf, -1 & t2, this.pos), Bd(this.buf, Math.floor(t2 * gd), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t2) {
        this.realloc(8), Bd(this.buf, -1 & t2, this.pos), Bd(this.buf, Math.floor(t2 * gd), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t2) {
        (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e22) {
          var r2, n2;
          if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e22.realloc(10), function(t4, e3, r3) {
            r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
          }(r2, 0, e22), function(t4, e3) {
            var r3 = (7 & t4) << 4;
            e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
          }(n2, e22);
        }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
      }, writeSVarint: function(t2) {
        this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
      }, writeBoolean: function(t2) {
        this.writeVarint(Boolean(t2));
      }, writeString: function(t2) {
        t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
        var e22 = this.pos;
        this.pos = function(t3, e3, r3) {
          for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
            if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
              if (!i2) {
                n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                continue;
              }
              if (n2 < 56320) {
                t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                continue;
              }
              n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
            } else
              i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
            n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
          }
          return r3;
        }(this.buf, t2, this.pos);
        var r2 = this.pos - e22;
        r2 >= 128 && _d(e22, r2, this), this.pos = e22 - 1, this.writeVarint(r2), this.pos += r2;
      }, writeFloat: function(t2) {
        this.realloc(4), dd.write(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t2) {
        this.realloc(8), dd.write(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t2) {
        var e22 = t2.length;
        this.writeVarint(e22), this.realloc(e22);
        for (var r2 = 0; r2 < e22; r2++)
          this.buf[this.pos++] = t2[r2];
      }, writeRawMessage: function(t2, e22) {
        this.pos++;
        var r2 = this.pos;
        t2(e22, this);
        var n2 = this.pos - r2;
        n2 >= 128 && _d(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
      }, writeMessage: function(t2, e22, r2) {
        this.writeTag(t2, md.Bytes), this.writeRawMessage(e22, r2);
      }, writePackedVarint: function(t2, e22) {
        e22.length && this.writeMessage(t2, wd, e22);
      }, writePackedSVarint: function(t2, e22) {
        e22.length && this.writeMessage(t2, Md, e22);
      }, writePackedBoolean: function(t2, e22) {
        e22.length && this.writeMessage(t2, Id, e22);
      }, writePackedFloat: function(t2, e22) {
        e22.length && this.writeMessage(t2, Ad, e22);
      }, writePackedDouble: function(t2, e22) {
        e22.length && this.writeMessage(t2, Sd, e22);
      }, writePackedFixed32: function(t2, e22) {
        e22.length && this.writeMessage(t2, kd, e22);
      }, writePackedSFixed32: function(t2, e22) {
        e22.length && this.writeMessage(t2, Td, e22);
      }, writePackedFixed64: function(t2, e22) {
        e22.length && this.writeMessage(t2, Pd, e22);
      }, writePackedSFixed64: function(t2, e22) {
        e22.length && this.writeMessage(t2, zd, e22);
      }, writeBytesField: function(t2, e22) {
        this.writeTag(t2, md.Bytes), this.writeBytes(e22);
      }, writeFixed32Field: function(t2, e22) {
        this.writeTag(t2, md.Fixed32), this.writeFixed32(e22);
      }, writeSFixed32Field: function(t2, e22) {
        this.writeTag(t2, md.Fixed32), this.writeSFixed32(e22);
      }, writeFixed64Field: function(t2, e22) {
        this.writeTag(t2, md.Fixed64), this.writeFixed64(e22);
      }, writeSFixed64Field: function(t2, e22) {
        this.writeTag(t2, md.Fixed64), this.writeSFixed64(e22);
      }, writeVarintField: function(t2, e22) {
        this.writeTag(t2, md.Varint), this.writeVarint(e22);
      }, writeSVarintField: function(t2, e22) {
        this.writeTag(t2, md.Varint), this.writeSVarint(e22);
      }, writeStringField: function(t2, e22) {
        this.writeTag(t2, md.Bytes), this.writeString(e22);
      }, writeFloatField: function(t2, e22) {
        this.writeTag(t2, md.Fixed32), this.writeFloat(e22);
      }, writeDoubleField: function(t2, e22) {
        this.writeTag(t2, md.Fixed64), this.writeDouble(e22);
      }, writeBooleanField: function(t2, e22) {
        this.writeVarintField(t2, Boolean(e22));
      } };
      var Cd = p(fd);
      const Rd = ["tile", "layer", "source", "sourceLayer", "state"];
      class Ld {
        constructor(t2, e22, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, this._z = e22, this._x = r2, this._y = n2, this.properties = t2.properties, this.id = i2;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(t2) {
          this._geometry = t2;
        }
        toJSON() {
          const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          void 0 !== this.id && (t2.id = this.id);
          for (const e22 of Rd)
            void 0 !== this[e22] && (t2[e22] = this[e22]);
          return t2;
        }
      }
      class Vd {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t2, e22, r2) {
          const n2 = String(e22);
          if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, B(this.stateChanges[t2][n2], r2), null === this.deletedStates[t2]) {
            this.deletedStates[t2] = {};
            for (const e3 in this.state[t2])
              e3 !== n2 && (this.deletedStates[t2][e3] = null);
          } else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2]) {
            this.deletedStates[t2][n2] = {};
            for (const e3 in this.state[t2][n2])
              r2[e3] || (this.deletedStates[t2][n2][e3] = null);
          } else
            for (const e3 in r2)
              this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][e3] && delete this.deletedStates[t2][n2][e3];
        }
        removeFeatureState(t2, e22, r2) {
          if (null === this.deletedStates[t2])
            return;
          const n2 = String(e22);
          if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e22)
            null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
          else if (void 0 !== e22)
            if (this.stateChanges[t2] && this.stateChanges[t2][n2])
              for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                this.deletedStates[t2][n2][r2] = null;
            else
              this.deletedStates[t2][n2] = null;
          else
            this.deletedStates[t2] = null;
        }
        getState(t2, e22) {
          const r2 = String(e22), n2 = B({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
          if (null === this.deletedStates[t2])
            return {};
          if (this.deletedStates[t2]) {
            const r3 = this.deletedStates[t2][e22];
            if (null === r3)
              return {};
            for (const t3 in r3)
              delete n2[t3];
          }
          return n2;
        }
        initializeTileState(t2, e22) {
          t2.setFeatureState(this.state, e22);
        }
        coalesceChanges(t2, e22) {
          const r2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const e3 = {};
            for (const r3 in this.stateChanges[t3])
              this.state[t3][r3] || (this.state[t3][r3] = {}), B(this.state[t3][r3], this.stateChanges[t3][r3]), e3[r3] = this.state[t3][r3];
            r2[t3] = e3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const e3 = {};
            if (null === this.deletedStates[t3])
              for (const r3 in this.state[t3])
                e3[r3] = {}, this.state[t3][r3] = {};
            else
              for (const r3 in this.deletedStates[t3]) {
                if (null === this.deletedStates[t3][r3])
                  this.state[t3][r3] = {};
                else if (this.state[t3][r3])
                  for (const e4 of Object.keys(this.deletedStates[t3][r3]))
                    delete this.state[t3][r3][e4];
                e3[r3] = this.state[t3][r3];
              }
            r2[t3] = r2[t3] || {}, B(r2[t3], e3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
            for (const n2 in t2)
              t2[n2].setFeatureState(r2, e22);
        }
      }
      class Od {
        constructor(t2) {
          this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(t2, e22) {
          const r2 = this.toIdx(t2, e22);
          return { min: this.minimums[r2], max: this.maximums[r2] };
        }
        isLeaf(t2, e22) {
          return this.leaves[this.toIdx(t2, e22)];
        }
        toIdx(t2, e22) {
          return e22 * this.size + t2;
        }
      }
      function Fd(t2, e22, r2, n2) {
        let i2 = 0, s2 = Number.MAX_VALUE;
        for (let a2 = 0; a2 < 3; a2++)
          if (Math.abs(n2[a2]) < 1e-15) {
            if (r2[a2] < t2[a2] || r2[a2] > e22[a2])
              return null;
          } else {
            const o2 = 1 / n2[a2];
            let l2 = (t2[a2] - r2[a2]) * o2, u2 = (e22[a2] - r2[a2]) * o2;
            if (l2 > u2) {
              const t3 = l2;
              l2 = u2, u2 = t3;
            }
            if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2)
              return null;
          }
        return i2;
      }
      function jd(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
        const h22 = n2 - t2, p2 = i2 - e22, f2 = s2 - r2, d2 = a2 - t2, m2 = o2 - e22, y2 = l2 - r2, g2 = c2[1] * y2 - c2[2] * m2, x2 = c2[2] * d2 - c2[0] * y2, v2 = c2[0] * m2 - c2[1] * d2, b2 = h22 * g2 + p2 * x2 + f2 * v2;
        if (Math.abs(b2) < 1e-15)
          return null;
        const _2 = 1 / b2, w2 = u2[0] - t2, M2 = u2[1] - e22, A2 = u2[2] - r2, S2 = (w2 * g2 + M2 * x2 + A2 * v2) * _2;
        if (S2 < 0 || S2 > 1)
          return null;
        const I2 = M2 * f2 - A2 * p2, k2 = A2 * h22 - w2 * f2, T2 = w2 * p2 - M2 * h22, P2 = (c2[0] * I2 + c2[1] * k2 + c2[2] * T2) * _2;
        return P2 < 0 || S2 + P2 > 1 ? null : (d2 * I2 + m2 * k2 + y2 * T2) * _2;
      }
      function Ud(t2, e22, r2) {
        return (t2 - e22) / (r2 - e22);
      }
      function Nd(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = 1 << r2, c2 = s2 - n2, h22 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, f2 = (e22 + 0) / u2 * h22 + i2, d2 = (e22 + 1) / u2 * h22 + i2;
        o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = f2, l2[0] = p2, l2[1] = d2;
      }
      class $d {
        constructor(t2) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const e22 = function(t3) {
            const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
            let n3 = Math.ceil(Math.pow(2, e3));
            const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
              const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
              i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l2;
            };
            let a2 = new Od(n3);
            const o2 = [];
            for (let e4 = 0; e4 < n3 * n3; e4++) {
              s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
              const r4 = Gd(o2[0], o2[1], t3), l2 = Gd(o2[2], o2[1], t3), u2 = Gd(o2[2], o2[3], t3), c2 = Gd(o2[0], o2[3], t3);
              a2.minimums.push(Math.min(r4, l2, u2, c2)), a2.maximums.push(Math.max(r4, l2, u2, c2)), a2.leaves.push(1);
            }
            for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
              const t4 = r3[r3.length - 1];
              a2 = new Od(n3);
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h22 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), f2 = t4.isLeaf(o2[0], o2[3]), d2 = Math.min(r4.min, i3.min, l2.min, u2.min), m2 = Math.max(r4.max, i3.max, l2.max, u2.max), y2 = c2 && h22 && p2 && f2;
                a2.maximums.push(m2), a2.minimums.push(d2), a2.leaves.push(m2 - d2 <= 5 && y2 ? 1 : 0);
              }
              r3.push(a2);
            }
            return r3;
          }(this.dem), r2 = e22.length - 1, n2 = e22[r2];
          this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e22, 0, 0, r2, 0);
        }
        raycastRoot(t2, e22, r2, n2, i2, s2, a2 = 1) {
          return Fd([t2, e22, -100], [r2, n2, this.maximums[0] * a2], i2, s2);
        }
        raycast(e22, r2, n2, i2, s2, a2, o2 = 1) {
          if (!this.nodeCount)
            return null;
          const l2 = this.raycastRoot(e22, r2, n2, i2, s2, a2, o2);
          if (null == l2)
            return null;
          const u2 = [], c2 = [], h22 = [], p2 = [], f2 = [{ idx: 0, t: l2, nodex: 0, nodey: 0, depth: 0 }];
          for (; f2.length > 0; ) {
            const { idx: l3, t: d2, nodex: m2, nodey: y2, depth: g2 } = f2.pop();
            if (this.leaves[l3]) {
              Nd(m2, y2, g2, e22, r2, n2, i2, h22, p2);
              const l4 = 1 << g2, u3 = (m2 + 0) / l4, c3 = (m2 + 1) / l4, f3 = (y2 + 0) / l4, x3 = (y2 + 1) / l4, v2 = Gd(u3, f3, this.dem) * o2, b2 = Gd(c3, f3, this.dem) * o2, _2 = Gd(c3, x3, this.dem) * o2, w2 = Gd(u3, x3, this.dem) * o2, M2 = jd(h22[0], h22[1], v2, p2[0], h22[1], b2, p2[0], p2[1], _2, s2, a2), A2 = jd(p2[0], p2[1], _2, h22[0], p2[1], w2, h22[0], h22[1], v2, s2, a2), S2 = Math.min(null !== M2 ? M2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
              if (S2 !== Number.MAX_VALUE)
                return S2;
              {
                const e3 = t.v.scaleAndAdd([], s2, a2, d2);
                if (qd(v2, b2, w2, _2, Ud(e3[0], h22[0], p2[0]), Ud(e3[1], h22[1], p2[1])) >= e3[2])
                  return d2;
              }
              continue;
            }
            let x2 = 0;
            for (let t2 = 0; t2 < this._siblingOffset.length; t2++) {
              Nd((m2 << 1) + this._siblingOffset[t2][0], (y2 << 1) + this._siblingOffset[t2][1], g2 + 1, e22, r2, n2, i2, h22, p2), h22[2] = -100, p2[2] = this.maximums[this.childOffsets[l3] + t2] * o2;
              const f3 = Fd(h22, p2, s2, a2);
              if (null != f3) {
                const e3 = f3;
                u2[t2] = e3;
                let r3 = false;
                for (let n3 = 0; n3 < x2 && !r3; n3++)
                  e3 >= u2[c2[n3]] && (c2.splice(n3, 0, t2), r3 = true);
                r3 || (c2[x2] = t2), x2++;
              }
            }
            for (let t2 = 0; t2 < x2; t2++) {
              const e3 = c2[t2];
              f2.push({ idx: this.childOffsets[l3] + e3, t: u2[e3], nodex: (m2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: g2 + 1 });
            }
          }
          return null;
        }
        _addNode(t2, e22, r2) {
          return this.minimums.push(t2), this.maximums.push(e22), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t2, e22, r2, n2, i2) {
          if (1 === t2[n2].isLeaf(e22, r2))
            return;
          this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
          const s2 = n2 - 1, a2 = t2[s2];
          let o2 = 0, l2 = 0;
          for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
            const n3 = 2 * e22 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
            u2 && (o2 |= 1 << t3), l2 || (l2 = c2);
          }
          for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
            o2 & 1 << n3 || this._construct(t2, 2 * e22 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, l2 + n3);
        }
      }
      function qd(t2, e22, r2, n2, i2, s2) {
        return Mn(Mn(t2, r2, s2), Mn(e22, n2, s2), i2);
      }
      function Gd(t2, e22, r2) {
        const n2 = r2.dim, i2 = k(t2 * n2 - 0.5, 0, n2 - 1), s2 = k(e22 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
        return qd(r2.get(a2, o2), r2.get(l2, o2), r2.get(a2, u2), r2.get(l2, u2), i2 - a2, s2 - o2);
      }
      const Yd = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function Zd(t2, e22, r2) {
        return (256 * t2 * 256 + 256 * e22 + r2) / 10 - 1e4;
      }
      function Xd(t2, e22, r2) {
        return 256 * t2 + e22 + r2 / 256 - 32768;
      }
      class Kd {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t2, e22, r2, n2 = false) {
          if (this.uid = t2, e22.height !== e22.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
            return q(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = e22.height;
          const i2 = this.dim = e22.height - 2, s2 = new Uint32Array(e22.data.buffer);
          if (this.pixels = new Uint8Array(e22.data.buffer), this.floatView = new Float32Array(e22.data.buffer), this.borderReady = n2, this._modifiedForSources = {}, !n2) {
            for (let t3 = 0; t3 < i2; t3++)
              s2[this._idx(-1, t3)] = s2[this._idx(0, t3)], s2[this._idx(i2, t3)] = s2[this._idx(i2 - 1, t3)], s2[this._idx(t3, -1)] = s2[this._idx(t3, 0)], s2[this._idx(t3, i2)] = s2[this._idx(t3, i2 - 1)];
            s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(i2, -1)] = s2[this._idx(i2 - 1, 0)], s2[this._idx(-1, i2)] = s2[this._idx(0, i2 - 1)], s2[this._idx(i2, i2)] = s2[this._idx(i2 - 1, i2 - 1)];
          }
          const a2 = "terrarium" === r2 ? Xd : Zd;
          for (let t3 = 0; t3 < s2.length; ++t3) {
            const e3 = 4 * t3;
            this.floatView[t3] = a2(this.pixels[e3], this.pixels[e3 + 1], this.pixels[e3 + 2]);
          }
          this._timestamp = Wt.now();
        }
        _buildQuadTree() {
          this._tree = new $d(this);
        }
        get(t2, e22, r2 = false) {
          r2 && (t2 = k(t2, -1, this.dim), e22 = k(e22, -1, this.dim));
          const n2 = this._idx(t2, e22);
          return this.floatView[n2];
        }
        set(t2, e22, r2) {
          const n2 = this._idx(t2, e22), i2 = this.floatView[n2];
          return this.floatView[n2] = r2, r2 - i2;
        }
        static getUnpackVector(t2) {
          return Yd[t2];
        }
        _idx(t2, e22) {
          if (t2 < -1 || t2 >= this.dim + 1 || e22 < -1 || e22 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e22 + 1) * this.stride + (t2 + 1);
        }
        static pack(t2, e22) {
          const r2 = [0, 0, 0, 0], n2 = Kd.getUnpackVector(e22);
          let i2 = Math.floor((t2 + n2[3]) / n2[2]);
          return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
        }
        getPixels() {
          return new tf({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(t2, e22, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          let n2 = e22 * this.dim, i2 = e22 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
          switch (e22) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e22 * this.dim, l2 = -r2 * this.dim;
          for (let e3 = s2; e3 < a2; e3++)
            for (let r3 = n2; r3 < i2; r3++) {
              const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + o2, e3 + l2);
              this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      Ks(Kd, "DEMData"), Ks($d, "DemMinMaxQuadTree", { omit: ["dem"] });
      class Wd {
        constructor(t2, e22, r2) {
          this._demTile = t2, this._dem = this._demTile.dem, this._scale = e22, this._offset = r2;
        }
        static create(t2, e22, r2) {
          const n2 = r2 || t2.findDEMTileFor(e22);
          if (!n2 || !n2.dem)
            return;
          const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e22.canonical.z - s2.canonical.z;
          return new Wd(n2, i2.dim / Cr / a2, [(e22.canonical.x / a2 - s2.canonical.x) * i2.dim, (e22.canonical.y / a2 - s2.canonical.y) * i2.dim]);
        }
        tileCoordToPixel(t2, e22) {
          const r2 = e22 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r2);
          return new x(n2, i2);
        }
        getElevationAt(t2, e22, r2, n2) {
          const i2 = t2 * this._scale + this._offset[0], s2 = e22 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
          return n2 = !!n2, r2 ? Mn(Mn(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), Mn(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
        }
        getElevationAtPixel(t2, e22, r2) {
          return this._dem.get(t2, e22, !!r2);
        }
        getMeterToDEM(t2) {
          return (1 << this._demTile.tileID.canonical.z) * Qh(1, t2) * this._dem.stride;
        }
      }
      class Hd {
        constructor(t2, e22) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Zs(Cr, 16, 0), this.featureIndexArray = new Po(), this.promoteId = e22;
        }
        insert(t2, e22, r2, n2, i2, s2 = 0) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
          const o2 = this.grid;
          for (let t3 = 0; t3 < e22.length; t3++) {
            const r3 = e22[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0; t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            n3[0] < Cr && n3[1] < Cr && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new ld(new Cd(this.rawTileData)).layers, this.sourceLayerCoder = new hd(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const t2 in this.vtLayers)
              this.vtFeatures[t2] = [];
          }
          return this.vtLayers;
        }
        query(t2, e22, r2, n2) {
          this.loadVTLayers();
          const i2 = t2.params || {}, s2 = ls(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r3, n3) => Ep(a2.bufferedTilespaceGeometry, t3, e3, r3, n3));
          u2.sort(Qd);
          let c2 = null;
          o2.elevation && u2.length > 0 && (c2 = Wd.create(o2.elevation, this.tileID));
          const h22 = {};
          let p2;
          for (let o3 = 0; o3 < u2.length; o3++) {
            const l3 = u2[o3];
            if (l3 === p2)
              continue;
            p2 = l3;
            const f2 = this.featureIndexArray.get(l3);
            let d2 = null;
            this.loadMatchingFeature(h22, f2, s2, i2.layers, i2.availableImages, e22, r2, n2, (e3, r3, n3, i3 = 0) => (d2 || (d2 = yp(e3, this.tileID.canonical, t2.tileTransform)), r3.queryIntersectsFeature(a2, e3, n3, d2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
          }
          return h22;
        }
        loadMatchingFeature(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
          const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h22, layoutVertexArrayOffset: p2 } = e22, f2 = this.bucketLayerIDs[c2];
          if (n2 && !function(t3, e3) {
            for (let r3 = 0; r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(n2, f2))
            return;
          const d2 = this.sourceLayerCoder.decode(h22), m2 = this.vtLayers[d2].feature(u2);
          if (r2.needGeometry) {
            const t3 = gp(m2, true);
            if (!r2.filter(new _a2(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!r2.filter(new _a2(this.tileID.overscaledZ), m2))
            return;
          const y2 = this.getId(m2, d2);
          for (let e3 = 0; e3 < f2.length; e3++) {
            const r3 = f2[e3];
            if (n2 && n2.indexOf(r3) < 0)
              continue;
            const c3 = s2[r3];
            if (!c3)
              continue;
            let h3 = {};
            void 0 !== y2 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", y2));
            const d3 = B({}, a2[r3]);
            d3.paint = Jd(d3.paint, c3.paint, m2, h3, i2), d3.layout = Jd(d3.layout, c3.layout, m2, h3, i2);
            const g2 = !l2 || l2(m2, c3, h3, p2);
            if (!g2)
              continue;
            const x2 = new Ld(m2, this.z, this.x, this.y, y2);
            x2.layer = d3;
            let v2 = t2[r3];
            void 0 === v2 && (v2 = t2[r3] = []), v2.push({ featureIndex: u2, feature: x2, intersectionZ: g2 });
          }
        }
        lookupSymbolFeatures(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = {};
          this.loadVTLayers();
          const u2 = ls(i2);
          for (const i3 of t2)
            this.loadMatchingFeature(l2, { bucketIndex: r2, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e22);
          return l2;
        }
        loadFeature(t2) {
          const { featureIndex: e22, sourceLayerIndex: r2 } = t2;
          this.loadVTLayers();
          const n2 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n2];
          if (i2[e22])
            return i2[e22];
          const s2 = this.vtLayers[n2].feature(e22);
          return i2[e22] = s2, s2;
        }
        hasLayer(t2) {
          for (const e22 of this.bucketLayerIDs)
            for (const r2 of e22)
              if (t2 === r2)
                return true;
          return false;
        }
        getId(t2, e22) {
          let r2 = t2.id;
          if (this.promoteId) {
            const n2 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e22];
            null != n2 && (r2 = t2.properties[n2]), "boolean" == typeof r2 && (r2 = Number(r2));
          }
          return r2;
        }
      }
      function Jd(t2, e22, r2, n2, i2) {
        return j(t2, (t3, s2) => {
          const a2 = e22 instanceof Pa ? e22.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
        });
      }
      function Qd(t2, e22) {
        return e22 - t2;
      }
      Ks(Hd, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      const tm = Ua([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), em = Ua([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), rm = Ua([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      Ua([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const nm = Ua([{ name: "a_z_offset", components: 1, type: "Float32" }], 4), im = Ua([{ name: "a_texb", components: 2, type: "Uint16" }]), sm = Ua([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), am = Ua([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_z_offset", components: 1, type: "Float32" }]);
      Ua([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const om = Ua([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), lm = Ua([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      Ua([{ name: "triangle", components: 3, type: "Uint16" }]), Ua([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ua([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), Ua([{ type: "Float32", name: "offsetX" }]), Ua([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var um = 24;
      const cm = 128;
      function hm(t2, e22) {
        const { expression: r2 } = e22;
        if ("constant" === r2.kind)
          return { kind: "constant", layoutSize: r2.evaluate(new _a2(t2 + 1)) };
        if ("source" === r2.kind)
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n2 } = r2;
          let i2 = 0;
          for (; i2 < e3.length && e3[i2] <= t2; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (; s2 < e3.length && e3[s2] < t2 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new _a2(a2)), maxSize: r2.evaluate(new _a2(o2)), interpolationType: n2 };
        }
      }
      function pm(t2, { uSize: e22, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
        return "source" === t2.kind ? n2 / cm : "composite" === t2.kind ? Mn(n2 / cm, i2 / cm, r2) : e22;
      }
      function fm(t2, e22) {
        let r2 = 0, n2 = 0;
        if ("constant" === t2.kind)
          n2 = t2.layoutSize;
        else if ("source" !== t2.kind) {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? k(Yn.interpolationFactor(i2, e22, s2, a2), 0, 1) : 0;
          "camera" === t2.kind ? n2 = Mn(t2.minSize, t2.maxSize, o2) : r2 = o2;
        }
        return { uSizeT: r2, uSize: n2 };
      }
      var dm = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: cm, evaluateSizeForFeature: pm, evaluateSizeForZoom: fm, getSizeData: hm });
      function mm(t2, e22, r2) {
        return t2.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), ba.applyArabicShaping && (t4 = ba.applyArabicShaping(t4)), t4;
          }(t3.text, e22, r2);
        }), t2;
      }
      const ym = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
      function gm(t2) {
        return "︶" === t2 || "﹈" === t2 || "︸" === t2 || "﹄" === t2 || "﹂" === t2 || "︾" === t2 || "︼" === t2 || "︺" === t2 || "︘" === t2 || "﹀" === t2 || "︐" === t2 || "︓" === t2 || "︔" === t2 || "｀" === t2 || "￣" === t2 || "︑" === t2 || "︒" === t2;
      }
      function xm(t2) {
        return "︵" === t2 || "﹇" === t2 || "︷" === t2 || "﹃" === t2 || "﹁" === t2 || "︽" === t2 || "︻" === t2 || "︹" === t2 || "︗" === t2 || "︿" === t2;
      }
      const vm = 3;
      function bm(t2, e22, r2) {
        e22.glyphs = [], 1 === t2 && r2.readMessage(_m, e22);
      }
      function _m(t2, e22, r2) {
        if (3 === t2) {
          const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(wm, {});
          e22.glyphs.push({ id: t3, bitmap: new Jp({ width: i2 + 2 * vm, height: s2 + 2 * vm }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
        } else
          4 === t2 ? e22.ascender = r2.readSVarint() : 5 === t2 && (e22.descender = r2.readSVarint());
      }
      function wm(t2, e22, r2) {
        1 === t2 ? e22.id = r2.readVarint() : 2 === t2 ? e22.bitmap = r2.readBytes() : 3 === t2 ? e22.width = r2.readVarint() : 4 === t2 ? e22.height = r2.readVarint() : 5 === t2 ? e22.left = r2.readSVarint() : 6 === t2 ? e22.top = r2.readSVarint() : 7 === t2 && (e22.advance = r2.readVarint());
      }
      const Mm = vm, Am = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Sm = -17;
      class Im {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t2, e22) {
          const r2 = new Im();
          return r2.scale = t2 || 1, r2.fontStack = e22, r2;
        }
        static forImage(t2) {
          const e22 = new Im();
          return e22.imageName = t2, e22;
        }
      }
      class km {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t2, e22) {
          const r2 = new km();
          for (let n2 = 0; n2 < t2.sections.length; n2++) {
            const i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e22);
          }
          return r2;
        }
        length() {
          return this.text.length;
        }
        getSection(t2) {
          return this.sections[this.sectionIndex[t2]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t2) {
          return this.sectionIndex[t2];
        }
        getCodePoint(t2) {
          return this.text.codePointAt(t2);
        }
        verticalizePunctuation(t2) {
          this.text = function(t3, e22) {
            let r2 = "";
            for (let n2 = 0; n2 < t3.length; n2++) {
              const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
              r2 += !e22 && (i2 && sa(i2) && !ym[t3[n2 + 1]] || s2 && sa(s2) && !ym[t3[n2 - 1]]) || !ym[t3[n2]] ? t3[n2] : ym[t3[n2]];
            }
            return r2;
          }(this.text, t2);
        }
        trim() {
          let t2 = 0;
          for (let e3 = 0; e3 < this.text.length && Pm[this.text.charCodeAt(e3)]; e3++)
            t2++;
          let e22 = this.text.length;
          for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && Pm[this.text.charCodeAt(r2)]; r2--)
            e22--;
          this.text = this.text.substring(t2, e22), this.sectionIndex = this.sectionIndex.slice(t2, e22);
        }
        substring(t2, e22) {
          const r2 = new km();
          return r2.text = this.text.substring(t2, e22), r2.sectionIndex = this.sectionIndex.slice(t2, e22), r2.sections = this.sections, r2;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t2, e22) => Math.max(t2, this.sections[e22].scale), 0);
        }
        addTextSection(t2, e22) {
          this.text += t2.text, this.sections.push(Im.forText(t2.scale, t2.fontStack || e22));
          const r2 = this.sections.length - 1;
          for (let e3 = 0; e3 < t2.text.length; ++e3)
            this.sectionIndex.push(r2);
        }
        addImageSection(t2) {
          const e22 = t2.image ? t2.image.namePrimary : "";
          if (0 === e22.length)
            return void q("Can't add FormattedSection with an empty image.");
          const r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCodePoint(r2), this.sections.push(Im.forImage(e22)), this.sectionIndex.push(this.sections.length - 1)) : q("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Tm(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2) {
        const m2 = km.fromFeature(t2, i2);
        h22 === Am.vertical && m2.verticalizePunctuation(p2);
        let y2 = [];
        const g2 = function(t3, e3, r3, n3, i3, s3) {
          if (!t3)
            return [];
          const a3 = [], o3 = function(t4, e4, r4, n4, i4, s4) {
            let a4 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const o4 = t4.getSection(r5);
              a4 += Em(t4.getCodePoint(r5), o4, n4, i4, e4, s4);
            }
            return a4 / Math.max(1, Math.ceil(a4 / r4));
          }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("​") >= 0;
          let u3 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const h3 = t3.getSection(r4), p3 = t3.getCodePoint(r4);
            if (Pm[p3] || (u3 += Em(p3, h3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
              const e4 = !((c3 = p3) < 11904 || !(ta["Bopomofo Extended"](c3) || ta.Bopomofo(c3) || ta["CJK Compatibility Forms"](c3) || ta["CJK Compatibility Ideographs"](c3) || ta["CJK Compatibility"](c3) || ta["CJK Radicals Supplement"](c3) || ta["CJK Strokes"](c3) || ta["CJK Symbols and Punctuation"](c3) || ta["CJK Unified Ideographs Extension A"](c3) || ta["CJK Unified Ideographs"](c3) || ta["Enclosed CJK Letters and Months"](c3) || ta["Halfwidth and Fullwidth Forms"](c3) || ta.Hiragana(c3) || ta["Ideographic Description Characters"](c3) || ta["Kangxi Radicals"](c3) || ta["Katakana Phonetic Extensions"](c3) || ta.Katakana(c3) || ta["Vertical Forms"](c3) || ta["Yi Radicals"](c3) || ta["Yi Syllables"](c3)));
              (zm[p3] || e4 || h3.imageName) && a3.push(Cm(r4 + 1, u3, o3, a3, Dm(p3, t3.getCodePoint(r4 + 1), e4 && l3), false));
            }
          }
          var c3;
          return Rm(Cm(t3.length(), u3, o3, a3, 0, true));
        }(m2, u2, s2, e22, n2, f2), { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = ba;
        if (x2 && 1 === m2.sections.length) {
          const t3 = x2(m2.toString(), g2);
          for (const e3 of t3) {
            const t4 = new km();
            t4.text = e3, t4.sections = m2.sections;
            for (let r3 = 0; r3 < e3.length; r3++)
              t4.sectionIndex.push(0);
            y2.push(t4);
          }
        } else if (v2) {
          const t3 = v2(m2.text, m2.sectionIndex, g2);
          for (const e3 of t3) {
            const t4 = new km();
            t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = m2.sections, y2.push(t4);
          }
        } else
          y2 = function(t3, e3) {
            const r3 = [], n3 = t3.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t3.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
          }(m2, g2);
        const b2 = [], _2 = { positionedLines: b2, text: m2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h22, iconsInText: false, verticalizable: false, hasBaseline: false };
        return function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
          let p3 = 0, f3 = 0, d3 = 0;
          const m3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
          let y3 = false;
          for (const t4 of i3) {
            const r4 = t4.getSections();
            for (const t5 of r4) {
              if (t5.imageName)
                continue;
              const r5 = e3[t5.fontStack];
              if (r5 && (y3 = void 0 !== r5.ascender && void 0 !== r5.descender, !y3))
                break;
            }
            if (!y3)
              break;
          }
          let g3 = 0;
          for (const a4 of i3) {
            a4.trim();
            const i4 = a4.getMaxScale(), o4 = (i4 - 1) * um, v4 = { positionedGlyphs: [], lineOffset: 0 };
            t3.positionedLines[g3] = v4;
            const b4 = v4.positionedGlyphs;
            let _4 = 0;
            if (!a4.length()) {
              f3 += s3, ++g3;
              continue;
            }
            let w2 = 0, M2 = 0;
            for (let s4 = 0; s4 < a4.length(); s4++) {
              const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), m4 = a4.getCodePoint(s4);
              let g4 = o5.scale, v5 = null, A3 = null, S2 = null, I2 = um, k2 = 0;
              const T2 = !(l3 === Am.horizontal || !c3 && !ia(m4) || c3 && (Pm[m4] || (x3 = m4, ta.Arabic(x3) || ta["Arabic Supplement"](x3) || ta["Arabic Extended-A"](x3) || ta["Arabic Presentation Forms-A"](x3) || ta["Arabic Presentation Forms-B"](x3))));
              if (o5.imageName) {
                const e4 = n3[o5.imageName];
                if (!e4)
                  continue;
                S2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, A3 = e4.paddedRect;
                const r4 = e4.displaySize;
                g4 = g4 * um / h3, v5 = { width: r4[0], height: r4[1], left: 0, top: -Mm, advance: T2 ? r4[1] : r4[0], localGlyph: false }, k2 = y3 ? -v5.height * g4 : Sm + i4 * um - r4[1] * g4, I2 = v5.advance;
                const s5 = (T2 ? r4[0] : r4[1]) * g4 - um * i4;
                s5 > 0 && s5 > _4 && (_4 = s5);
              } else {
                const t4 = r3[o5.fontStack];
                if (!t4)
                  continue;
                t4[m4] && (A3 = t4[m4]);
                const n4 = e3[o5.fontStack];
                if (!n4)
                  continue;
                const s5 = n4.glyphs[m4];
                if (!s5)
                  continue;
                if (v5 = s5.metrics, I2 = 8203 !== m4 ? um : 0, y3) {
                  const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                  w2 < r4 && (w2 = r4, M2 = (t5 - e4) / 2 * g4), k2 = -t5 * g4;
                } else
                  k2 = Sm + (i4 - g4) * um;
              }
              T2 ? (t3.verticalizable = true, b4.push({ glyph: m4, imageName: S2, x: p3, y: f3 + k2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v5, rect: A3 }), p3 += I2 * g4 + u3) : (b4.push({ glyph: m4, imageName: S2, x: p3, y: f3 + k2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: d4, metrics: v5, rect: A3 }), p3 += v5.advance * g4 + u3);
            }
            0 !== b4.length && (d3 = Math.max(p3 - u3, d3), y3 ? Vm(b4, m3, _4, M2, s3 * i4 / 2) : Vm(b4, m3, _4, 0, s3 / 2)), p3 = 0;
            const A2 = s3 * i4 + _4;
            v4.lineOffset = Math.max(_4, o4), f3 += A2, ++g3;
          }
          var x3;
          const v3 = f3, { horizontalAlign: b3, verticalAlign: _3 } = Lm(a3);
          (function(t4, e4, r4, n4, i4, s4) {
            const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
            for (const e52 of t4)
              for (const t5 of e52.positionedGlyphs)
                t5.x += a4, t5.y += o4;
          })(t3.positionedLines, m3, b3, _3, d3, v3), t3.top += -_3 * v3, t3.bottom = t3.top + v3, t3.left += -b3 * d3, t3.right = t3.left + d3, t3.hasBaseline = y3;
        }(_2, e22, r2, n2, y2, a2, o2, l2, h22, u2, p2, d2), !function(t3) {
          for (const e3 of t3)
            if (0 !== e3.positionedGlyphs.length)
              return false;
          return true;
        }(b2) && _2;
      }
      const Pm = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, zm = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function Em(t2, e22, r2, n2, i2, s2) {
        if (e22.imageName) {
          const t3 = n2[e22.imageName];
          return t3 ? t3.displaySize[0] * e22.scale * um / s2 + i2 : 0;
        }
        {
          const n3 = r2[e22.fontStack], s3 = n3 && n3.glyphs[t2];
          return s3 ? s3.metrics.advance * e22.scale + i2 : 0;
        }
      }
      function Bm(t2, e22, r2, n2) {
        const i2 = Math.pow(t2 - e22, 2);
        return n2 ? t2 < e22 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function Dm(t2, e22, r2) {
        let n2 = 0;
        return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e22 && 65289 !== e22 || (n2 += 50), n2;
      }
      function Cm(t2, e22, r2, n2, i2, s2) {
        let a2 = null, o2 = Bm(e22, r2, i2, s2);
        for (const t3 of n2) {
          const n3 = Bm(e22 - t3.x, r2, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t2, x: e22, priorBreak: a2, badness: o2 };
      }
      function Rm(t2) {
        return t2 ? Rm(t2.priorBreak).concat(t2.index) : [];
      }
      function Lm(t2) {
        let e22 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e22 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e22 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e22, verticalAlign: r2 };
      }
      function Vm(t2, e22, r2, n2, i2) {
        if (!(e22 || r2 || n2 || i2))
          return;
        const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e22;
        for (let e3 = 0; e3 <= s2; e3++)
          t2[e3].x -= o2, t2[e3].y += r2 + n2 + i2;
      }
      function Om(t2, e22, r2, n2) {
        const { horizontalAlign: i2, verticalAlign: s2 } = Lm(n2), a2 = r2[0] - t2.displaySize[0] * i2, o2 = r2[1] - t2.displaySize[1] * s2;
        return { imagePrimary: t2, imageSecondary: e22, top: o2, bottom: o2 + t2.displaySize[1], left: a2, right: a2 + t2.displaySize[0] };
      }
      function Fm(t2, e22, r2, n2, i2, s2) {
        const a2 = t2.imagePrimary;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
        }
        const l2 = e22.left * s2, u2 = e22.right * s2;
        let c2, h22, p2, f2;
        "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h22 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h22 = f2 + a2.displaySize[0]);
        const d2 = e22.top * s2, m2 = e22.bottom * s2;
        return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + m2 + n2[2]) : (c2 = i2[1] + (d2 + m2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { imagePrimary: a2, imageSecondary: void 0, top: c2, right: h22, bottom: p2, left: f2, collisionPadding: o2 };
      }
      class jm extends x {
        constructor(t2, e22, r2, n2, i2) {
          super(t2, e22), this.angle = n2, this.z = r2, void 0 !== i2 && (this.segment = i2);
        }
        clone() {
          return new jm(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function Um(t2, e22, r2, n2, i2) {
        if (void 0 === e22.segment)
          return true;
        let s2 = e22, a2 = e22.segment + 1, o2 = 0;
        for (; o2 > -r2 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t2[a2].dist(s2), s2 = t2[a2];
        }
        o2 += t2[a2].dist(t2[a2 + 1]), a2++;
        const l2 = [];
        let u2 = 0;
        for (; o2 < r2 / 2; ) {
          const e3 = t2[a2], r3 = t2[a2 + 1];
          if (!r3)
            return false;
          let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
            u2 -= l2.shift().angleDelta;
          if (u2 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function Nm(t2) {
        let e22 = 0;
        for (let r2 = 0; r2 < t2.length - 1; r2++)
          e22 += t2[r2].dist(t2[r2 + 1]);
        return e22;
      }
      function $m(t2, e22, r2) {
        return t2 ? 0.6 * e22 * r2 : 0;
      }
      function qm(t2, e22) {
        return Math.max(t2 ? t2.right - t2.left : 0, e22 ? e22.right - e22.left : 0);
      }
      function Gm(t2, e22, r2, n2, i2, s2) {
        const a2 = $m(r2, i2, s2), o2 = qm(r2, n2) * s2;
        let l2 = 0;
        const u2 = Nm(t2) / 2;
        for (let r3 = 0; r3 < t2.length - 1; r3++) {
          const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
          if (l2 + s3 > u2) {
            const c2 = (u2 - l2) / s3, h22 = Mn(n3.x, i3.x, c2), p2 = Mn(n3.y, i3.y, c2), f2 = new jm(h22, p2, 0, i3.angleTo(n3), r3);
            return !a2 || Um(t2, f2, o2, a2, e22) ? f2 : void 0;
          }
          l2 += s3;
        }
      }
      function Ym(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = $m(n2, s2, a2), c2 = qm(n2, i2), h22 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
        return e22 - h22 < e22 / 4 && (e22 = h22 + e22 / 4), Zm(t2, p2 ? e22 / 2 * o2 % e22 : (c2 / 2 + 2 * s2) * a2 * o2 % e22, e22, u2, r2, h22, p2, false, l2);
      }
      function Zm(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = s2 / 2, c2 = Nm(t2);
        let h22 = 0, p2 = e22 - r2, f2 = [];
        for (let e3 = 0; e3 < t2.length - 1; e3++) {
          const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), m2 = o3.angleTo(a3);
          for (; p2 + r2 < h22 + d2; ) {
            p2 += r2;
            const y2 = (p2 - h22) / d2, g2 = Mn(a3.x, o3.x, y2), x2 = Mn(a3.y, o3.y, y2);
            if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
              const r3 = new jm(g2, x2, 0, m2, e3);
              n2 && !Um(t2, r3, s2, n2, i2) || f2.push(r3);
            }
          }
          h22 += d2;
        }
        return o2 || f2.length || a2 || (f2 = Zm(t2, h22 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
      }
      function Xm(t2, e22, r2, n2, i2) {
        const s2 = [];
        for (let a2 = 0; a2 < t2.length; a2++) {
          const o2 = t2[a2];
          let l2;
          for (let t3 = 0; t3 < o2.length - 1; t3++) {
            let a3 = o2[t3], u2 = o2[t3 + 1];
            a3.x < e22 && u2.x < e22 || (a3.x < e22 ? a3 = new x(e22, a3.y + (e22 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x < e22 && (u2 = new x(e22, a3.y + (e22 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y < r2 && u2.y < r2 || (a3.y < r2 ? a3 = new x(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round() : u2.y < r2 && (u2 = new x(a3.x + (r2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), r2)._round()), a3.x >= n2 && u2.x >= n2 || (a3.x >= n2 ? a3 = new x(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round() : u2.x >= n2 && (u2 = new x(n2, a3.y + (n2 - a3.x) / (u2.x - a3.x) * (u2.y - a3.y))._round()), a3.y >= i2 && u2.y >= i2 || (a3.y >= i2 ? a3 = new x(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round() : u2.y >= i2 && (u2 = new x(a3.x + (i2 - a3.y) / (u2.y - a3.y) * (u2.x - a3.x), i2)._round()), l2 && a3.equals(l2[l2.length - 1]) || (l2 = [a3], s2.push(l2)), l2.push(u2)))));
          }
        }
        return s2;
      }
      function Km(t2) {
        let e22 = 0, r2 = 0;
        for (const n3 of t2)
          e22 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
        t2.sort((t3, e3) => e3.h - t3.h);
        const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e22 / 0.95)), r2), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t2)
          for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e22 / (i2 * s2) || 0 };
      }
      Ks(jm, "Anchor");
      const Wm = 1;
      class Hm {
        constructor(t2, { pixelRatio: e22, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
          this.paddedRect = t2, this.pixelRatio = e22, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
        }
        get tl() {
          return [this.paddedRect.x + Wm, this.paddedRect.y + Wm];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - Wm, this.paddedRect.y + this.paddedRect.h - Wm];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * Wm) / this.pixelRatio, (this.paddedRect.h - 2 * Wm) / this.pixelRatio];
        }
      }
      class Jm {
        constructor(t2, e22) {
          const r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e22, n2, i2);
          const { w: s2, h: a2 } = Km(i2), o2 = new Qp({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t2) {
            const n3 = t2[e3], i3 = r2[e3].paddedRect;
            Qp.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + Wm, y: i3.y + Wm }, n3.data, n3.sdf);
          }
          for (const t3 in e22) {
            const r3 = e22[t3], i3 = n2[t3].paddedRect, s3 = i3.x + Wm, a3 = i3.y + Wm, l2 = r3.data.width, u2 = r3.data.height;
            Qp.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Qp.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Qp.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Qp.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Qp.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        }
        addImages(t2, e22, r2) {
          for (const n2 in t2) {
            const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * Wm, h: i2.data.height + 2 * Wm };
            r2.push(s2), e22[n2] = new Hm(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }
        patchUpdatedImages(t2, e22, r2) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3, r2)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks, r2);
          for (const n2 in t2.getUpdatedImages(r2))
            this.patchUpdatedImage(this.iconPositions[n2], t2.getImage(n2, r2), e22), this.patchUpdatedImage(this.patternPositions[n2], t2.getImage(n2, r2), e22);
        }
        patchUpdatedImage(t2, e22, r2) {
          if (!t2 || !e22)
            return;
          if (t2.version === e22.version)
            return;
          t2.version = e22.version;
          const [n2, i2] = t2.tl, s2 = !!Object.keys(this.patternPositions).length;
          r2.update(e22.data, { useMipmap: s2 }, { x: n2, y: i2 });
        }
      }
      Ks(Hm, "ImagePosition"), Ks(Jm, "ImageAtlas");
      const Qm = 1e20;
      function ty(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        for (let u2 = e22; u2 < e22 + n2; u2++)
          ey(t2, r2 * s2 + u2, s2, i2, a2, o2, l2);
        for (let u2 = r2; u2 < r2 + i2; u2++)
          ey(t2, u2 * s2 + e22, 1, n2, a2, o2, l2);
      }
      function ey(t2, e22, r2, n2, i2, s2, a2) {
        s2[0] = 0, a2[0] = -Qm, a2[1] = Qm, i2[0] = t2[e22];
        for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
          i2[o2] = t2[e22 + o2 * r2];
          const n3 = o2 * o2;
          do {
            const t3 = s2[l2];
            u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
          } while (u2 <= a2[l2] && --l2 > -1);
          l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = Qm;
        }
        for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
          for (; a2[l2 + 1] < o2; )
            l2++;
          const n3 = s2[l2], u2 = o2 - n3;
          t2[e22 + o2 * r2] = i2[n3] + u2 * u2;
        }
      }
      const ry = 2, ny = { none: 0, ideographs: 1, all: 2 };
      class iy {
        constructor(t2, e22, r2) {
          this.requestManager = t2, this.localGlyphMode = e22, this.localFontFamily = r2, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(t2, e22) {
          this.urls[e22] = t2;
        }
        getGlyphs(t2, e22, r2) {
          const i2 = [], s2 = this.urls[e22] || n.GLYPHS_URL;
          for (const e3 in t2)
            for (const r3 of t2[e3])
              i2.push({ stack: e3, id: r3 });
          z(i2, ({ stack: t3, id: e3 }, r3) => {
            let n2 = this.entries[t3];
            n2 || (n2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let i3 = n2.glyphs[e3];
            if (void 0 !== i3)
              return void r3(null, { stack: t3, id: e3, glyph: i3 });
            if (i3 = this._tinySDF(n2, t3, e3), i3)
              return n2.glyphs[e3] = i3, void r3(null, { stack: t3, id: e3, glyph: i3 });
            const a2 = Math.floor(e3 / 256);
            if (256 * a2 > 65535)
              return void r3(new Error("glyphs > 65535 not supported"));
            if (n2.ranges[a2])
              return void r3(null, { stack: t3, id: e3, glyph: i3 });
            let o2 = n2.requests[a2];
            o2 || (o2 = n2.requests[a2] = [], iy.loadGlyphRange(t3, a2, s2, this.requestManager, (t4, e4) => {
              if (e4) {
                n2.ascender = e4.ascender, n2.descender = e4.descender;
                for (const t5 in e4.glyphs)
                  this._doesCharSupportLocalGlyph(+t5) || (n2.glyphs[+t5] = e4.glyphs[+t5]);
                n2.ranges[a2] = true;
              }
              for (const r4 of o2)
                r4(t4, e4);
              delete n2.requests[a2];
            })), o2.push((n3, i4) => {
              n3 ? r3(n3) : i4 && r3(null, { stack: t3, id: e3, glyph: i4.glyphs[e3] || null });
            });
          }, (t3, e3) => {
            if (t3)
              r2(t3);
            else if (e3) {
              const t4 = {};
              for (const { stack: r3, id: n2, glyph: i3 } of e3)
                void 0 === t4[r3] && (t4[r3] = {}), void 0 === t4[r3].glyphs && (t4[r3].glyphs = {}), t4[r3].glyphs[n2] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t4[r3].ascender = this.entries[r3].ascender, t4[r3].descender = this.entries[r3].descender;
              r2(null, t4);
            }
          });
        }
        _doesCharSupportLocalGlyph(t2) {
          return this.localGlyphMode !== ny.none && (this.localGlyphMode === ny.all ? !!this.localFontFamily : !!this.localFontFamily && (ta["CJK Unified Ideographs"](t2) || ta["Hangul Syllables"](t2) || ta.Hiragana(t2) || ta.Katakana(t2) || ta["CJK Symbols and Punctuation"](t2) || ta["CJK Unified Ideographs Extension A"](t2) || ta["CJK Unified Ideographs Extension B"](t2)));
        }
        _tinySDF(t2, e22, r2) {
          const n2 = this.localFontFamily;
          if (!n2 || !this._doesCharSupportLocalGlyph(r2))
            return;
          let i2 = t2.tinySDF;
          if (!i2) {
            let r3 = "400";
            /bold/i.test(e22) ? r3 = "900" : /medium/i.test(e22) ? r3 = "500" : /light/i.test(e22) && (r3 = "200"), i2 = t2.tinySDF = new iy.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 24 * ry, buffer: 3 * ry, radius: 8 * ry }), i2.fontWeight = r3;
          }
          if (this.localGlyphs[i2.fontWeight][r2])
            return this.localGlyphs[i2.fontWeight][r2];
          const s2 = String.fromCodePoint(r2), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h22, glyphTop: p2, glyphAdvance: f2 } = i2.draw(s2);
          return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new Jp({ width: o2, height: l2 }, a2), metrics: { width: u2 / ry, height: c2 / ry, left: h22 / ry, top: p2 / ry - 27, advance: f2 / ry, localGlyph: true } };
        }
      }
      iy.loadGlyphRange = function(t2, e22, r2, n2, i2) {
        const s2 = 256 * e22, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), ct.Glyphs);
        dt(o2, (t3, e3) => {
          if (t3)
            i2(t3);
          else if (e3) {
            const t4 = {}, r3 = function(t5) {
              return new Cd(t5).readFields(bm, {});
            }(e3);
            for (const e4 of r3.glyphs)
              t4[e4.id] = e4;
            i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
          }
        });
      }, iy.TinySDF = class {
        constructor({ fontSize: t2 = 24, buffer: e22 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" } = {}) {
          this.buffer = e22, this.cutoff = n2, this.radius = r2;
          const o2 = this.size = t2 + 4 * e22, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
          u2.font = `${a2} ${s2} ${t2}px ${i2}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
        }
        _createCanvas(t2) {
          const e22 = document.createElement("canvas");
          return e22.width = e22.height = t2, e22;
        }
        draw(t2) {
          const { width: e22, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.ceil(r2), o2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, a2 + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h22 = Math.max(u2 * c2, 0), p2 = new Uint8ClampedArray(h22), f2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e22 };
          if (0 === o2 || 0 === l2)
            return f2;
          const { ctx: d2, buffer: m2, gridInner: y2, gridOuter: g2 } = this;
          d2.clearRect(m2, m2, o2, l2), d2.fillText(t2, m2, m2 + a2);
          const x2 = d2.getImageData(m2, m2, o2, l2);
          g2.fill(Qm, 0, h22), y2.fill(0, 0, h22);
          for (let t3 = 0; t3 < l2; t3++)
            for (let e3 = 0; e3 < o2; e3++) {
              const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
              if (0 === r3)
                continue;
              const n3 = (t3 + m2) * u2 + e3 + m2;
              if (1 === r3)
                g2[n3] = 0, y2[n3] = Qm;
              else {
                const t4 = 0.5 - r3;
                g2[n3] = t4 > 0 ? t4 * t4 : 0, y2[n3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
          ty(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), ty(y2, m2, m2, o2, l2, u2, this.f, this.v, this.z);
          for (let t3 = 0; t3 < h22; t3++) {
            const e3 = Math.sqrt(g2[t3]) - Math.sqrt(y2[t3]);
            p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return f2;
        }
      };
      const sy = Wm;
      function ay(t2, e22, r2, n2) {
        const i2 = [], s2 = t2.imagePrimary, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2 * sy, l2 = s2.paddedRect.h - 2 * sy, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h22 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, l2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h22.reduce(f2, 0), m2 = p2.reduce(f2, 0), y2 = o2 - d2, g2 = l2 - m2;
        let v2 = 0, b2 = d2, _2 = 0, w2 = m2, M2 = 0, A2 = y2, S2 = 0, I2 = g2;
        if (s2.content && n2) {
          const t3 = s2.content;
          v2 = oy(h22, 0, t3[0]), _2 = oy(p2, 0, t3[1]), b2 = oy(h22, t3[0], t3[2]), w2 = oy(p2, t3[1], t3[3]), M2 = t3[0] - v2, S2 = t3[1] - _2, A2 = t3[2] - t3[0] - b2, I2 = t3[3] - t3[1] - w2;
        }
        const k2 = (n3, i3, o3, l3) => {
          const h3 = uy(n3.stretch - v2, b2, u2, t2.left), p3 = cy(n3.fixed - M2, A2, n3.stretch, d2), f3 = uy(i3.stretch - _2, w2, c2, t2.top), y3 = cy(i3.fixed - S2, I2, i3.stretch, m2), g3 = uy(o3.stretch - v2, b2, u2, t2.left), k3 = cy(o3.fixed - M2, A2, o3.stretch, d2), T2 = uy(l3.stretch - _2, w2, c2, t2.top), P2 = cy(l3.fixed - S2, I2, l3.stretch, m2), z2 = new x(h3, f3), E2 = new x(g3, f3), B2 = new x(g3, T2), D2 = new x(h3, T2), C2 = new x(p3 / a2, y3 / a2), R2 = new x(k3 / a2, P2 / a2), L2 = e22 * Math.PI / 180;
          if (L2) {
            const t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
            z2._matMult(r3), E2._matMult(r3), D2._matMult(r3), B2._matMult(r3);
          }
          const V2 = n3.stretch + n3.fixed, O2 = o3.stretch + o3.fixed, F2 = i3.stretch + i3.fixed, j2 = l3.stretch + l3.fixed, U2 = t2.imageSecondary;
          return { tl: z2, tr: E2, bl: D2, br: B2, texPrimary: { x: s2.paddedRect.x + sy + V2, y: s2.paddedRect.y + sy + F2, w: O2 - V2, h: j2 - F2 }, texSecondary: U2 ? { x: U2.paddedRect.x + sy + V2, y: U2.paddedRect.y + sy + F2, w: O2 - V2, h: j2 - F2 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: C2, pixelOffsetBR: R2, minFontScaleX: A2 / a2 / u2, minFontScaleY: I2 / a2 / c2, isSDF: r2 };
        };
        if (n2 && (s2.stretchX || s2.stretchY)) {
          const t3 = ly(h22, y2, d2), e3 = ly(p2, g2, m2);
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], s3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              i2.push(k2(n3, e3[t4], s3, e3[t4 + 1]));
          }
        } else
          i2.push(k2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
        return i2;
      }
      function oy(t2, e22, r2) {
        let n2 = 0;
        for (const i2 of t2)
          n2 += Math.max(e22, Math.min(r2, i2[1])) - Math.max(e22, Math.min(r2, i2[0]));
        return n2;
      }
      function ly(t2, e22, r2) {
        const n2 = [{ fixed: -sy, stretch: 0 }];
        for (const [e3, r3] of t2) {
          const t3 = n2[n2.length - 1];
          n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n2.push({ fixed: e22 + sy, stretch: r2 }), n2;
      }
      function uy(t2, e22, r2, n2) {
        return t2 / e22 * r2 + n2;
      }
      function cy(t2, e22, r2, n2) {
        return t2 - e22 * r2 / n2;
      }
      function hy(t2, e22, r2, n2) {
        const i2 = e22 + t2.positionedLines[n2].lineOffset;
        return 0 === n2 ? r2 + i2 / 2 : r2 + (i2 + (e22 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
      }
      function py(t2, e22 = 1, r2 = false) {
        let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
        const o2 = t2[0];
        for (let t3 = 0; t3 < o2.length; t3++) {
          const e3 = o2[t3];
          (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
        }
        const l2 = Math.min(s2 - n2, a2 - i2);
        let u2 = l2 / 2;
        const c2 = new Dr([], fy);
        if (0 === l2)
          return new x(n2, i2);
        for (let e3 = n2; e3 < s2; e3 += l2)
          for (let r3 = i2; r3 < a2; r3 += l2)
            c2.push(new dy(e3 + u2, r3 + u2, u2, t2));
        let h22 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
            const s4 = i3[t4], o3 = i3[a3], l3 = s4.x * o3.y - o3.x * s4.y;
            r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new dy(r3 / e3, n3 / e3, 0, t3);
        }(t2), p2 = c2.length;
        for (; c2.length; ) {
          const n3 = c2.pop();
          (n3.d > h22.d || !h22.d) && (h22 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h22.d <= e22 || (u2 = n3.h / 2, c2.push(new dy(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new dy(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new dy(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new dy(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
        }
        return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h22.d}`)), h22.p;
      }
      function fy(t2, e22) {
        return e22.max - t2.max;
      }
      class dy {
        constructor(t2, e22, r2, n2) {
          this.p = new x(t2, e22), this.h = r2, this.d = function(t3, e3) {
            let r3 = false, n3 = 1 / 0;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s2 = e3[i2];
              for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                const i4 = s2[e4], o2 = s2[a2];
                i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Tp(t3, i4, o2));
              }
            }
            return (r3 ? 1 : -1) * Math.sqrt(n3);
          }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const my = 7, yy = Number.POSITIVE_INFINITY, gy = Math.sqrt(2);
      function xy(t2, [e22, r2]) {
        let n2 = 0, i2 = 0;
        if (r2 === yy) {
          e22 < 0 && (e22 = 0);
          const r3 = e22 / gy;
          switch (t2) {
            case "top-right":
            case "top-left":
              i2 = r3 - my;
              break;
            case "bottom-right":
            case "bottom-left":
              i2 = -r3 + my;
              break;
            case "bottom":
              i2 = -e22 + my;
              break;
            case "top":
              i2 = e22 - my;
          }
          switch (t2) {
            case "top-right":
            case "bottom-right":
              n2 = -r3;
              break;
            case "top-left":
            case "bottom-left":
              n2 = r3;
              break;
            case "left":
              n2 = e22;
              break;
            case "right":
              n2 = -e22;
          }
        } else {
          switch (e22 = Math.abs(e22), r2 = Math.abs(r2), t2) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - my;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = -r2 + my;
          }
          switch (t2) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e22;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e22;
          }
        }
        return [n2, i2];
      }
      function vy(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
        t2.createArrays(), t2.tilePixelRatio = Cr / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
        const h22 = t2.layers[0].layout, p2 = t2.layers[0]._unevaluatedLayout._values, f2 = {};
        if ("composite" === t2.textSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
          f2.compositeTextSizes = [p2["text-size"].possiblyEvaluate(new _a2(e3), o2), p2["text-size"].possiblyEvaluate(new _a2(r3), o2)];
        }
        if ("composite" === t2.iconSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
          f2.compositeIconSizes = [p2["icon-size"].possiblyEvaluate(new _a2(e3), o2), p2["icon-size"].possiblyEvaluate(new _a2(r3), o2)];
        }
        f2.layoutTextSize = p2["text-size"].possiblyEvaluate(new _a2(l2 + 1), o2), f2.layoutIconSize = p2["icon-size"].possiblyEvaluate(new _a2(l2 + 1), o2), f2.textMaxSize = p2["text-size"].possiblyEvaluate(new _a2(18), o2);
        const d2 = "map" === h22.get("text-rotation-alignment") && "point" !== h22.get("symbol-placement"), m2 = h22.get("text-size");
        let y2 = false;
        for (const e3 of t2.features)
          if (e3.icon && e3.icon.nameSecondary) {
            y2 = true;
            break;
          }
        for (const s3 of t2.features) {
          const l3 = h22.get("text-font").evaluate(s3, {}, o2).join(","), p3 = m2.evaluate(s3, {}, o2), g2 = f2.layoutTextSize.evaluate(s3, {}, o2), x2 = (f2.layoutIconSize.evaluate(s3, {}, o2), { horizontal: {}, vertical: void 0 }), v2 = s3.text;
          let b2, _2 = [0, 0];
          if (v2) {
            const n3 = v2.toString(), a3 = h22.get("text-letter-spacing").evaluate(s3, {}, o2) * um, u3 = h22.get("text-line-height").evaluate(s3, {}, o2) * um, c3 = ra(n3) ? a3 : 0, f3 = h22.get("text-anchor").evaluate(s3, {}, o2), m3 = h22.get("text-variable-anchor");
            if (!m3) {
              const t3 = h22.get("text-radial-offset").evaluate(s3, {}, o2);
              _2 = t3 ? xy(f3, [t3 * um, yy]) : h22.get("text-offset").evaluate(s3, {}, o2).map((t4) => t4 * um);
            }
            let y3 = d2 ? "center" : h22.get("text-justify").evaluate(s3, {}, o2);
            const b3 = "point" === h22.get("symbol-placement"), w3 = b3 ? h22.get("text-max-width").evaluate(s3, {}, o2) * um : 1 / 0, M3 = (s4) => {
              t2.allowVerticalPlacement && ea(n3) && (x2.vertical = Tm(v2, e22, r2, i2, l3, w3, u3, f3, s4, c3, _2, Am.vertical, true, g2, p3));
            };
            if (!d2 && m3) {
              const t3 = "auto" === y3 ? m3.map((t4) => by(t4)) : [y3];
              let n4 = false;
              for (let s4 = 0; s4 < t3.length; s4++) {
                const a4 = t3[s4];
                if (!x2.horizontal[a4])
                  if (n4)
                    x2.horizontal[a4] = x2.horizontal[0];
                  else {
                    const t4 = Tm(v2, e22, r2, i2, l3, w3, u3, "center", a4, c3, _2, Am.horizontal, false, g2, p3);
                    t4 && (x2.horizontal[a4] = t4, n4 = 1 === t4.positionedLines.length);
                  }
              }
              M3("left");
            } else {
              if ("auto" === y3 && (y3 = by(f3)), b3 || h22.get("text-writing-mode").indexOf("horizontal") >= 0 || !ea(n3)) {
                const t3 = Tm(v2, e22, r2, i2, l3, w3, u3, f3, y3, c3, _2, Am.horizontal, false, g2, p3);
                t3 && (x2.horizontal[y3] = t3);
              }
              M3(b3 ? "left" : y3);
            }
          }
          let w2 = false;
          if (s3.icon && s3.icon.namePrimary) {
            const e3 = n2[s3.icon.namePrimary];
            e3 && (b2 = Om(i2[s3.icon.namePrimary], s3.icon.nameSecondary ? i2[s3.icon.nameSecondary] : void 0, h22.get("icon-offset").evaluate(s3, {}, o2), h22.get("icon-anchor").evaluate(s3, {}, o2)), w2 = e3.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && q("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || 0 !== h22.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
          }
          const M2 = Sy(x2.horizontal) || x2.vertical;
          t2.iconsInText || (t2.iconsInText = !!M2 && M2.iconsInText), (M2 || b2) && _y(t2, s3, x2, b2, n2, f2, g2, 0, _2, w2, a2, o2, u2, c2, y2);
        }
        s2 && t2.generateCollisionDebugBuffers(l2, t2.collisionBoxArray);
      }
      function by(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function _y(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2) {
        let m2 = s2.textMaxSize.evaluate(e22, {}, h22);
        void 0 === m2 && (m2 = a2);
        const y2 = t2.layers[0].layout, g2 = y2.get("icon-offset").evaluate(e22, {}, h22), x2 = Sy(r2.horizontal) || r2.vertical, v2 = "globe" === p2.name, b2 = um, w2 = a2 / b2, M2 = t2.tilePixelRatio * m2 / b2, A2 = (B2 = t2.overscaling, t2.zoom > 18 && B2 > 2 && (B2 >>= 1), Math.max(Cr / (512 * B2), 1) * y2.get("symbol-spacing")), S2 = y2.get("text-padding") * t2.tilePixelRatio, I2 = y2.get("icon-padding") * t2.tilePixelRatio, k2 = _(y2.get("text-max-angle")), T2 = "map" === y2.get("text-rotation-alignment") && "point" !== y2.get("symbol-placement"), P2 = "map" === y2.get("icon-rotation-alignment") && "point" !== y2.get("symbol-placement"), z2 = y2.get("symbol-placement"), E2 = A2 / 2;
        var B2;
        const D2 = y2.get("icon-text-fit").evaluate(e22, {}, h22), C2 = y2.get("icon-text-fit-padding").evaluate(e22, {}, h22), R2 = "none" !== D2;
        let L2;
        false === t2.hasAnyIconTextFit && R2 && (t2.hasAnyIconTextFit = true), n2 && R2 && (t2.allowVerticalPlacement && r2.vertical && (L2 = Fm(n2, r2.vertical, D2, C2, g2, w2)), x2 && (n2 = Fm(n2, x2, D2, C2, g2, w2)));
        const V2 = (a3, o3, m3) => {
          if (o3.x < 0 || o3.x >= Cr || o3.y < 0 || o3.y >= Cr)
            return;
          let y3 = null;
          if (v2) {
            const { x: t3, y: e3, z: r3 } = p2.projectTilePoint(o3.x, o3.y, m3);
            y3 = { anchor: new jm(t3, e3, r3, 0, void 0), up: p2.upVector(m3, o3.x, o3.y) };
          }
          !function(t3, e3, r3, n3, i3, s3, a4, o4, l3, u3, c3, h3, p3, f3, d3, m4, y4, g3, x3, v3, b3, _2, w3, M3, A3, S3, I3) {
            const k3 = t3.addToLineVertexArray(e3, n3);
            let T3, P3, z3, E3, B3, D3, C3, R3 = 0, L3 = 0, V3 = 0, O2 = 0, F2 = -1, j2 = -1;
            const U2 = {};
            let N2 = $o("");
            const $2 = r3 ? r3.anchor : e3, G2 = "none" !== l3.layout.get("icon-text-fit").evaluate(b3, {}, A3);
            let Y2 = 0, Z2 = 0;
            if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [Y2, Z2] = l3.layout.get("text-offset").evaluate(b3, {}, A3).map((t4) => t4 * um) : (Y2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, A3) * um, Z2 = yy), t3.allowVerticalPlacement && i3.vertical) {
              const t4 = i3.vertical;
              if (d3)
                D3 = ky(t4), o4 && (C3 = ky(o4));
              else {
                const r4 = l3.layout.get("text-rotate").evaluate(b3, {}, A3) + 90;
                z3 = Iy(u3, $2, e3, c3, h3, p3, t4, f3, r4, m4), o4 && (E3 = Iy(u3, $2, e3, c3, h3, p3, o4, g3, r4));
              }
            }
            if (s3) {
              const n4 = l3.layout.get("icon-rotate").evaluate(b3, {}, A3), i4 = ay(s3, n4, w3, G2), a5 = o4 ? ay(o4, n4, w3, G2) : void 0;
              P3 = Iy(u3, $2, e3, c3, h3, p3, s3, g3, n4), R3 = 4 * i4.length;
              const f4 = t3.iconSizeData;
              let d4 = null;
              "source" === f4.kind ? (d4 = [cm * l3.layout.get("icon-size").evaluate(b3, {}, A3)], d4[0] > My && q(`${t3.layerIds[0]}: Value for "icon-size" is >= ${wy}. Reduce your "icon-size".`)) : "composite" === f4.kind && (d4 = [cm * _2.compositeIconSizes[0].evaluate(b3, {}, A3), cm * _2.compositeIconSizes[1].evaluate(b3, {}, A3)], (d4[0] > My || d4[1] > My) && q(`${t3.layerIds[0]}: Value for "icon-size" is >= ${wy}. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, i4, d4, v3, x3, b3, false, r3, e3, k3.lineStartIndex, k3.lineLength, -1, M3, A3, S3, I3), F2 = t3.icon.placedSymbolArray.length - 1, a5 && (L3 = 4 * a5.length, t3.addSymbols(t3.icon, a5, d4, v3, x3, b3, Am.vertical, r3, e3, k3.lineStartIndex, k3.lineLength, -1, M3, A3, S3, I3), j2 = t3.icon.placedSymbolArray.length - 1);
            }
            for (const n4 in i3.horizontal) {
              const s4 = i3.horizontal[n4];
              T3 || (N2 = $o(s4.text), d3 ? B3 = ky(s4) : T3 = Iy(u3, $2, e3, c3, h3, p3, s4, f3, l3.layout.get("text-rotate").evaluate(b3, {}, A3), m4));
              const o5 = 1 === s4.positionedLines.length;
              if (V3 += Ay(t3, r3, e3, s4, a4, l3, d3, b3, m4, k3, i3.vertical ? Am.horizontal : Am.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], U2, F2, _2, M3, A3, S3), o5)
                break;
            }
            i3.vertical && (O2 += Ay(t3, r3, e3, i3.vertical, a4, l3, d3, b3, m4, k3, Am.vertical, ["vertical"], U2, j2, _2, M3, A3, S3));
            let X2 = -1;
            const K2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
            X2 = K2(B3, X2), X2 = K2(D3, X2), X2 = K2(C3, X2);
            const W2 = X2 > -1 ? 1 : 0;
            t3.glyphOffsetArray.length >= fg.MAX_GLYPHS && q("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b3.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, $2.x, $2.y, $2.z, U2.right >= 0 ? U2.right : -1, U2.center >= 0 ? U2.center : -1, U2.left >= 0 ? U2.left : -1, U2.vertical >= 0 ? U2.vertical : -1, F2, j2, N2, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, void 0 !== z3 ? z3 : t3.collisionBoxArray.length, void 0 !== z3 ? z3 + 1 : t3.collisionBoxArray.length, void 0 !== P3 ? P3 : t3.collisionBoxArray.length, void 0 !== P3 ? P3 + 1 : t3.collisionBoxArray.length, E3 || t3.collisionBoxArray.length, E3 ? E3 + 1 : t3.collisionBoxArray.length, c3, V3, O2, R3, L3, W2, 0, Y2, Z2, X2, 0, G2 ? 1 : 0);
          }(t2, o3, y3, a3, r2, n2, i2, L2, t2.layers[0], t2.collisionBoxArray, e22.index, e22.sourceLayerIndex, t2.index, S2, T2, l2, 0, I2, P2, g2, e22, s2, u2, c2, h22, f2, d2);
        };
        if ("line" === z2)
          for (const i3 of Xm(e22.geometry, 0, 0, Cr, Cr)) {
            const e3 = Ym(i3, A2, k2, r2.vertical || x2, n2, b2, M2, t2.overscaling, Cr);
            for (const r3 of e3)
              x2 && Ty(t2, x2.text, E2, r3) || V2(i3, r3, h22);
          }
        else if ("line-center" === z2) {
          for (const t3 of e22.geometry)
            if (t3.length > 1) {
              const e3 = Gm(t3, k2, r2.vertical || x2, n2, b2, M2);
              e3 && V2(t3, e3, h22);
            }
        } else if ("Polygon" === e22.type)
          for (const t3 of Vf(e22.geometry, 0)) {
            const e3 = py(t3, 16);
            V2(t3[0], new jm(e3.x, e3.y, 0, 0, void 0), h22);
          }
        else if ("LineString" === e22.type)
          for (const t3 of e22.geometry)
            V2(t3, new jm(t3[0].x, t3[0].y, 0, 0, void 0), h22);
        else if ("Point" === e22.type)
          for (const t3 of e22.geometry)
            for (const e3 of t3)
              V2([e3], new jm(e3.x, e3.y, 0, 0, void 0), h22);
      }
      const wy = 255, My = wy * cm;
      function Ay(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2, y2, g2) {
        const v2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          const l3 = [];
          if (0 === e3.positionedLines.length)
            return l3;
          const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
            const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
            return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
          }(r3);
          let h3 = Math.abs(e3.top - e3.bottom);
          for (const t4 of e3.positionedLines)
            h3 -= t4.lineOffset;
          const p3 = e3.positionedLines.length, f3 = h3 / p3;
          let d3 = e3.top - r3[1];
          for (let t4 = 0; t4 < p3; ++t4) {
            const n4 = e3.positionedLines[t4];
            d3 = hy(e3, f3, d3, t4);
            for (const t5 of n4.positionedGlyphs) {
              if (!t5.rect)
                continue;
              const n5 = t5.rect || {};
              let s4 = Mm + 1, h4 = true, p4 = 1, f4 = 0;
              if (t5.imageName) {
                const e4 = a3[t5.imageName];
                if (!e4)
                  continue;
                if (e4.sdf) {
                  q("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                h4 = false, p4 = e4.pixelRatio, s4 = Wm / p4;
              }
              const m3 = (i3 || o3) && t5.vertical, y3 = t5.metrics.advance * t5.scale / 2, g3 = t5.metrics, v3 = t5.rect;
              if (null === v3)
                continue;
              o3 && e3.verticalizable && (f4 = t5.imageName ? y3 - t5.metrics.width * t5.scale / 2 : 0);
              const b3 = i3 ? [t5.x + y3, t5.y] : [0, 0];
              let _3 = [0, 0], w2 = [0, 0], M2 = false;
              i3 || (m3 ? (w2 = [t5.x + y3 + c3[0], t5.y + c3[1] - f4], M2 = true) : _3 = [t5.x + y3 + r3[0], t5.y + r3[1] - f4]);
              const A2 = v3.w * t5.scale / (p4 * (t5.localGlyph ? ry : 1)), S2 = v3.h * t5.scale / (p4 * (t5.localGlyph ? ry : 1));
              let I2, k2, T2, P2;
              if (m3) {
                const e4 = t5.y - d3, r4 = new x(-y3, y3 - e4), n6 = -Math.PI / 2, i4 = new x(...w2);
                I2 = new x(-y3 + _3[0], _3[1]), I2._rotateAround(n6, r4)._add(i4), I2.x += -e4 + y3, I2.y -= (g3.left - s4) * t5.scale;
                const a4 = t5.imageName ? g3.advance * t5.scale : um * t5.scale, o4 = String.fromCodePoint(t5.glyph);
                gm(o4) ? I2.x += (1 - s4) * t5.scale : xm(o4) ? I2.x += a4 - g3.height * t5.scale + (-s4 - 1) * t5.scale : I2.x += t5.imageName || g3.width + 2 * s4 === v3.w && g3.height + 2 * s4 === v3.h ? (a4 - S2) / 2 : (a4 - (g3.height + 2 * s4) * t5.scale) / 2, k2 = new x(I2.x, I2.y - A2), T2 = new x(I2.x + S2, I2.y), P2 = new x(I2.x + S2, I2.y - A2);
              } else {
                const e4 = (g3.left - s4) * t5.scale - y3 + _3[0], r4 = (-g3.top - s4) * t5.scale + _3[1], n6 = e4 + A2, i4 = r4 + S2;
                I2 = new x(e4, r4), k2 = new x(n6, r4), T2 = new x(e4, i4), P2 = new x(n6, i4);
              }
              if (u3) {
                let t6;
                t6 = i3 ? new x(0, 0) : M2 ? new x(c3[0], c3[1]) : new x(r3[0], r3[1]), I2._rotateAround(u3, t6), k2._rotateAround(u3, t6), T2._rotateAround(u3, t6), P2._rotateAround(u3, t6);
              }
              const z2 = new x(0, 0), E2 = new x(0, 0);
              l3.push({ tl: I2, tr: k2, bl: T2, br: P2, texPrimary: n5, texSecondary: void 0, writingMode: e3.writingMode, glyphOffset: b3, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: z2, pixelOffsetBR: E2, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return l3;
        }(0, n2, l2, s2, a2, o2, i2, t2.allowVerticalPlacement), b2 = t2.textSizeData;
        let _2 = null;
        "source" === b2.kind ? (_2 = [cm * s2.layout.get("text-size").evaluate(o2, {}, y2)], _2[0] > My && q(`${t2.layerIds[0]}: Value for "text-size" is >= ${wy}. Reduce your "text-size".`)) : "composite" === b2.kind && (_2 = [cm * d2.compositeTextSizes[0].evaluate(o2, {}, y2), cm * d2.compositeTextSizes[1].evaluate(o2, {}, y2)], (_2[0] > My || _2[1] > My) && q(`${t2.layerIds[0]}: Value for "text-size" is >= ${wy}. Reduce your "text-size".`)), t2.addSymbols(t2.text, v2, _2, l2, a2, o2, c2, e22, r2, u2.lineStartIndex, u2.lineLength, f2, m2, y2, g2, false);
        for (const e3 of h22)
          p2[e3] = t2.text.placedSymbolArray.length - 1;
        return 4 * v2.length;
      }
      function Sy(t2) {
        for (const e22 in t2)
          return t2[e22];
        return null;
      }
      function Iy(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2) {
        let c2 = a2.top, h22 = a2.bottom, p2 = a2.left, f2 = a2.right;
        const d2 = a2.collisionPadding;
        if (d2 && (p2 -= d2[0], c2 -= d2[1], f2 += d2[2], h22 += d2[3]), l2) {
          const t3 = new x(p2, c2), e3 = new x(f2, c2), r3 = new x(p2, h22), n3 = new x(f2, h22), i3 = _(l2);
          let s3 = new x(0, 0);
          u2 && (s3 = new x(u2[0], u2[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), c2 = Math.min(t3.y, e3.y, r3.y, n3.y), h22 = Math.max(t3.y, e3.y, r3.y, n3.y);
        }
        return t2.emplaceBack(e22.x, e22.y, e22.z, r2.x, r2.y, p2, c2, f2, h22, o2, n2, i2, s2), t2.length - 1;
      }
      function ky(t2) {
        t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
        const e22 = t2.bottom - t2.top;
        return e22 > 0 ? Math.max(10, e22) : null;
      }
      function Ty(t2, e22, r2, n2) {
        const i2 = t2.compareText;
        if (e22 in i2) {
          const t3 = i2[e22];
          for (let e3 = t3.length - 1; e3 >= 0; e3--)
            if (n2.dist(t3[e3]) < r2)
              return true;
        } else
          i2[e22] = [];
        return i2[e22].push(n2), false;
      }
      function Py(t2, e22) {
        const r2 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e22 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01)), a2 = Math.sin(t2._pitch) * s2 + i2;
        return Math.min(1.01 * a2, i2 * (1 / t2._horizonShift));
      }
      function zy(t2, e22) {
        if (!e22.isReprojectedInTileSpace)
          return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e22 };
        const r2 = Math.pow(2, -t2.z), n2 = t2.x * r2, i2 = (t2.x + 1) * r2, s2 = t2.y * r2, a2 = (t2.y + 1) * r2, o2 = tp(n2), l2 = tp(i2), u2 = ep(s2), c2 = ep(a2), h22 = e22.project(o2, u2), p2 = e22.project(l2, u2), f2 = e22.project(l2, c2), d2 = e22.project(o2, c2);
        let m2 = Math.min(h22.x, p2.x, f2.x, d2.x), y2 = Math.min(h22.y, p2.y, f2.y, d2.y), g2 = Math.max(h22.x, p2.x, f2.x, d2.x), x2 = Math.max(h22.y, p2.y, f2.y, d2.y);
        const v2 = r2 / 16;
        function b2(t3, r3, n3, i3, s3, a3) {
          const o3 = (n3 + s3) / 2, l3 = (i3 + a3) / 2, u3 = e22.project(tp(o3), ep(l3)), c3 = Math.max(0, m2 - u3.x, y2 - u3.y, u3.x - g2, u3.y - x2);
          m2 = Math.min(m2, u3.x), g2 = Math.max(g2, u3.x), y2 = Math.min(y2, u3.y), x2 = Math.max(x2, u3.y), c3 > v2 && (b2(t3, u3, n3, i3, o3, l3), b2(u3, r3, o3, l3, s3, a3));
        }
        b2(h22, p2, n2, s2, i2, s2), b2(p2, f2, i2, s2, i2, a2), b2(f2, d2, i2, a2, n2, a2), b2(d2, h22, n2, a2, n2, s2), m2 -= v2, y2 -= v2, g2 += v2, x2 += v2;
        const _2 = 1 / Math.max(g2 - m2, x2 - y2);
        return { scale: _2, x: m2 * _2, y: y2 * _2, x2: g2 * _2, y2: x2 * _2, projection: e22 };
      }
      function Ey(t2, { x: e22, y: r2 }, n2 = 0) {
        return new x(((e22 - n2) * t2.scale - t2.x) * Cr, (r2 * t2.scale - t2.y) * Cr);
      }
      const By = t.m.identity(new Float32Array(16));
      class Dy {
        constructor(t2) {
          this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(t2, e22) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(t2, e22) {
          return new Zh(0, 0);
        }
        projectTilePoint(t2, e22, r2) {
          return { x: t2, y: e22, z: 0 };
        }
        locationPoint(t2, e22, r2 = true) {
          return t2._coordinatePoint(t2.locationCoordinate(e22), r2);
        }
        pixelsPerMeter(t2, e22) {
          return Qh(1, t2) * e22;
        }
        pixelSpaceConversion(t2, e22, r2) {
          return 1;
        }
        farthestPixelDistance(t2) {
          return Py(t2, t2.pixelsPerMeter);
        }
        pointCoordinate(t2, e22, r2, n2) {
          const i2 = t2.horizonLineFromTop(false), s2 = new x(e22, Math.max(i2, r2));
          return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
        }
        pointCoordinate3D(t2, e22, r2) {
          const n2 = new x(e22, r2);
          if (t2.elevation)
            return t2.elevation.pointCoordinate(n2);
          {
            const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
            return [e3.x, e3.y, e3.z];
          }
        }
        isPointAboveHorizon(t2, e22) {
          if (t2.elevation)
            return !this.pointCoordinate3D(t2, e22.x, e22.y);
          const r2 = t2.horizonLineFromTop();
          return e22.y < r2;
        }
        createInversionMatrix(t2, e22) {
          return By;
        }
        createTileMatrix(e22, r2, n2) {
          let i2, s2, a2;
          const o2 = n2.canonical, l2 = t.m.identity(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const u2 = zy(o2, this);
            i2 = 1, s2 = u2.x + n2.wrap * u2.scale, a2 = u2.y, t.m.scale(l2, l2, [i2 / u2.scale, i2 / u2.scale, e22.pixelsPerMeter / r2]);
          } else
            i2 = r2 / e22.zoomScale(o2.z), s2 = (o2.x + Math.pow(2, o2.z) * n2.wrap) * i2, a2 = o2.y * i2;
          return t.m.translate(l2, l2, [s2, a2, 0]), t.m.scale(l2, l2, [i2 / Cr, i2 / Cr, 1]), l2;
        }
        upVector(t2, e22, r2) {
          return [0, 0, 1];
        }
        upVectorScale(t2, e22, r2) {
          return { metersToTile: 1 };
        }
      }
      class Cy extends Dy {
        constructor(t2) {
          super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
          const [e22, r2] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(_(e22));
          this.n = (n2 + Math.sin(_(r2))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(t2, e22) {
          const { n: r2, c: n2, r0: i2 } = this, s2 = _(t2 - this.center[0]), a2 = _(e22), o2 = Math.sqrt(n2 - 2 * r2 * Math.sin(a2)) / r2;
          return { x: o2 * Math.sin(s2 * r2), y: o2 * Math.cos(s2 * r2) - i2, z: 0 };
        }
        unproject(t2, e22) {
          const { n: r2, c: n2, r0: i2 } = this, s2 = i2 + e22;
          let a2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
          s2 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
          const o2 = _(this.center[0]) * r2;
          a2 = P(a2, -Math.PI - o2, Math.PI - o2);
          const l2 = k(w(a2 / r2) + this.center[0], -180, 180), u2 = Math.asin(k((n2 - (t2 * t2 + s2 * s2) * r2 * r2) / (2 * r2), -1, 1)), c2 = k(w(u2), -np, np);
          return new Zh(l2, c2);
        }
      }
      const Ry = 1.340264, Ly = -0.081106, Vy = 893e-6, Oy = 3796e-6, Fy = Math.sqrt(3) / 2;
      class jy extends Dy {
        project(t2, e22) {
          e22 = e22 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
          const r2 = Math.asin(Fy * Math.sin(e22)), n2 = r2 * r2, i2 = n2 * n2 * n2;
          return { x: 0.5 * (t2 * Math.cos(r2) / (Fy * (Ry + 3 * Ly * n2 + i2 * (7 * Vy + 9 * Oy * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (Ry + Ly * n2 + i2 * (Vy + Oy * n2)) / Math.PI + 1), z: 0 };
        }
        unproject(t2, e22) {
          t2 = (2 * t2 - 0.5) * Math.PI;
          let r2 = e22 = (2 * (1 - e22) - 1) * Math.PI, n2 = r2 * r2, i2 = n2 * n2 * n2;
          for (let t3, s3, a3, o3 = 0; o3 < 12 && (s3 = r2 * (Ry + Ly * n2 + i2 * (Vy + Oy * n2)) - e22, a3 = Ry + 3 * Ly * n2 + i2 * (7 * Vy + 9 * Oy * n2), t3 = s3 / a3, r2 = k(r2 - t3, -Math.PI / 3, Math.PI / 3), n2 = r2 * r2, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++o3)
            ;
          const s2 = Fy * t2 * (Ry + 3 * Ly * n2 + i2 * (7 * Vy + 9 * Oy * n2)) / Math.cos(r2), a2 = Math.asin(Math.sin(r2) / Fy), o2 = k(180 * s2 / Math.PI, -180, 180), l2 = k(180 * a2 / Math.PI, -np, np);
          return new Zh(o2, l2);
        }
      }
      class Uy extends Dy {
        constructor(t2) {
          super(t2), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t2, e22) {
          return { x: 0.5 + t2 / 360, y: 0.5 - e22 / 360, z: 0 };
        }
        unproject(t2, e22) {
          const r2 = 360 * (t2 - 0.5), n2 = k(360 * (0.5 - e22), -np, np);
          return new Zh(r2, n2);
        }
      }
      const Ny = Math.PI / 2;
      function $y(t2) {
        return Math.tan((Ny + t2) / 2);
      }
      class qy extends Dy {
        constructor(t2) {
          super(t2), this.center = t2.center || [0, 30];
          const [e22, r2] = this.parallels = t2.parallels || [30, 30];
          let n2 = _(e22), i2 = _(r2);
          this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
          const s2 = Math.cos(n2), a2 = $y(n2);
          this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log($y(i2) / a2), this.f = s2 * Math.pow($y(n2), this.n) / this.n;
        }
        project(t2, e22) {
          e22 = _(e22), this.southernCenter && (e22 = -e22), t2 = _(t2 - this.center[0]);
          const r2 = 1e-6, { n: n2, f: i2 } = this;
          i2 > 0 ? e22 < -Ny + r2 && (e22 = -Ny + r2) : e22 > Ny - r2 && (e22 = Ny - r2);
          const s2 = i2 / Math.pow($y(e22), n2);
          let a2 = s2 * Math.sin(n2 * t2), o2 = i2 - s2 * Math.cos(n2 * t2);
          return a2 = 0.5 * (a2 / Math.PI + 0.5), o2 = 0.5 * (o2 / Math.PI + 0.5), { x: a2, y: this.southernCenter ? o2 : 1 - o2, z: 0 };
        }
        unproject(t2, e22) {
          t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e22 = 1 - e22), e22 = (2 * (1 - e22) - 0.5) * Math.PI;
          const { n: r2, f: n2 } = this, i2 = n2 - e22, s2 = Math.sign(i2), a2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
          let o2 = Math.atan2(t2, Math.abs(i2)) * s2;
          i2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * s2);
          const l2 = k(w(o2 / r2) + this.center[0], -180, 180), u2 = k(w(2 * Math.atan(Math.pow(n2 / a2, 1 / r2)) - Ny), -np, np);
          return new Zh(l2, this.southernCenter ? -u2 : u2);
        }
      }
      class Gy extends Dy {
        constructor(t2) {
          super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
        }
        project(t2, e22) {
          return { x: Hh(t2), y: Jh(e22), z: 0 };
        }
        unproject(t2, e22) {
          const r2 = tp(t2), n2 = ep(e22);
          return new Zh(r2, n2);
        }
      }
      const Yy = _(np);
      class Zy extends Dy {
        project(t2, e22) {
          const r2 = (e22 = _(e22)) * e22, n2 = r2 * r2;
          return { x: 0.5 * ((t2 = _(t2)) * (0.8707 - 0.131979 * r2 + n2 * (n2 * (3971e-6 * r2 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e22 * (1.007226 + r2 * (0.015085 + n2 * (0.028874 * r2 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
        }
        unproject(t2, e22) {
          t2 = (2 * t2 - 0.5) * Math.PI;
          let r2 = e22 = (2 * (1 - e22) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r2 * r2;
          do {
            s2 = r2 * r2;
            const t3 = s2 * s2;
            i2 = (r2 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e22) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r2 = k(r2 - i2, -Yy, Yy);
          } while (Math.abs(i2) > 1e-6 && --n2 > 0);
          s2 = r2 * r2;
          const a2 = k(w(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), o2 = w(r2);
          return new Zh(a2, o2);
        }
      }
      const Xy = _(np);
      class Ky extends Dy {
        project(t2, e22) {
          e22 = _(e22), t2 = _(t2);
          const r2 = Math.cos(e22), n2 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, a2 = 0.5 * (t2 * n2 + 2 * r2 * Math.sin(t2 / 2) / s2) || 0, o2 = 0.5 * (e22 + Math.sin(e22) / s2) || 0;
          return { x: 0.5 * (a2 / Math.PI + 0.5), y: 1 - 0.5 * (o2 / Math.PI + 1), z: 0 };
        }
        unproject(t2, e22) {
          let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e22 = (2 * (1 - e22) - 1) * Math.PI, i2 = 25;
          const s2 = 1e-6;
          let a2 = 0, o2 = 0;
          do {
            const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u2 = s3 * s3, c2 = i3 * i3, h22 = Math.cos(r2 / 2), p2 = Math.sin(r2 / 2), f2 = 2 * h22 * p2, d2 = p2 * p2, m2 = 1 - c2 * h22 * h22, y2 = m2 ? 1 / m2 : 0, g2 = m2 ? Math.acos(i3 * h22) * Math.sqrt(1 / m2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r2 / Math.PI) - t2, v2 = 0.5 * (g2 * s3 + n2) - e22, b2 = 0.5 * y2 * (c2 * d2 + g2 * i3 * h22 * u2) + 1 / Math.PI, _2 = y2 * (f2 * l2 / 4 - g2 * s3 * p2), w2 = 0.125 * y2 * (l2 * p2 - g2 * s3 * c2 * f2), M2 = 0.5 * y2 * (u2 * h22 + g2 * d2 * i3) + 0.5, A2 = _2 * w2 - M2 * b2;
            a2 = (v2 * _2 - x2 * M2) / A2, o2 = (x2 * w2 - v2 * b2) / A2, r2 = k(r2 - a2, -Math.PI, Math.PI), n2 = k(n2 - o2, -Xy, Xy);
          } while ((Math.abs(a2) > s2 || Math.abs(o2) > s2) && --i2 > 0);
          return new Zh(w(r2), w(n2));
        }
      }
      class Wy extends Dy {
        constructor(t2) {
          super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(_(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
        }
        project(t2, e22) {
          const { scale: r2, cosPhi: n2 } = this;
          return { x: _(t2) * n2 * r2 + 0.5, y: -Math.sin(_(e22)) / n2 * r2 + 0.5, z: 0 };
        }
        unproject(t2, e22) {
          const { scale: r2, cosPhi: n2 } = this, i2 = -(e22 - 0.5) / r2, s2 = k(w((t2 - 0.5) / r2) / n2, -180, 180), a2 = Math.asin(k(i2 * n2, -1, 1)), o2 = k(w(a2), -np, np);
          return new Zh(s2, o2);
        }
      }
      class Hy extends Gy {
        constructor(t2) {
          super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(e22, r2, n2) {
          const i2 = zh(e22, r2, n2), s2 = Dh(_h(n2));
          return t.v.transformMat4(i2, i2, s2), { x: i2[0], y: i2[1], z: i2[2] };
        }
        locationPoint(e22, r2) {
          const n2 = Ph(r2.lat, r2.lng), i2 = t.v.normalize([], n2), s2 = e22.elevation ? e22.elevation.getAtPointOrZero(e22.locationCoordinate(r2), e22._centerAltitude) : e22._centerAltitude, a2 = Qh(1, 0) * Cr * s2;
          t.v.scaleAndAdd(n2, n2, i2, a2);
          const o2 = t.m.identity(new Float64Array(16));
          return t.m.multiply(o2, e22.pixelMatrix, e22.globeMatrix), t.v.transformMat4(n2, n2, o2), new x(n2[0], n2[1]);
        }
        pixelsPerMeter(t2, e22) {
          return Qh(1, 0) * e22;
        }
        pixelSpaceConversion(t2, e22, r2) {
          const n2 = Qh(1, t2) * e22, i2 = Mn(Qh(1, 45) * e22, n2, r2);
          return this.pixelsPerMeter(t2, e22) / i2;
        }
        createTileMatrix(e22, r2, n2) {
          const i2 = Ch(_h(n2.canonical));
          return t.m.multiply(new Float64Array(16), e22.globeMatrix, i2);
        }
        createInversionMatrix(e22, r2) {
          const { center: n2 } = e22, i2 = Dh(_h(r2));
          return t.m.rotateY(i2, i2, _(n2.lng)), t.m.rotateX(i2, i2, _(n2.lat)), t.m.scale(i2, i2, [e22._pixelsPerMercatorPixel, e22._pixelsPerMercatorPixel, 1]), Float32Array.from(i2);
        }
        pointCoordinate(t2, e22, r2, n2) {
          return xh(t2, e22, r2, true) || new lp(0, 0);
        }
        pointCoordinate3D(t2, e22, r2) {
          const n2 = this.pointCoordinate(t2, e22, r2, 0);
          return [n2.x, n2.y, n2.z];
        }
        isPointAboveHorizon(t2, e22) {
          return !xh(t2, e22.x, e22.y, false);
        }
        farthestPixelDistance(e22) {
          const r2 = function(e3, r3) {
            const n3 = e3.cameraToCenterDistance, i2 = e3._centerAltitude * r3, s2 = e3._camera, a2 = e3._camera.forward(), o2 = t.v.add([], t.v.scale([], a2, -n3), [0, 0, i2]), l2 = e3.worldSize / (2 * Math.PI), u2 = [0, 0, -l2], c2 = e3.width / e3.height, h22 = Math.tan(e3.fovAboveCenter), p2 = t.v.scale([], s2.up(), h22), f2 = t.v.scale([], s2.right(), h22 * c2), d2 = t.v.normalize([], t.v.add([], t.v.add([], a2, p2), f2)), m2 = [];
            let y2;
            if (new th(o2, d2).closestPointOnSphere(u2, l2, m2)) {
              const r4 = t.v.add([], m2, u2), n4 = t.v.sub([], r4, o2);
              y2 = Math.cos(e3.fovAboveCenter) * t.v.length(n4);
            } else {
              const e4 = t.v.sub([], o2, u2), r4 = t.v.sub([], u2, o2);
              t.v.normalize(r4, r4);
              const n4 = t.v.length(e4) - l2;
              y2 = Math.sqrt(n4 * (n4 + 2 * l2));
              const i3 = Math.acos(y2 / (l2 + n4)) - Math.acos(t.v.dot(a2, r4));
              y2 *= Math.cos(i3);
            }
            return 1.01 * y2;
          }(e22, this.pixelsPerMeter(e22.center.lat, e22.worldSize)), n2 = Oh(e22.zoom);
          if (n2 > 0) {
            const t2 = Py(e22, Qh(1, e22.center.lat) * e22.worldSize), i2 = e22.worldSize / (2 * Math.PI), s2 = Math.max(e22.width, e22.height) / e22.worldSize * Math.PI;
            return Mn(r2, t2 + i2 * (1 - Math.cos(s2)), Math.pow(n2, 10));
          }
          return r2;
        }
        upVector(t2, e22, r2) {
          return zh(e22, r2, t2, 1);
        }
        upVectorScale(t2) {
          return { metersToTile: gh(Eh(_h(t2))) };
        }
      }
      function Jy(t2) {
        const e22 = t2.parallels, r2 = !!e22 && Math.abs(e22[0] + e22[1]) < 0.01;
        switch (t2.name) {
          case "mercator":
            return new Gy(t2);
          case "equirectangular":
            return new Uy(t2);
          case "naturalEarth":
            return new Zy(t2);
          case "equalEarth":
            return new jy(t2);
          case "winkelTripel":
            return new Ky(t2);
          case "albers":
            return r2 ? new Wy(t2) : new Cy(t2);
          case "lambertConformalConic":
            return r2 ? new Wy(t2) : new qy(t2);
          case "globe":
            return new Hy(t2);
        }
        throw new Error(`Invalid projection name: ${t2.name}`);
      }
      const Qy = new Da({ "symbol-placement": new za(re2.layout_symbol["symbol-placement"]), "symbol-spacing": new za(re2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new za(re2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ea(re2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new za(re2.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new za(re2.layout_symbol["symbol-z-elevate"]), "icon-allow-overlap": new za(re2.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new za(re2.layout_symbol["icon-ignore-placement"]), "icon-optional": new za(re2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new za(re2.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ea(re2.layout_symbol["icon-size"]), "icon-text-fit": new Ea(re2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ea(re2.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ea(re2.layout_symbol["icon-image"]), "icon-rotate": new Ea(re2.layout_symbol["icon-rotate"]), "icon-padding": new za(re2.layout_symbol["icon-padding"]), "icon-keep-upright": new za(re2.layout_symbol["icon-keep-upright"]), "icon-offset": new Ea(re2.layout_symbol["icon-offset"]), "icon-anchor": new Ea(re2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new za(re2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new za(re2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new za(re2.layout_symbol["text-rotation-alignment"]), "text-field": new Ea(re2.layout_symbol["text-field"]), "text-font": new Ea(re2.layout_symbol["text-font"]), "text-size": new Ea(re2.layout_symbol["text-size"]), "text-max-width": new Ea(re2.layout_symbol["text-max-width"]), "text-line-height": new Ea(re2.layout_symbol["text-line-height"]), "text-letter-spacing": new Ea(re2.layout_symbol["text-letter-spacing"]), "text-justify": new Ea(re2.layout_symbol["text-justify"]), "text-radial-offset": new Ea(re2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new za(re2.layout_symbol["text-variable-anchor"]), "text-anchor": new Ea(re2.layout_symbol["text-anchor"]), "text-max-angle": new za(re2.layout_symbol["text-max-angle"]), "text-writing-mode": new za(re2.layout_symbol["text-writing-mode"]), "text-rotate": new Ea(re2.layout_symbol["text-rotate"]), "text-padding": new za(re2.layout_symbol["text-padding"]), "text-keep-upright": new za(re2.layout_symbol["text-keep-upright"]), "text-transform": new Ea(re2.layout_symbol["text-transform"]), "text-offset": new Ea(re2.layout_symbol["text-offset"]), "text-allow-overlap": new za(re2.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new za(re2.layout_symbol["text-ignore-placement"]), "text-optional": new za(re2.layout_symbol["text-optional"]), visibility: new za(re2.layout_symbol.visibility) });
      var tg = { paint: new Da({ "icon-opacity": new Ea(re2.paint_symbol["icon-opacity"]), "icon-emissive-strength": new Ea(re2.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new Ea(re2.paint_symbol["text-emissive-strength"]), "icon-color": new Ea(re2.paint_symbol["icon-color"]), "icon-halo-color": new Ea(re2.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ea(re2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ea(re2.paint_symbol["icon-halo-blur"]), "icon-translate": new za(re2.paint_symbol["icon-translate"]), "icon-translate-anchor": new za(re2.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Ea(re2.paint_symbol["icon-image-cross-fade"]), "text-opacity": new Ea(re2.paint_symbol["text-opacity"]), "text-color": new Ea(re2.paint_symbol["text-color"], { runtimeType: ye, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Ea(re2.paint_symbol["text-halo-color"]), "text-halo-width": new Ea(re2.paint_symbol["text-halo-width"]), "text-halo-blur": new Ea(re2.paint_symbol["text-halo-blur"]), "text-translate": new za(re2.paint_symbol["text-translate"]), "text-translate-anchor": new za(re2.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new za(re2.paint_symbol["icon-color-saturation"]) }), layout: Qy };
      class eg {
        constructor(t2) {
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : pe, this.defaultValue = t2;
        }
        evaluate(t2) {
          if (t2.formattedSection) {
            const e22 = this.defaultValue.property.overrides;
            if (e22 && e22.hasOverride(t2.formattedSection))
              return e22.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      Ks(eg, "FormatSectionOverride", { omit: ["defaultValue"] });
      class rg extends Va {
        constructor(t2, e22, r2) {
          super(t2, tg, e22, r2);
        }
        recalculate(t2, e22) {
          super.recalculate(t2, e22), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const r2 = this.layout.get("text-writing-mode");
          if (r2) {
            const t3 = [];
            for (const e3 of r2)
              t3.indexOf(e3) < 0 && t3.push(e3);
            this.layout._values["text-writing-mode"] = t3;
          } else
            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t2, e22, r2, n2) {
          const i2 = this.layout.get(t2).evaluate(e22, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
          return s2.isDataDriven() || Zi(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
          }(e22.properties, i2);
        }
        createBucket(t2) {
          return new fg(t2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const t2 of tg.paint.overridableProperties) {
            if (!rg.hasPaintOverride(this.layout, t2))
              continue;
            const e22 = this.paint.get(t2), r2 = new eg(e22), n2 = new Yi(r2, e22.property.specification, this.scope, this.options);
            let i2 = null;
            i2 = "constant" === e22.value.kind || "source" === e22.value.kind ? new Ki("source", n2) : new Wi("composite", n2, e22.value.zoomStops, e22.value._interpolationType), this.paint._values[t2] = new Ta(e22.property, i2, e22.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t2, e22, r2) {
          return !(!this.layout || e22.isDataDriven() || r2.isDataDriven()) && rg.hasPaintOverride(this.layout, t2);
        }
        static hasPaintOverride(t2, e22) {
          const r2 = t2.get("text-field"), n2 = tg.paint.properties[e22];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n2.overrides && n2.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if ("constant" === r2.value.kind && r2.value.value instanceof Oe)
            s2(r2.value.value.sections);
          else if ("source" === r2.value.kind) {
            const t3 = (e4) => {
              i2 || (e4 instanceof Ge && Ne(e4.value) === be ? s2(e4.value.sections) : e4 instanceof We ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r2.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
        getProgramIds() {
          const t2 = 0 !== this.paint.get("icon-opacity").constantOr(1), e22 = 0 !== this.paint.get("text-opacity").constantOr(1), r2 = [];
          return t2 && r2.push("symbolIcon"), e22 && r2.push("symbolSDF"), r2;
        }
        getDefaultProgramParams(t2, e22) {
          return { config: new pl(this, e22), overrideFog: false };
        }
      }
      const ng = ud.types, ig = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function sg(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2) {
        const f2 = o2 ? Math.min(My, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(My, Math.round(o2[1])) : 0;
        t2.emplaceBack(e22, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h22, 256 * p2);
      }
      function ag(t2, e22, r2) {
        t2.emplaceBack(e22, r2);
      }
      function og(t2, e22, r2, n2, i2, s2, a2) {
        t2.emplaceBack(e22, r2, n2, i2, s2, a2);
      }
      function lg(t2, e22, r2, n2, i2) {
        t2.emplaceBack(e22, r2, n2, i2), t2.emplaceBack(e22, r2, n2, i2), t2.emplaceBack(e22, r2, n2, i2), t2.emplaceBack(e22, r2, n2, i2);
      }
      function ug(t2) {
        for (const e22 of t2.sections)
          if (la(e22.text))
            return true;
        return false;
      }
      class cg {
        constructor(t2) {
          this.layoutVertexArray = new Ja(), this.indexArray = new ao(), this.programConfigurations = t2, this.segments = new Do(), this.dynamicLayoutVertexArray = new Xa(), this.opacityVertexArray = new to2(), this.placedSymbolArray = new Mo(), this.iconTransitioningVertexArray = new eo(), this.globeExtVertexArray = new Qa(), this.zOffsetVertexArray = new uo();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
        }
        upload(t2, e22, r2, n2, i2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, tm.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e22), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, rm.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, ig, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t2.createVertexBuffer(this.iconTransitioningVertexArray, im.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, em.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i2) && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, nm.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      Ks(cg, "SymbolBuffers");
      class hg {
        constructor(t2, e22, r2) {
          this.layoutVertexArray = new t2(), this.layoutAttributes = e22, this.indexArray = new r2(), this.segments = new Do(), this.collisionVertexArray = new so(), this.collisionVertexArrayExt = new Xa();
        }
        upload(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, sm.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, am.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Ks(hg, "CollisionBuffers");
      class pg {
        constructor(e22) {
          this.collisionBoxArray = e22.collisionBoxArray, this.zoom = e22.zoom, this.overscaling = e22.overscaling, this.layers = e22.layers, this.layerIds = this.layers.map((t2) => t2.fqid), this.index = e22.index, this.pixelRatio = e22.pixelRatio, this.sourceLayerIndex = e22.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = t.m.identity([]), this.placementViewportMatrix = t.m.identity([]);
          const r2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = hm(this.zoom, r2["text-size"]), this.iconSizeData = hm(this.zoom, r2["icon-size"]);
          const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
          this.canOverlap = n2.get("text-allow-overlap") || n2.get("icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && void 0 !== i2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = n2.get("text-writing-mode").map((t2) => Am[t2]), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e22.sourceID, this.projection = e22.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = n2.get("symbol-z-elevate");
        }
        createArrays() {
          this.text = new cg(new fl(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new cg(new fl(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Io(), this.lineVertexArray = new ko(), this.symbolInstances = new So();
        }
        calculateGlyphDependencies(t2, e22, r2, n2, i2) {
          for (let r3 = 0; r3 < t2.length; r3++) {
            const s2 = t2.codePointAt(r3);
            if (void 0 === s2)
              break;
            if (e22[s2] = true, n2 && i2 && s2 <= 65535) {
              const n3 = ym[t2.charAt(r3)];
              n3 && (e22[n3.charCodeAt(0)] = true);
            }
          }
        }
        populate(e22, r2, n2, i2) {
          const s2 = this.layers[0], a2 = s2.layout, o2 = "globe" === this.projection.name, l2 = a2.get("text-font"), u2 = a2.get("text-field"), c2 = a2.get("icon-image"), h22 = ("constant" !== u2.value.kind || u2.value.value instanceof Oe && !u2.value.value.isEmpty() || u2.value.value.toString().length > 0) && ("constant" !== l2.value.kind || l2.value.value.length > 0), p2 = "constant" !== c2.value.kind || !!c2.value.value || Object.keys(c2.parameters).length > 0, f2 = a2.get("symbol-sort-key");
          if (this.features = [], !h22 && !p2)
            return;
          const d2 = r2.iconDependencies, m2 = r2.glyphDependencies, y2 = r2.availableImages, g2 = new _a2(this.zoom);
          for (const { feature: r3, id: u3, index: c3, sourceLayerIndex: x2 } of e22) {
            const e3 = s2._featureFilter.needGeometry, v2 = gp(r3, e3);
            if (!s2._featureFilter.filter(g2, v2, n2))
              continue;
            if (e3 || (v2.geometry = yp(r3, n2, i2)), o2 && 1 !== r3.type && n2.z <= 5) {
              const e4 = v2.geometry, r4 = 0.98078528056, i3 = (e52, i4) => {
                const s3 = zh(e52.x, e52.y, n2, 1), a3 = zh(i4.x, i4.y, n2, 1);
                return t.v.dot(s3, a3) < r4;
              };
              for (let t2 = 0; t2 < e4.length; t2++)
                e4[t2] = pp(e4[t2], i3);
            }
            let b2, _2;
            if (h22) {
              const t2 = s2.getValueAndResolveTokens("text-field", v2, n2, y2), e4 = Oe.factory(t2);
              ug(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === xa() || this.hasRTLText && ba.isParsed()) && (b2 = mm(e4, s2, v2));
            }
            if (p2) {
              const t2 = s2.getValueAndResolveTokens("icon-image", v2, n2, y2);
              _2 = t2 instanceof Fe ? t2 : Fe.fromString(t2);
            }
            if (!b2 && !_2)
              continue;
            const w2 = this.sortFeaturesByKey ? f2.evaluate(v2, {}, n2) : void 0;
            if (this.features.push({ id: u3, text: b2, icon: _2, index: c3, sourceLayerIndex: x2, geometry: v2.geometry, properties: r3.properties, type: ng[r3.type], sortKey: w2 }), _2 && (d2[_2.namePrimary] = true, _2.nameSecondary && (d2[_2.nameSecondary] = true)), b2) {
              const t2 = l2.evaluate(v2, {}, n2).join(","), e4 = "map" === a2.get("text-rotation-alignment") && "point" !== a2.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Am.vertical) >= 0;
              for (const r4 of b2.sections)
                if (r4.image)
                  d2[r4.image.namePrimary] = true;
                else {
                  const n3 = ea(b2.toString()), i3 = r4.fontStack || t2, s3 = m2[i3] = m2[i3] || {};
                  this.calculateGlyphDependencies(r4.text, s3, e4, this.allowVerticalPlacement, n3);
                }
            }
          }
          "line" === a2.get("symbol-placement") && (this.features = function(t2) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t2[e4]), i3++;
            }
            function a3(t3, e4, i4) {
              const s4 = r3[t3];
              return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t3, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t3, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t3}:${n4.x}:${n4.y}`;
            }
            for (let u3 = 0; u3 < t2.length; u3++) {
              const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
              } else
                f3 in r3 ? a3(f3, d3, h3) : d3 in e3 ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t3) => t3.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
        }
        update(t2, e22, r2, n2, i2) {
          const s2 = 0 !== Object.keys(t2).length;
          if (s2 && !this.stateDependentLayers.length)
            return;
          const a2 = s2 ? this.stateDependentLayers : this.layers;
          this.text.programConfigurations.updatePaintArrays(t2, e22, a2, r2, n2, i2), this.icon.programConfigurations.updatePaintArrays(t2, e22, a2, r2, n2, i2);
        }
        updateZOffset() {
          const t2 = (t3, e3, n3) => {
            r2 += e3, r2 > t3.length && t3.resize(r2);
            for (let i2 = -e3; i2 < 0; i2++)
              t3.emplace(i2 + r2, n3);
          }, e22 = (t3, e3, r3) => {
            n2 += e3, n2 > t3.length && t3.resize(n2);
            for (let i2 = -e3; i2 < 0; i2++)
              t3.emplace(i2 + n2, r3);
          };
          if (!this.zOffsetBuffersNeedUpload)
            return;
          this.zOffsetBuffersNeedUpload = false;
          let r2 = 0, n2 = 0;
          for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
            const n3 = this.symbolInstances.get(r3), { numHorizontalGlyphVertices: i2, numVerticalGlyphVertices: s2, numIconVertices: a2 } = n3, o2 = n3.zOffset, l2 = a2 > 0;
            if ((i2 > 0 || s2 > 0) && (t2(this.text.zOffsetVertexArray, i2, o2), t2(this.text.zOffsetVertexArray, s2, o2)), l2) {
              const { placedIconSymbolIndex: t3, verticalPlacedIconSymbolIndex: r4 } = n3;
              t3 >= 0 && e22(this.icon.zOffsetVertexArray, a2, o2), r4 >= 0 && e22(this.icon.zOffsetVertexArray, n3.numVerticalIconVertices, o2);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = Jy(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t2, e22) {
          const r2 = this.lineVertexArray.length;
          if (void 0 !== t2.segment)
            for (const { x: t3, y: r3 } of e22)
              this.lineVertexArray.emplaceBack(t3, r3);
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }
        addSymbols(t2, e22, r2, n2, i2, s2, a2, o2, l2, u2, c2, h22, p2, f2, d2, m2) {
          const y2 = t2.indexArray, g2 = t2.layoutVertexArray, x2 = t2.globeExtVertexArray, v2 = t2.segments.prepareSegment(4 * e22.length, g2, y2, this.canOverlap ? s2.sortKey : void 0), b2 = this.glyphOffsetArray.length, _2 = v2.vertexLength, w2 = this.allowVerticalPlacement && a2 === Am.vertical ? Math.PI / 2 : 0, M2 = s2.text && s2.text.sections;
          for (let n3 = 0; n3 < e22.length; n3++) {
            const { tl: i3, tr: a3, bl: u3, br: c3, texPrimary: h3, texSecondary: b3, pixelOffsetTL: _3, pixelOffsetBR: A3, minFontScaleX: S2, minFontScaleY: I2, glyphOffset: k2, isSDF: T2, sectionIndex: P2 } = e22[n3], z2 = v2.vertexLength, E2 = k2[1];
            if (sg(g2, l2.x, l2.y, i3.x, E2 + i3.y, h3.x, h3.y, r2, T2, _3.x, _3.y, S2, I2), sg(g2, l2.x, l2.y, a3.x, E2 + a3.y, h3.x + h3.w, h3.y, r2, T2, A3.x, _3.y, S2, I2), sg(g2, l2.x, l2.y, u3.x, E2 + u3.y, h3.x, h3.y + h3.h, r2, T2, _3.x, A3.y, S2, I2), sg(g2, l2.x, l2.y, c3.x, E2 + c3.y, h3.x + h3.w, h3.y + h3.h, r2, T2, A3.x, A3.y, S2, I2), o2) {
              const { x: e3, y: r3, z: n4 } = o2.anchor, [i4, s3, a4] = o2.up;
              og(x2, e3, r3, n4, i4, s3, a4), og(x2, e3, r3, n4, i4, s3, a4), og(x2, e3, r3, n4, i4, s3, a4), og(x2, e3, r3, n4, i4, s3, a4), lg(t2.dynamicLayoutVertexArray, e3, r3, n4, w2);
            } else
              lg(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, w2);
            if (m2) {
              const e3 = b3 || h3;
              ag(t2.iconTransitioningVertexArray, e3.x, e3.y), ag(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y), ag(t2.iconTransitioningVertexArray, e3.x, e3.y + e3.h), ag(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y + e3.h);
            }
            y2.emplaceBack(z2, z2 + 1, z2 + 2), y2.emplaceBack(z2 + 1, z2 + 2, z2 + 3), v2.vertexLength += 4, v2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(k2[0]), n3 !== e22.length - 1 && P2 === e22[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(g2.length, s2, s2.index, {}, p2, f2, d2, M2 && M2[P2]);
          }
          const A2 = o2 ? o2.anchor : l2;
          t2.placedSymbolArray.emplaceBack(A2.x, A2.y, A2.z, l2.x, l2.y, b2, this.glyphOffsetArray.length - b2, _2, u2, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], a2, 0, false, 0, h22, 0);
        }
        _commitLayoutVertex(t2, e22, r2, n2, i2, s2, a2) {
          t2.emplaceBack(e22, r2, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
        }
        _addCollisionDebugVertices(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l2 = o2.vertexLength, u2 = a2.tileAnchorX, c2 = a2.tileAnchorY;
          for (let t3 = 0; t3 < 4; t3++)
            r2.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(r2.collisionVertexArrayExt, e22, t2.padding, a2.zOffset), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new x(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new x(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new x(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u2, c2, new x(t2.x1, t2.y2)), o2.vertexLength += 4;
          const h22 = r2.indexArray;
          h22.emplaceBack(l2, l2 + 1), h22.emplaceBack(l2 + 1, l2 + 2), h22.emplaceBack(l2 + 2, l2 + 3), h22.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(t2, e22, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e22, a2);
            this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        _addIconDebugCollisionBoxes(t2, e22, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e22, s2.placedIconSymbolIndex);
            this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        generateCollisionDebugBuffers(t2, e22) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new hg(no, om.members, eo), this.iconCollisionBox = new hg(no, om.members, eo);
          const r2 = fm(this.iconSizeData, t2), n2 = fm(this.textSizeData, t2);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._addTextDebugCollisionBoxes(n2, t2, e22, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e22, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e22, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e22, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
        }
        getSymbolInstanceTextSize(t2, e22, r2, n2) {
          const i2 = this.text.placedSymbolArray.get(e22.rightJustifiedTextSymbolIndex >= 0 ? e22.rightJustifiedTextSymbolIndex : e22.centerJustifiedTextSymbolIndex >= 0 ? e22.centerJustifiedTextSymbolIndex : e22.leftJustifiedTextSymbolIndex >= 0 ? e22.leftJustifiedTextSymbolIndex : e22.verticalPlacedTextSymbolIndex >= 0 ? e22.verticalPlacedTextSymbolIndex : n2), s2 = pm(this.textSizeData, t2, i2) / um;
          return this.tilePixelRatio * s2;
        }
        getSymbolInstanceIconSize(t2, e22, r2) {
          const n2 = this.icon.placedSymbolArray.get(r2), i2 = pm(this.iconSizeData, t2, n2);
          return this.tilePixelRatio * i2;
        }
        _commitDebugCollisionVertexUpdate(t2, e22, r2, n2) {
          t2.emplaceBack(e22, -r2, -r2, n2), t2.emplaceBack(e22, r2, -r2, n2), t2.emplaceBack(e22, r2, r2, n2), t2.emplaceBack(e22, -r2, r2, n2);
        }
        _updateTextDebugCollisionBoxes(t2, e22, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e22, a2);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(t2, e22, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e22, s2.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
          }
        }
        updateCollisionDebugBuffers(t2, e22) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const r2 = fm(this.iconSizeData, t2), n2 = fm(this.textSizeData, t2);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._updateTextDebugCollisionBoxes(n2, t2, e22, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e22, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e22, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e22, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = {};
          if (e22 < r2) {
            const { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2, featureIndex: f2 } = t2.get(e22);
            u2.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2 }, u2.textFeatureIndex = f2;
          }
          if (n2 < i2) {
            const { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2, featureIndex: f2 } = t2.get(n2);
            u2.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2 }, u2.verticalTextFeatureIndex = f2;
          }
          if (s2 < a2) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2, featureIndex: f2 } = t2.get(s2);
            u2.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: a3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2 }, u2.iconFeatureIndex = f2;
          }
          if (o2 < l2) {
            const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2, featureIndex: f2 } = t2.get(o2);
            u2.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h22, tileAnchorY: p2 }, u2.verticalIconFeatureIndex = f2;
          }
          return u2;
        }
        deserializeCollisionBoxes(t2) {
          this.collisionArrays = [];
          for (let e22 = 0; e22 < this.symbolInstances.length; e22++) {
            const r2 = this.symbolInstances.get(e22);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(t2, e22) {
          const r2 = t2.placedSymbolArray.get(e22), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
          for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
            t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t2) {
          if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          const e22 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
          for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n2.push(0 | Math.round(e22 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty)
            return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let t2 = 0; t2 < this.symbolInstances.length; ++t2)
              this.symbolInstanceIndexesSortedZOffset.push(t2);
          }
          return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t2, e22) => this.symbolInstances.get(e22).zOffset - this.symbolInstances.get(t2).zOffset);
        }
        addToSortKeyRanges(t2, e22) {
          const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e22 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e22, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
        }
        sortFeatures(t2) {
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e22 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e22.featureIndex);
              const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: a2, verticalPlacedIconSymbolIndex: o2 } = e22;
              r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      Ks(pg, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), pg.MAX_GLYPHS = 65535, pg.addDynamicAttributes = lg;
      var fg = pg;
      const dg = Ua([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: mg } = dg, yg = Ua([{ name: "a_packed", components: 4, type: "Float32" }]), { members: gg } = yg, xg = ud.types, vg = Math.cos(Math.PI / 180 * 37.5);
      class bg {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new Za(), this.layoutVertexArray2 = new Xa(), this.indexArray = new ao(), this.programConfigurations = new fl(t2.layers, t2.zoom), this.segments = new Do(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e22, r2, n2) {
          this.hasPattern = Ff("line", this.layers, e22);
          const i2 = this.layers[0].layout.get("line-sort-key"), s2 = [];
          for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: l3 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = gp(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new _a2(this.zoom), u2, r2))
              continue;
            const c2 = i2 ? i2.evaluate(u2, {}, r2) : void 0, h22 = { id: a3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u2.geometry : yp(e3, r2, n2), patterns: {}, sortKey: c2 };
            s2.push(h22);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          const { lineAtlas: a2, featureIndex: o2 } = e22, l2 = this.addConstantDashes(a2);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: u2 } = n3;
            if (l2 && this.addFeatureDashes(n3, a2), this.hasPattern) {
              const t3 = jf("line", this.layers, n3, this.zoom, e22);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, a2.positions, e22.availableImages, e22.brightness);
            o2.insert(t2[s3].feature, i3, s3, u2, this.index);
          }
        }
        addConstantDashes(t2) {
          let e22 = false;
          for (const r2 of this.layers) {
            const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
            if ("constant" !== n2.kind || "constant" !== i2.kind)
              e22 = true;
            else {
              const e3 = i2.value, r3 = n2.value;
              if (!r3)
                continue;
              t2.addDash(r3, e3);
            }
          }
          return e22;
        }
        addFeatureDashes(t2, e22) {
          const r2 = this.zoom;
          for (const n2 of this.layers) {
            const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
            if ("constant" === i2.kind && "constant" === s2.kind)
              continue;
            let a2, o2;
            if ("constant" === i2.kind) {
              if (a2 = i2.value, !a2)
                continue;
            } else
              a2 = i2.evaluate({ zoom: r2 }, t2);
            o2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r2 }, t2), e22.addDash(a2, o2), t2.patterns[n2.id] = e22.getKey(a2, o2);
          }
        }
        update(t2, e22, r2, n2, i2) {
          const s2 = 0 !== Object.keys(t2).length;
          s2 && !this.stateDependentLayers.length || this.programConfigurations.updatePaintArrays(t2, e22, s2 ? this.stateDependentLayers : this.layers, r2, n2, i2);
        }
        addFeatures(t2, e22, r2, n2, i2, s2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e22, r2, n2, s2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, gg)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, mg), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t2) {
          if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
        }
        addFeature(t2, e22, r2, n2, i2, s2, a2) {
          const o2 = this.layers[0].layout, l2 = o2.get("line-join").evaluate(t2, {}), u2 = o2.get("line-cap").evaluate(t2, {}), c2 = o2.get("line-miter-limit"), h22 = o2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t2);
          for (const r3 of e22)
            this.addLine(r3, t2, l2, u2, c2, h22);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, a2);
        }
        addLine(t2, e22, r2, n2, i2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0; e3 < t2.length - 1; e3++)
              this.totalDistance += t2[e3].dist(t2[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const a2 = "Polygon" === xg[e22.type];
          let o2 = t2.length;
          for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
            o2--;
          let l2 = 0;
          for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
            l2++;
          if (o2 < (a2 ? 3 : 2))
            return;
          "bevel" === r2 && (i2 = 1.05);
          const u2 = this.overscaling <= 16 ? 15 * Cr / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
          let h22, p2, f2, d2, m2;
          this.e1 = this.e2 = -1, a2 && (h22 = t2[o2 - 2], m2 = t2[l2].sub(h22)._unit()._perp());
          for (let e3 = l2; e3 < o2; e3++) {
            if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], f2 && t2[e3].equals(f2))
              continue;
            m2 && (d2 = m2), h22 && (p2 = h22), h22 = t2[e3], m2 = f2 ? f2.sub(h22)._unit()._perp() : d2, d2 = d2 || m2;
            let y2 = d2.add(m2);
            0 === y2.x && 0 === y2.y || y2._unit();
            const g2 = d2.x * m2.x + d2.y * m2.y, x2 = y2.x * m2.x + y2.y * m2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), _2 = x2 < vg && p2 && f2, w2 = d2.x * m2.y - d2.y * m2.x > 0;
            if (_2 && e3 > l2) {
              const t3 = h22.dist(p2);
              if (t3 > 2 * u2) {
                const e4 = h22.sub(h22.sub(p2)._mult(u2 / t3)._round());
                this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
              }
            }
            const M2 = p2 && f2;
            let A2 = M2 ? r2 : a2 ? "butt" : n2;
            if (M2 && "round" === A2 && (v2 < s2 ? A2 = "miter" : v2 <= 2 && (A2 = "fakeround")), "miter" === A2 && v2 > i2 && (A2 = "bevel"), "bevel" === A2 && (v2 > 2 && (A2 = "flipbevel"), v2 < i2 && (A2 = "miter")), p2 && this.updateDistance(p2, h22), "miter" === A2)
              y2._mult(v2), this.addCurrentVertex(h22, y2, 0, 0, c2);
            else if ("flipbevel" === A2) {
              if (v2 > 100)
                y2 = m2.mult(-1);
              else {
                const t3 = v2 * d2.add(m2).mag() / d2.sub(m2).mag();
                y2._perp()._mult(t3 * (w2 ? -1 : 1));
              }
              this.addCurrentVertex(h22, y2, 0, 0, c2), this.addCurrentVertex(h22, y2.mult(-1), 0, 0, c2);
            } else if ("bevel" === A2 || "fakeround" === A2) {
              const t3 = -Math.sqrt(v2 * v2 - 1), e4 = w2 ? t3 : 0, r3 = w2 ? 0 : t3;
              if (p2 && this.addCurrentVertex(h22, d2, e4, r3, c2), "fakeround" === A2) {
                const t4 = Math.round(180 * b2 / Math.PI / 20);
                for (let e52 = 1; e52 < t4; e52++) {
                  let r4 = e52 / t4;
                  if (0.5 !== r4) {
                    const t5 = r4 - 0.5;
                    r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const n3 = m2.sub(d2)._mult(r4)._add(d2)._unit()._mult(w2 ? -1 : 1);
                  this.addHalfVertex(h22, n3.x, n3.y, false, w2, 0, c2);
                }
              }
              f2 && this.addCurrentVertex(h22, m2, -e4, -r3, c2);
            } else if ("butt" === A2)
              this.addCurrentVertex(h22, y2, 0, 0, c2);
            else if ("square" === A2) {
              const t3 = p2 ? 1 : -1;
              p2 || this.addCurrentVertex(h22, y2, t3, t3, c2), this.addCurrentVertex(h22, y2, 0, 0, c2), p2 && this.addCurrentVertex(h22, y2, t3, t3, c2);
            } else
              "round" === A2 && (p2 && (this.addCurrentVertex(h22, d2, 0, 0, c2), this.addCurrentVertex(h22, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h22, m2, -1, -1, c2, true), this.addCurrentVertex(h22, m2, 0, 0, c2)));
            if (_2 && e3 < o2 - 1) {
              const t3 = h22.dist(f2);
              if (t3 > 2 * u2) {
                const e4 = h22.add(f2.sub(h22)._mult(u2 / t3)._round());
                this.updateDistance(h22, e4), this.addCurrentVertex(e4, m2, 0, 0, c2), h22 = e4;
              }
            }
          }
        }
        addCurrentVertex(t2, e22, r2, n2, i2, s2 = false) {
          const a2 = e22.y * n2 - e22.x, o2 = -e22.y - e22.x * n2;
          this.addHalfVertex(t2, e22.x + e22.y * r2, e22.y - e22.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2);
        }
        addHalfVertex({ x: t2, y: e22 }, r2, n2, i2, s2, a2, o2) {
          this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e22 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const l2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s2 ? this.e2 = l2 : this.e1 = l2;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(t2, e22) {
          this.distance += t2.dist(e22), this.updateScaledDistance();
        }
      }
      Ks(bg, "LineBucket", { omit: ["layers", "patternFeatures"] });
      class _g {
        constructor(t2, e22, r2, n2) {
          this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e22, n2);
        }
        update(t2, e22, r2) {
          const { width: n2, height: i2 } = t2, { context: s2 } = this, { gl: a2 } = s2;
          if (a2.bindTexture(a2.TEXTURE_2D, this.texture), s2.pixelStoreUnpackFlipY.set(false), s2.pixelStoreUnpack.set(1), s2.pixelStoreUnpackPremultiplyAlpha.set(this.format === a2.RGBA && (!e22 || false !== e22.premultiply)), r2 || this.size && this.size[0] === n2 && this.size[1] === i2) {
            const { x: e3, y: s3 } = r2 || { x: 0, y: 0 };
            if (t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || ImageBitmap && t2 instanceof ImageBitmap)
              a2.texSubImage2D(a2.TEXTURE_2D, 0, e3, s3, a2.RGBA, a2.UNSIGNED_BYTE, t2);
            else {
              let r3 = this.format, o2 = a2.UNSIGNED_BYTE;
              this.format === a2.R32F && (r3 = a2.RED, o2 = a2.FLOAT), a2.texSubImage2D(a2.TEXTURE_2D, 0, e3, s3, n2, i2, r3, o2, t2.data);
            }
          } else if (this.size = [n2, i2], t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || ImageBitmap && t2 instanceof ImageBitmap) {
            let e3 = this.format;
            this.format === a2.R8 && (e3 = a2.RED), a2.texImage2D(a2.TEXTURE_2D, 0, this.format, e3, a2.UNSIGNED_BYTE, t2);
          } else {
            let e3 = this.format, r3 = this.format, s3 = a2.UNSIGNED_BYTE;
            this.format === a2.DEPTH_COMPONENT && (e3 = a2.DEPTH_COMPONENT16, s3 = a2.UNSIGNED_SHORT), this.format === a2.R8 && (r3 = a2.RED), this.format === a2.R32F && (s3 = a2.FLOAT, r3 = a2.RED), a2.texImage2D(a2.TEXTURE_2D, 0, e3, n2, i2, 0, r3, s3, t2.data);
          }
          this.useMipmap = Boolean(e22 && e22.useMipmap), this.useMipmap && a2.generateMipmap(a2.TEXTURE_2D);
        }
        bind(t2, e22, r2 = false) {
          const { context: n2 } = this, { gl: i2 } = n2;
          i2.bindTexture(i2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, this.useMipmap && !r2 ? t2 === i2.NEAREST ? i2.NEAREST_MIPMAP_NEAREST : i2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), e22 !== this.wrapS && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e22), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
        bindExtraParam(t2, e22, r2, n2) {
          const { context: i2 } = this, { gl: s2 } = i2;
          s2.bindTexture(s2.TEXTURE_2D, this.texture), e22 !== this.magFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, e22), this.magFilter = e22), t2 !== this.minFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === s2.NEAREST ? s2.NEAREST_MIPMAP_NEAREST : s2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), r2 !== this.wrapS && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, r2), this.wrapS = r2), n2 !== this.wrapT && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, n2), this.wrapT = n2);
        }
        destroy() {
          const { gl: t2 } = this.context;
          t2.deleteTexture(this.texture), this.texture = null;
        }
      }
      class wg {
        constructor(t2, e22) {
          this.context = t2, this.texture = e22;
        }
        bind(t2, e22) {
          const { context: r2 } = this, { gl: n2 } = r2;
          n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e22 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e22), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e22), this.wrapS = e22);
        }
      }
      const Mg = 32, Ag = 33, Sg = new Uint16Array(8184);
      for (let t2 = 0; t2 < 2046; t2++) {
        let e22 = t2 + 2, r2 = 0, n2 = 0, i2 = 0, s2 = 0, a2 = 0, o2 = 0;
        for (1 & e22 ? i2 = s2 = a2 = Mg : r2 = n2 = o2 = Mg; (e22 >>= 1) > 1; ) {
          const t3 = r2 + i2 >> 1, l3 = n2 + s2 >> 1;
          1 & e22 ? (i2 = r2, s2 = n2, r2 = a2, n2 = o2) : (r2 = i2, n2 = s2, i2 = a2, s2 = o2), a2 = t3, o2 = l3;
        }
        const l2 = 4 * t2;
        Sg[l2 + 0] = r2, Sg[l2 + 1] = n2, Sg[l2 + 2] = i2, Sg[l2 + 3] = s2;
      }
      const Ig = new Uint16Array(2178), kg = new Uint8Array(1089), Tg = new Uint16Array(1089);
      function Pg(t2) {
        return 0 === t2 ? -0.03125 : 32 === t2 ? 0.03125 : 0;
      }
      var zg = Ua([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      const Eg = { type: 2, extent: Cr, loadGeometry: () => [[new x(0, 0), new x(Cr + 1, 0), new x(Cr + 1, Cr + 1), new x(0, Cr + 1), new x(0, 0)]] };
      class Bg {
        constructor(t2, e22, r2, n2, i2) {
          this.tileID = t2, this.uid = C(), this.uses = 0, this.tileSize = e22, this.tileZoom = r2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i2, n2 && n2.style && (this._lastUpdatedBrightness = n2.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", n2 && n2.transform && (this.projection = n2.transform.projection);
        }
        registerFadeDuration(t2) {
          const e22 = t2 + this.timeAdded;
          e22 < Wt.now() || this.fadeEndTime && e22 < this.fadeEndTime || (this.fadeEndTime = e22);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = zy(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t2, e22, r2) {
          if (this.unloadVectorData(), this.state = "loaded", t2) {
            t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
              const r3 = {};
              if (!e3)
                return r3;
              for (const n2 of t3) {
                const t4 = n2.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                if (0 !== t4.length) {
                  n2.layers = t4, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                  for (const e4 of t4)
                    r3[e4.fqid] = n2;
                }
              }
              return r3;
            }(t2.buckets, e22.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const e3 = this.buckets[t3];
              if (e3 instanceof fg) {
                if (this.hasSymbolBuckets = true, !r2)
                  break;
                e3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                if (e3 instanceof fg && e3.hasRTLText) {
                  this.hasRTLText = true, ba.isLoading() || ba.isLoaded() || "deferred" !== xa() || va();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t3 in this.buckets) {
              const r3 = this.buckets[t3], n2 = e22.style.getOwnLayer(t3);
              if (!n2)
                continue;
              const i2 = n2.queryRadius(r3);
              this.queryPadding = Math.max(this.queryPadding, i2);
            }
            t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas), this._lastUpdatedBrightness = t2.brightness;
          } else
            this.collisionBoxArray = new _o();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const t2 in this.buckets)
              this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        getBucket(t2) {
          return this.buckets[t2.fqid];
        }
        upload(t2) {
          for (const e3 in this.buckets) {
            const r3 = this.buckets[e3];
            r3.uploadPending() && r3.upload(t2);
          }
          const e22 = t2.gl, r2 = this.imageAtlas;
          if (r2 && !r2.uploaded) {
            const n2 = !!Object.keys(r2.patternPositions).length;
            this.imageAtlasTexture = new _g(t2, r2.image, e22.RGBA, { useMipmap: n2 }), this.imageAtlas.uploaded = true;
          }
          this.glyphAtlasImage && (this.glyphAtlasTexture = new _g(t2, this.glyphAtlasImage, e22.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new _g(t2, this.lineAtlas.image, e22.R8), this.lineAtlas.uploaded = true);
        }
        prepare(t2, e22, r2) {
          if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture, r2), !e22 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
            return;
          const n2 = e22.style.getBrightness();
          (this._lastUpdatedBrightness || n2) && (this._lastUpdatedBrightness && n2 && Math.abs(this._lastUpdatedBrightness - n2) < 1e-3 || (this._lastUpdatedBrightness = n2, this.updateBuckets(void 0, e22)));
        }
        queryRenderedFeatures(t2, e22, r2, n2, i2, s2, a2, o2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s2, params: i2, tileTransform: this.tileTransform }, t2, e22, r2) : {};
        }
        querySourceFeatures(t2, e22) {
          const r2 = this.latestFeatureIndex;
          if (!r2 || !r2.rawTileData)
            return;
          const n2 = r2.loadVTLayers(), i2 = e22 ? e22.sourceLayer : "", s2 = n2._geojsonTileLayer || n2[i2];
          if (!s2)
            return;
          const a2 = ls(e22 && e22.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
          for (let e3 = 0; e3 < s2.length; e3++) {
            const n3 = s2.feature(e3);
            if (a2.needGeometry) {
              const t3 = gp(n3, true);
              if (!a2.filter(new _a2(this.tileID.overscaledZ), t3, this.tileID.canonical))
                continue;
            } else if (!a2.filter(new _a2(this.tileID.overscaledZ), n3))
              continue;
            const h22 = r2.getId(n3, i2), p2 = new Ld(n3, o2, l2, u2, h22);
            p2.tile = c2, t2.push(p2);
          }
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        bucketsLoaded() {
          for (const t2 in this.buckets)
            if (this.buckets[t2].uploadPending())
              return false;
          return true;
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t2) {
          const e22 = this.expirationTime;
          if (t2.cacheControl) {
            const e3 = K(t2.cacheControl);
            e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
          } else
            t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
          if (this.expirationTime) {
            const t3 = Date.now();
            let r2 = false;
            if (this.expirationTime > t3)
              r2 = false;
            else if (e22)
              if (this.expirationTime < e22)
                r2 = true;
              else {
                const n2 = this.expirationTime - e22;
                n2 ? this.expirationTime = t3 + Math.max(n2, 3e4) : r2 = true;
              }
            else
              r2 = true;
            r2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t2, e22) {
          this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t2).length && e22 && this.updateBuckets(t2, e22);
        }
        updateBuckets(t2, e22) {
          if (!this.latestFeatureIndex)
            return;
          const r2 = this.latestFeatureIndex.loadVTLayers(), n2 = e22.style.listImages(), i2 = e22.style.getBrightness();
          for (const s2 in this.buckets) {
            if (!e22.style.hasLayer(s2))
              continue;
            const a2 = this.buckets[s2], o2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", l2 = r2[o2];
            let u2 = {};
            if (t2 && (u2 = t2[o2], !l2 || !u2 || 0 === Object.keys(u2).length))
              continue;
            if (a2.update(u2, l2, n2, this.imageAtlas && this.imageAtlas.patternPositions || {}, i2), a2 instanceof bg || a2 instanceof Uf) {
              const t3 = e22.style.getOwnSourceCache(a2.layers[0].source);
              e22._terrain && e22._terrain.enabled && t3 && a2.programConfigurations.needsUpload && e22._terrain._clearRenderCacheForTile(t3.id, this.tileID);
            }
            const c2 = e22 && e22.style && e22.style.getOwnLayer(s2);
            c2 && (this.queryPadding = Math.max(this.queryPadding, c2.queryRadius(a2)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Wt.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t2) {
          this.symbolFadeHoldUntil = Wt.now() + t2;
        }
        setTexture(t2, e22) {
          const r2 = e22.context, n2 = r2.gl;
          this.texture = this.texture || e22.getTileTexture(t2.width), this.texture && this.texture instanceof _g ? this.texture.update(t2, { useMipmap: true }) : (this.texture = new _g(r2, t2, n2.RGBA, { useMipmap: true }), this.texture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE));
        }
        setDependencies(t2, e22) {
          const r2 = {};
          for (const t3 of e22)
            r2[t3] = true;
          this.dependencies[t2] = r2;
        }
        hasDependency(t2, e22) {
          for (const r2 of t2) {
            const t3 = this.dependencies[r2];
            if (t3) {
              for (const r3 of e22)
                if (t3[r3])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t2, e22) {
          if (!e22 || "mercator" === e22.name || this._tileDebugBuffer)
            return;
          const r2 = yp(Eg, this.tileID.canonical, this.tileTransform)[0], n2 = new $a(), i2 = new fo();
          for (let t3 = 0; t3 < r2.length; t3++) {
            const { x: e3, y: s2 } = r2[t3];
            n2.emplaceBack(e3, s2), i2.emplaceBack(t3);
          }
          i2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(i2), this._tileDebugBuffer = t2.createVertexBuffer(n2, Yc.members), this._tileDebugSegments = Do.simpleSegment(0, 0, n2.length, i2.length);
        }
        _makeTileBoundsBuffers(t2, e22) {
          if (this._tileBoundsBuffer || !e22 || "mercator" === e22.name)
            return;
          const r2 = yp(Eg, this.tileID.canonical, this.tileTransform)[0];
          let n2, i2;
          if (this.isRaster) {
            const t3 = function(t4, e3) {
              const r3 = zy(t4, e3), n3 = Math.pow(2, t4.z);
              for (let i4 = 0; i4 < Ag; i4++)
                for (let s3 = 0; s3 < Ag; s3++) {
                  const a3 = tp((t4.x + (s3 + Pg(s3)) / Mg) / n3), o3 = ep((t4.y + (i4 + Pg(i4)) / Mg) / n3), l3 = e3.project(a3, o3), u2 = i4 * Ag + s3;
                  Ig[2 * u2 + 0] = Math.round((l3.x * r3.scale - r3.x) * Cr), Ig[2 * u2 + 1] = Math.round((l3.y * r3.scale - r3.y) * Cr);
                }
              kg.fill(0), Tg.fill(0);
              for (let t5 = 2045; t5 >= 0; t5--) {
                const e4 = 4 * t5, r4 = Sg[e4 + 0], n4 = Sg[e4 + 1], i4 = Sg[e4 + 2], s3 = Sg[e4 + 3], a3 = r4 + i4 >> 1, o3 = n4 + s3 >> 1, l3 = a3 + o3 - n4, u2 = o3 + r4 - a3, c2 = n4 * Ag + r4, h22 = s3 * Ag + i4, p2 = o3 * Ag + a3, f2 = Math.hypot((Ig[2 * c2 + 0] + Ig[2 * h22 + 0]) / 2 - Ig[2 * p2 + 0], (Ig[2 * c2 + 1] + Ig[2 * h22 + 1]) / 2 - Ig[2 * p2 + 1]) >= 16;
                kg[p2] = kg[p2] || (f2 ? 1 : 0), t5 < 1022 && (kg[p2] = kg[p2] || kg[(n4 + u2 >> 1) * Ag + (r4 + l3 >> 1)] || kg[(s3 + u2 >> 1) * Ag + (i4 + l3 >> 1)]);
              }
              const i3 = new Ga(), s2 = new ao();
              let a2 = 0;
              function o2(t5, e4) {
                const r4 = e4 * Ag + t5;
                return 0 === Tg[r4] && (i3.emplaceBack(Ig[2 * r4 + 0], Ig[2 * r4 + 1], t5 * Cr / Mg, e4 * Cr / Mg), Tg[r4] = ++a2), Tg[r4] - 1;
              }
              function l2(t5, e4, r4, n4, i4, a3) {
                const u2 = t5 + r4 >> 1, c2 = e4 + n4 >> 1;
                if (Math.abs(t5 - i4) + Math.abs(e4 - a3) > 1 && kg[c2 * Ag + u2])
                  l2(i4, a3, t5, e4, u2, c2), l2(r4, n4, i4, a3, u2, c2);
                else {
                  const l3 = o2(t5, e4), u3 = o2(r4, n4), c3 = o2(i4, a3);
                  s2.emplaceBack(l3, u3, c3);
                }
              }
              return l2(0, 0, Mg, Mg, Mg, 0), l2(Mg, Mg, 0, 0, 0, Mg), { vertices: i3, indices: s2 };
            }(this.tileID.canonical, e22);
            n2 = t3.vertices, i2 = t3.indices;
          } else {
            n2 = new Ga(), i2 = new ao();
            for (const { x: t4, y: e3 } of r2)
              n2.emplaceBack(t4, e3, 0, 0);
            const t3 = Lf(n2.int16, void 0, 4);
            for (let e3 = 0; e3 < t3.length; e3 += 3)
              i2.emplaceBack(t3[e3], t3[e3 + 1], t3[e3 + 2]);
          }
          this._tileBoundsBuffer = t2.createVertexBuffer(n2, zg.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(i2), this._tileBoundsSegments = Do.simpleSegment(0, 0, n2.length, i2.length);
        }
        _makeGlobeTileDebugBuffers(e22, r2) {
          const n2 = r2.projection;
          if (!n2 || "globe" !== n2.name || r2.freezeTileCoverage)
            return;
          const i2 = this.tileID.canonical, s2 = Dh(Mh(i2, r2)), a2 = Oh(r2.zoom);
          let o2;
          a2 > 0 && (o2 = t.m.invert(new Float64Array(16), r2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(e22, i2, r2, s2, o2, a2), this._makeGlobeTileDebugTextBuffer(e22, i2, r2, s2, o2, a2);
        }
        _globePoint(e22, r2, n2, i2, s2, a2, o2) {
          let l2 = zh(e22, r2, n2);
          if (a2) {
            const s3 = 1 << n2.z, u2 = Hh(i2.center.lng), c2 = Jh(i2.center.lat), h22 = (n2.x + 0.5) / s3 - u2;
            let p2 = 0;
            h22 > 0.5 ? p2 = -1 : h22 < -0.5 && (p2 = 1);
            let f2 = (e22 / Cr + n2.x) / s3 + p2, d2 = (r2 / Cr + n2.y) / s3;
            f2 = (f2 - u2) * i2._pixelsPerMercatorPixel + u2, d2 = (d2 - c2) * i2._pixelsPerMercatorPixel + c2;
            const m2 = [f2 * i2.worldSize, d2 * i2.worldSize, 0];
            t.v.transformMat4(m2, m2, a2), l2 = wh(l2, m2, o2);
          }
          return t.v.transformMat4(l2, l2, s2);
        }
        _makeGlobeTileDebugBorderBuffer(t2, e22, r2, n2, i2, s2) {
          const a2 = new $a(), o2 = new fo(), l2 = new qa(), u2 = (t3, u3, c3, h22, p2) => {
            const f2 = (c3 - t3) / (p2 - 1), d2 = (h22 - u3) / (p2 - 1), m2 = a2.length;
            for (let c4 = 0; c4 < p2; c4++) {
              const h3 = t3 + c4 * f2, p3 = u3 + c4 * d2;
              a2.emplaceBack(h3, p3);
              const y2 = this._globePoint(h3, p3, e22, r2, n2, i2, s2);
              l2.emplaceBack(y2[0], y2[1], y2[2]), o2.emplaceBack(m2 + c4);
            }
          }, c2 = Cr;
          u2(0, 0, c2, 0, 16), u2(c2, 0, c2, c2, 16), u2(c2, c2, 0, c2, 16), u2(0, c2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(o2), this._tileDebugBuffer = t2.createVertexBuffer(a2, Yc.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(l2, Gc.members), this._tileDebugSegments = Do.simpleSegment(0, 0, a2.length, o2.length);
        }
        _makeGlobeTileDebugTextBuffer(t2, e22, r2, n2, i2, s2) {
          const a2 = Cr / 4, o2 = new $a(), l2 = new ao(), u2 = new qa(), c2 = 25;
          l2.reserve(32), o2.reserve(c2), u2.reserve(c2);
          const h22 = (t3, e3) => c2 * t3 + e3;
          for (let t3 = 0; t3 < c2; t3++) {
            const l3 = t3 * a2;
            for (let t4 = 0; t4 < c2; t4++) {
              const c3 = t4 * a2;
              o2.emplaceBack(c3, l3);
              const h3 = this._globePoint(c3, l3, e22, r2, n2, i2, s2);
              u2.emplaceBack(h3[0], h3[1], h3[2]);
            }
          }
          for (let t3 = 0; t3 < 4; t3++)
            for (let e3 = 0; e3 < 4; e3++) {
              const r3 = h22(t3, e3), n3 = h22(t3, e3 + 1), i3 = h22(t3 + 1, e3), s3 = h22(t3 + 1, e3 + 1);
              l2.emplaceBack(r3, n3, i3), l2.emplaceBack(i3, n3, s3);
            }
          this._tileDebugTextIndexBuffer = t2.createIndexBuffer(l2), this._tileDebugTextBuffer = t2.createVertexBuffer(o2, Yc.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(u2, Gc.members), this._tileDebugTextSegments = Do.simpleSegment(0, 0, c2, 32);
        }
        destroy(t2 = false) {
          for (const t3 in this.buckets)
            this.buckets[t3].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t2 && this.texture && this.texture instanceof _g && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      class Dg {
        constructor(t2, e22) {
          this.max = t2, this.onRemove = e22, this.reset();
        }
        reset() {
          for (const t2 in this.data)
            for (const e22 of this.data[t2])
              e22.timeout && clearTimeout(e22.timeout), this.onRemove(e22.value);
          return this.data = {}, this.order = [], this;
        }
        add(t2, e22, r2) {
          const n2 = t2.wrapped().key;
          void 0 === this.data[n2] && (this.data[n2] = []);
          const i2 = { value: e22, timeout: void 0 };
          if (void 0 !== r2 && (i2.timeout = setTimeout(() => {
            this.remove(t2, i2);
          }, r2)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        has(t2) {
          return t2.wrapped().key in this.data;
        }
        getAndRemove(t2) {
          return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
        }
        _getAndRemoveByKey(t2) {
          const e22 = this.data[t2].shift();
          return e22.timeout && clearTimeout(e22.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e22.value;
        }
        getByKey(t2) {
          const e22 = this.data[t2];
          return e22 ? e22[0].value : null;
        }
        get(t2) {
          return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
        }
        remove(t2, e22) {
          if (!this.has(t2))
            return this;
          const r2 = t2.wrapped().key, n2 = void 0 === e22 ? 0 : this.data[r2].indexOf(e22), i2 = this.data[r2][n2];
          return this.data[r2].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r2].length && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
        }
        setMaxSize(t2) {
          for (this.max = t2; this.order.length > this.max; ) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        filter(t2) {
          const e22 = [];
          for (const r2 in this.data)
            for (const n2 of this.data[r2])
              t2(n2.value) || e22.push(n2);
          for (const t3 of e22)
            this.remove(t3.value.tileID, t3);
        }
      }
      class Cg {
        constructor(t2, e22, r2, n2) {
          this.id = Cg.uniqueIdxCounter, Cg.uniqueIdxCounter++, this.context = t2;
          const i2 = t2.gl;
          this.buffer = i2.createBuffer(), this.dynamicDraw = Boolean(r2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), i2.bufferData(i2.ELEMENT_ARRAY_BUFFER, e22.arrayBuffer, this.dynamicDraw ? i2.DYNAMIC_DRAW : i2.STATIC_DRAW), this.dynamicDraw || n2 || e22.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t2) {
          this.id = Cg.uniqueIdxCounter, Cg.uniqueIdxCounter++;
          const e22 = this.context.gl;
          this.context.unbindVAO(), this.bind(), e22.bufferSubData(e22.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      Cg.uniqueIdxCounter = 0;
      class Rg {
        constructor(t2, e22, r2) {
          this.func = t2, this.mask = e22, this.range = r2;
        }
      }
      Rg.ReadOnly = false, Rg.ReadWrite = true, Rg.disabled = new Rg(519, Rg.ReadOnly, [0, 1]);
      const Lg = 7680;
      class Vg {
        constructor(t2, e22, r2, n2, i2, s2) {
          this.test = t2, this.ref = e22, this.mask = r2, this.fail = n2, this.depthFail = i2, this.pass = s2;
        }
      }
      Vg.disabled = new Vg({ func: 519, mask: 0 }, 0, 0, Lg, Lg, Lg);
      class Og {
        constructor(t2, e22, r2, n2) {
          this.blendFunction = t2, this.blendColor = e22, this.mask = r2, this.blendEquation = n2;
        }
      }
      Og.Replace = [1, 0, 1, 0], Og.disabled = new Og(Og.Replace, Re.transparent, [false, false, false, false]), Og.unblended = new Og(Og.Replace, Re.transparent, [true, true, true, true]), Og.alphaBlended = new Og([1, 771, 1, 771], Re.transparent, [true, true, true, true]), Og.multiply = new Og([774, 0, 774, 0], Re.transparent, [true, true, true, true]);
      const Fg = 1029, jg = 2305;
      class Ug {
        constructor(t2, e22, r2) {
          this.enable = t2, this.mode = e22, this.frontFace = r2;
        }
      }
      Ug.disabled = new Ug(false, Fg, jg), Ug.backCCW = new Ug(true, Fg, jg), Ug.backCW = new Ug(true, Fg, 2304), Ug.frontCW = new Ug(true, 1028, 2304), Ug.frontCCW = new Ug(true, 1028, jg);
      class Ng extends ee {
        constructor(t2, e22, r2) {
          super(), this.id = t2, this._onlySymbols = r2, e22.on("data", (t3) => {
            "source" === t3.dataType && "metadata" === t3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t3.dataType && "content" === t3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
          }), e22.on("error", () => {
            this._sourceErrored = true;
          }), this._source = e22, this._tiles = {}, this._cache = new Dg(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e22.minTileCacheSize, this._maxTileCacheSize = e22.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Vd(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
        }
        onAdd(t2) {
          this.map = t2, this._minTileCacheSize = void 0 === this._minTileCacheSize && t2 ? t2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t2 ? t2._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const t2 in this._tiles) {
            const e22 = this._tiles[t2];
            if ("errored" !== e22.state && ("loaded" !== e22.state || !e22.bucketsLoaded()))
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const t2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t2, e22) {
          return t2.isSymbolTile = this._onlySymbols, t2.isExtraShadowCaster = this._shadowCasterTiles[t2.tileID.key], this._source.loadTile(t2, e22);
        }
        _unloadTile(t2) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t2, () => {
            });
        }
        _abortTile(t2) {
          if (this._source.abortTile)
            return this._source.abortTile(t2, () => {
            });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const e22 in this._tiles) {
            const r2 = this._tiles[e22];
            r2.upload(t2), r2.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return E(this._tiles).map((t2) => t2.tileID).sort($g).map((t2) => t2.key);
        }
        getRenderableIds(t2, e22) {
          const r2 = [];
          for (const n2 in this._tiles)
            this._isIdRenderable(+n2, t2, e22) && r2.push(this._tiles[n2]);
          return t2 ? r2.sort((t3, e3) => {
            const r3 = t3.tileID, n2 = e3.tileID, i2 = new x(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle), s2 = new x(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
            return r3.overscaledZ - n2.overscaledZ || s2.y - i2.y || s2.x - i2.x;
          }).map((t3) => t3.tileID.key) : r2.map((t3) => t3.tileID).sort($g).map((t3) => t3.key);
        }
        hasRenderableParent(t2) {
          const e22 = this.findLoadedParent(t2, 0);
          return !!e22 && this._isIdRenderable(e22.tileID.key);
        }
        _isIdRenderable(t2, e22, r2) {
          return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e22 || !this._tiles[t2].holdingForFade()) && (r2 || !this._shadowCasterTiles[t2]);
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t2 in this._tiles)
              "errored" !== this._tiles[t2].state && this._reloadTile(+t2, "reloading");
          }
        }
        _reloadTile(t2, e22) {
          const r2 = this._tiles[t2];
          r2 && ("loading" !== r2.state && (r2.state = e22), this._loadTile(r2, this._tileLoaded.bind(this, r2, t2, e22)));
        }
        _tileLoaded(t2, e22, r2, n2) {
          if (n2)
            if (t2.state = "errored", 404 !== n2.status)
              this._source.fire(new te(n2, { tile: t2 }));
            else {
              if (!(t2.tileID.key in this._loadedParentTiles))
                return void this._source.fire(new Qt("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id }));
              if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                const t3 = this.map.painter.terrain;
                this.update(this.transform, t3.getScaledDemTileSize(), true), t3.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            }
          else
            t2.timeAdded = Wt.now(), "expired" === r2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e22, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Qt("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t2) {
          const e22 = this.getRenderableIds();
          for (let n2 = 0; n2 < e22.length; n2++) {
            const i2 = e22[n2];
            if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
              const e3 = this.getTileByID(i2);
              r2(t2, e3), r2(e3, t2);
            }
          }
          function r2(t3, e3) {
            if (!t3.dem || t3.dem.borderReady)
              return;
            t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
            let r3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
            const n2 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
            0 === r3 && 0 === n2 || Math.abs(n2) > 1 || (Math.abs(r3) > 1 && (1 === Math.abs(r3 + i2) ? r3 += i2 : 1 === Math.abs(r3 - i2) && (r3 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r3, n2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
          }
        }
        getTile(t2) {
          return this.getTileByID(t2.key);
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        _retainLoadedChildren(t2, e22, r2, n2) {
          for (const i2 in this._tiles) {
            let s2 = this._tiles[i2];
            if (n2[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e22 || s2.tileID.overscaledZ > r2)
              continue;
            let a2 = s2.tileID;
            for (; s2 && s2.tileID.overscaledZ > e22 + 1; ) {
              const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
              s2 = this._tiles[t3.key], s2 && s2.hasData() && (a2 = t3);
            }
            let o2 = a2;
            for (; o2.overscaledZ > e22; )
              if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                n2[a2.key] = a2;
                break;
              }
          }
        }
        findLoadedParent(t2, e22) {
          if (t2.key in this._loadedParentTiles) {
            const r2 = this._loadedParentTiles[t2.key];
            return r2 && r2.tileID.overscaledZ >= e22 ? r2 : null;
          }
          for (let r2 = t2.overscaledZ - 1; r2 >= e22; r2--) {
            const e3 = t2.scaledTo(r2), n2 = this._getLoadedTile(e3);
            if (n2)
              return n2;
          }
        }
        _getLoadedTile(t2) {
          const e22 = this._tiles[t2.key];
          return e22 && e22.hasData() ? e22 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
        }
        updateCacheSize(t2, e22) {
          e22 = e22 || this._source.tileSize;
          const r2 = Math.ceil(t2.width / e22) + 1, n2 = Math.ceil(t2.height / e22) + 1, i2 = Math.floor(r2 * n2 * 5), s2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i2) : i2, a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s2) : s2;
          this._cache.setMaxSize(a2);
        }
        handleWrapJump(t2) {
          const e22 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
          if (this._prevLng = t2, e22) {
            const t3 = {};
            for (const r2 in this._tiles) {
              const n2 = this._tiles[r2];
              n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e22), t3[n2.tileID.key] = n2;
            }
            this._tiles = t3;
            for (const t4 in this._timers)
              clearTimeout(this._timers[t4]), delete this._timers[t4];
            for (const t4 in this._tiles)
              this._setTileReloadTimer(+t4, this._tiles[t4]);
          }
        }
        update(t2, e22, r2, n2) {
          if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !r2)
            return;
          let i2;
          if (this.updateCacheSize(t2, e22), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? i2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new Hc(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (i2 = t2.coveringTiles({ tileSize: e22 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (i2 = i2.filter((t3) => this._source.hasTile(t3)))) : i2 = [], i2.length > 0 && this.castsShadows && n2 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !qg(this._source.type)) {
            const s3 = t2.coveringZoomLevel({ tileSize: e22 || this._source.tileSize, roundZoom: this._source.roundZoom && !r2 }), a3 = Math.min(s3, this._source.maxzoom), o2 = t2.extendTileCoverForShadows(i2, n2, a3);
            for (const t3 of o2)
              this._shadowCasterTiles[t3.key] = true, i2.push(t3);
          }
          const s2 = this._updateRetainedTiles(i2);
          if (qg(this._source.type) && 0 !== i2.length) {
            const t3 = {}, e3 = {}, r3 = Object.keys(s2);
            for (const n4 of r3) {
              const r4 = s2[n4], i3 = this._tiles[n4];
              if (!i3 || i3.fadeEndTime && i3.fadeEndTime <= Wt.now())
                continue;
              const a3 = this.findLoadedParent(r4, Math.max(r4.overscaledZ - Ng.maxOverzooming, this._source.minzoom));
              a3 && (this._addTile(a3.tileID), t3[a3.tileID.key] = a3.tileID), e3[n4] = r4;
            }
            const n3 = i2[i2.length - 1].overscaledZ;
            for (const t4 in this._tiles) {
              const r4 = this._tiles[t4];
              if (s2[t4] || !r4.hasData())
                continue;
              let i3 = r4.tileID;
              for (; i3.overscaledZ > n3; ) {
                i3 = i3.scaledTo(i3.overscaledZ - 1);
                const n4 = this._tiles[i3.key];
                if (n4 && n4.hasData() && e3[i3.key]) {
                  s2[t4] = r4.tileID;
                  break;
                }
              }
            }
            for (const e4 in t3)
              s2[e4] || (this._coveredTiles[e4] = true, s2[e4] = t3[e4]);
          }
          for (const t3 in s2)
            this._tiles[t3].clearFadeHold();
          const a2 = function(t3, e3) {
            const r3 = [];
            for (const n3 in t3)
              n3 in e3 || r3.push(n3);
            return r3;
          }(this._tiles, s2);
          for (const t3 of a2) {
            const e3 = this._tiles[t3];
            e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t2 in this._tiles)
            this._tiles[t2].holdingForFade() && this._removeTile(+t2);
        }
        _updateRetainedTiles(t2) {
          const e22 = {};
          if (0 === t2.length)
            return e22;
          const r2 = {}, n2 = t2.reduce((t3, e3) => Math.min(t3, e3.overscaledZ), 1 / 0), i2 = t2[0].overscaledZ, s2 = Math.max(i2 - Ng.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + Ng.maxUnderzooming, this._source.minzoom), o2 = {};
          for (const r3 of t2) {
            const t3 = this._addTile(r3);
            e22[r3.key] = r3, t3.hasData() || n2 < this._source.maxzoom && (o2[r3.key] = r3);
          }
          this._retainLoadedChildren(o2, n2, a2, e22);
          for (const n3 of t2) {
            let t3 = this._tiles[n3.key];
            if (t3.hasData())
              continue;
            if (n3.canonical.z >= this._source.maxzoom) {
              const t4 = n3.children(this._source.maxzoom)[0], r3 = this.getTile(t4);
              if (r3 && r3.hasData()) {
                e22[t4.key] = t4;
                continue;
              }
            } else {
              const t4 = n3.children(this._source.maxzoom);
              if (e22[t4[0].key] && e22[t4[1].key] && e22[t4[2].key] && e22[t4[3].key])
                continue;
            }
            let i3 = t3.wasRequested();
            for (let a3 = n3.overscaledZ - 1; a3 >= s2; --a3) {
              const s3 = n3.scaledTo(a3);
              if (r2[s3.key])
                break;
              if (r2[s3.key] = true, t3 = this.getTile(s3), !t3 && i3 && (t3 = this._addTile(s3)), t3 && (e22[s3.key] = s3, i3 = t3.wasRequested(), t3.hasData()))
                break;
            }
          }
          return e22;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t2 in this._tiles) {
            const e22 = [];
            let r2, n2 = this._tiles[t2].tileID;
            for (; n2.overscaledZ > 0; ) {
              if (n2.key in this._loadedParentTiles) {
                r2 = this._loadedParentTiles[n2.key];
                break;
              }
              e22.push(n2.key);
              const t3 = n2.scaledTo(n2.overscaledZ - 1);
              if (r2 = this._getLoadedTile(t3), r2)
                break;
              n2 = t3;
            }
            for (const t3 of e22)
              this._loadedParentTiles[t3] = r2;
          }
        }
        _addTile(t2) {
          let e22 = this._tiles[t2.key];
          if (e22)
            return true !== e22.isExtraShadowCaster || !!this._shadowCasterTiles[t2.key] || this._reloadTile(t2.key, "reloading"), e22;
          e22 = this._cache.getAndRemove(t2), e22 && (this._setTileReloadTimer(t2.key, e22), e22.tileID = t2, this._state.initializeTileState(e22, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e22)));
          const r2 = Boolean(e22);
          if (!r2) {
            const r3 = this.map ? this.map.painter : null;
            e22 = new Bg(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom, r3, this._isRaster), this._loadTile(e22, this._tileLoaded.bind(this, e22, t2.key, e22.state));
          }
          return e22 ? (e22.uses++, this._tiles[t2.key] = e22, r2 || this._source.fire(new Qt("dataloading", { tile: e22, coord: e22.tileID, dataType: "source" })), e22) : null;
        }
        _setTileReloadTimer(t2, e22) {
          t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
          const r2 = e22.getExpiryTimeout();
          r2 && (this._timers[t2] = setTimeout(() => {
            this._reloadTile(t2, "expired"), delete this._timers[t2];
          }, r2));
        }
        _removeTile(t2) {
          const e22 = this._tiles[t2];
          e22 && (e22.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e22.uses > 0 || (e22.hasData() && "reloading" !== e22.state ? this._cache.add(e22.tileID, e22, e22.getExpiryTimeout()) : (e22.aborted = true, this._abortTile(e22), this._unloadTile(e22))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t2 in this._tiles)
            this._removeTile(+t2);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t2, e22, r2) {
          const n2 = [], i2 = this.transform;
          if (!i2)
            return n2;
          const s2 = "globe" === i2.projection.name, a2 = Hh(i2.center.lng);
          for (const o2 in this._tiles) {
            const l2 = this._tiles[o2];
            if (r2 && l2.clearQueryDebugViz(), l2.holdingForFade())
              continue;
            let u2;
            if (s2) {
              const t3 = l2.tileID.canonical;
              if (0 === t3.z) {
                const e3 = [Math.abs(k(a2, ...Gg(t3, -1)) - a2), Math.abs(k(a2, ...Gg(t3, 1)) - a2)];
                u2 = [0, 2 * e3.indexOf(Math.min(...e3)) - 1];
              } else {
                const e3 = [Math.abs(k(a2, ...Gg(t3, -1)) - a2), Math.abs(k(a2, ...Gg(t3, 0)) - a2), Math.abs(k(a2, ...Gg(t3, 1)) - a2)];
                u2 = [e3.indexOf(Math.min(...e3)) - 1];
              }
            } else
              u2 = [0];
            for (const r3 of u2) {
              const s3 = t2.containsTile(l2, i2, e22, r3);
              s3 && n2.push(s3);
            }
          }
          return n2;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(false, true);
        }
        getVisibleCoordinates(t2) {
          return this._getRenderableCoordinates(t2);
        }
        _getRenderableCoordinates(t2, e22) {
          const r2 = this.getRenderableIds(t2, e22).map((t3) => this._tiles[t3].tileID), n2 = "globe" === this.transform.projection.name;
          for (const t3 of r2)
            t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped()), t3.expandedProjMatrix = n2 ? this.transform.calculateProjMatrix(t3.toUnwrapped(), false, true) : t3.projMatrix;
          return r2;
        }
        sortCoordinatesByDistance(t2) {
          const e22 = t2.slice(), r2 = this.transform._camera.position, n2 = this.transform._camera.forward(), i2 = {};
          for (const t3 of e22) {
            const e3 = 1 / (1 << t3.canonical.z);
            i2[t3.key] = ((t3.canonical.x + 0.5) * e3 + t3.wrap - r2[0]) * n2[0] + ((t3.canonical.y + 0.5) * e3 - r2[1]) * n2[1] - r2[2] * n2[2];
          }
          return e22.sort((t3, e3) => i2[t3.key] - i2[e3.key]), e22;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (qg(this._source.type))
            for (const t2 in this._tiles) {
              const e22 = this._tiles[t2];
              if (void 0 !== e22.fadeEndTime && e22.fadeEndTime >= Wt.now())
                return true;
            }
          return false;
        }
        setFeatureState(t2, e22, r2) {
          this._state.updateState(t2 = t2 || "_geojsonTileLayer", e22, r2);
        }
        removeFeatureState(t2, e22, r2) {
          this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e22, r2);
        }
        getFeatureState(t2, e22) {
          return this._state.getState(t2 = t2 || "_geojsonTileLayer", e22);
        }
        setDependencies(t2, e22, r2) {
          const n2 = this._tiles[t2];
          n2 && n2.setDependencies(e22, r2);
        }
        reloadTilesForDependencies(t2, e22) {
          for (const r2 in this._tiles)
            this._tiles[r2].hasDependency(t2, e22) && this._reloadTile(+r2, "reloading");
          this._cache.filter((r2) => !r2.hasDependency(t2, e22));
        }
        _preloadTiles(t2, e22) {
          if (!this._sourceLoaded) {
            const r3 = () => {
              this._sourceLoaded && (this._source.off("data", r3), this._preloadTiles(t2, e22));
            };
            return void this._source.on("data", r3);
          }
          const r2 = /* @__PURE__ */ new Map(), n2 = Array.isArray(t2) ? t2 : [t2], i2 = this.map.painter.terrain, s2 = this.usedForTerrain && i2 ? i2.getScaledDemTileSize() : this._source.tileSize;
          for (const t3 of n2) {
            const e3 = t3.coveringTiles({ tileSize: s2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const t4 of e3)
              r2.set(t4.key, t4);
            this.usedForTerrain && t3.updateElevation(false);
          }
          z(Array.from(r2.values()), (t3, e3) => {
            const r3 = new Bg(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(r3, (t4) => {
              "raster-dem" === this._source.type && r3.dem && this._backfillDEM(r3), e3(t4, r3);
            });
          }, e22);
        }
      }
      function $g(t2, e22) {
        const r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e22.wrap) - +(e22.wrap < 0);
        return t2.overscaledZ - e22.overscaledZ || n2 - r2 || e22.canonical.y - t2.canonical.y || e22.canonical.x - t2.canonical.x;
      }
      function qg(t2) {
        return "raster" === t2 || "image" === t2 || "video" === t2 || "custom" === t2;
      }
      function Gg(t2, e22) {
        const r2 = 1 << t2.z;
        return [t2.x / r2 + e22, (t2.x + 1) / r2 + e22];
      }
      Ng.maxOverzooming = 10, Ng.maxUnderzooming = 3;
      const Yg = Ua([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Zg = Ua([{ name: "a_color_3f", components: 3, type: "Float32" }]), Xg = Ua([{ name: "a_color_4f", components: 4, type: "Float32" }]), Kg = Ua([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Wg = Ua([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Hg = Ua([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), Jg = Ua([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]);
      function Qg(e22, r2) {
        const n2 = ex(e22.projection, e22.zoom, e22.width, e22.height), i2 = function(e3, r3, n3, i3, s3) {
          const a2 = new Zh(n3.lng - 180 * rx, n3.lat), o2 = new Zh(n3.lng + 180 * rx, n3.lat), l2 = e3.project(a2.lng, a2.lat), u2 = e3.project(o2.lng, o2.lat), c2 = -Math.atan2(u2.y - l2.y, u2.x - l2.x), h22 = lp.fromLngLat(n3);
          h22.y = k(h22.y, -1 + rx, 1 - rx);
          const p2 = h22.toLngLat(), f2 = e3.project(p2.lng, p2.lat), d2 = lp.fromLngLat(p2);
          d2.x += rx;
          const m2 = d2.toLngLat(), y2 = e3.project(m2.lng, m2.lat), g2 = ix(y2.x - f2.x, y2.y - f2.y, c2), x2 = lp.fromLngLat(p2);
          x2.y += rx;
          const v2 = x2.toLngLat(), b2 = e3.project(v2.lng, v2.lat), _2 = ix(b2.x - f2.x, b2.y - f2.y, c2), w2 = Math.abs(g2.x) / Math.abs(_2.y), M2 = t.m.identity([]);
          t.m.rotateZ(M2, M2, -c2 * (1 - (s3 ? 0 : i3)));
          const A2 = t.m.identity([]);
          return t.m.scale(A2, A2, [1, 1 - (1 - w2) * i3, 1]), A2[4] = -_2.x / _2.y * i3, t.m.rotateZ(A2, A2, c2), t.m.multiply(A2, M2, A2), A2;
        }(e22.projection, 0, e22.center, n2, r2), s2 = tx(e22);
        return t.m.scale(i2, i2, [s2, s2, 1]), i2;
      }
      function tx(t2) {
        const e22 = t2.projection, r2 = ex(t2.projection, t2.zoom, t2.width, t2.height), n2 = nx(e22, t2.center), i2 = nx(e22, Zh.convert(e22.center));
        return Math.pow(2, n2 * r2 + (1 - r2) * i2);
      }
      function ex(t2, e22, r2, n2, i2 = 1 / 0) {
        const s2 = t2.range;
        if (!s2)
          return 0;
        const a2 = Math.min(i2, Math.max(r2, n2)), o2 = Math.log(a2 / 1024) / Math.LN2;
        return T(s2[0] + o2, s2[1] + o2, e22);
      }
      const rx = 1 / 4e4;
      function nx(t2, e22) {
        const r2 = k(e22.lat, -np, np), n2 = new Zh(e22.lng - 180 * rx, r2), i2 = new Zh(e22.lng + 180 * rx, r2), s2 = t2.project(n2.lng, r2), a2 = t2.project(i2.lng, r2), o2 = lp.fromLngLat(n2), l2 = lp.fromLngLat(i2), u2 = a2.x - s2.x, c2 = a2.y - s2.y, h22 = l2.x - o2.x, p2 = l2.y - o2.y, f2 = Math.sqrt((h22 * h22 + p2 * p2) / (u2 * u2 + c2 * c2));
        return Math.log(f2) / Math.LN2;
      }
      function ix(t2, e22, r2) {
        const n2 = Math.cos(r2), i2 = Math.sin(r2);
        return { x: t2 * n2 - e22 * i2, y: t2 * i2 + e22 * n2 };
      }
      function sx(t2, e22, r2) {
        return e22 * (Cr / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
      }
      function ax(e22, r2, n2) {
        t.m.identity(e22), t.m.rotateZ(e22, e22, _(r2[2])), t.m.rotateX(e22, e22, _(r2[0])), t.m.rotateY(e22, e22, _(r2[1])), t.m.scale(e22, e22, n2), t.m.multiply(e22, e22, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function ox(e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = [n2[0] - r2[0], n2[1] - r2[1], 0], c2 = [i2[0] - r2[0], i2[1] - r2[1], 0];
        if (t.v.length(u2) < 1e-12 || t.v.length(c2) < 1e-12)
          return t.q.identity(e22);
        const h22 = t.v.cross([], u2, c2);
        t.v.normalize(h22, h22), t.v.subtract(c2, i2, r2), u2[2] = (a2 - s2) * l2, c2[2] = (o2 - s2) * l2;
        const p2 = u2;
        return t.v.cross(p2, u2, c2), t.v.normalize(p2, p2), t.q.rotationTo(e22, h22, p2);
      }
      function lx(e22, r2, n2 = false) {
        const i2 = Oh(r2.zoom), s2 = function(e3, r3, n3) {
          const i3 = r3.worldSize, s3 = [e3[12], e3[13], e3[14]], a2 = ep(s3[1] / i3), o2 = tp(s3[0] / i3), l2 = t.m.identity([]), u2 = Qh(1, a2) * i3, c2 = Qh(1, 0) * i3 * sp(a2, r3.zoom), h22 = 1 / Rh(i3);
          let p2 = c2 * h22;
          if (n3) {
            const t2 = ex(r3.projection, r3.zoom, r3.width, r3.height, 1024);
            p2 = h22 * r3.projection.pixelSpaceConversion(r3.center.lat, i3, t2);
          }
          const f2 = Ph(a2, o2);
          t.v.add(f2, f2, t.v.scale([], t.v.normalize([], f2), u2 * p2 * s3[2]));
          const d2 = function(e4) {
            const r4 = [e4[0], e4[1], e4[2]];
            let n4 = [0, 1, 0];
            const i4 = t.v.cross([], n4, r4);
            return t.v.cross(n4, r4, i4), 0 === t.v.squaredLength(n4) && (n4 = [0, 1, 0], t.v.cross(i4, r4, n4)), t.v.normalize(i4, i4), t.v.normalize(n4, n4), t.v.normalize(r4, r4), [i4[0], i4[1], i4[2], 0, n4[0], n4[1], n4[2], 0, r4[0], r4[1], r4[2], 0, e4[0], e4[1], e4[2], 1];
          }(f2);
          t.m.scale(l2, l2, [p2, p2, p2 * u2]), t.m.translate(l2, l2, [-s3[0], -s3[1], -s3[2]]);
          const m2 = t.m.multiply([], r3.globeMatrix, d2);
          return t.m.multiply(m2, m2, l2), t.m.multiply(m2, m2, e3), m2;
        }(e22, r2, n2);
        if (i2 > 0) {
          const n3 = function(e3, r3) {
            const n4 = r3.worldSize, i3 = Qh(1, 0) * n4 * sp(r3.center.lat, r3.zoom) / Rh(n4), s3 = Qh(1, r3.center.lat) * n4, a2 = t.m.identity([]);
            return t.m.rotateY(a2, a2, _(r3.center.lng)), t.m.rotateX(a2, a2, _(r3.center.lat)), t.m.translate(a2, a2, [0, 0, ch]), t.m.scale(a2, a2, [i3, i3, i3 * s3]), t.m.translate(a2, a2, [r3.point.x - 0.5 * n4, r3.point.y - 0.5 * n4, 0]), t.m.multiply(a2, a2, e3), t.m.multiply(a2, r3.globeMatrix, a2);
          }(e22, r2);
          return function(e3, r3, n4) {
            const i3 = (e4, r4, n5) => {
              const i4 = t.v.length(e4), s4 = t.v.length(r4), a3 = wh(e4, r4, n5);
              return t.v.scale(a3, a3, 1 / t.v.length(a3) * Mn(i4, s4, n5));
            }, s3 = i3([e3[0], e3[1], e3[2]], [r3[0], r3[1], r3[2]], n4), a2 = i3([e3[4], e3[5], e3[6]], [r3[4], r3[5], r3[6]], n4), o2 = i3([e3[8], e3[9], e3[10]], [r3[8], r3[9], r3[10]], n4), l2 = wh([e3[12], e3[13], e3[14]], [r3[12], r3[13], r3[14]], n4);
            return [s3[0], s3[1], s3[2], 0, a2[0], a2[1], a2[2], 0, o2[0], o2[1], o2[2], 0, l2[0], l2[1], l2[2], 1];
          }(s2, n3, i2);
        }
        return s2;
      }
      const ux = 64, cx = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4 };
      function hx(t2, e22, r2 = false) {
        t2.uploaded || (t2.gfxTexture = new _g(e22, t2.image, r2 ? e22.gl.R8 : e22.gl.RGBA, { useMipmap: t2.sampler.minFilter >= e22.gl.NEAREST_MIPMAP_NEAREST }), t2.uploaded = true, t2.image = null);
      }
      function px(t2, e22, r2) {
        t2.indexBuffer = e22.createIndexBuffer(t2.indexArray, false, true), t2.vertexBuffer = e22.createVertexBuffer(t2.vertexArray, Yg.members, false, true), t2.normalArray && (t2.normalBuffer = e22.createVertexBuffer(t2.normalArray, Wg.members, false, true)), t2.texcoordArray && (t2.texcoordBuffer = e22.createVertexBuffer(t2.texcoordArray, Kg.members, false, true)), t2.colorArray && (t2.colorBuffer = e22.createVertexBuffer(t2.colorArray, (12 === t2.colorArray.bytesPerElement ? Zg : Xg).members, false, true)), t2.featureArray && (t2.pbrBuffer = e22.createVertexBuffer(t2.featureArray, Jg.members, true)), t2.segments = Do.simpleSegment(0, 0, t2.vertexArray.length, t2.indexArray.length);
        const n2 = t2.material;
        n2.pbrMetallicRoughness.baseColorTexture && hx(n2.pbrMetallicRoughness.baseColorTexture, e22), n2.pbrMetallicRoughness.metallicRoughnessTexture && hx(n2.pbrMetallicRoughness.metallicRoughnessTexture, e22), n2.normalTexture && hx(n2.normalTexture, e22), n2.occlusionTexture && hx(n2.occlusionTexture, e22, r2), n2.emissionTexture && hx(n2.emissionTexture, e22);
      }
      function fx(t2, e22, r2) {
        if (t2.meshes)
          for (const n2 of t2.meshes)
            px(n2, e22, r2);
        if (t2.children)
          for (const n2 of t2.children)
            fx(n2, e22, r2);
      }
      function dx(t2) {
        if (t2.meshes)
          for (const e22 of t2.meshes)
            e22.indexArray.destroy(), e22.vertexArray.destroy(), e22.colorArray && e22.colorArray.destroy(), e22.normalArray && e22.normalArray.destroy(), e22.texcoordArray && e22.texcoordArray.destroy(), e22.featureArray && e22.featureArray.destroy();
        if (t2.children)
          for (const e22 of t2.children)
            dx(e22);
      }
      function mx(t2) {
        if (t2.meshes)
          for (const r2 of t2.meshes)
            r2.vertexBuffer && (r2.vertexBuffer.destroy(), r2.indexBuffer.destroy(), r2.normalBuffer && r2.normalBuffer.destroy(), r2.texcoordBuffer && r2.texcoordBuffer.destroy(), r2.colorBuffer && r2.colorBuffer.destroy(), r2.pbrBuffer && r2.pbrBuffer.destroy(), r2.segments.destroy(), r2.material && ((e22 = r2.material).pbrMetallicRoughness.baseColorTexture && e22.pbrMetallicRoughness.baseColorTexture.gfxTexture && e22.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e22.pbrMetallicRoughness.metallicRoughnessTexture && e22.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e22.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e22.normalTexture && e22.normalTexture.gfxTexture && e22.normalTexture.gfxTexture.destroy(), e22.emissionTexture && e22.emissionTexture.gfxTexture && e22.emissionTexture.gfxTexture.destroy(), e22.occlusionTexture && e22.occlusionTexture.gfxTexture && e22.occlusionTexture.gfxTexture.destroy()));
        var e22;
        if (t2.children)
          for (const e3 of t2.children)
            mx(e3);
      }
      class yx {
        constructor(t2, e22) {
          this.feature = t2, this.instancedDataOffset = e22, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
        }
      }
      class gx {
        constructor() {
          this.instancedDataArray = new go(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
        }
      }
      class xx {
        constructor(t2) {
          this.zoom = t2.zoom, this.canonical = t2.canonical, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.projection = t2.projection, this.index = t2.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 };
        }
        populate(t2, e22, r2, n2) {
          this.tileToMeter = op(r2);
          const i2 = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: s2, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
            const t3 = gp(s2, i2);
            if (!this.layers[0]._featureFilter.filter(new _a2(this.zoom), t3, r2))
              continue;
            const u2 = { id: a2, sourceLayerIndex: l2, index: o2, geometry: i2 ? t3.geometry : yp(s2, r2, n2), properties: s2.properties, type: s2.type, patterns: {} }, c2 = this.addFeature(u2, u2.geometry, t3);
            c2 && e22.featureIndex.insert(s2, u2.geometry, o2, l2, this.index, this.instancesPerModel[c2].instancedDataArray.length);
          }
          this.lookup = null;
        }
        update(t2, e22, r2, n2) {
          for (const e3 in this.instancesPerModel) {
            const r3 = this.instancesPerModel[e3];
            for (const e4 in t2)
              r3.idToFeaturesIndex.hasOwnProperty(e4) && this.evaluate(r3.features[r3.idToFeaturesIndex[e4]], t2[e4], r3, true);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties)
            return false;
          let e22 = false;
          for (const r2 in this.instancesPerModel) {
            const n2 = this.instancesPerModel[r2];
            for (const r3 of n2.features) {
              const i2 = this.layers[0], s2 = r3.feature, a2 = this.canonical, o2 = i2.paint.get("model-rotation").evaluate(s2, {}, a2), l2 = i2.paint.get("model-scale").evaluate(s2, {}, a2), u2 = i2.paint.get("model-translation").evaluate(s2, {}, a2);
              t.v.exactEquals(r3.rotation, o2) && t.v.exactEquals(r3.scale, l2) && t.v.exactEquals(r3.translation, u2) || (this.evaluate(r3, r3.featureStates, n2, true), e22 = true);
            }
          }
          return e22;
        }
        isEmpty() {
          for (const t2 in this.instancesPerModel)
            if (0 !== this.instancesPerModel[t2].instancedDataArray.length)
              return false;
          return true;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(t2) {
          if (!this.uploaded)
            for (const e22 in this.instancesPerModel) {
              const r2 = this.instancesPerModel[e22];
              r2.instancedDataArray.length < 0 || 0 === r2.instancedDataArray.length || (r2.instancedDataBuffer ? r2.instancedDataBuffer.updateData(r2.instancedDataArray) : r2.instancedDataBuffer = t2.createVertexBuffer(r2.instancedDataArray, Hg.members, true, void 0, this.instanceCount));
            }
          this.uploaded = true;
        }
        destroy() {
          for (const t2 in this.instancesPerModel) {
            const e22 = this.instancesPerModel[t2];
            0 !== e22.instancedDataArray.length && e22.instancedDataBuffer && e22.instancedDataBuffer.destroy();
          }
        }
        addFeature(t2, e22, r2) {
          const n2 = this.layers[0], i2 = n2.layout.get("model-id").evaluate(r2, {}, this.canonical);
          if (!i2)
            return q(`modelId is not evaluated for layer ${n2.id} and it is not going to get rendered.`), i2;
          this.instancesPerModel[i2] || (this.instancesPerModel[i2] = new gx());
          const s2 = this.instancesPerModel[i2], a2 = s2.instancedDataArray, o2 = new yx(r2, a2.length);
          for (const t3 of e22)
            for (const e3 of t3) {
              if (e3.x < 0 || e3.x >= Cr || e3.y < 0 || e3.y >= Cr)
                continue;
              const t4 = (this.lookupDim - 1) / Cr, r3 = this.lookupDim * (e3.y * t4 | 0) + e3.x * t4 | 0;
              if (this.lookup) {
                if (0 !== this.lookup[r3])
                  continue;
                this.lookup[r3] = 1;
              }
              this.instanceCount++;
              const n3 = a2.length;
              a2.resize(n3 + 1), s2.instancesEvaluatedElevation.push(0), a2.float32[16 * n3] = e3.x, a2.float32[16 * n3 + 1] = e3.y;
            }
          return o2.instancedDataCount = s2.instancedDataArray.length - o2.instancedDataOffset, o2.instancedDataCount > 0 && (t2.id && (s2.idToFeaturesIndex[t2.id] = s2.features.length), s2.features.push(o2), this.evaluate(o2, {}, s2, false)), i2;
        }
        evaluate(t2, e22, r2, n2) {
          const i2 = this.layers[0], s2 = t2.feature, a2 = this.canonical, o2 = t2.rotation = i2.paint.get("model-rotation").evaluate(s2, e22, a2), l2 = t2.scale = i2.paint.get("model-scale").evaluate(s2, e22, a2), u2 = t2.translation = i2.paint.get("model-translation").evaluate(s2, e22, a2), c2 = i2.paint.get("model-color").evaluate(s2, e22, a2);
          c2.a = i2.paint.get("model-color-mix-intensity").evaluate(s2, e22, a2);
          const h22 = [];
          this.maxVerticalOffset < u2[2] && (this.maxVerticalOffset = u2[2]), this.maxScale = Math.max(Math.max(this.maxScale, l2[0]), Math.max(l2[1], l2[2])), ax(h22, o2, l2);
          const p2 = Math.round(100 * c2.a) + c2.b / 1.05;
          for (let e3 = 0; e3 < t2.instancedDataCount; ++e3) {
            const i3 = t2.instancedDataOffset + e3, s3 = 16 * i3, o3 = r2.instancedDataArray.float32;
            let l3 = 0;
            n2 && (l3 = o3[s3 + 6] - r2.instancesEvaluatedElevation[i3]);
            const f2 = 0 | o3[s3 + 1];
            o3[s3] = (0 | o3[s3]) + c2.r / 1.05, o3[s3 + 1] = f2 + c2.g / 1.05, o3[s3 + 2] = p2, o3[s3 + 3] = 1 / (a2.z > 10 ? this.tileToMeter : op(a2, f2)), o3[s3 + 4] = u2[0], o3[s3 + 5] = u2[1], o3[s3 + 6] = u2[2] + l3, o3[s3 + 7] = h22[0], o3[s3 + 8] = h22[1], o3[s3 + 9] = h22[2], o3[s3 + 10] = h22[4], o3[s3 + 11] = h22[5], o3[s3 + 12] = h22[6], o3[s3 + 13] = h22[8], o3[s3 + 14] = h22[9], o3[s3 + 15] = h22[10], r2.instancesEvaluatedElevation[i3] = u2[2];
          }
        }
      }
      Ks(xx, "ModelBucket", { omit: ["layers"] }), Ks(gx, "PerModelAttributes"), Ks(yx, "ModelFeature");
      const vx = new Da({ visibility: new za(re2.layout_model.visibility), "model-id": new Ea(re2.layout_model["model-id"]) });
      var bx = { paint: new Da({ "model-opacity": new za(re2.paint_model["model-opacity"]), "model-rotation": new Ea(re2.paint_model["model-rotation"]), "model-scale": new Ea(re2.paint_model["model-scale"]), "model-translation": new Ea(re2.paint_model["model-translation"]), "model-color": new Ea(re2.paint_model["model-color"]), "model-color-mix-intensity": new Ea(re2.paint_model["model-color-mix-intensity"]), "model-type": new za(re2.paint_model["model-type"]), "model-cast-shadows": new za(re2.paint_model["model-cast-shadows"]), "model-receive-shadows": new za(re2.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new za(re2.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new Ea(re2.paint_model["model-emissive-strength"]), "model-roughness": new Ea(re2.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new Ea(re2.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new za(re2.paint_model["model-cutoff-fade-range"]) }), layout: vx };
      const _x = new Float32Array(262144), wx = new Uint8Array(262144);
      function Mx(t2) {
        let e22 = 0;
        if (t2.meshes)
          for (const r2 of t2.meshes)
            e22 = Math.max(e22, r2.aabb.max[2]);
        if (t2.children)
          for (const r2 of t2.children)
            e22 = Math.max(e22, Mx(r2));
        return e22;
      }
      const Ax = ["", "wall", "door", "roof", "window", "lamp", "logo"];
      class Sx {
        constructor(t2) {
          this.node = t2, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.feature = { type: "Point", id: t2.id, geometry: [], properties: { height: Mx(t2) } };
        }
      }
      class Ix {
        constructor(t2, e22, r2, n2) {
          this.nodes = t2, this.id = e22, this.modelTraits |= cx.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, r2 && (this.modelTraits |= cx.HasMapboxMeshFeatures), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = n2, this.dirty = true, this.needsUpload = false;
        }
        update() {
          console.log("Update 3D model bucket");
        }
        populate() {
          console.log("populate 3D model bucket");
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(t2) {
          if (!this.needsUpload)
            return;
          const e22 = this.getNodesInfo();
          for (const r2 of e22) {
            const e3 = r2.node;
            this.uploaded ? this.updatePbrBuffer(e3) : fx(e3, t2, true);
          }
          for (const t3 of e22)
            dx(t3.node);
          this.uploaded = true, this.needsUpload = false;
        }
        updatePbrBuffer(t2) {
          let e22 = false;
          if (!t2.meshes)
            return e22;
          for (const r2 of t2.meshes)
            r2.pbrBuffer && (r2.pbrBuffer.updateData(r2.featureArray), e22 = true);
          return e22;
        }
        needsReEvaluation(t2, e22, r2) {
          const n2 = t2.transform.projectionOptions, i2 = t2.style.getBrightness(), s2 = this.brightness !== i2;
          return !!(!this.uploaded || this.dirty || n2.name !== this.projection.name || kx(r2.paint.get("model-color").value, s2) || kx(r2.paint.get("model-color-mix-intensity").value, s2) || kx(r2.paint.get("model-roughness").value, s2) || kx(r2.paint.get("model-emissive-strength").value, s2) || kx(r2.paint.get("model-height-based-emissive-strength-multiplier").value, s2)) && (this.projection = n2, this.brightness = i2, true);
        }
        evaluateScale(t2, e22) {
          if (t2.transform.zoom === this.zoom)
            return;
          this.zoom = t2.transform.zoom;
          const r2 = this.getNodesInfo(), n2 = this.id.canonical;
          for (const t3 of r2) {
            const r3 = t3.feature;
            t3.evaluatedScale = e22.paint.get("model-scale").evaluate(r3, {}, n2);
          }
        }
        evaluate(t2) {
          const e22 = this.getNodesInfo();
          for (const r2 of e22) {
            if (!r2.node.meshes)
              continue;
            const e3 = r2.feature, n2 = r2.node.meshes && r2.node.meshes[0].featureData, i2 = r2.evaluatedColor[2], s2 = r2.evaluatedRMEA[2], a2 = this.id.canonical;
            if (r2.hasTranslucentParts = false, n2) {
              for (let n3 = 0; n3 < Ax.length; n3++) {
                const i3 = Ax[n3];
                i3.length && (e3.properties.part = i3);
                const s3 = t2.paint.get("model-color").evaluate(e3, {}, a2), o2 = t2.paint.get("model-color-mix-intensity").evaluate(e3, {}, a2);
                r2.evaluatedColor[n3] = [s3.r, s3.g, s3.b, o2], r2.evaluatedRMEA[n3][0] = t2.paint.get("model-roughness").evaluate(e3, {}, a2), r2.evaluatedRMEA[n3][2] = t2.paint.get("model-emissive-strength").evaluate(e3, {}, a2), r2.evaluatedRMEA[n3][3] = s3.a, r2.emissionHeightBasedParams[n3] = t2.paint.get("model-height-based-emissive-strength-multiplier").evaluate(e3, {}, a2), !r2.hasTranslucentParts && s3.a < 1 && (r2.hasTranslucentParts = true);
              }
              delete e3.properties.part, Px(r2, i2 !== r2.evaluatedColor[2] || s2 !== r2.evaluatedRMEA[2]);
            } else
              r2.evaluatedRMEA[0][2] = t2.paint.get("model-emissive-strength").evaluate(e3, {}, a2);
            r2.evaluatedScale = t2.paint.get("model-scale").evaluate(e3, {}, a2), this.updatePbrBuffer(r2.node) || (this.needsUpload = true);
          }
          this.dirty = false;
        }
        elevationUpdate(t2, e22, r2, n2) {
          const i2 = t2.findDEMTileFor(r2);
          if (i2 && (i2.tileID.canonical !== this.terrainTile || e22 !== this.terrainExaggeration)) {
            if (i2.dem && i2.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = i2.tileID.overscaledZ;
              const e3 = Wd.create(t2, r2, i2);
              if (!e3)
                return;
              this.modelTraits & cx.HasMapboxMeshFeatures && this.updateDEM(t2, e3, r2, n2);
              for (const t3 of this.getNodesInfo()) {
                const r3 = t3.node;
                if (!r3.footprint || !r3.footprint.vertices || !r3.footprint.vertices.length)
                  continue;
                const n3 = r3.footprint.vertices;
                let i3 = e3.getElevationAt(n3[0].x, n3[0].y, true, true);
                for (let t4 = 1; t4 < n3.length; t4++)
                  i3 = Math.min(i3, e3.getElevationAt(n3[t4].x, n3[t4].y, true, true));
                r3.elevation = i3;
              }
            }
            this.terrainTile = i2.tileID.canonical, this.terrainExaggeration = e22;
          }
        }
        updateDEM(t2, e22, r2, n2) {
          let i2 = e22._dem._modifiedForSources[n2];
          if (void 0 === i2 && (e22._dem._modifiedForSources[n2] = [], i2 = e22._dem._modifiedForSources[n2]), i2.includes(r2.canonical))
            return;
          const s2 = e22._dem.dim;
          i2.push(r2.canonical);
          let a2 = false;
          for (const t3 of this.getNodesInfo()) {
            const r3 = t3.node;
            if (!r3.footprint || !r3.footprint.grid)
              continue;
            const n3 = r3.footprint.grid, i3 = e22.tileCoordToPixel(n3.min.x, n3.min.y), o2 = e22.tileCoordToPixel(n3.max.x, n3.max.y), l2 = Math.min(Math.min(s2 - o2.y, i3.x), Math.min(i3.y, s2 - o2.x));
            if (l2 < 0)
              continue;
            const u2 = k(l2, 2, 5);
            let c2 = Math.max(0, i3.x - u2), h22 = Math.max(0, i3.y - u2), p2 = Math.min(o2.x + u2, s2 - 1), f2 = Math.min(o2.y + u2, s2 - 1);
            for (let t4 = h22; t4 <= f2; ++t4)
              for (let e3 = c2; e3 <= p2; ++e3)
                wx[t4 * s2 + e3] = 255;
            let d2 = 0, m2 = 0;
            for (let t4 = 0; t4 < n3.cellsY; ++t4)
              for (let r4 = 0; r4 < n3.cellsX; ++r4) {
                if (!n3.cells[t4 * n3.cellsX + r4])
                  continue;
                const i4 = e22.tileCoordToPixel(n3.min.x + r4 / n3.xScale, n3.min.y + t4 / n3.yScale), a3 = e22.tileCoordToPixel(n3.min.x + (r4 + 1) / n3.xScale, n3.min.y + (t4 + 1) / n3.yScale);
                for (let t5 = i4.y; t5 <= Math.min(a3.y + 1, s2 - 1); ++t5)
                  for (let r5 = i4.x; r5 <= Math.min(a3.x + 1, s2 - 1); ++r5)
                    255 === wx[t5 * s2 + r5] && (wx[t5 * s2 + r5] = 0, d2 += e22.getElevationAtPixel(r5, t5), m2++);
              }
            const y2 = d2 / m2;
            c2 = Math.max(1, i3.x - u2), h22 = Math.max(1, i3.y - u2), p2 = Math.min(o2.x + u2, s2 - 2), f2 = Math.min(o2.y + u2, s2 - 2), a2 = true;
            for (let t4 = h22; t4 <= f2; ++t4)
              for (let r4 = c2; r4 <= p2; ++r4)
                0 === wx[t4 * s2 + r4] && (_x[t4 * s2 + r4] = e22._dem.set(r4, t4, y2));
            for (let t4 = 1; t4 < u2; ++t4) {
              c2 = Math.max(1, i3.x - t4), h22 = Math.max(1, i3.y - t4), p2 = Math.min(o2.x + t4, s2 - 2), f2 = Math.min(o2.y + t4, s2 - 2);
              for (let r4 = h22; r4 <= f2; ++r4)
                for (let n4 = c2; n4 <= p2; ++n4) {
                  const i4 = r4 * s2 + n4;
                  if (255 === wx[i4]) {
                    let a3 = 0, o3 = 0, l3 = -1, c3 = -1;
                    for (let e3 = -1; e3 <= 1; ++e3)
                      for (let i5 = -1; i5 <= 1; ++i5) {
                        const u3 = (r4 + e3) * s2 + n4 + i5;
                        if (wx[u3] >= t4)
                          continue;
                        const h3 = _x[u3], p3 = Math.abs(h3);
                        p3 > o3 && (a3 = h3, o3 = p3, l3 = i5, c3 = e3);
                      }
                    if (o3 > 0.1) {
                      const s3 = 1 - (t4 + 0.5 * Math.abs(l3 * c3)) / u2;
                      let o4 = e22._dem.get(n4, r4) + a3 * s3;
                      const h3 = e22._dem.get(n4 + l3, r4 + c3), p3 = e22._dem.get(n4 - l3, r4 - c3, true);
                      (o4 - h3) * (o4 - p3) > 0 && (o4 = (h3 + p3) / 2), _x[i4] = e22._dem.set(n4, r4, o4), wx[i4] = t4;
                    }
                  }
                }
            }
          }
          a2 && (e22._demTile.needsDEMTextureUpload = true, e22._dem._timestamp = Wt.now());
        }
        getNodesInfo() {
          if (!this.nodesInfo) {
            this.nodesInfo = [];
            for (const t2 of this.nodes)
              this.nodesInfo.push(new Sx(t2));
            this.freeNodes();
          }
          return this.nodesInfo;
        }
        freeNodes() {
          if (this.nodes) {
            for (const t2 of this.nodes)
              mx(t2);
            this.nodes.splice(0, this.nodes.length);
          }
        }
        destroy() {
          this.freeNodes();
          const t2 = this.getNodesInfo();
          for (const e22 of t2)
            dx(e22.node), mx(e22.node);
        }
        isEmpty() {
          return !this.nodes.length;
        }
        updateReplacement(t2, e22) {
          if (e22.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = e22.updateTime;
          const r2 = e22.getReplacementRegionsForTile(t2.toUnwrapped()), n2 = this.getNodesInfo();
          for (let t3 = 0; t3 < this.nodesInfo.length; t3++) {
            const e3 = n2[t3].node;
            n2[t3].hiddenByReplacement = !!e3.footprint && !r2.find((t4) => t4.footprint === e3.footprint);
          }
        }
        getHeightAtTileCoord(t2, e22) {
          const r2 = this.getNodesInfo(), n2 = [];
          for (let i2 = 0; i2 < this.nodesInfo.length; i2++) {
            const s2 = r2[i2], a2 = s2.node.meshes[0];
            if (t2 < a2.aabb.min[0] || e22 < a2.aabb.min[1] || t2 > a2.aabb.max[0] || e22 > a2.aabb.max[1])
              continue;
            const o2 = (t2 - a2.aabb.min[0]) / (a2.aabb.max[0] - a2.aabb.min[0]) * ux | 0, l2 = Math.min(63, (e22 - a2.aabb.min[1]) / (a2.aabb.max[1] - a2.aabb.min[1]) * ux | 0) * ux + Math.min(63, o2);
            if (!(a2.heightmap[l2] < 0 && s2.node.footprint)) {
              if (s2.hiddenByReplacement)
                return;
              return { height: a2.heightmap[l2], maxHeight: s2.feature.properties.height, hidden: false, verticalScale: s2.evaluatedScale[2] };
            }
            if (s2.node.footprint.grid.query(new x(t2, e22), new x(t2, e22), n2), n2.length > 0)
              return { height: void 0, maxHeight: s2.feature.properties.height, hidden: s2.hiddenByReplacement, verticalScale: s2.evaluatedScale[2] };
          }
        }
      }
      function kx(t2, e22) {
        return !t2.isLightConstant && e22;
      }
      function Tx(t2, e22, r2, n2, i2, s2, a2, o2) {
        let l2 = (61440 & e22 | (61440 & e22) >> 4) >> 8, u2 = (3840 & e22 | (3840 & e22) >> 4) >> 4, c2 = 240 & e22 | (240 & e22) >> 4;
        r2[3] > 0 && (l2 = Mn(l2, 255 * r2[0], r2[3]), u2 = Mn(u2, 255 * r2[1], r2[3]), c2 = Mn(c2, 255 * r2[2], r2[3]));
        const h22 = l2 << 8 | u2, p2 = c2 << 8 | Math.floor(255 * n2[3]), f2 = function(t3) {
          const e3 = k(t3, 0, 2);
          return Math.min(Math.round(0.5 * e3 * 255), 255);
        }(n2[2]) << 8 | 15 * n2[0] << 4 | 15 * n2[1], d2 = k(i2[0], 0, 1), m2 = k(i2[1], 0, 1), y2 = k(i2[2], 0, 1), g2 = k(i2[3], 0, 1);
        let x2, v2, b2, _2;
        if (d2 !== m2 && a2 !== s2 && m2 !== d2) {
          const t3 = a2 - s2;
          v2 = 1 / (t3 * (m2 - d2)), b2 = -(s2 + t3 * d2) / (t3 * (m2 - d2));
          const e3 = k(i2[4], -1, 1);
          _2 = Math.pow(10, e3), x2 = 255 * y2 << 8 | 255 * g2;
        } else
          x2 = 65535, v2 = 0, b2 = 1, _2 = 1;
        if (t2.emplaceBack(h22, p2, f2, x2, v2, b2, _2), o2) {
          const t3 = o2.length;
          o2.clear();
          for (let e3 = 0; e3 < t3; e3++)
            o2.emplaceBack(h22, p2, f2, x2, v2, b2, _2);
        }
      }
      function Px(t2, e22) {
        const r2 = t2.node;
        let n2 = 0;
        for (const i2 of r2.meshes) {
          if (r2.lights && r2.lightMeshIndex === n2)
            continue;
          if (!i2.featureData)
            continue;
          i2.featureArray = new xo(), i2.featureArray.reserve(i2.featureData.length);
          let s2 = e22;
          for (const e3 of i2.featureData) {
            let n3;
            const a2 = 65535 & e3, o2 = (15 & a2) < 8 ? 15 & a2 : 0, l2 = e3 >> 16 & 65535, u2 = t2.evaluatedRMEA[o2], c2 = t2.evaluatedColor[o2], h22 = t2.emissionHeightBasedParams[o2];
            if (s2 && 2 === o2 && r2.lights && (n3 = new xo(), n3.resize(10 * r2.lights.length)), Tx(i2.featureArray, l2, c2, u2, h22, i2.aabb.min[2], i2.aabb.max[2], n3), n3 && s2) {
              s2 = false;
              const t3 = r2.meshes[r2.lightMeshIndex];
              t3.featureArray = n3, t3.featureArray._trim();
            }
          }
          i2.featureArray._trim(), n2++;
        }
      }
      function zx(t2, e22) {
        return t2.x - e22.x || t2.y - e22.y;
      }
      function Ex(t2, e22) {
        return 0 === zx(t2.min, e22.min) && 0 === zx(t2.max, e22.max);
      }
      function Bx(t2, e22) {
        return !(t2.min.x > e22.max.x || t2.max.x < e22.min.x || t2.min.y > e22.max.y || t2.max.y < e22.min.y);
      }
      function Dx(t2, e22, r2) {
        const n2 = 1 / Cr, i2 = 1 / (1 << r2.canonical.z), s2 = (e22.x * n2 + r2.canonical.x) * i2 + r2.wrap, a2 = (e22.y * n2 + r2.canonical.y) * i2;
        return { min: new x((t2.x * n2 + r2.canonical.x) * i2 + r2.wrap, (t2.y * n2 + r2.canonical.y) * i2), max: new x(s2, a2) };
      }
      function Cx(t2, e22, r2) {
        const n2 = 1 << r2.canonical.z, i2 = ((e22.x - r2.wrap) * n2 - r2.canonical.x) * Cr, s2 = (e22.y * n2 - r2.canonical.y) * Cr;
        return { min: new x(((t2.x - r2.wrap) * n2 - r2.canonical.x) * Cr, (t2.y * n2 - r2.canonical.y) * Cr), max: new x(i2, s2) };
      }
      function Rx(t2, e22, r2, n2, i2, s2, a2) {
        const o2 = t2.indices, l2 = t2.vertices, u2 = [];
        for (let c2 = n2; c2 < n2 + i2; c2 += 3) {
          const n3 = e22[r2[c2 + 0] + s2], i3 = e22[r2[c2 + 1] + s2], h22 = e22[r2[c2 + 2] + s2], p2 = Math.min(n3.x, i3.x, h22.x), f2 = Math.max(n3.x, i3.x, h22.x), d2 = Math.min(n3.y, i3.y, h22.y), m2 = Math.max(n3.y, i3.y, h22.y);
          u2.length = 0, t2.grid.query(new x(p2, d2), new x(f2, m2), u2);
          for (let t3 = 0; t3 < u2.length; t3++) {
            const e3 = u2[t3];
            if (Cp(l2[o2[3 * e3 + 0]], l2[o2[3 * e3 + 1]], l2[o2[3 * e3 + 2]], n3, i3, h22, a2))
              return true;
          }
        }
        return false;
      }
      function Lx(t2, e22, r2, n2) {
        if (!t2 || !r2)
          return false;
        let i2 = t2.vertices;
        if (!e22.canonical.equals(n2.canonical) || e22.wrap !== n2.wrap) {
          if (r2.vertices.length < t2.vertices.length)
            return Lx(r2, n2, t2, e22);
          const s2 = e22.canonical, a2 = n2.canonical, o2 = Math.pow(2, a2.z - s2.z);
          i2 = t2.vertices.map((t3) => new x(t3.x * s2.x * Cr * o2 - a2.x * Cr, t3.y * s2.y * Cr * o2 - a2.y * Cr));
        }
        return Rx(r2, i2, t2.indices, 0, t2.indices.length, 0, 0);
      }
      Ks(Ix, "Tiled3dModelBucket", { omit: ["layers"] }), Ks(Sx, "Tiled3dModelFeature");
      const Vx = ud.types, Ox = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius"], Fx = ["fill-extrusion-flood-light-ground-radius"], jx = Math.pow(2, 13), Ux = Math.pow(2, 15) - 1, Nx = new x(0, 1), $x = 2147483648;
      function qx(t2, e22, r2, n2, i2, s2, a2, o2) {
        t2.emplaceBack((e22 << 1) + a2, (r2 << 1) + s2, (Math.floor(n2 * jx) << 1) + i2, Math.round(o2));
      }
      function Gx(t2, e22, r2, n2, i2, s2) {
        t2.emplaceBack(e22.x, e22.y, (r2.x << 1) + n2, (r2.y << 1) + i2, s2);
      }
      function Yx(t2, e22, r2) {
        const n2 = 16384;
        t2.emplaceBack(e22.x, e22.y, e22.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
      }
      class Zx {
        constructor() {
          this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
        }
      }
      class Xx {
        constructor() {
          this.centroidXY = new x(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new x(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new x(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
        }
        span() {
          return new x(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class Kx {
        constructor() {
          this.acc = new x(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
        }
        startRing(t2, e22) {
          t2.min.x === Number.MAX_VALUE && (t2.min.x = t2.max.x = e22.x, t2.min.y = t2.max.y = e22.y);
        }
        appendEdge(t2, e22, r2) {
          this.accCount++, this.acc._add(e22);
          let n2 = !!this.borders;
          e22.x < t2.min.x ? (t2.min.x = e22.x, n2 = true) : e22.x > t2.max.x && (t2.max.x = e22.x, n2 = true), e22.y < t2.min.y ? (t2.min.y = e22.y, n2 = true) : e22.y > t2.max.y && (t2.max.y = e22.y, n2 = true), ((0 === e22.x || e22.x === Cr) && e22.x === r2.x) != ((0 === e22.y || e22.y === Cr) && e22.y === r2.y) && this.processBorderOverlap(e22, r2), n2 && this.checkBorderIntersection(e22, r2);
        }
        checkBorderIntersection(t2, e22) {
          e22.x < 0 != t2.x < 0 && this.addBorderIntersection(0, Mn(e22.y, t2.y, (0 - e22.x) / (t2.x - e22.x))), e22.x > Cr != t2.x > Cr && this.addBorderIntersection(1, Mn(e22.y, t2.y, (Cr - e22.x) / (t2.x - e22.x))), e22.y < 0 != t2.y < 0 && this.addBorderIntersection(2, Mn(e22.x, t2.x, (0 - e22.y) / (t2.y - e22.y))), e22.y > Cr != t2.y > Cr && this.addBorderIntersection(3, Mn(e22.x, t2.x, (Cr - e22.y) / (t2.y - e22.y)));
        }
        addBorderIntersection(t2, e22) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const r2 = this.borders[t2];
          e22 < r2[0] && (r2[0] = e22), e22 > r2[1] && (r2[1] = e22);
        }
        processBorderOverlap(t2, e22) {
          if (t2.x === e22.x) {
            if (t2.y === e22.y)
              return;
            const r2 = 0 === t2.x ? 0 : 1;
            this.addBorderIntersection(r2, e22.y), this.addBorderIntersection(r2, t2.y);
          } else {
            const r2 = 0 === t2.y ? 2 : 3;
            this.addBorderIntersection(r2, e22.x), this.addBorderIntersection(r2, t2.x);
          }
        }
        centroid() {
          return 0 === this.accCount ? new x(0, 0) : new x(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((t2, e22) => t2 + +(e22[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function Wx(t2, e22) {
        const r2 = t2.add(e22)._unit(), n2 = k(t2.x * r2.x + t2.y * r2.y, -1, 1);
        var i2, s2, a2;
        return i2 = Math.acos(n2), Math.min(4, Math.max(-4, Math.tan(i2))) / 4 * Ux * ((s2 = t2).x * (a2 = e22).y - s2.y * a2.x < 0 ? -1 : 1);
      }
      const Hx = [(t2) => t2.x < 0, (t2) => t2.x > Cr, (t2) => t2.y < 0, (t2) => t2.y > Cr];
      function Jx(t2, e22, r2, n2) {
        const i2 = [4];
        if (0 === n2)
          return i2;
        r2._mult(n2);
        const s2 = t2.sub(r2), a2 = e22.sub(r2), o2 = [t2, e22, s2, a2];
        for (let t3 = 0; t3 < 4; t3++)
          for (const e3 of o2)
            if (Hx[t3](e3)) {
              i2.push(t3);
              break;
            }
        return i2;
      }
      class Qx {
        constructor(t2) {
          this.vertexArray = new Ya(), this.indexArray = new ao(), this.programConfigurations = new fl(t2.layers, t2.zoom, (t3) => Fx.includes(t3)), this._segments = new Do(), this.hiddenByLandmarkVertexArray = new vo(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Do();
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return 0 !== this.vertexArray.length;
        }
        addData(t2, e22, r2, n2 = false) {
          const i2 = t2.length;
          if (i2 > 2) {
            let s2 = Math.max(0, this._segments.get().length - 1);
            const a2 = this._segments._prepareSegment(4 * i2, this.vertexArray.length, 2 * this._segmentToGroundQuads[s2].length);
            let o2;
            s2 !== this._segments.get().length - 1 && (s2++, this._segmentToGroundQuads[s2] = [], this._segmentToRegionTriCounts[s2] = [0, 0, 0, 0, 0]);
            {
              const e3 = t2[0], r3 = t2[1];
              o2 = Wx(e3.sub(t2[i2 - 1])._perp()._unit(), r3.sub(e3)._perp()._unit());
            }
            for (let l2 = 0; l2 < i2; l2++) {
              const u2 = l2 === i2 - 1 ? 0 : l2 + 1, c2 = t2[l2], h22 = t2[u2], p2 = t2[u2 === i2 - 1 ? 0 : u2 + 1], f2 = h22.sub(c2)._perp()._unit(), d2 = Wx(f2, p2.sub(h22)._perp()._unit()), m2 = o2, y2 = d2;
              if (iv(c2, h22, e22) || n2 && sv(c2, e22) && sv(h22, e22)) {
                o2 = d2;
                continue;
              }
              const g2 = a2.vertexLength;
              Gx(this.vertexArray, c2, h22, 1, 1, m2), Gx(this.vertexArray, c2, h22, 1, 0, m2), Gx(this.vertexArray, c2, h22, 0, 1, y2), Gx(this.vertexArray, c2, h22, 0, 0, y2), a2.vertexLength += 4;
              const x2 = Jx(c2, h22, f2, r2);
              for (const t3 of x2)
                this._segmentToGroundQuads[s2].push({ id: g2, region: t3 }), this._segmentToRegionTriCounts[s2][t3] += 2, a2.primitiveLength += 2;
              o2 = d2;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData())
            return;
          const t2 = this._segments.get(), e22 = t2.length;
          for (let t3 = 0; t3 < e22; t3++)
            this._segmentToGroundQuads[t3].sort((t4, e3) => t4.region - e3.region);
          for (let r2 = 0; r2 < e22; r2++) {
            const e3 = this._segmentToGroundQuads[r2], n2 = t2[r2], i2 = this._segmentToRegionTriCounts[r2];
            i2.reduce((t3, e4) => t3 + e4, 0);
            let s2 = 0;
            for (let t3 = 0; t3 <= 4; t3++) {
              const e4 = i2[t3];
              if (0 !== e4) {
                let r3 = this.regionSegments[t3];
                r3 || (r3 = this.regionSegments[t3] = new Do());
                const i3 = { vertexOffset: n2.vertexOffset, primitiveOffset: n2.primitiveOffset + s2, vertexLength: n2.vertexLength, primitiveLength: e4 };
                r3.get().push(i3);
              }
              s2 += e4;
            }
            for (let t3 = 0; t3 < e3.length; t3++) {
              const r3 = e3[t3].id;
              this.indexArray.emplaceBack(r3, r3 + 1, r3 + 3), this.indexArray.emplaceBack(r3, r3 + 3, r3 + 2);
            }
          }
          this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
        }
        addPaintPropertiesData(t2, e22, r2, n2, i2, s2) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t2, e22, r2, n2, i2, s2);
        }
        upload(t2) {
          this.hasData() && (this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Gf.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray));
        }
        uploadPaintProperties(t2) {
          this.hasData() && this.programConfigurations.upload(t2);
        }
        update(t2, e22, r2, n2, i2, s2) {
          this.hasData() && this.programConfigurations.updatePaintArrays(t2, e22, r2, n2, i2, s2);
        }
        updateHiddenByLandmark(t2) {
          if (!this.hasData())
            return;
          const e22 = t2.groundVertexCount + t2.groundVertexArrayOffset;
          if (0 === t2.groundVertexCount)
            return;
          const r2 = t2.flags & $x ? 1 : 0;
          for (let n2 = t2.groundVertexArrayOffset; n2 < e22; ++n2)
            this.hiddenByLandmarkVertexArray.emplace(n2, r2);
          this._needsHiddenByLandmarkUpdate = true;
        }
        uploadHiddenByLandmark(t2) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t2.createVertexBuffer(this.hiddenByLandmarkVertexArray, Zf.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let t2 = 0; t2 <= 4; t2++) {
              const e22 = this.regionSegments[t2];
              e22 && e22.destroy();
            }
          }
        }
      }
      class tv {
        constructor(t2) {
          this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ao(), this.footprintVertices = new $a(), this.footprintSegments = [], this.layoutVertexArray = new Ga(), this.centroidVertexArray = new zo(), this.indexArray = new ao(), this.programConfigurations = new fl(t2.layers, t2.zoom, (t3) => Ox.includes(t3)), this.segments = new Do(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.groundEffect = new Qx(t2), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
        }
        populate(t2, e22, r2, n2) {
          this.features = [], this.hasPattern = Ff("fill-extrusion", this.layers, e22), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = op(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
          for (const { feature: i2, id: s2, index: a2, sourceLayerIndex: o2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l2 = gp(i2, t3);
            if (!this.layers[0]._featureFilter.filter(new _a2(this.zoom), l2, r2))
              continue;
            const u2 = { id: s2, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : yp(i2, r2, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(jf("fill-extrusion", this.layers, u2, this.zoom, e22)) : this.addFeature(u2, u2.geometry, a2, r2, {}, e22.availableImages, n2, e22.brightness), e22.featureIndex.insert(i2, u2.geometry, a2, o2, this.index, c2);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
        }
        addFeatures(t2, e22, r2, n2, i2, s2) {
          for (const t3 of this.features) {
            const { geometry: a2 } = t3;
            this.addFeature(t3, a2, t3.index, e22, r2, n2, i2, s2);
          }
          this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
        }
        update(t2, e22, r2, n2, i2) {
          const s2 = 0 !== Object.keys(t2).length;
          if (s2 && !this.stateDependentLayers.length)
            return;
          const a2 = s2 ? this.stateDependentLayers : this.layers;
          this.programConfigurations.updatePaintArrays(t2, e22, a2, r2, n2, i2), this.groundEffect.update(t2, e22, a2, r2, n2, i2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Kf), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Xf.members, true)), this.groundEffect.upload(t2)), this.groundEffect.uploadPaintProperties(t2), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        uploadCentroid(t2) {
          this.groundEffect.uploadHiddenByLandmark(t2), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Yf.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t2, {}) / this.tileToMeter, u2 = [new x(0, 0), new x(Cr, Cr)], c2 = a2.projection, h22 = "globe" === c2.name, p2 = "Polygon" === Vx[t2.type], f2 = new Kx();
          f2.centroidDataIndex = this.centroidData.length;
          const d2 = new Xx(), m2 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t2, {}, n2) <= 0, y2 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t2, {}, n2);
          d2.height = y2, d2.vertexArrayOffset = this.layoutVertexArray.length, d2.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h22 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ha());
          const g2 = Vf(e22, 500);
          for (let t3 = g2.length - 1; t3 >= 0; t3--) {
            const e3 = g2[t3];
            (0 === e3.length || (v2 = e3[0]).every((t4) => t4.x <= 0) || v2.every((t4) => t4.x >= Cr) || v2.every((t4) => t4.y <= 0) || v2.every((t4) => t4.y >= Cr)) && g2.splice(t3, 1);
          }
          var v2;
          let b2;
          if (h22)
            b2 = uv(g2, u2, n2);
          else {
            b2 = [];
            for (const t3 of g2)
              b2.push({ polygon: t3, bounds: u2 });
          }
          const _2 = p2 ? this.edgeRadius : 0, w2 = _2 > 0 && this.zoom < 17, M2 = (t3, e3) => {
            if (0 === t3.length)
              return false;
            const r3 = t3[t3.length - 1];
            return e3.x === r3.x && e3.y === r3.y;
          };
          for (const { polygon: t3, bounds: e3 } of b2) {
            let r3 = 0, i3 = 0;
            for (const e4 of t3)
              p2 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += p2 ? e4.length - 1 : e4.length;
            const s3 = this.segments.prepareSegment((p2 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
            d2.footprintSegIdx < 0 && (d2.footprintSegIdx = this.footprintSegments.length), d2.polygonSegIdx < 0 && (d2.polygonSegIdx = this.polygonSegments.length);
            const a3 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, o3 = new Zx();
            if (o3.vertexOffset = this.footprintVertices.length, o3.indexOffset = 3 * this.footprintIndices.length, o3.ringIndices = [], p2) {
              const i4 = [], a4 = [];
              r3 = s3.vertexLength;
              for (let r4 = 0; r4 < t3.length; r4++) {
                const u4 = t3[r4];
                u4.length && 0 !== r4 && a4.push(i4.length / 2);
                const p3 = [];
                let f3, d3;
                f3 = u4[1].sub(u4[0])._perp()._unit(), o3.ringIndices.push(u4.length - 1);
                for (let t4 = 1; t4 < u4.length; t4++) {
                  const e4 = u4[t4], r5 = u4[t4 === u4.length - 1 ? 1 : t4 + 1], a5 = e4.clone();
                  if (_2) {
                    d3 = r5.sub(e4)._perp()._unit();
                    const t5 = f3.add(d3)._unit(), n3 = _2 * Math.min(4, 1 / (f3.x * t5.x + f3.y * t5.y));
                    a5.x += n3 * t5.x, a5.y += n3 * t5.y, a5.x = Math.round(a5.x), a5.y = Math.round(a5.y), f3 = d3;
                  }
                  !m2 || 0 !== _2 && !w2 || M2(p3, a5) || p3.push(a5), qx(this.layoutVertexArray, a5.x, a5.y, 0, 0, 1, 1, 0), s3.vertexLength++, this.footprintVertices.emplaceBack(e4.x, e4.y), i4.push(e4.x, e4.y), h22 && Yx(this.layoutVertexExtArray, c2.projectTilePoint(a5.x, a5.y, n2), c2.upVector(n2, a5.x, a5.y));
                }
                m2 && (0 === _2 || w2) && (0 !== p3.length && M2(p3, p3[0]) && p3.pop(), this.groundEffect.addData(p3, e3, l2));
              }
              const u3 = Lf(i4, a4);
              for (let t4 = 0; t4 < u3.length; t4 += 3)
                this.footprintIndices.emplaceBack(o3.vertexOffset + u3[t4 + 0], o3.vertexOffset + u3[t4 + 1], o3.vertexOffset + u3[t4 + 2]), this.indexArray.emplaceBack(r3 + u3[t4], r3 + u3[t4 + 2], r3 + u3[t4 + 1]), s3.primitiveLength++;
              o3.indexCount += u3.length, o3.vertexCount += this.footprintVertices.length - o3.vertexOffset;
            }
            for (let i4 = 0; i4 < t3.length; i4++) {
              const a4 = t3[i4];
              f2.startRing(d2, a4[0]);
              let o4 = a4.length > 4 && av(a4[a4.length - 2], a4[0], a4[1]), u3 = _2 ? rv(a4[a4.length - 2], a4[0], a4[1], _2) : 0;
              const y3 = [];
              let g3, x2, v3;
              x2 = a4[1].sub(a4[0])._perp()._unit();
              let b3 = true;
              for (let t4 = 1, i5 = 0; t4 < a4.length; t4++) {
                let l3 = a4[t4 - 1], p3 = a4[t4];
                const w3 = a4[t4 === a4.length - 1 ? 1 : t4 + 1];
                if (f2.appendEdge(d2, p3, l3), iv(p3, l3, e3)) {
                  _2 && (x2 = w3.sub(p3)._perp()._unit(), b3 = !b3);
                  continue;
                }
                const A2 = p3.sub(l3)._perp(), S2 = A2.x / (Math.abs(A2.x) + Math.abs(A2.y)), I2 = A2.y > 0 ? 1 : 0, k2 = l3.dist(p3);
                if (i5 + k2 > 32768 && (i5 = 0), _2) {
                  v3 = w3.sub(p3)._perp()._unit();
                  let t5 = nv(l3, p3, w3, ev(x2, v3), _2);
                  isNaN(t5) && (t5 = 0);
                  const e4 = p3.sub(l3)._unit();
                  l3 = l3.add(e4.mult(u3))._round(), p3 = p3.add(e4.mult(-t5))._round(), u3 = t5, x2 = v3, m2 && this.zoom >= 17 && (M2(y3, l3) || y3.push(l3), M2(y3, p3) || y3.push(p3));
                }
                const T2 = s3.vertexLength, P2 = a4.length > 4 && av(l3, p3, w3);
                let z2 = ov(i5, o4, b3);
                if (qx(this.layoutVertexArray, l3.x, l3.y, S2, I2, 0, 0, z2), qx(this.layoutVertexArray, l3.x, l3.y, S2, I2, 0, 1, z2), i5 += k2, z2 = ov(i5, P2, !b3), o4 = P2, qx(this.layoutVertexArray, p3.x, p3.y, S2, I2, 0, 0, z2), qx(this.layoutVertexArray, p3.x, p3.y, S2, I2, 0, 1, z2), s3.vertexLength += 4, this.indexArray.emplaceBack(T2 + 0, T2 + 1, T2 + 2), this.indexArray.emplaceBack(T2 + 1, T2 + 3, T2 + 2), s3.primitiveLength += 2, _2) {
                  const n3 = r3 + (1 === t4 ? a4.length - 2 : t4 - 2), i6 = 1 === t4 ? r3 : n3 + 1;
                  if (this.indexArray.emplaceBack(T2 + 1, n3, T2 + 3), this.indexArray.emplaceBack(n3, i6, T2 + 3), s3.primitiveLength += 2, void 0 === g3 && (g3 = T2), !iv(w3, a4[t4], e3)) {
                    const e4 = t4 === a4.length - 1 ? g3 : s3.vertexLength;
                    this.indexArray.emplaceBack(T2 + 2, T2 + 3, e4), this.indexArray.emplaceBack(T2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(T2 + 3, i6, e4 + 1), s3.primitiveLength += 3;
                  }
                  b3 = !b3;
                }
                if (h22) {
                  const t5 = this.layoutVertexExtArray, e4 = c2.projectTilePoint(l3.x, l3.y, n2), r4 = c2.projectTilePoint(p3.x, p3.y, n2), i6 = c2.upVector(n2, l3.x, l3.y), s4 = c2.upVector(n2, p3.x, p3.y);
                  Yx(t5, e4, i6), Yx(t5, e4, i6), Yx(t5, r4, s4), Yx(t5, r4, s4);
                }
              }
              p2 && (r3 += a4.length - 1), m2 && _2 && this.zoom >= 17 && (0 !== y3.length && M2(y3, y3[0]) && y3.pop(), this.groundEffect.addData(y3, e3, l2, _2 > 0));
            }
            this.footprintSegments.push(o3), a3.triangleCount = this.indexArray.length - a3.triangleArrayOffset, this.polygonSegments.push(a3), ++d2.footprintSegLen, ++d2.polygonSegLen;
          }
          if (d2.vertexCount = this.layoutVertexArray.length - d2.vertexArrayOffset, d2.groundVertexCount = this.groundEffect.vertexArray.length - d2.groundVertexArrayOffset, 0 !== d2.vertexCount) {
            if (d2.centroidXY = f2.borders ? Nx : this.encodeCentroid(f2, d2), this.centroidData.push(d2), f2.borders) {
              this.featuresOnBorder.push(f2);
              const t3 = this.featuresOnBorder.length - 1;
              for (let e3 = 0; e3 < f2.borders.length; e3++)
                f2.borders[e3][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e3].push(t3);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, o2), this.groundEffect.addPaintPropertiesData(t2, r2, i2, s2, n2, o2), this.maxHeight = Math.max(this.maxHeight, y2);
          }
        }
        sortBorders() {
          for (let t2 = 0; t2 < this.borderFeatureIndices.length; t2++)
            this.borderFeatureIndices[t2].sort((e22, r2) => this.featuresOnBorder[e22].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
        }
        splitToSubtiles() {
          const t2 = [];
          for (let e3 = 0; e3 < this.centroidData.length; e3++) {
            const r3 = this.centroidData[e3], n3 = +(r3.min.y + r3.max.y > Cr), i3 = 2 * n3 + (+(r3.min.x + r3.max.x > Cr) ^ n3);
            for (let n4 = 0; n4 < r3.polygonSegLen; n4++) {
              const s3 = r3.polygonSegIdx + n4;
              t2.push({ centroidIdx: e3, subtile: i3, polygonSegmentIdx: s3, triangleSegmentIdx: this.polygonSegments[s3].triangleSegIdx });
            }
          }
          const e22 = new ao();
          t2.sort((t3, e3) => t3.triangleSegmentIdx === e3.triangleSegmentIdx ? t3.subtile - e3.subtile : t3.triangleSegmentIdx - e3.triangleSegmentIdx);
          let r2 = 0, n2 = 0, i2 = 0;
          for (const e3 of t2) {
            if (e3.triangleSegmentIdx !== r2)
              break;
            i2++;
          }
          const s2 = t2.length;
          for (; n2 !== t2.length; ) {
            r2 = t2[n2].triangleSegmentIdx;
            let a2 = 0, o2 = n2, l2 = n2;
            for (let e3 = o2; e3 < i2 && t2[e3].subtile === a2; e3++)
              l2++;
            for (; o2 !== i2; ) {
              const n3 = t2[o2];
              a2 = n3.subtile;
              const s3 = this.centroidData[n3.centroidIdx].min.clone(), u2 = this.centroidData[n3.centroidIdx].max.clone(), c2 = { vertexOffset: this.segments.segments[r2].vertexOffset, primitiveOffset: e22.length, vertexLength: this.segments.segments[r2].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let r3 = o2; r3 < l2; r3++) {
                const n4 = t2[r3], i3 = this.polygonSegments[n4.polygonSegmentIdx], a3 = this.centroidData[n4.centroidIdx].min, o3 = this.centroidData[n4.centroidIdx].max, l3 = this.indexArray.uint16;
                for (let t3 = i3.triangleArrayOffset; t3 < i3.triangleArrayOffset + i3.triangleCount; t3++)
                  e22.emplaceBack(l3[3 * t3], l3[3 * t3 + 1], l3[3 * t3 + 2]);
                c2.primitiveLength += i3.triangleCount, s3.x = Math.min(s3.x, a3.x), s3.y = Math.min(s3.y, a3.y), u2.x = Math.max(u2.x, o3.x), u2.y = Math.max(u2.y, o3.y);
              }
              c2.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c2, min: s3, max: u2 }), o2 = l2;
              for (let e3 = o2; e3 < i2 && t2[e3].subtile === t2[o2].subtile; e3++)
                l2++;
            }
            n2 = i2;
            for (let e3 = n2; e3 < s2 && t2[e3].triangleSegmentIdx === t2[n2].triangleSegmentIdx; e3++)
              i2++;
          }
          e22._trim(), this.indexArray = e22;
        }
        getVisibleSegments(t2, e22, r2) {
          let n2 = 0, i2 = 0;
          const s2 = 1 << t2.canonical.z;
          if (e22) {
            const r3 = e22.getMinMaxForTile(t2);
            r3 && (n2 = r3.min, i2 = r3.max);
          }
          i2 += this.maxHeight;
          const a2 = t2.toUnwrapped();
          let o2;
          const l2 = [a2.canonical.x / s2 + a2.wrap, a2.canonical.y / s2], u2 = [(a2.canonical.x + 1) / s2 + a2.wrap, (a2.canonical.y + 1) / s2], c2 = new Do(), h22 = (t3, e3, r3) => [t3[0] * (1 - r3[0]) + e3[0] * r3[0], t3[1] * (1 - r3[1]) + e3[1] * r3[1]], p2 = [], f2 = [];
          for (const t3 of this.triangleSubSegments) {
            p2[0] = t3.min.x / Cr, p2[1] = t3.min.y / Cr, f2[0] = t3.max.x / Cr, f2[1] = t3.max.y / Cr;
            const e3 = h22(l2, u2, p2), s3 = h22(l2, u2, f2);
            if (0 === new oh([e3[0], e3[1], n2], [s3[0], s3[1], i2]).intersectsPrecise(r2)) {
              o2 && (c2.segments.push(o2), o2 = void 0);
              continue;
            }
            const a3 = t3.segment;
            o2 && o2.vertexOffset !== a3.vertexOffset && (c2.segments.push(o2), o2 = void 0), o2 ? (o2.vertexLength += a3.vertexLength, o2.primitiveLength += a3.primitiveLength) : o2 = { vertexOffset: a3.vertexOffset, primitiveLength: a3.primitiveLength, vertexLength: a3.vertexLength, primitiveOffset: a3.primitiveOffset, sortKey: void 0, vaos: {} };
          }
          return o2 && c2.segments.push(o2), c2;
        }
        encodeCentroid(t2, e22) {
          const r2 = t2.centroid(), n2 = e22.span(), i2 = Math.min(7, Math.round(n2.x * this.tileToMeter / 10)), s2 = Math.min(7, Math.round(n2.y * this.tileToMeter / 10));
          return new x(k(r2.x, 1, Cr - 1) << 3 | i2, k(r2.y, 1, Cr - 1) << 3 | s2);
        }
        encodeBorderCentroid(t2) {
          if (!t2.borders)
            return new x(0, 0);
          const e22 = t2.borders, r2 = Number.MAX_VALUE;
          if (e22[0][0] !== r2 || e22[1][0] !== r2) {
            const t3 = e22[0][0] !== r2 ? 0 : 1;
            return new x(6 | (e22[0][0] !== r2 ? 0 : 65528), ((e22[t3][0] + e22[t3][1]) / 2 | 0) << 3 | 6);
          }
          {
            const t3 = e22[2][0] !== r2 ? 2 : 3;
            return new x(((e22[t3][0] + e22[t3][1]) / 2 | 0) << 3 | 6, 6 | (e22[2][0] !== r2 ? 0 : 65528));
          }
        }
        showCentroid(t2) {
          const e22 = this.centroidData[t2.centroidDataIndex];
          e22.flags &= $x, e22.centroidXY.x = 0, e22.centroidXY.y = 0, this.writeCentroidToBuffer(e22);
        }
        writeCentroidToBuffer(t2) {
          this.groundEffect.updateHiddenByLandmark(t2);
          const e22 = t2.vertexArrayOffset, r2 = t2.vertexCount + t2.vertexArrayOffset, n2 = t2.flags & $x ? Nx : t2.centroidXY, i2 = this.centroidVertexArray.geta_centroid_pos0(e22);
          if (this.centroidVertexArray.geta_centroid_pos1(e22) !== n2.y || i2 !== n2.x) {
            for (let t3 = e22; t3 < r2; ++t3)
              this.centroidVertexArray.emplace(t3, n2.x, n2.y);
            this.needsCentroidUpdate = true;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const t2 of this.centroidData)
            this.writeCentroidToBuffer(t2);
        }
        updateReplacement(t2, e22) {
          if (e22.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = e22.updateTime;
          const r2 = e22.getReplacementRegionsForTile(t2.toUnwrapped());
          if (function(t3, e3) {
            if (t3.length !== e3.length)
              return false;
            for (let r3 = 0; r3 < t3.length; r3++)
              if (t3[r3].sourceId !== e3[r3].sourceId || !Ex(t3[r3], e3[r3]))
                return false;
            return true;
          }(this.activeReplacements, r2))
            return;
          if (this.activeReplacements = r2, 0 === this.centroidVertexArray.length)
            this.createCentroidsBuffer();
          else
            for (const t3 of this.centroidData)
              t3.flags &= 2147483647;
          const n2 = [];
          for (const e3 of this.activeReplacements) {
            const r3 = Math.pow(2, e3.footprintTileId.canonical.z - t2.canonical.z);
            for (const i2 of this.centroidData)
              if (!(i2.flags & $x || e3.min.x > i2.max.x || i2.min.x > e3.max.x || e3.min.y > i2.max.y || i2.min.y > e3.max.y))
                for (let s2 = 0; s2 < i2.footprintSegLen; s2++) {
                  const a2 = this.footprintSegments[i2.footprintSegIdx + s2];
                  if (n2.length = 0, cv(this.footprintVertices, a2.vertexOffset, a2.vertexCount, e3.footprintTileId.canonical, t2.canonical, n2), Rx(e3.footprint, n2, this.footprintIndices.uint16, a2.indexOffset, a2.indexCount, -a2.vertexOffset, -r3)) {
                    i2.flags |= $x;
                    break;
                  }
                }
          }
          for (const t3 of this.centroidData)
            this.writeCentroidToBuffer(t3);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(t2, e22, r2) {
          let n2 = false;
          for (let i2 = 0; i2 < r2.footprintSegLen; i2++) {
            const s2 = this.footprintSegments[r2.footprintSegIdx + i2];
            let a2 = 0;
            for (const r3 of s2.ringIndices) {
              for (let i3 = a2, o2 = r3 + a2 - 1; i3 < r3 + a2; o2 = i3++) {
                const r4 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 0], a3 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 1], l2 = this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 1];
                a3 > e22 != l2 > e22 && t2 < (this.footprintVertices.int16[2 * (o2 + s2.vertexOffset) + 0] - r4) * (e22 - a3) / (l2 - a3) + r4 && (n2 = !n2);
              }
              a2 = r3;
            }
          }
          return n2;
        }
        getHeightAtTileCoord(t2, e22) {
          let r2 = Number.NEGATIVE_INFINITY, n2 = true;
          const i2 = 4 * (t2 + Cr) * Cr + (e22 + Cr);
          if (this.partLookup.hasOwnProperty(i2)) {
            const t3 = this.partLookup[i2];
            return t3 ? { height: t3.height, hidden: !!(t3.flags & $x) } : void 0;
          }
          for (const s2 of this.centroidData)
            t2 > s2.max.x || s2.min.x > t2 || e22 > s2.max.y || s2.min.y > e22 || this.footprintContainsPoint(t2, e22, s2) && s2 && s2.height > r2 && (r2 = s2.height, this.partLookup[i2] = s2, n2 = !!(s2.flags & $x));
          if (r2 !== Number.NEGATIVE_INFINITY)
            return { height: r2, hidden: n2 };
          this.partLookup[i2] = void 0;
        }
      }
      function ev(t2, e22) {
        const r2 = t2.add(e22)._unit();
        return t2.x * r2.x + t2.y * r2.y;
      }
      function rv(t2, e22, r2, n2) {
        const i2 = e22.sub(t2)._perp()._unit(), s2 = r2.sub(e22)._perp()._unit();
        return nv(t2, e22, r2, ev(i2, s2), n2);
      }
      function nv(t2, e22, r2, n2, i2) {
        const s2 = Math.sqrt(1 - n2 * n2);
        return Math.min(t2.dist(e22) / 3, e22.dist(r2) / 3, i2 * s2 / n2);
      }
      function iv(t2, e22, r2) {
        return t2.x < r2[0].x && e22.x < r2[0].x || t2.x > r2[1].x && e22.x > r2[1].x || t2.y < r2[0].y && e22.y < r2[0].y || t2.y > r2[1].y && e22.y > r2[1].y;
      }
      function sv(t2, e22) {
        return t2.x < e22[0].x || t2.x > e22[1].x || t2.y < e22[0].y || t2.y > e22[1].y;
      }
      function av(t2, e22, r2) {
        if (t2.x < 0 || t2.x >= Cr || e22.x < 0 || e22.x >= Cr || r2.x < 0 || r2.x >= Cr)
          return false;
        const n2 = r2.sub(e22), i2 = n2.perp(), s2 = t2.sub(e22);
        return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
      }
      function ov(t2, e22, r2) {
        const n2 = e22 ? 2 | t2 : -3 & t2;
        return r2 ? 1 | n2 : -2 & n2;
      }
      function lv() {
        const t2 = Math.PI / 32, e22 = Math.tan(t2), r2 = qh;
        return r2 * Math.sqrt(1 + 2 * e22 * e22) - r2;
      }
      function uv(t2, e22, r2) {
        const n2 = 1 << r2.z, i2 = tp(r2.x / n2), s2 = tp((r2.x + 1) / n2), a2 = ep(r2.y / n2), o2 = ep((r2.y + 1) / n2);
        return function(t3, e3, r3, n3, i3 = 0, s3) {
          const a3 = [];
          if (!t3.length || !r3 || !n3)
            return a3;
          const o3 = (t4, e4) => {
            for (const r4 of t4)
              a3.push({ polygon: r4, bounds: e4 });
          }, l2 = Math.ceil(Math.log2(r3)), u2 = Math.ceil(Math.log2(n3)), c2 = l2 - u2, h22 = [];
          for (let t4 = 0; t4 < Math.abs(c2); t4++)
            h22.push(c2 > 0 ? 0 : 1);
          for (let t4 = 0; t4 < Math.min(l2, u2); t4++)
            h22.push(0), h22.push(1);
          let p2 = t3;
          if (p2 = cd(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = cd(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length)
            return a3;
          const f2 = [];
          for (h22.length ? f2.push({ polygons: p2, bounds: e3, depth: 0 }) : o3(p2, e3); f2.length; ) {
            const t4 = f2.pop(), e4 = t4.depth, r4 = h22[e4], n4 = t4.bounds[0], a4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u3 = 0 === r4 ? a4.x : a4.y, c3 = s3 ? s3(r4, l3, u3) : 0.5 * (l3 + u3), p3 = cd(t4.polygons, l3 - i3, c3 + i3, r4), d2 = cd(t4.polygons, c3 - i3, u3 + i3, r4);
            if (p3.length) {
              const t5 = [n4, new x(0 === r4 ? c3 : a4.x, 1 === r4 ? c3 : a4.y)];
              h22.length > e4 + 1 ? f2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : o3(p3, t5);
            }
            if (d2.length) {
              const t5 = [new x(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), a4];
              h22.length > e4 + 1 ? f2.push({ polygons: d2, bounds: t5, depth: e4 + 1 }) : o3(d2, t5);
            }
          }
          return a3;
        }(t2, e22, Math.ceil((s2 - i2) / 11.25), Math.ceil((a2 - o2) / 11.25), 1, (t3, e3, i3) => {
          if (0 === t3)
            return 0.5 * (e3 + i3);
          {
            const t4 = ep((r2.y + e3 / Cr) / n2);
            return (Jh(0.5 * (ep((r2.y + i3 / Cr) / n2) + t4)) * n2 - r2.y) * Cr;
          }
        });
      }
      function cv(t2, e22, r2, n2, i2, s2) {
        const a2 = Math.pow(2, n2.z - i2.z);
        for (let o2 = 0; o2 < r2; o2++) {
          let r3 = t2.int16[2 * (o2 + e22) + 0], l2 = t2.int16[2 * (o2 + e22) + 1];
          r3 = (r3 + i2.x * Cr) * a2 - n2.x * Cr, l2 = (l2 + i2.y * Cr) * a2 - n2.y * Cr, s2.push(new x(r3, l2));
        }
      }
      Ks(tv, "FillExtrusionBucket", { omit: ["layers", "features"] }), Ks(Xx, "PartData"), Ks(Zx, "FootprintSegment"), Ks(Kx, "BorderCentroidData"), Ks(Qx, "GroundEffect");
      const hv = new Da({ visibility: new za(re2["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new za(re2["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
      var pv = { paint: new Da({ "fill-extrusion-opacity": new za(re2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ea(re2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new za(re2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new za(re2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ea(re2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ea(re2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ea(re2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new za(re2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new za(re2["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new za(re2["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new za(re2["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new za(re2["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new za(re2["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new za(re2["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new za(re2["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new Ea(re2["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new Ea(re2["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new za(re2["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new za(re2["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new za(re2["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new za(re2["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new za(re2["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]) }), layout: hv };
      class fv extends x {
        constructor(t2, e22, r2) {
          super(t2, e22), this.z = r2;
        }
      }
      function dv(t2, e22) {
        return t2.x * e22.x + t2.y * e22.y;
      }
      function mv(t2, e22) {
        if (1 === t2.length) {
          let r2 = 0;
          const n2 = e22[r2++];
          let i2;
          for (; !i2 || n2.equals(i2); )
            if (i2 = e22[r2++], !i2)
              return 1 / 0;
          for (; r2 < e22.length; r2++) {
            const s2 = e22[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = dv(o2, o2), h22 = dv(o2, l2), p2 = dv(l2, l2), f2 = dv(u2, o2), d2 = dv(u2, l2), m2 = c2 * p2 - h22 * h22, y2 = (p2 * f2 - h22 * d2) / m2, g2 = (c2 * d2 - h22 * f2) / m2, x2 = n2.z * (1 - y2 - g2) + i2.z * y2 + s2.z * g2;
            if (isFinite(x2))
              return x2;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r2 of e22)
            t3 = Math.min(t3, r2.z);
          return t3;
        }
      }
      function yv(t2, e22, r2, n2, i2, s2, a2, o2) {
        const l2 = a2 * i2.getElevationAt(t2, e22, true, true), u2 = 0 !== s2[0], c2 = u2 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
          const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h22 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, f2 = 2 * c3 + 1, d2 = function(t4, e4, r4, n4, i4) {
            return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
          }(t3, h22.x - u3, h22.y - c3, p2, f2), m2 = Math.abs(d2[0] - d2[1]), y2 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x2 = Math.min(0.25, 0.5 * l3 * (m2 + y2) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / f2);
          return o3 + Math.max(x2 * s3, v2 * a3);
        }(i2, s2, o2) : l2;
        return { base: l2 + (0 === r2) ? -1 : r2, top: u2 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
      }
      const gv = new Da({ "line-cap": new Ea(re2.layout_line["line-cap"]), "line-join": new Ea(re2.layout_line["line-join"]), "line-miter-limit": new za(re2.layout_line["line-miter-limit"]), "line-round-limit": new za(re2.layout_line["line-round-limit"]), "line-sort-key": new Ea(re2.layout_line["line-sort-key"]), visibility: new za(re2.layout_line.visibility) });
      var xv = { paint: new Da({ "line-opacity": new Ea(re2.paint_line["line-opacity"]), "line-color": new Ea(re2.paint_line["line-color"]), "line-translate": new za(re2.paint_line["line-translate"]), "line-translate-anchor": new za(re2.paint_line["line-translate-anchor"]), "line-width": new Ea(re2.paint_line["line-width"]), "line-gap-width": new Ea(re2.paint_line["line-gap-width"]), "line-offset": new Ea(re2.paint_line["line-offset"]), "line-blur": new Ea(re2.paint_line["line-blur"]), "line-dasharray": new Ea(re2.paint_line["line-dasharray"]), "line-pattern": new Ea(re2.paint_line["line-pattern"]), "line-gradient": new Ba(re2.paint_line["line-gradient"]), "line-trim-offset": new za(re2.paint_line["line-trim-offset"]), "line-emissive-strength": new za(re2.paint_line["line-emissive-strength"]), "line-border-width": new Ea(re2.paint_line["line-border-width"]), "line-border-color": new Ea(re2.paint_line["line-border-color"]) }), layout: gv };
      function vv(t2, e22) {
        return 1 / sx(t2, 1, e22.tileZoom);
      }
      function bv(t2, e22, r2, n2) {
        return t2.translatePosMatrix(n2 || e22.tileID.projMatrix, e22, r2.paint.get("line-translate"), r2.paint.get("line-translate-anchor"));
      }
      const _v = (t2) => {
        const e22 = [];
        wv(t2) && e22.push("RENDER_LINE_DASH"), t2.paint.get("line-gradient") && e22.push("RENDER_LINE_GRADIENT");
        const r2 = t2.paint.get("line-trim-offset");
        return 0 === r2[0] && 0 === r2[1] || e22.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t2.paint.get("line-border-width").constantOr(1) && e22.push("RENDER_LINE_BORDER"), e22;
      };
      function wv(t2) {
        const e22 = t2.paint.get("line-dasharray").value;
        return e22.value || "constant" !== e22.kind;
      }
      const Mv = new class extends Ea {
        possiblyEvaluate(t2, e22) {
          return e22 = new _a2(Math.floor(e22.zoom), { now: e22.now, fadeDuration: e22.fadeDuration, transition: e22.transition }), super.possiblyEvaluate(t2, e22);
        }
        evaluate(t2, e22, r2, n2) {
          return e22 = B({}, e22, { zoom: Math.floor(e22.zoom) }), super.evaluate(t2, e22, r2, n2);
        }
      }(xv.paint.properties["line-width"].specification);
      function Av(t2, e22) {
        return e22 > 0 ? e22 + 2 * t2 : t2;
      }
      Mv.useIntegerZoom = true;
      const Sv = new Da({ visibility: new za(re2.layout_background.visibility) });
      var Iv = { paint: new Da({ "background-color": new za(re2.paint_background["background-color"]), "background-pattern": new za(re2.paint_background["background-pattern"]), "background-opacity": new za(re2.paint_background["background-opacity"]), "background-emissive-strength": new za(re2.paint_background["background-emissive-strength"]) }), layout: Sv };
      const kv = new Da({ visibility: new za(re2.layout_raster.visibility) });
      var Tv = { paint: new Da({ "raster-opacity": new za(re2.paint_raster["raster-opacity"]), "raster-color": new Ba(re2.paint_raster["raster-color"]), "raster-color-mix": new za(re2.paint_raster["raster-color-mix"]), "raster-color-range": new za(re2.paint_raster["raster-color-range"]), "raster-hue-rotate": new za(re2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new za(re2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new za(re2.paint_raster["raster-brightness-max"]), "raster-saturation": new za(re2.paint_raster["raster-saturation"]), "raster-contrast": new za(re2.paint_raster["raster-contrast"]), "raster-resampling": new za(re2.paint_raster["raster-resampling"]), "raster-fade-duration": new za(re2.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new za(re2.paint_raster["raster-emissive-strength"]), "raster-array-band": new za(re2.paint_raster["raster-array-band"]), "raster-elevation": new za(re2.paint_raster["raster-elevation"]) }), layout: kv };
      function Pv(e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = [e22, r2, 1, n2, i2, 1, s2, a2, 1], c2 = [o2, l2, 1], h22 = t.bx.adjoint([], u2), [p2, f2, d2] = t.v.transformMat3(c2, c2, h22);
        return t.bx.multiply(u2, u2, [p2, 0, 0, 0, f2, 0, 0, 0, d2]);
      }
      function zv(e22, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = function(e3, r3, n3, i3, s3, a3, o3, l3) {
          const u3 = Pv(0, 0, 1, 0, 1, 1, 0, 1), c2 = Pv(e3, r3, n3, i3, s3, a3, o3, l3), h22 = t.bx.adjoint([], u3);
          return t.bx.multiply(c2, c2, h22);
        }(e22, r2, n2, i2, s2, a2, o2, l2);
        return [u2[2] / u2[8] / Cr, u2[5] / u2[8] / Cr];
      }
      function Ev(t2) {
        return [t2[0], Math.min(Math.max(t2[1], -np), np)];
      }
      class Bv extends ee {
        constructor(t2, e22, r2, n2) {
          super(), this.id = t2, this.dispatcher = r2, this.coordinates = e22.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n2), this.options = e22, this._dirty = false;
        }
        load(t2, e22) {
          if (this._loaded = e22 || false, this.fire(new Qt("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
            return t2 && (this.coordinates = t2), this._loaded = true, void this._finishLoading();
          this._imageRequest = vt(this.map._requestManager.transformRequest(this.url, ct.Image), (e3, r2) => {
            this._imageRequest = null, this._loaded = true, e3 ? this.fire(new te(e3)) : r2 && (this.image = r2 instanceof HTMLImageElement ? Wt.getImageData(r2) : r2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t2) {
          return t2.url ? (this._imageRequest && t2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t2.url, this.load(t2.coordinates, this._loaded), this) : this;
        }
        setTexture(t2) {
          if (!(t2.handle instanceof WebGLTexture))
            throw new Error("The provided handle is not a WebGLTexture instance");
          return this.texture = new wg(this.map.painter.context, t2.handle), this.width = t2.dimensions[0], this.height = t2.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new Qt("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        onRemove() {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof wg || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
        }
        setCoordinates(t2) {
          if (this.coordinates = t2, this._boundsArray = void 0, this._unsupportedCoords = false, !t2.length)
            return this;
          this.onNorthPole = false, this.onSouthPole = false;
          let e22 = t2[0][1], r2 = t2[0][1];
          for (const n3 of t2)
            n3[1] > r2 && (r2 = n3[1]), n3[1] < e22 && (e22 = n3[1]);
          const n2 = (r2 + e22) / 2;
          if (n2 > np ? this.onNorthPole = true : n2 < -np && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
            const e3 = t2.map(lp.fromLngLat);
            this.tileID = function(t3) {
              let e4 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i2 = -1 / 0;
              for (const s3 of t3)
                e4 = Math.min(e4, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i2 = Math.max(i2, s3.y);
              const s2 = Math.max(n3 - e4, i2 - r3), a2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), o2 = Math.pow(2, a2);
              let l2 = Math.floor((e4 + n3) / 2 * o2);
              return l2 > 1 && (l2 -= 1), new Kc(a2, l2, Math.floor((r3 + i2) / 2 * o2));
            }(e3), this.minzoom = this.maxzoom = this.tileID.z;
          }
          return this.fire(new Qt("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0, this._unsupportedCoords = false;
        }
        _prepareData(e22) {
          for (const t2 in this.tiles) {
            const e3 = this.tiles[t2];
            "loaded" !== e3.state && (e3.state = "loaded", e3.texture = this.texture);
          }
          if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
            return;
          const r2 = zy(new Kc(0, 0, 0), this.map.transform.projection), n2 = [r2.projection.project(this.coordinates[0][0], this.coordinates[0][1]), r2.projection.project(this.coordinates[1][0], this.coordinates[1][1]), r2.projection.project(this.coordinates[2][0], this.coordinates[2][1]), r2.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
          if (!function(t2) {
            const e3 = t2[1].x - t2[0].x, r3 = t2[1].y - t2[0].y, n3 = t2[2].x - t2[1].x, i3 = t2[2].y - t2[1].y, s3 = t2[3].x - t2[2].x, a3 = t2[3].y - t2[2].y, o3 = t2[0].x - t2[3].x, l3 = t2[0].y - t2[3].y, u3 = e3 * i3 - n3 * r3, c3 = n3 * a3 - s3 * i3, h3 = s3 * l3 - o3 * a3, p3 = o3 * r3 - e3 * l3;
            return u3 > 0 && c3 > 0 && h3 > 0 && p3 > 0 || u3 < 0 && c3 < 0 && h3 < 0 && p3 < 0;
          }(n2))
            return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
          const i2 = zy(this.tileID, this.map.transform.projection), [s2, a2, o2, l2] = this.coordinates.map((t2) => {
            const e3 = i2.projection.project(t2[0], t2[1]);
            return Ey(i2, e3)._round();
          });
          this.perspectiveTransform = zv(s2.x, s2.y, a2.x, a2.y, o2.x, o2.y, l2.x, l2.y);
          const u2 = this._boundsArray = new Ga();
          u2.emplaceBack(s2.x, s2.y, 0, 0), u2.emplaceBack(a2.x, a2.y, Cr, 0), u2.emplaceBack(l2.x, l2.y, 0, Cr), u2.emplaceBack(o2.x, o2.y, Cr, Cr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e22.createVertexBuffer(u2, zg.members), this.boundsSegments = Do.simpleSegment(0, 0, 4, 2);
          const c2 = [], h22 = function(t2) {
            return [Ev(t2[0]), Ev(t2[1]), Ev(t2[2]), Ev(t2[3])];
          }(this.coordinates), [p2, f2, d2, m2] = function(t2) {
            let e3 = t2[0][0], r3 = e3, n3 = t2[0][1], i3 = n3;
            for (let s3 = 1; s3 < t2.length; s3++)
              t2[s3][0] < e3 ? e3 = t2[s3][0] : t2[s3][0] > r3 && (r3 = t2[s3][0]), t2[s3][1] < n3 ? n3 = t2[s3][1] : t2[s3][1] > i3 && (i3 = t2[s3][1]);
            return [e3, n3, r3 - e3, i3 - n3];
          }(h22);
          {
            const i3 = new Ga(), [s3, a3, o3, l3] = function(t2) {
              let e3 = t2[0].x, r3 = e3, n3 = t2[0].y, i4 = n3;
              for (let s4 = 1; s4 < t2.length; s4++)
                t2[s4].x < e3 ? e3 = t2[s4].x : t2[s4].x > r3 && (r3 = t2[s4].x), t2[s4].y < n3 ? n3 = t2[s4].y : t2[s4].y > i4 && (i4 = t2[s4].y);
              return [e3, n3, r3 - e3, i4 - n3];
            }(n2), u3 = (t2) => [(t2.x - s3) / o3, (t2.y - a3) / l3], [h3, y2, g2, x2] = n2.map(u3), v2 = function(e3, r3, n3, i4, s4, a4, o4, l4) {
              const u4 = Pv(0, 0, 1, 0, 1, 1, 0, 1), c3 = Pv(e3, r3, n3, i4, s4, a4, o4, l4), h4 = t.bx.adjoint([], c3);
              return t.bx.multiply(u4, u4, h4);
            }(h3[0], h3[1], y2[0], y2[1], g2[0], g2[1], x2[0], x2[1]);
            this.elevatedGlobePerspectiveTransform = zv(h3[0], h3[1], y2[0], y2[1], g2[0], g2[1], x2[0], x2[1]);
            const b2 = (e3, r3) => {
              c2.push(e3.lng);
              const n3 = Math.round((e3.lng - p2) / d2 * Cr), s4 = Math.round((e3.lat - f2) / m2 * Cr), a4 = u3(r3), o4 = t.v.transformMat3([], [a4[0], a4[1], 1], v2), l4 = Math.round(o4[0] / o4[2] * Cr), h4 = Math.round(o4[1] / o4[2] * Cr);
              i3.emplaceBack(n3, s4, l4, h4);
            }, _2 = n2[3].x - n2[0].x, w2 = n2[3].y - n2[0].y, M2 = n2[2].x - n2[1].x, A2 = n2[2].y - n2[1].y;
            for (let t2 = 0; t2 < 65; t2++) {
              const e3 = t2 / 64, i4 = [n2[0].x + e3 * _2, n2[0].y + e3 * w2], s4 = [n2[1].x + e3 * M2, n2[1].y + e3 * A2], a4 = s4[0] - i4[0], o4 = s4[1] - i4[1];
              for (let t3 = 0; t3 < 65; t3++) {
                const e4 = t3 / 64, n3 = { x: i4[0] + a4 * e4, y: i4[1] + o4 * e4, z: 0 };
                b2(r2.projection.unproject(n3.x, n3.y), n3);
              }
            }
            this.elevatedGlobeVertexBuffer = e22.createVertexBuffer(i3, zg.members);
          }
          {
            this.maxLongitudeTriangleSize = 0;
            let t2 = [], r3 = new ao();
            const n3 = (e3, n4, i3) => {
              r3.emplaceBack(e3, n4, i3);
              const s3 = c2[e3], a3 = c2[n4], o3 = c2[i3], l3 = Math.min(Math.min(s3, a3), o3), u3 = Math.max(Math.max(s3, a3), o3) - l3;
              u3 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u3), t2.push(l3 + u3 / 2);
            };
            for (let t3 = 0; t3 < 64; t3++)
              for (let e3 = 0; e3 < 64; e3++) {
                const r4 = 65 * t3 + e3, i3 = r4 + 1, s3 = r4 + 65, a3 = s3 + 1;
                n3(r4, s3, i3), n3(i3, s3, a3);
              }
            [t2, r3] = function(t3, e3) {
              const r4 = Array.from({ length: t3.length }, (t4, e4) => e4);
              r4.sort((e4, r5) => t3[e4] - t3[r5]);
              const n4 = [], i3 = new ao();
              for (let s3 = 0; s3 < r4.length; s3++) {
                const a3 = r4[s3];
                n4.push(t3[a3]);
                const o3 = 3 * a3, l3 = o3 + 1;
                i3.emplaceBack(e3.uint16[o3], e3.uint16[l3], e3.uint16[l3 + 1]);
              }
              return [n4, i3];
            }(t2, r3), this.elevatedGlobeTrianglesCenterLongitudes = t2, this.elevatedGlobeIndexBuffer = e22.createIndexBuffer(r3);
          }
          this.elevatedGlobeSegments = Do.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, d2 / Cr, 0, m2 / Cr, 0, 0, f2, p2, 0]);
        }
        prepare() {
          const t2 = 0 !== Object.keys(this.tiles).length;
          if (this.tileID && !t2)
            return;
          const e22 = this.map.painter.context, r2 = e22.gl;
          !this._dirty || this.texture instanceof wg || (this.texture ? this.texture.update(this.image) : (this.texture = new _g(e22, this.image, r2.RGBA), this.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE)), this._dirty = false), t2 && this._prepareData(e22);
        }
        loadTile(t2, e22) {
          this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e22(null)) : (t2.state = "errored", e22(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
        getSegmentsForLongitude(t2) {
          const e22 = this.elevatedGlobeSegments;
          if (!this.elevatedGlobeTrianglesCenterLongitudes || !e22)
            return null;
          const r2 = this.elevatedGlobeTrianglesCenterLongitudes;
          let n2 = ((t3, e3) => t3 + 360 * Math.round((e3 - t3) / 360))(t2 + 180, r2[0]);
          const i2 = new Do(), s2 = (t3, r3) => {
            i2.segments.push({ vertexOffset: 0, primitiveOffset: t3, vertexLength: e22.segments[0].vertexLength, primitiveLength: r3, sortKey: void 0, vaos: {} });
          }, a2 = 0.51 * this.maxLongitudeTriangleSize;
          if (Math.abs(r2[0] - n2) <= a2) {
            const t3 = tt(r2, 0, r2.length, n2 + a2);
            return t3 === r2.length || s2(t3, Q(r2, t3 + 1, r2.length, n2 + 360 - a2) - t3), i2;
          }
          n2 < r2[0] && (n2 += 360);
          const o2 = Q(r2, 0, r2.length, n2 - a2);
          if (o2 === r2.length)
            return s2(0, r2.length), i2;
          s2(0, o2 - 0);
          const l2 = tt(r2, o2 + 1, r2.length, n2 + a2);
          return l2 !== r2.length && s2(l2, r2.length - l2), i2;
        }
      }
      class Dv extends Va {
        constructor(t2, e22) {
          super(t2, {}, e22), this.implementation = t2, t2.slot && (this.slot = t2.slot);
        }
        is3D() {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        isLayerDraped(t2) {
          return void 0 !== this.implementation.renderToTile;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
        }
        onAdd(t2) {
          this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
        }
        onRemove(t2) {
          this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
        }
      }
      const Cv = new Da({ visibility: new za(re2.layout_sky.visibility) });
      var Rv = { paint: new Da({ "sky-type": new za(re2.paint_sky["sky-type"]), "sky-atmosphere-sun": new za(re2.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new za(re2.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new za(re2.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new za(re2.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ba(re2.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new za(re2.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new za(re2.paint_sky["sky-atmosphere-color"]), "sky-opacity": new za(re2.paint_sky["sky-opacity"]) }), layout: Cv };
      function Lv(e22, r2, n2) {
        const i2 = [0, 0, 1], s2 = t.q.identity([]);
        return t.q.rotateY(s2, s2, n2 ? -_(e22) + Math.PI : _(e22)), t.q.rotateX(s2, s2, -_(r2)), t.v.transformQuat(i2, i2, s2), t.v.normalize(i2, i2);
      }
      var Vv = { paint: new Da({}) };
      const Ov = { circle: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, jp, e22, r2);
        }
        createBucket(t2) {
          return new bp(t2);
        }
        queryRadius(t2) {
          const e22 = t2;
          return Rp("circle-radius", this, e22) + Rp("circle-stroke-width", this, e22) + Lp(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = Op(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e22, r2) + this.paint.get("circle-stroke-width").evaluate(e22, r2);
          return $p(t2, n2, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u2);
        }
        getProgramIds() {
          return ["circle"];
        }
        getDefaultProgramParams(t2, e22) {
          const r2 = Np(this);
          return { config: new pl(this, e22), defines: r2, overrideFog: false };
        }
      }, heatmap: class extends Va {
        createBucket(t2) {
          return new Xp(t2);
        }
        constructor(t2, e22, r2) {
          super(t2, rf, e22, r2), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          "heatmap-color" === t2 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = nf({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t2) {
          return Rp("heatmap-radius", this, t2);
        }
        queryIntersectsFeature(t2, e22, r2, n2, i2, s2, a2, o2) {
          const l2 = this.paint.get("heatmap-radius").evaluate(e22, r2);
          return $p(t2, n2, s2, a2, o2, true, true, new x(0, 0), l2);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getDefaultProgramParams(t2, e22) {
          return "heatmap" === t2 ? { config: new pl(this, e22), overrideFog: false } : {};
        }
      }, hillshade: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, af, e22, r2);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getDefaultProgramParams(t2, e22) {
          return { overrideFog: false };
        }
      }, fill: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, $f, e22, r2);
        }
        getProgramIds() {
          const t2 = this.paint.get("fill-pattern"), e22 = t2 && t2.constantOr(1), r2 = [e22 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r2.push(e22 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
        }
        getDefaultProgramParams(t2, e22) {
          return { config: new pl(this, e22), overrideFog: false };
        }
        recalculate(t2, e22) {
          super.recalculate(t2, e22);
          const r2 = this.paint._values["fill-outline-color"];
          "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t2) {
          return new Uf(t2);
        }
        queryRadius() {
          return Lp(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t2, e22, r2, n2, i2, s2) {
          return !t2.queryGeometry.isAboveHorizon && Mp(Vp(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
        }
        isTileClipped() {
          return true;
        }
      }, "fill-extrusion": class extends Va {
        constructor(t2, e22, r2) {
          super(t2, pv, e22, r2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(t2) {
          return new tv(t2);
        }
        queryRadius() {
          return Lp(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        hasShadowPass() {
          return true;
        }
        cutoffRange() {
          return this.paint.get("fill-extrusion-cutoff-fade-range");
        }
        canCastShadows() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        queryIntersectsFeature(e22, r2, n2, i2, s2, a2, o2, l2, u2) {
          const c2 = Op(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, e22.pixelToTileUnitsFactor), h22 = this.paint.get("fill-extrusion-height").evaluate(r2, n2), p2 = this.paint.get("fill-extrusion-base").evaluate(r2, n2), f2 = [0, 0], d2 = l2 && a2.elevation, m2 = a2.elevation ? a2.elevation.exaggeration() : 1, y2 = e22.tile.getBucket(this);
          if (d2 && y2 instanceof tv) {
            const t2 = y2.centroidVertexArray, e3 = u2 + 1;
            e3 < t2.length && (f2[0] = t2.geta_centroid_pos0(e3), f2[1] = t2.geta_centroid_pos1(e3));
          }
          if (0 === f2[0] && 1 === f2[1])
            return false;
          "globe" === a2.projection.name && (i2 = uv([i2], [new x(0, 0), new x(Cr, Cr)], e22.tileID.canonical).map((t2) => t2.polygon).flat());
          const g2 = d2 ? l2 : null, [v2, b2] = function(e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
            return "globe" === e3.projection.name ? function(e4, r4, n4, i4, s4, a4, o4, l4, u4, c4, h4) {
              const p3 = [], f3 = [], d3 = e4.projection.upVectorScale(h4, e4.center.lat, e4.worldSize).metersToTile, m3 = [0, 0, 0, 1], y3 = [0, 0, 0, 1], g3 = (t2, e52, r5, n5) => {
                t2[0] = e52, t2[1] = r5, t2[2] = n5, t2[3] = 1;
              }, x2 = lv();
              n4 > 0 && (n4 += x2), i4 += x2;
              for (const x3 of r4) {
                const r5 = [], v3 = [];
                for (const p4 of x3) {
                  const f4 = p4.x + s4.x, x4 = p4.y + s4.y, b3 = e4.projection.projectTilePoint(f4, x4, h4), _3 = e4.projection.upVector(h4, p4.x, p4.y);
                  let w2 = n4, M2 = i4;
                  if (o4) {
                    const t2 = yv(f4, x4, n4, i4, o4, l4, u4, c4);
                    w2 += t2.base, M2 += t2.top;
                  }
                  0 !== n4 ? g3(m3, b3.x + _3[0] * d3 * w2, b3.y + _3[1] * d3 * w2, b3.z + _3[2] * d3 * w2) : g3(m3, b3.x, b3.y, b3.z), g3(y3, b3.x + _3[0] * d3 * M2, b3.y + _3[1] * d3 * M2, b3.z + _3[2] * d3 * M2), t.v.transformMat4(m3, m3, a4), t.v.transformMat4(y3, y3, a4), r5.push(new fv(m3[0], m3[1], m3[2])), v3.push(new fv(y3[0], y3[1], y3[2]));
                }
                p3.push(r5), f3.push(v3);
              }
              return [p3, f3];
            }(e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) : o3 ? function(e4, r4, n4, i4, s4, a4, o4, l4, u4) {
              const c4 = [], h4 = [], p3 = [0, 0, 0, 1];
              for (const f3 of e4) {
                const e52 = [], d3 = [];
                for (const c5 of f3) {
                  const h5 = c5.x + i4.x, f4 = c5.y + i4.y, m3 = yv(h5, f4, r4, n4, a4, o4, l4, u4);
                  p3[0] = h5, p3[1] = f4, p3[2] = m3.base, p3[3] = 1, t.e.transformMat4(p3, p3, s4), p3[3] = Math.max(p3[3], 1e-5);
                  const y3 = new fv(p3[0] / p3[3], p3[1] / p3[3], p3[2] / p3[3]);
                  p3[0] = h5, p3[1] = f4, p3[2] = m3.top, p3[3] = 1, t.e.transformMat4(p3, p3, s4), p3[3] = Math.max(p3[3], 1e-5);
                  const g3 = new fv(p3[0] / p3[3], p3[1] / p3[3], p3[2] / p3[3]);
                  e52.push(y3), d3.push(g3);
                }
                c4.push(e52), h4.push(d3);
              }
              return [c4, h4];
            }(r3, n3, i3, s3, a3, o3, l3, u3, c3) : function(t2, e4, r4, n4, i4) {
              const s4 = [], a4 = [], o4 = i4[8] * e4, l4 = i4[9] * e4, u4 = i4[10] * e4, c4 = i4[11] * e4, h4 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d3 = i4[11] * r4;
              for (const e52 of t2) {
                const t3 = [], r5 = [];
                for (const s5 of e52) {
                  const e6 = s5.x + n4.x, a5 = s5.y + n4.y, m3 = i4[0] * e6 + i4[4] * a5 + i4[12], y3 = i4[1] * e6 + i4[5] * a5 + i4[13], g3 = i4[2] * e6 + i4[6] * a5 + i4[14], x2 = i4[3] * e6 + i4[7] * a5 + i4[15], v3 = m3 + o4, b3 = y3 + l4, _3 = g3 + u4, w2 = Math.max(x2 + c4, 1e-5), M2 = m3 + h4, A2 = y3 + p3, S2 = g3 + f3, I2 = Math.max(x2 + d3, 1e-5);
                  t3.push(new fv(v3 / w2, b3 / w2, _3 / w2)), r5.push(new fv(M2 / I2, A2 / I2, S2 / I2));
                }
                s4.push(t3), a4.push(r5);
              }
              return [s4, a4];
            }(r3, n3, i3, s3, a3);
          }(a2, i2, p2, h22, c2, o2, g2, f2, m2, a2.center.lat, e22.tileID.canonical), _2 = e22.queryGeometry;
          return function(t2, e3, r3) {
            let n3 = 1 / 0;
            Mp(r3, e3) && (n3 = mv(r3, e3[0]));
            for (let i3 = 0; i3 < e3.length; i3++) {
              const s3 = e3[i3], a3 = t2[i3];
              for (let t3 = 0; t3 < s3.length - 1; t3++) {
                const e4 = s3[t3], i4 = [e4, s3[t3 + 1], a3[t3 + 1], a3[t3], e4];
                _p(r3, i4) && (n3 = Math.min(n3, mv(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(v2, b2, _2.isPointQuery() ? _2.screenBounds : _2.screenGeometry);
        }
      }, line: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, xv, e22, r2), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          if ("line-gradient" === t2) {
            const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof wn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(t2, e22) {
          super.recalculate(t2, e22), this.paint._values["line-floorwidth"] = Mv.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
        }
        createBucket(t2) {
          return new bg(t2);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getDefaultProgramParams(t2, e22) {
          const r2 = _v(this);
          return { config: new pl(this, e22), defines: r2, overrideFog: false };
        }
        queryRadius(t2) {
          const e22 = t2, r2 = Av(Rp("line-width", this, e22), Rp("line-gap-width", this, e22)), n2 = Rp("line-offset", this, e22);
          return r2 / 2 + Math.abs(n2) + Lp(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t2, e22, r2, n2, i2, s2) {
          if (t2.queryGeometry.isAboveHorizon)
            return false;
          const a2 = Vp(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), o2 = t2.pixelToTileUnitsFactor / 2 * Av(this.paint.get("line-width").evaluate(e22, r2), this.paint.get("line-gap-width").evaluate(e22, r2)), l2 = this.paint.get("line-offset").evaluate(e22, r2);
          return l2 && (n2 = function(t3, e3) {
            const r3 = [], n3 = new x(0, 0);
            for (let i3 = 0; i3 < t3.length; i3++) {
              const s3 = t3[i3], a3 = [];
              for (let t4 = 0; t4 < s3.length; t4++) {
                const r4 = s3[t4], i4 = s3[t4 + 1], o3 = 0 === t4 ? n3 : r4.sub(s3[t4 - 1])._unit()._perp(), l3 = t4 === s3.length - 1 ? n3 : i4.sub(r4)._unit()._perp(), u2 = o3._add(l3)._unit();
                u2._mult(1 / (u2.x * l3.x + u2.y * l3.y)), a3.push(u2._mult(e3)._add(r4));
              }
              r3.push(a3);
            }
            return r3;
          }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0; e4 < i3.length; e4++)
                  if (zp(t3, i3[e4]))
                    return true;
              }
              if (Ap(t3, i3, r3))
                return true;
            }
            return false;
          }(a2, n2, o2);
        }
        isTileClipped() {
          return true;
        }
      }, symbol: rg, background: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, Iv, e22, r2);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
        getDefaultProgramParams(t2, e22) {
          return { overrideFog: false };
        }
      }, raster: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, Tv, e22, r2), this._updateColorRamp();
        }
        getProgramIds() {
          return ["raster"];
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-color"].value.value;
        }
        isLayerDraped(t2) {
          return !(t2 && t2._source instanceof Bv) || !t2._source.onNorthPole && !t2._source.onSouthPole && 0 === this.paint.get("raster-elevation");
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          "raster-color" !== t2 && "raster-color-range" !== t2 || this._updateColorRamp();
        }
        _updateColorRamp() {
          if (!this.hasColorMap())
            return;
          const t2 = this._transitionablePaint._values["raster-color"].value.expression, [e22, r2] = this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 });
          this.colorRamp = nf({ expression: t2, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: e22, end: r2 }], resolution: 256 }), this.colorRampTexture = null;
        }
      }, sky: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, Rv, e22, r2), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = nf({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t2) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e22 = t2.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e22.azimuthal || this._lightPosition.polar !== e22.polar;
          }
          return false;
        }
        getCenter(t2, e22) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
            return n2 && "viewport" === i2.properties.get("anchor") && q("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? Lv(s2.azimuthal, 90 - s2.polar, e22) : Lv(r3[0], 90 - r3[1], e22);
          }
          const r2 = this.paint.get("sky-gradient-center");
          return Lv(r2[0], 90 - r2[1], e22);
        }
        isSky() {
          return true;
        }
        markSkyboxValid(t2) {
          this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const t2 = this.paint.get("sky-type");
          return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
        }
      }, slot: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, Vv, e22);
        }
      }, model: class extends Va {
        constructor(t2, e22, r2) {
          super(t2, bx, e22, r2);
        }
        createBucket(t2) {
          return new xx(t2);
        }
        getProgramIds() {
          return ["model"];
        }
        is3D() {
          return true;
        }
        hasShadowPass() {
          return true;
        }
        canCastShadows() {
          return true;
        }
        hasLightBeamPass() {
          return true;
        }
        cutoffRange() {
          return this.paint.get("model-cutoff-fade-range");
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _handleOverridablePaintPropertyUpdate(t2, e22, r2) {
          return !(!this.layout || e22.isDataDriven() || r2.isDataDriven() || "model-color" !== t2 && "model-color-mix-intensity" !== t2 && "model-rotation" !== t2 && "model-scale" !== t2 && "model-translation" !== t2 && "model-emissive-strength" !== t2);
        }
        _isPropertyZoomDependent(t2) {
          const e22 = this._transitionablePaint._values[t2];
          return null != e22 && null != e22.value && null != e22.value.expression && e22.value.expression instanceof Wi;
        }
        isZoomDependent() {
          return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
        }
      } };
      class Fv {
        constructor(t2) {
          this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class jv {
        constructor() {
          this.tasks = {}, this.taskQueue = [], O(["process"], this), this.invoker = new Fv(this.process), this.nextId = 0;
        }
        add(t2, e22) {
          const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
            return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
          }(e22);
          if (0 === n2) {
            X();
            try {
              t2();
            } finally {
            }
            return null;
          }
          return this.tasks[r2] = { fn: t2, metadata: e22, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[r2];
          } };
        }
        process() {
          X();
          try {
            if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
              return;
            const t2 = this.pick();
            if (null === t2)
              return;
            const e22 = this.tasks[t2];
            if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e22)
              return;
            e22.fn();
          } finally {
          }
        }
        pick() {
          let t2 = null, e22 = 1 / 0;
          for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
            const n2 = this.tasks[this.taskQueue[r3]];
            n2.priority < e22 && (e22 = n2.priority, t2 = r3);
          }
          if (null === t2)
            return null;
          const r2 = this.taskQueue[t2];
          return this.taskQueue.splice(t2, 1), r2;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class Uv {
        constructor(t2, e22, r2) {
          this.target = t2, this.parent = e22, this.mapId = r2, this.callbacks = {}, this.cancelCallbacks = {}, O(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new jv();
        }
        send(t2, e22, r2, n2, i2 = false, s2) {
          const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r2 && (r2.metadata = s2, this.callbacks[a2] = r2);
          const o2 = /* @__PURE__ */ new Set();
          return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: Js(e22, o2) }, o2), { cancel: () => {
            r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
          } };
        }
        receive(t2) {
          const e22 = t2.data, r2 = e22.id;
          if (r2 && (!e22.targetMapId || this.mapId === e22.targetMapId))
            if ("<cancel>" === e22.type) {
              const t3 = this.cancelCallbacks[r2];
              delete this.cancelCallbacks[r2], t3 && t3.cancel();
            } else if (e22.mustQueue || X()) {
              const t3 = this.callbacks[r2], n2 = this.scheduler.add(() => this.processTask(r2, e22), t3 && t3.metadata || { type: "message" });
              n2 && (this.cancelCallbacks[r2] = n2);
            } else
              this.processTask(r2, e22);
        }
        processTask(t2, e22) {
          if (delete this.cancelCallbacks[t2], "<response>" === e22.type) {
            const r2 = this.callbacks[t2];
            delete this.callbacks[t2], r2 && (e22.error ? r2(Qs(e22.error)) : r2(null, Qs(e22.data)));
          } else {
            const r2 = /* @__PURE__ */ new Set(), n2 = e22.hasCallback ? (e3, n3) => {
              this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? Js(e3) : null, data: Js(n3, r2) }, r2);
            } : (t3) => {
            }, i2 = Qs(e22.data);
            if (this.parent[e22.type])
              this.parent[e22.type](e22.sourceMapId, i2, n2);
            else if (this.parent.getWorkerSource) {
              const t3 = e22.type.split(".");
              this.parent.getWorkerSource(e22.sourceMapId, t3[0], i2.source, i2.scope)[t3[1]](i2, n2);
            } else
              n2(new Error(`Could not find function ${e22.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }
      class Nv {
        constructor(t2, e22) {
          this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = C();
          const r2 = this.workerPool.acquire(this.id);
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n2 = new Nv.Actor(r2[t3], e22, this.id);
            n2.name = `Worker ${t3}`, this.actors.push(n2);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(t2, e22, r2) {
          z(this.actors, (r3, n2) => {
            r3.send(t2, e22, n2);
          }, r2 = r2 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((t2) => {
            t2.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      Nv.Actor = Uv;
      class $v {
        constructor(t2, e22) {
          this.width = t2, this.height = e22, this.nextRow = 0, this.image = new Jp({ width: t2, height: e22 }), this.positions = {}, this.uploaded = false;
        }
        getDash(t2, e22) {
          const r2 = this.getKey(t2, e22);
          return this.positions[r2];
        }
        trim() {
          const t2 = this.width, e22 = this.height = L(this.nextRow);
          this.image.resize({ width: t2, height: e22 });
        }
        getKey(t2, e22) {
          return t2.join(",") + e22;
        }
        getDashRanges(t2, e22, r2) {
          const n2 = [];
          let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, a2 = true;
          n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t2[0] });
          let o2 = t2[0];
          for (let e3 = 1; e3 < t2.length; e3++) {
            a2 = !a2;
            const l2 = t2[e3];
            i2 = o2 * r2, o2 += l2, s2 = o2 * r2, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l2 });
          }
          return n2;
        }
        addRoundDash(t2, e22, r2) {
          const n2 = e22 / 2;
          for (let e3 = -r2; e3 <= r2; e3++) {
            const i2 = this.width * (this.nextRow + r2 + e3);
            let s2 = 0, a2 = t2[s2];
            for (let o2 = 0; o2 < this.width; o2++) {
              o2 / a2.right > 1 && (a2 = t2[++s2]);
              const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
              let h22;
              const p2 = e3 / r2 * (n2 + 1);
              if (a2.isDash) {
                const t3 = n2 - Math.abs(p2);
                h22 = Math.sqrt(c2 * c2 + t3 * t3);
              } else
                h22 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
              this.image.data[i2 + o2] = Math.max(0, Math.min(255, h22 + 128));
            }
          }
        }
        addRegularDash(t2, e22) {
          for (let e3 = t2.length - 1; e3 >= 0; --e3) {
            const r3 = t2[e3], n3 = t2[e3 + 1];
            r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
          }
          const r2 = t2[0], n2 = t2[t2.length - 1];
          r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
          const i2 = this.width * this.nextRow;
          let s2 = 0, a2 = t2[s2];
          for (let r3 = 0; r3 < this.width; r3++) {
            r3 / a2.right > 1 && (a2 = t2[++s2]);
            const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l2 = Math.min(n3, o2);
            this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e22 + 128));
          }
        }
        addDash(t2, e22) {
          const r2 = this.getKey(t2, e22);
          if (this.positions[r2])
            return this.positions[r2];
          const n2 = "round" === e22, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
          if (this.nextRow + s2 > this.height)
            return q("LineAtlas out of space"), null;
          0 === t2.length && t2.push(1);
          let a2 = 0;
          for (let e3 = 0; e3 < t2.length; e3++)
            t2[e3] < 0 && (q("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
          if (0 !== a2) {
            const r3 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r3);
            n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e22 ? 0.5 * r3 : 0);
          }
          const o2 = this.nextRow + i2;
          this.nextRow += s2;
          const l2 = { tl: [o2, i2], br: [a2, 0] };
          return this.positions[r2] = l2, l2;
        }
      }
      Ks($v, "LineAtlas");
      const qv = 1 * ry;
      class Gv {
        constructor(t2) {
          const e22 = {}, r2 = [];
          for (const n3 in t2) {
            const i3 = t2[n3], s3 = e22[n3] = {};
            for (const t3 in i3.glyphs) {
              const e3 = i3.glyphs[+t3];
              if (!e3 || 0 === e3.bitmap.width || 0 === e3.bitmap.height)
                continue;
              const n4 = e3.metrics.localGlyph ? qv : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n4, h: e3.bitmap.height + 2 * n4 };
              r2.push(a2), s3[t3] = a2;
            }
          }
          const { w: n2, h: i2 } = Km(r2), s2 = new Jp({ width: n2 || 1, height: i2 || 1 });
          for (const r3 in t2) {
            const n3 = t2[r3];
            for (const t3 in n3.glyphs) {
              const i3 = n3.glyphs[+t3];
              if (!i3 || 0 === i3.bitmap.width || 0 === i3.bitmap.height)
                continue;
              const a2 = e22[r3][t3], o2 = i3.metrics.localGlyph ? qv : 1;
              Jp.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
            }
          }
          this.image = s2, this.positions = e22;
        }
      }
      Ks(Gv, "GlyphAtlas");
      class Yv {
        constructor(t2) {
          this.tileID = new Hc(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.scope = t2.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.promoteId = t2.promoteId, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = zy(t2.tileID.canonical, t2.projection), this.projection = t2.projection, this.brightness = t2.brightness, this.extraShadowCaster = !!t2.extraShadowCaster;
        }
        parse(t2, e22, r2, n2, i2) {
          this.status = "parsing", this.data = t2, this.collisionBoxArray = new _o();
          const s2 = new hd(Object.keys(t2.layers).sort()), a2 = new Hd(this.tileID, this.promoteId);
          a2.bucketLayerIDs = [];
          const o2 = {}, l2 = new $v(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r2, brightness: this.brightness }, c2 = e22.familiesBySource[this.source];
          for (const e3 in c2) {
            const n3 = t2.layers[e3];
            if (!n3)
              continue;
            let i3 = false, l3 = false, h3 = false;
            for (const t3 of c2[e3])
              "symbol" === t3[0].type ? i3 = true : l3 = true, t3[0].is3D() && "model" !== t3[0].type && (h3 = true);
            if (this.extraShadowCaster && !h3)
              continue;
            if (true === this.isSymbolTile && !i3)
              continue;
            if (false === this.isSymbolTile && !l3)
              continue;
            1 === n3.version && q(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const p3 = s2.encode(e3), f3 = [];
            for (let t3 = 0; t3 < n3.length; t3++) {
              const r3 = n3.feature(t3), i4 = a2.getId(r3, e3);
              f3.push({ feature: r3, id: i4, index: t3, sourceLayerIndex: p3 });
            }
            for (const t3 of c2[e3]) {
              const e4 = t3[0];
              (!this.extraShadowCaster || e4.is3D() && "model" !== e4.type) && (void 0 !== this.isSymbolTile && "symbol" === e4.type !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || "none" !== e4.visibility && (Zv(t3, this.zoom, u2.brightness, r2), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: p3, sourceID: this.source, projection: this.projection.spec })).populate(f3, u2, this.tileID.canonical, this.tileTransform), a2.bucketLayerIDs.push(t3.map((t4) => t4.id))));
            }
          }
          let h22, p2, f2, d2;
          l2.trim();
          const m2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, y2 = () => {
            if (h22)
              return this.status = "done", i2(h22);
            if (this.extraShadowCaster)
              this.status = "done", i2(null, { buckets: E(o2).filter((t3) => !t3.isEmpty()), featureIndex: a2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: u2.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (p2 && f2 && d2) {
              const t3 = new Gv(p2), e3 = new Jm(f2, d2);
              for (const n3 in o2) {
                const i3 = o2[n3];
                i3 instanceof fg ? (Zv(i3.layers, this.zoom, u2.brightness, r2), vy(i3, p2, t3.positions, f2, e3.iconPositions, this.showCollisionBoxes, r2, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : i3.hasPattern && (i3 instanceof bg || i3 instanceof Uf || i3 instanceof tv) && (Zv(i3.layers, this.zoom, u2.brightness, r2), i3.addFeatures(u2, this.tileID.canonical, e3.patternPositions, r2, this.tileTransform, this.brightness));
              }
              this.status = "done", i2(null, { buckets: E(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l2, imageAtlas: e3, brightness: u2.brightness });
            }
          };
          if (!this.extraShadowCaster) {
            const t3 = j(u2.glyphDependencies, (t4) => Object.keys(t4).map(Number));
            Object.keys(t3).length ? n2.send("getGlyphs", { uid: this.uid, stacks: t3, scope: this.scope }, (t4, e4) => {
              h22 || (h22 = t4, p2 = e4, y2());
            }, void 0, false, m2) : p2 = {};
            const e3 = Object.keys(u2.iconDependencies);
            e3.length ? n2.send("getImages", { icons: e3, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (t4, e4) => {
              h22 || (h22 = t4, f2 = e4, y2());
            }, void 0, false, m2) : f2 = {};
            const r3 = Object.keys(u2.patternDependencies);
            r3.length ? n2.send("getImages", { icons: r3, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (t4, e4) => {
              h22 || (h22 = t4, d2 = e4, y2());
            }, void 0, false, m2) : d2 = {};
          }
          y2();
        }
      }
      function Zv(t2, e22, r2, n2) {
        const i2 = new _a2(e22, { brightness: r2 });
        for (const e3 of t2)
          e3.recalculate(i2, n2);
      }
      class Xv {
        constructor(t2) {
          this.entries = {}, this.scheduler = t2;
        }
        request(t2, e22, r2, n2) {
          const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
          if (i2.result) {
            const [t3, r3] = i2.result;
            return this.scheduler ? this.scheduler.add(() => {
              n2(t3, r3);
            }, e22) : n2(t3, r3), () => {
            };
          }
          return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
            i2.result = [r3, n3];
            for (const t3 of i2.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                t3(r3, n3);
              }, e22) : t3(r3, n3);
            setTimeout(() => delete this.entries[t2], 3e3);
          })), () => {
            i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
          };
        }
      }
      function Kv(t2, e22, r2) {
        const n2 = JSON.stringify(t2.request);
        return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
          const n3 = dt(t2.request, (t3, n4, i2, s2) => {
            t3 ? e3(t3) : n4 && e3(null, { vectorTile: r2 ? void 0 : new ld(new Cd(n4)), rawData: n4, cacheControl: i2, expires: s2 });
          });
          return () => {
            n3.cancel(), e3();
          };
        }, e22);
      }
      var Wv = { workerUrl: "", workerClass: null, workerParams: void 0 };
      function Hv() {
        return null != Wv.workerClass ? new Wv.workerClass() : new self.Worker(Wv.workerUrl, Wv.workerParams);
      }
      const Jv = "mapboxgl_preloaded_worker_pool";
      class Qv {
        constructor() {
          this.active = {};
        }
        acquire(t2) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Qv.workerCount; )
              this.workers.push(new Hv());
          return this.active[t2] = true, this.workers.slice();
        }
        release(t2) {
          delete this.active[t2], this.workers && 0 === this.numActive() && (this.workers.forEach((t3) => {
            t3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Jv];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let tb;
      function eb() {
        return tb || (tb = new Qv()), tb;
      }
      Qv.workerCount = 2;
      let rb, nb, ib, sb = null;
      function ab() {
        return X() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : nb || n.DRACO_URL;
      }
      const ob = 5123, lb = 5126, ub = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, [ob]: Uint16Array, 5125: Uint32Array, [lb]: Float32Array }, cb = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", [ob]: "DT_UINT16", 5125: "DT_UINT32", [lb]: "DT_FLOAT32" }, hb = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function pb(t2, e22, r2) {
        const n2 = r2.json.bufferViews.length, i2 = r2.buffers.length;
        e22.bufferView = n2, r2.json.bufferViews[n2] = { buffer: i2, byteLength: t2.byteLength }, r2.buffers[i2] = t2;
      }
      const fb = "KHR_draco_mesh_compression";
      function db(t2, e22) {
        const r2 = t2.extensions && t2.extensions[fb];
        if (!r2)
          return;
        const n2 = new ib.Decoder(), i2 = vb(e22, r2.bufferView), s2 = new ib.Mesh();
        if (!n2.DecodeArrayToMesh(i2, i2.byteLength, s2))
          throw new Error("Failed to decode Draco mesh");
        const a2 = e22.json.accessors[t2.indices], o2 = ub[a2.componentType], l2 = a2.count * o2.BYTES_PER_ELEMENT, u2 = ib._malloc(l2);
        o2 === Uint16Array ? n2.GetTrianglesUInt16Array(s2, l2, u2) : n2.GetTrianglesUInt32Array(s2, l2, u2), pb(ib.memory.buffer.slice(u2, u2 + l2), a2, e22), ib._free(u2);
        for (const i3 of Object.keys(r2.attributes)) {
          const a3 = n2.GetAttributeByUniqueId(s2, r2.attributes[i3]), o3 = e22.json.accessors[t2.attributes[i3]], l3 = cb[o3.componentType], u3 = o3.count * hb[o3.type] * ub[o3.componentType].BYTES_PER_ELEMENT, c2 = ib._malloc(u3);
          n2.GetAttributeDataArrayForAllPoints(s2, a3, ib[l3], u3, c2), pb(ib.memory.buffer.slice(c2, c2 + u3), o3, e22), ib._free(c2);
        }
        n2.destroy(), s2.destroy(), delete t2.extensions[fb];
      }
      const mb = 1179937895, yb = new TextDecoder("utf8");
      function gb(t2, e22) {
        return new URL(t2, e22).href;
      }
      function xb(t2, e22, r2, n2) {
        return fetch(gb(t2.uri, n2)).then((t3) => t3.arrayBuffer()).then((t3) => {
          e22.buffers[r2] = t3;
        });
      }
      function vb(t2, e22) {
        const r2 = t2.json.bufferViews[e22];
        return new Uint8Array(t2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength);
      }
      function bb(t2, e22, r2, n2) {
        if (t2.uri) {
          const i2 = gb(t2.uri, n2);
          return fetch(i2).then((t3) => t3.blob()).then((t3) => createImageBitmap(t3)).then((t3) => {
            e22.images[r2] = t3;
          });
        }
        if (void 0 !== t2.bufferView) {
          const n3 = vb(e22, t2.bufferView), i2 = new Blob([n3], { type: t2.mimeType });
          return createImageBitmap(i2).then((t3) => {
            e22.images[r2] = t3;
          });
        }
      }
      function _b2(t2, e22 = 0, r2) {
        const n2 = { json: null, images: [], buffers: [] };
        if (new Uint32Array(t2, e22, 1)[0] === mb) {
          const r3 = new Uint32Array(t2, e22);
          let i3 = 2;
          const s3 = (r3[i3++] >> 2) - 3, a3 = r3[i3++] >> 2;
          if (i3++, n2.json = JSON.parse(yb.decode(r3.subarray(i3, i3 + a3))), i3 += a3, i3 < s3) {
            const s4 = r3[i3++];
            i3++;
            const a4 = e22 + (i3 << 2);
            n2.buffers[0] = t2.slice(a4, a4 + s4);
          }
        } else
          n2.json = JSON.parse(yb.decode(new Uint8Array(t2, e22)));
        const { buffers: i2, images: s2, meshes: a2, extensionsUsed: o2 } = n2.json;
        let l2 = Promise.resolve();
        if (i2) {
          const t3 = [];
          for (let e3 = 0; e3 < i2.length; e3++) {
            const s3 = i2[e3];
            s3.uri ? t3.push(xb(s3, n2, e3, r2)) : n2.buffers[e3] || (n2.buffers[e3] = null);
          }
          l2 = Promise.all(t3);
        }
        return l2.then(() => {
          const t3 = [], e3 = o2 && o2.includes(fb);
          if (e3 && t3.push(function() {
            if (!ib)
              return rb || (rb = function(t4) {
                let e4, r3 = null;
                function n3() {
                  e4 = new Uint8Array(r3.buffer);
                }
                function i3() {
                  throw new Error("Unexpected Draco error.");
                }
                const s3 = { a: { a: i3, d: function(t5, r4, n4) {
                  return e4.copyWithin(t5, r4, r4 + n4);
                }, c: function(t5) {
                  const i4 = e4.length, s4 = Math.max(t5 >>> 0, Math.ceil(1.2 * i4)), a3 = Math.ceil((s4 - i4) / 65536);
                  try {
                    return r3.grow(a3), n3(), true;
                  } catch (t6) {
                    return false;
                  }
                }, b: i3 } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t4, s3) : t4.then((t5) => t5.arrayBuffer()).then((t5) => WebAssembly.instantiate(t5, s3))).then((t5) => {
                  const { Rb: i4, Qb: s4, P: a3, T: o3, X: l3, Ja: u2, La: c2, Qa: h22, Va: p2, Wa: f2, eb: d2, jb: m2, f: y2, e: g2, yb: x2, zb: v2, Ab: b2, Bb: _2, Db: w2, Gb: M2 } = t5.instance.exports;
                  r3 = g2;
                  const A2 = /* @__PURE__ */ (() => {
                    let t6 = 0, r4 = 0, n4 = 0, a4 = 0;
                    return (o4) => {
                      n4 && (i4(a4), i4(t6), r4 += n4, n4 = t6 = 0), t6 || (r4 += 128, t6 = s4(r4));
                      const l4 = o4.length + 7 & -8;
                      let u3 = t6;
                      l4 >= r4 && (n4 = l4, u3 = a4 = s4(l4));
                      for (let t7 = 0; t7 < o4.length; t7++)
                        e4[u3 + t7] = o4[t7];
                      return u3;
                    };
                  })();
                  return n3(), y2(), { memory: g2, _free: i4, _malloc: s4, Mesh: class {
                    constructor() {
                      this.ptr = a3();
                    }
                    destroy() {
                      o3(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = u2();
                    }
                    destroy() {
                      m2(this.ptr);
                    }
                    DecodeArrayToMesh(t6, e52, r4) {
                      const n4 = A2(t6), i5 = c2(this.ptr, n4, e52, r4.ptr);
                      return !!l3(i5);
                    }
                    GetAttributeByUniqueId(t6, e52) {
                      return { ptr: h22(this.ptr, t6.ptr, e52) };
                    }
                    GetTrianglesUInt16Array(t6, e52, r4) {
                      p2(this.ptr, t6.ptr, e52, r4);
                    }
                    GetTrianglesUInt32Array(t6, e52, r4) {
                      f2(this.ptr, t6.ptr, e52, r4);
                    }
                    GetAttributeDataArrayForAllPoints(t6, e52, r4, n4, i5) {
                      d2(this.ptr, t6.ptr, e52.ptr, r4, n4, i5);
                    }
                  }, DT_INT8: x2(), DT_UINT8: v2(), DT_INT16: b2(), DT_UINT16: _2(), DT_UINT32: w2(), DT_FLOAT32: M2() };
                });
              }(fetch(ab())), rb.then((t4) => {
                ib = t4, rb = void 0;
              }));
          }()), s2)
            for (let e4 = 0; e4 < s2.length; e4++)
              t3.push(bb(s2[e4], n2, e4, r2));
          return (t3.length ? Promise.all(t3) : Promise.resolve()).then(() => {
            if (e3 && a2)
              for (const { primitives: t4 } of a2)
                for (const e4 of t4)
                  db(e4, n2);
            return n2;
          });
        });
      }
      class wb {
        constructor(t2, e22, r2) {
          if (this.triangleCount = e22.length / 3, this.min = new x(0, 0), this.max = new x(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t2.length || 0 === r2)
            return;
          const n2 = t2.map((t3) => t3.x), i2 = t2.map((t3) => t3.y);
          this.min = new x(Math.min(...n2), Math.min(...i2)), this.max = new x(Math.max(...n2), Math.max(...i2));
          const s2 = this.max.sub(this.min);
          s2.x = Math.max(s2.x, 1), s2.y = Math.max(s2.y, 1);
          const a2 = Math.max(s2.x, s2.y) / r2;
          this.cellsX = Math.max(1, Math.ceil(s2.x / a2)), this.cellsY = Math.max(1, Math.ceil(s2.y / a2)), this.xScale = 1 / a2, this.yScale = 1 / a2;
          const o2 = [];
          for (let r3 = 0; r3 < this.triangleCount; r3++) {
            const n3 = t2[e22[3 * r3 + 0]].sub(this.min), i3 = t2[e22[3 * r3 + 1]].sub(this.min), s3 = t2[e22[3 * r3 + 2]].sub(this.min), l3 = Mb(Math.floor(Math.min(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), u2 = Mb(Math.floor(Math.max(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), c2 = Mb(Math.floor(Math.min(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), h22 = Mb(Math.floor(Math.max(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), p2 = new x(0, 0), f2 = new x(0, 0), d2 = new x(0, 0), m2 = new x(0, 0);
            for (let t3 = c2; t3 <= h22; ++t3) {
              p2.y = f2.y = t3 * a2, d2.y = m2.y = (t3 + 1) * a2;
              for (let e3 = l3; e3 <= u2; ++e3)
                p2.x = d2.x = e3 * a2, f2.x = m2.x = (e3 + 1) * a2, (Cp(n3, i3, s3, p2, f2, m2) || Cp(n3, i3, s3, p2, m2, d2)) && o2.push({ cellIdx: t3 * this.cellsX + e3, triIdx: r3 });
            }
          }
          if (0 === o2.length)
            return;
          o2.sort((t3, e3) => t3.cellIdx - e3.cellIdx || t3.triIdx - e3.triIdx);
          let l2 = 0;
          for (; l2 < o2.length; ) {
            const t3 = o2[l2].cellIdx, e3 = { start: this.payload.length, len: 0 };
            for (; l2 < o2.length && o2[l2].cellIdx === t3; )
              ++e3.len, this.payload.push(o2[l2++].triIdx);
            this.cells[t3] = e3;
          }
        }
        query(t2, e22, r2) {
          if (0 === this.triangleCount || 0 === this.cells.length)
            return;
          if (t2.x > this.max.x || this.min.x > e22.x)
            return;
          if (t2.y > this.max.y || this.min.y > e22.y)
            return;
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8)));
          for (let t3 = 0; t3 < this.lookup.length; t3++)
            this.lookup[t3] = 0;
          const n2 = Mb(t2.x - this.min.x, this.xScale, this.cellsX), i2 = Mb(e22.x - this.min.x, this.xScale, this.cellsX), s2 = Mb(t2.y - this.min.y, this.yScale, this.cellsY), a2 = Mb(e22.y - this.min.y, this.yScale, this.cellsY);
          for (let t3 = s2; t3 <= a2; t3++)
            for (let e3 = n2; e3 <= i2; e3++) {
              const n3 = this.cells[t3 * this.cellsX + e3];
              if (n3)
                for (let t4 = 0; t4 < n3.len; t4++) {
                  const e4 = this.payload[n3.start + t4], i3 = Math.floor(e4 / 8), s3 = 1 << e4 % 8;
                  if (!(this.lookup[i3] & s3) && (this.lookup[i3] |= s3, r2.push(e4), r2.length === this.triangleCount))
                    return;
                }
            }
        }
      }
      function Mb(t2, e22, r2) {
        return Math.max(0, Math.min(r2 - 1, Math.floor(t2 * e22)));
      }
      function Ab(t2, e22) {
        const r2 = t2.json.bufferViews[e22.bufferView];
        return new ub[e22.componentType](t2.buffers[r2.buffer], (e22.byteOffset || 0) + (r2.byteOffset || 0), e22.count * hb[e22.type]);
      }
      function Sb(t2, e22, r2) {
        const n2 = t2.indices, i2 = t2.attributes, s2 = {};
        s2.indexArray = new ao();
        const a2 = e22.json.accessors[n2], o2 = a2.count / 3;
        s2.indexArray.reserve(o2);
        const l2 = Ab(e22, a2);
        for (let t3 = 0; t3 < o2; t3++)
          s2.indexArray.emplaceBack(l2[3 * t3], l2[3 * t3 + 1], l2[3 * t3 + 2]);
        s2.indexArray._trim(), s2.vertexArray = new mo();
        const u2 = e22.json.accessors[i2.POSITION];
        s2.vertexArray.reserve(u2.count);
        const c2 = Ab(e22, u2);
        for (let t3 = 0; t3 < u2.count; t3++)
          s2.vertexArray.emplaceBack(c2[3 * t3], c2[3 * t3 + 1], c2[3 * t3 + 2]);
        if (s2.vertexArray._trim(), s2.aabb = new oh(u2.min, u2.max), s2.centroid = function(t3, e3) {
          const r3 = [0, 0, 0], n3 = t3.length;
          if (n3 > 0) {
            for (let i3 = 0; i3 < n3; i3++) {
              const n4 = 3 * t3[i3];
              r3[0] += e3[n4], r3[1] += e3[n4 + 1], r3[2] += e3[n4 + 2];
            }
            r3[0] /= n3, r3[1] /= n3, r3[2] /= n3;
          }
          return r3;
        }(l2, c2), void 0 !== i2.COLOR_0) {
          const t3 = e22.json.accessors[i2.COLOR_0], r3 = hb[t3.type];
          if (t3.componentType === lb) {
            s2.colorArray = 3 === r3 ? new mo() : new Xa(), s2.colorArray.reserve(t3.count);
            const n3 = Ab(e22, t3);
            if (3 === r3)
              for (let e3 = 0; e3 < t3.count; e3++)
                s2.colorArray.emplaceBack(n3[3 * e3], n3[3 * e3 + 1], n3[3 * e3 + 2]);
            else
              for (let e3 = 0; e3 < t3.count; e3++)
                s2.colorArray.emplaceBack(n3[4 * e3], n3[4 * e3 + 1], n3[4 * e3 + 2], n3[4 * e3 + 3]);
            s2.colorArray._trim();
          } else if (t3.componentType === ob && 4 === r3) {
            s2.colorArray = new Xa(), s2.colorArray.resize(t3.count);
            const r4 = Ab(e22, t3), n3 = 1 / 65535, i3 = s2.colorArray.float32;
            for (let t4 = 0; t4 < 4 * r4.length; ++t4)
              i3[t4] = r4[t4] * n3;
          } else
            q(`glTF color buffer parsing for accessor ${JSON.stringify(t3)} is not supported`);
        }
        if (void 0 !== i2.NORMAL) {
          s2.normalArray = new mo();
          const t3 = e22.json.accessors[i2.NORMAL];
          s2.normalArray.reserve(t3.count);
          const r3 = Ab(e22, t3);
          for (let e3 = 0; e3 < t3.count; e3++)
            s2.normalArray.emplaceBack(r3[3 * e3], r3[3 * e3 + 1], r3[3 * e3 + 2]);
          s2.normalArray._trim();
        }
        if (void 0 !== i2.TEXCOORD_0 && r2.length > 0) {
          s2.texcoordArray = new yo();
          const t3 = e22.json.accessors[i2.TEXCOORD_0];
          s2.texcoordArray.reserve(t3.count);
          const r3 = Ab(e22, t3);
          for (let e3 = 0; e3 < t3.count; e3++)
            s2.texcoordArray.emplaceBack(r3[2 * e3], r3[2 * e3 + 1]);
          s2.texcoordArray._trim();
        }
        const h22 = t2.material;
        return s2.material = function(t3, e3) {
          const { emissiveFactor: r3 = [0, 0, 0], alphaMode: n3 = "OPAQUE", alphaCutoff: i3 = 0.5, normalTexture: s3, occlusionTexture: a3, emissiveTexture: o3, doubleSided: l3 } = t3, { baseColorFactor: u3 = [1, 1, 1, 1], metallicFactor: c3 = 1, roughnessFactor: h3 = 1, baseColorTexture: p2, metallicRoughnessTexture: f2 } = t3.pbrMetallicRoughness || {};
          return { pbrMetallicRoughness: { baseColorFactor: new Re(...u3), metallicFactor: c3, roughnessFactor: h3, baseColorTexture: p2 ? e3[p2.index] : void 0, metallicRoughnessTexture: f2 ? e3[f2.index] : void 0 }, doubleSided: l3, emissiveFactor: r3, alphaMode: n3, alphaCutoff: i3, normalTexture: s3 ? e3[s3.index] : void 0, occlusionTexture: a3 ? e3[a3.index] : void 0, emissionTexture: o3 ? e3[o3.index] : void 0, defined: void 0 === t3.defined };
        }(void 0 !== h22 ? e22.json.materials[h22] : { defined: false }, r2), void 0 !== i2._FEATURE_RGBA4444 && (s2.featureData = new Uint32Array(Ab(e22, e22.json.accessors[i2._FEATURE_RGBA4444]).buffer)), s2;
      }
      function Ib(e22, r2, n2) {
        const { matrix: i2, rotation: s2, translation: a2, scale: o2, mesh: l2, extras: u2, children: c2 } = e22, h22 = {};
        if (h22.matrix = i2 || t.m.fromRotationTranslationScale([], s2 || [0, 0, 0, 1], a2 || [0, 0, 0], o2 || [1, 1, 1]), void 0 !== l2) {
          h22.meshes = n2[l2];
          const t2 = h22.anchor = [0, 0];
          for (const e3 of h22.meshes) {
            const { min: r3, max: n3 } = e3.aabb;
            t2[0] += r3[0] + n3[0], t2[1] += r3[1] + n3[1];
          }
          t2[0] = Math.floor(t2[0] / h22.meshes.length / 2), t2[1] = Math.floor(t2[1] / h22.meshes.length / 2);
        }
        if (u2 && (u2.id && (h22.id = u2.id), u2.lights && (h22.lights = function(t2) {
          if (!t2.length)
            return [];
          const e3 = function(t3) {
            const e4 = atob(t3), r4 = new Uint8Array(e4.length);
            for (let t4 = 0; t4 < e4.length; t4++)
              r4[t4] = e4.codePointAt(t4);
            return r4;
          }(t2), r3 = [], n3 = e3.length / 24, i3 = new Uint16Array(e3.buffer), s3 = new Float32Array(e3.buffer);
          for (let t3 = 0; t3 < n3; t3++) {
            const e4 = i3[2 * t3 * 6] / 30, n4 = i3[2 * t3 * 6 + 1] / 30, a3 = i3[2 * t3 * 6 + 10] / 100, o3 = s3[6 * t3 + 1], l3 = s3[6 * t3 + 2], u3 = s3[6 * t3 + 3], c3 = s3[6 * t3 + 4], h3 = u3 - o3, p2 = c3 - l3, f2 = Math.hypot(h3, p2);
            r3.push({ pos: [o3 + 0.5 * h3, l3 + 0.5 * p2, n4], normal: [p2 / f2, -h3 / f2, 0], width: f2, height: e4, depth: a3, points: [o3, l3, u3, c3] });
          }
          return r3;
        }(u2.lights))), c2) {
          const t2 = [];
          for (const e3 of c2)
            t2.push(Ib(r2.json.nodes[e3], r2, n2));
          h22.children = t2;
        }
        return h22;
      }
      function kb(t2) {
        if (0 === t2.vertices.length || 0 === t2.indices.length)
          return null;
        const [e22, r2] = [t2.vertices[0].clone(), t2.vertices[0].clone()];
        for (let n3 = 1; n3 < t2.vertices.length; ++n3) {
          const i3 = t2.vertices[n3];
          e22.x = Math.min(e22.x, i3.x), e22.y = Math.min(e22.y, i3.y), r2.x = Math.max(r2.x, i3.x), r2.y = Math.max(r2.y, i3.y);
        }
        const n2 = Math.ceil(Math.max(r2.x - e22.x, r2.y - e22.y) / 256), i2 = Math.max(8, n2), s2 = new wb(t2.vertices, t2.indices, i2);
        return { vertices: t2.vertices, indices: t2.indices, grid: s2, min: e22, max: r2 };
      }
      function Tb(t2) {
        if (!t2.extras || !t2.extras.ground)
          return null;
        const e22 = t2.extras.ground;
        if (!e22 || !Array.isArray(e22) || 0 === e22.length)
          return null;
        const r2 = e22[0];
        if (!r2 || !Array.isArray(r2) || 0 === r2.length)
          return null;
        const n2 = [];
        for (const t3 of r2) {
          if (!Array.isArray(t3) || 2 !== t3.length)
            continue;
          const e3 = t3[0], r3 = t3[1];
          "number" == typeof e3 && "number" == typeof r3 && n2.push(new x(e3, r3));
        }
        if (n2.length < 3)
          return null;
        n2.length > 1 && n2[n2.length - 1].equals(n2[0]) && n2.pop();
        let i2 = 0;
        for (let t3 = 0; t3 < n2.length; t3++) {
          const e3 = n2[t3], r3 = n2[(t3 + 1) % n2.length], s3 = n2[(t3 + 2) % n2.length];
          i2 += (e3.x - r3.x) * (s3.y - r3.y) - (s3.x - r3.x) * (e3.y - r3.y);
        }
        i2 > 0 && n2.reverse();
        const s2 = Lf(n2.flatMap((t3) => [t3.x, t3.y]), []);
        return 0 === s2.length ? null : { vertices: n2, indices: s2 };
      }
      function Pb(t2) {
        const e22 = [], r2 = [];
        let n2 = 0;
        for (const i2 of t2) {
          n2 = e22.length;
          const t3 = i2.vertexArray.float32, s2 = i2.indexArray.uint16;
          for (let r3 = 0; r3 < i2.vertexArray.length; r3++)
            e22.push(new x(t3[3 * r3 + 0], t3[3 * r3 + 1]));
          for (let t4 = 0; t4 < 3 * i2.indexArray.length; t4++)
            r2.push(s2[t4] + n2);
        }
        if (r2.length % 3 != 0)
          return null;
        for (let t3 = 0; t3 < r2.length; t3 += 3) {
          const n3 = e22[r2[t3 + 0]], i2 = e22[r2[t3 + 1]], s2 = e22[r2[t3 + 2]];
          (n3.x - i2.x) * (s2.y - i2.y) - (s2.x - i2.x) * (n3.y - i2.y) > 0 && ([r2[t3 + 1], r2[t3 + 2]] = [r2[t3 + 2], r2[t3 + 1]]);
        }
        return { vertices: e22, indices: r2 };
      }
      function zb(t2) {
        const e22 = function(t3, e3) {
          const r3 = [], n3 = WebGL2RenderingContext;
          if (t3.json.textures)
            for (const i3 of t3.json.textures) {
              const s3 = { magFilter: n3.LINEAR, minFilter: n3.NEAREST, wrapS: n3.REPEAT, wrapT: n3.REPEAT };
              void 0 !== i3.sampler && Object.assign(s3, t3.json.samplers[i3.sampler]), r3.push({ image: e3[i3.source], sampler: s3, uploaded: false });
            }
          return r3;
        }(t2, t2.images), r2 = function(t3, e3) {
          const r3 = [];
          for (const n3 of t3.json.meshes) {
            const i3 = [];
            for (const r4 of n3.primitives)
              i3.push(Sb(r4, t3, e3));
            r3.push(i3);
          }
          return r3;
        }(t2, e22), { scenes: n2, scene: i2, nodes: s2 } = t2.json, a2 = n2 ? n2[i2 || 0].nodes : s2, o2 = [];
        for (const e3 of a2)
          o2.push(Ib(s2[e3], t2, r2));
        return function(t3, e3, r3) {
          const n3 = {}, i3 = /* @__PURE__ */ new Set();
          for (let s3 = 0; s3 < t3.length; s3++) {
            const t4 = r3[e3[s3]];
            if (!t4.extras)
              continue;
            const a3 = t4.extras["mapbox:footprint:version"], o3 = t4.extras["mapbox:footprint:id"];
            (a3 || o3) && i3.add(s3), "1.0.0" === a3 && o3 && (n3[o3] = s3);
          }
          for (let s3 = 0; s3 < t3.length; s3++) {
            if (i3.has(s3))
              continue;
            const a3 = t3[s3], o3 = r3[e3[s3]];
            if (!o3.extras)
              continue;
            let l2 = null;
            a3.id in n3 && (l2 = Pb(t3[n3[a3.id]].meshes)), l2 || (l2 = Tb(o3)), l2 && (a3.footprint = kb(l2));
          }
          if (i3.size > 0) {
            const e4 = Array.from(i3.values()).sort((t4, e52) => t4 - e52);
            for (let r4 = e4.length - 1; r4 >= 0; r4--)
              t3.splice(e4[r4], 1);
          }
        }(o2, a2, t2.json.nodes), o2;
      }
      function Eb(t2) {
        t2.heightmap = new Float32Array(4096), t2.heightmap.fill(-1);
        const e22 = t2.vertexArray.float32, r2 = t2.aabb.min[0] - 1, n2 = t2.aabb.min[1] - 1, i2 = ux / (t2.aabb.max[0] - r2 + 2), s2 = ux / (t2.aabb.max[1] - n2 + 2);
        for (let a2 = 0; a2 < e22.length; a2 += 3) {
          const o2 = e22[a2 + 2], l2 = (e22[a2 + 0] - r2) * i2 | 0, u2 = (e22[a2 + 1] - n2) * s2 | 0;
          o2 > t2.heightmap[u2 * ux + l2] && (t2.heightmap[u2 * ux + l2] = o2);
        }
      }
      function Bb(e22, r2) {
        const n2 = {};
        n2.indexArray = new ao(), n2.indexArray.reserve(4 * e22.length), n2.vertexArray = new mo(), n2.vertexArray.reserve(10 * e22.length), n2.colorArray = new Xa(), n2.vertexArray.reserve(10 * e22.length);
        let i2 = 0;
        for (const s3 of e22) {
          const e3 = Math.min(10, Math.max(4, 1.3 * s3.height)) * r2, a3 = [-s3.normal[1], s3.normal[0], 0], o2 = Math.min(0.29, 0.1 * s3.width / s3.depth), l2 = s3.width - 2 * s3.depth * r2 * (o2 + 0.01), u2 = t.v.scaleAndAdd([], s3.pos, a3, l2 / 2), c2 = t.v.scaleAndAdd([], s3.pos, a3, -l2 / 2), h22 = [u2[0], u2[1], u2[2] + s3.height], p2 = [c2[0], c2[1], c2[2] + s3.height], f2 = t.v.scaleAndAdd([], s3.normal, a3, o2);
          t.v.scale(f2, f2, e3);
          const d2 = t.v.scaleAndAdd([], s3.normal, a3, -o2);
          t.v.scale(d2, d2, e3), t.v.add(f2, u2, f2), t.v.add(d2, c2, d2), u2[2] += 0.1, c2[2] += 0.1, n2.vertexArray.emplaceBack(f2[0], f2[1], f2[2]), n2.vertexArray.emplaceBack(d2[0], d2[1], d2[2]), n2.vertexArray.emplaceBack(u2[0], u2[1], u2[2]), n2.vertexArray.emplaceBack(c2[0], c2[1], c2[2]), n2.vertexArray.emplaceBack(h22[0], h22[1], h22[2]), n2.vertexArray.emplaceBack(p2[0], p2[1], p2[2]), n2.vertexArray.emplaceBack(u2[0], u2[1], u2[2]), n2.vertexArray.emplaceBack(c2[0], c2[1], c2[2]), n2.vertexArray.emplaceBack(f2[0], f2[1], f2[2]), n2.vertexArray.emplaceBack(d2[0], d2[1], d2[2]);
          const m2 = l2 / e3 / 2;
          n2.colorArray.emplaceBack(-m2 - o2, -1, m2, 0.8), n2.colorArray.emplaceBack(m2 + o2, -1, m2, 0.8), n2.colorArray.emplaceBack(-m2, 0, m2, 1.3), n2.colorArray.emplaceBack(m2, 0, m2, 1.3), n2.colorArray.emplaceBack(m2 + o2, -0.8, m2, 0.7), n2.colorArray.emplaceBack(m2 + o2, -0.8, m2, 0.7), n2.colorArray.emplaceBack(0, 0, m2, 1.3), n2.colorArray.emplaceBack(0, 0, m2, 1.3), n2.colorArray.emplaceBack(m2 + o2, -1.2, m2, 0.8), n2.colorArray.emplaceBack(m2 + o2, -1.2, m2, 0.8), n2.indexArray.emplaceBack(6 + i2, 4 + i2, 8 + i2), n2.indexArray.emplaceBack(7 + i2, 9 + i2, 5 + i2), n2.indexArray.emplaceBack(0 + i2, 1 + i2, 2 + i2), n2.indexArray.emplaceBack(1 + i2, 3 + i2, 2 + i2), i2 += 10;
        }
        const s2 = { defined: true, emissiveFactor: [0, 0, 0] }, a2 = {};
        return a2.baseColorFactor = Re.white, s2.pbrMetallicRoughness = a2, n2.material = s2, n2.aabb = new oh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), n2;
      }
      Ks(wb, "TriangleGridIndex");
      const Db = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Cb {
        static from(t2) {
          if (!(t2 instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [e22, r2] = new Uint8Array(t2, 0, 2);
          if (219 !== e22)
            throw new Error("Data does not appear to be in a KDBush format.");
          const n2 = r2 >> 4;
          if (1 !== n2)
            throw new Error(`Got v${n2} data when expected v1.`);
          const i2 = Db[15 & r2];
          if (!i2)
            throw new Error("Unrecognized array type.");
          const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
          return new Cb(a2, s2, i2, t2);
        }
        constructor(t2, e22 = 64, r2 = Float64Array, n2) {
          if (isNaN(t2) || t2 < 0)
            throw new Error(`Unpexpected numItems value: ${t2}.`);
          this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e22, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
          const i2 = Db.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
          if (i2 < 0)
            throw new Error(`Unexpected typed array class: ${r2}.`);
          n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e22, new Uint32Array(this.data, 4, 1)[0] = t2);
        }
        add(t2, e22) {
          const r2 = this._pos >> 1;
          return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e22, r2;
        }
        finish() {
          const t2 = this._pos >> 1;
          if (t2 !== this.numItems)
            throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
          return Rb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t2, e22, r2, n2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
          for (; o2.length; ) {
            const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h22 = o2.pop() || 0;
            if (c2 - h22 <= a2) {
              for (let a3 = h22; a3 <= c2; a3++) {
                const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                o3 >= t2 && o3 <= r2 && u3 >= e22 && u3 <= n2 && l2.push(i2[a3]);
              }
              continue;
            }
            const p2 = h22 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
            f2 >= t2 && f2 <= r2 && d2 >= e22 && d2 <= n2 && l2.push(i2[p2]), (0 === u2 ? t2 <= f2 : e22 <= d2) && (o2.push(h22), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
          }
          return l2;
        }
        within(t2, e22, r2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
          for (; a2.length; ) {
            const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h22 = a2.pop() || 0;
            if (c2 - h22 <= s2) {
              for (let r3 = h22; r3 <= c2; r3++)
                Fb(i2[2 * r3], i2[2 * r3 + 1], t2, e22) <= l2 && o2.push(n2[r3]);
              continue;
            }
            const p2 = h22 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
            Fb(f2, d2, t2, e22) <= l2 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= f2 : e22 - r2 <= d2) && (a2.push(h22), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= f2 : e22 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
          }
          return o2;
        }
      }
      function Rb(t2, e22, r2, n2, i2, s2) {
        if (i2 - n2 <= r2)
          return;
        const a2 = n2 + i2 >> 1;
        Lb(t2, e22, a2, n2, i2, s2), Rb(t2, e22, r2, n2, a2 - 1, 1 - s2), Rb(t2, e22, r2, a2 + 1, i2, 1 - s2);
      }
      function Lb(t2, e22, r2, n2, i2, s2) {
        for (; i2 > n2; ) {
          if (i2 - n2 > 600) {
            const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
            Lb(t2, e22, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
          }
          const a2 = e22[2 * r2 + s2];
          let o2 = n2, l2 = i2;
          for (Vb(t2, e22, n2, r2), e22[2 * i2 + s2] > a2 && Vb(t2, e22, n2, i2); o2 < l2; ) {
            for (Vb(t2, e22, o2, l2), o2++, l2--; e22[2 * o2 + s2] < a2; )
              o2++;
            for (; e22[2 * l2 + s2] > a2; )
              l2--;
          }
          e22[2 * n2 + s2] === a2 ? Vb(t2, e22, n2, l2) : (l2++, Vb(t2, e22, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
        }
      }
      function Vb(t2, e22, r2, n2) {
        Ob(t2, r2, n2), Ob(e22, 2 * r2, 2 * n2), Ob(e22, 2 * r2 + 1, 2 * n2 + 1);
      }
      function Ob(t2, e22, r2) {
        const n2 = t2[e22];
        t2[e22] = t2[r2], t2[r2] = n2;
      }
      function Fb(t2, e22, r2, n2) {
        const i2 = t2 - r2, s2 = e22 - n2;
        return i2 * i2 + s2 * s2;
      }
      t.$ = 45, t.A = np, t.B = function(e22) {
        const r2 = t.m.identity(new Float64Array(16));
        t.m.multiply(r2, e22.pixelMatrix, e22.globeMatrix);
        const n2 = [0, dh, 0], i2 = [0, mh, 0];
        return t.v.transformMat4(n2, n2, r2), t.v.transformMat4(i2, i2, r2), [n2[0] > 0 && n2[0] <= e22.width && n2[1] > 0 && n2[1] <= e22.height && !jh(e22, new Zh(e22.center.lat, 90)), i2[0] > 0 && i2[0] <= e22.width && i2[1] > 0 && i2[1] <= e22.height && !jh(e22, new Zh(e22.center.lat, -90))];
      }, t.C = Re, t.D = vl, t.E = Hh, t.F = ah, t.G = uh, t.H = Jh, t.I = Cg, t.J = Cr, t.K = function(e22, r2) {
        const { scale: n2 } = e22.tileTransform, i2 = n2 * Cr / (e22.tileSize * Math.pow(2, r2.zoom - e22.tileID.overscaledZ + e22.tileID.canonical.z));
        return t.h.scale(new Float32Array(4), r2.inverseAdjustmentMatrix, [i2, i2]);
      }, t.L = Zh, t.M = lp, t.N = ex, t.O = Hc, t.P = x, t.Q = Qg, t.R = th, t.S = function(e22) {
        const r2 = Qg(e22, true);
        return t.h.invert([], [r2[0], r2[1], r2[4], r2[5]]);
      }, t.T = eh, t.U = Wc, t.V = function(t2) {
        const { x: e22, y: r2 } = t2.point, { lng: n2, lat: i2 } = t2._center;
        return Vh(e22, r2, t2.worldSize, n2, i2);
      }, t.W = Am, t.X = q, t.Y = w, t.Z = lh, t._ = function(t2) {
        const e22 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
        return M[e22];
      }, t.a = Og, t.a$ = Ko, t.a0 = Wh, t.a1 = function(t2, e22) {
        return ft(B(t2, { type: "json" }), e22);
      }, t.a2 = ct, t.a3 = vt, t.a4 = Wt, t.a5 = Qp, t.a6 = ee, t.a7 = te, t.a8 = Qt, t.a9 = _g, t.aA = zp, t.aB = cp, t.aC = ch, t.aD = Xv, t.aE = Ra, t.aF = Kv, t.aG = function(t2) {
        ut++, ut > nt && (t2.getActor().send("enforceCacheSizeLimit", rt), ut = 0);
      }, t.aH = Dt, t.aI = Kt, t.aJ = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
      }, t.aK = Bv, t.aL = function(t2, e22) {
        const r2 = document.createElement("video");
        r2.muted = true, r2.onloadstart = function() {
          e22(null, r2);
        };
        for (let e3 = 0; e3 < t2.length; e3++) {
          const n2 = document.createElement("source");
          mt(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
        }
        return { cancel: () => {
        } };
      }, t.aM = ne, t.aN = wg, t.aO = function(t2) {
        return fetch(t2).then((t3) => t3.arrayBuffer()).then((e22) => _b2(e22, 0, t2));
      }, t.aP = zb, t.aQ = class {
        constructor(t2, e22, r2, n2) {
          this.id = t2, this.position = null != e22 ? new Zh(e22[0], e22[1]) : new Zh(0, 0), this.orientation = null != r2 ? r2 : [0, 0, 0], this.nodes = n2, this.uploaded = false, this.aabb = new oh([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
        }
        _applyTransformations(e22, r2) {
          if (t.m.multiply(e22.matrix, r2, e22.matrix), e22.meshes)
            for (const t2 of e22.meshes) {
              const r3 = oh.applyTransform(t2.aabb, e22.matrix);
              this.aabb.encapsulate(r3);
            }
          if (e22.children)
            for (const t2 of e22.children)
              this._applyTransformations(t2, e22.matrix);
        }
        computeBoundsAndApplyParent() {
          const e22 = t.m.identity([]);
          for (const t2 of this.nodes)
            this._applyTransformations(t2, e22);
        }
        _positionModelOnTerrain(e22, r2) {
          const n2 = e22.elevation;
          if (!n2)
            return 0;
          const i2 = oh.projectAabbCorners(this.aabb, this.matrix), s2 = Qh(1, this.position.lat) * e22.worldSize, a2 = function(e3, r3) {
            const n3 = [0, 0, 1], i3 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
            for (const s3 of i3) {
              const i4 = e3[s3.corners[0]], a3 = e3[s3.corners[1]], o3 = e3[s3.corners[2]], l3 = [a3[0] - i4[0], a3[1] - i4[1], r3 * (a3[2] - i4[2])], u3 = t.v.cross(l3, l3, [o3[0] - i4[0], o3[1] - i4[1], r3 * (o3[2] - i4[2])]);
              t.v.normalize(u3, u3), s3.dotProductWithUp = t.v.dot(u3, n3);
            }
            return i3.sort((t2, e4) => t2.dotProductWithUp - e4.dotProductWithUp), i3[0].corners;
          }(i2, s2), o2 = i2[a2[0]], l2 = i2[a2[1]], u2 = i2[a2[2]], c2 = i2[a2[3]], h22 = n2.getAtPointOrZero(new lp(o2[0] / e22.worldSize, o2[1] / e22.worldSize), 0), p2 = n2.getAtPointOrZero(new lp(l2[0] / e22.worldSize, l2[1] / e22.worldSize), 0), f2 = n2.getAtPointOrZero(new lp(u2[0] / e22.worldSize, u2[1] / e22.worldSize), 0), d2 = n2.getAtPointOrZero(new lp(c2[0] / e22.worldSize, c2[1] / e22.worldSize), 0), m2 = (h22 + d2) / 2, y2 = (p2 + f2) / 2;
          return m2 > y2 ? p2 < f2 ? ox(r2, l2, c2, o2, p2, d2, h22, s2) : ox(r2, u2, o2, c2, f2, h22, d2, s2) : h22 < d2 ? ox(r2, o2, l2, u2, h22, p2, f2, s2) : ox(r2, c2, u2, l2, d2, f2, p2, s2), Math.max(m2, y2);
        }
        computeModelMatrix(e22, r2, n2, i2, s2, a2, o2 = false) {
          const l2 = e22.transform, u2 = l2.zoom, c2 = l2.project(this.position), h22 = sp(this.position.lat, u2), p2 = 1 / h22;
          t.m.identity(this.matrix), t.m.translate(this.matrix, this.matrix, [c2.x + i2[0] * p2, c2.y + i2[1] * p2, i2[2]]);
          let f2 = 1, d2 = 1;
          const m2 = l2.worldSize;
          if (o2) {
            if ("mercator" === l2.projection.name) {
              let e3 = 0;
              l2.elevation && (e3 = l2.elevation.getAtPointOrZero(new lp(c2.x / m2, c2.y / m2), 0));
              const r3 = t.e.transformMat4([], [c2.x, c2.y, e3, 1], l2.projMatrix)[3] / l2.cameraToCenterDistance;
              f2 = r3, d2 = r3 * sp(l2.center.lat, u2);
            } else if ("globe" === l2.projection.name) {
              const e3 = lx(this.matrix, l2), r3 = t.m.multiply([], l2.projMatrix, e3), n3 = [0, 0, 0, 1];
              t.e.transformMat4(n3, n3, r3);
              const i3 = n3[3] / l2.cameraToCenterDistance, s3 = Oh(u2), a3 = l2.projection.pixelsPerMeter(this.position.lat, m2) * sp(this.position.lat, u2), o3 = l2.projection.pixelsPerMeter(l2.center.lat, m2) * sp(l2.center.lat, u2);
              f2 = i3 / Mn(a3, ip(l2.center.lat), s3), d2 = i3 * h22 / a3, f2 *= o3, d2 *= o3;
            }
          } else
            f2 = p2;
          t.m.scale(this.matrix, this.matrix, [f2, f2, d2]);
          const y2 = [...this.matrix], g2 = this.orientation, x2 = [];
          if (ax(x2, [g2[0] + r2[0], g2[1] + r2[1], g2[2] + r2[2]], n2), t.m.multiply(this.matrix, y2, x2), s2 && l2.elevation) {
            let e3 = 0;
            const r3 = [];
            if (a2 && l2.elevation) {
              e3 = this._positionModelOnTerrain(l2, r3);
              const n3 = t.m.fromQuat([], r3), i3 = t.m.multiply([], n3, x2);
              t.m.multiply(this.matrix, y2, i3);
            } else
              e3 = l2.elevation.getAtPointOrZero(new lp(c2.x / m2, c2.y / m2), 0);
            0 !== e3 && (this.matrix[14] += e3);
          }
        }
        upload(t2) {
          if (!this.uploaded) {
            for (const e22 of this.nodes)
              fx(e22, t2);
            for (const t3 of this.nodes)
              dx(t3);
            this.uploaded = true;
          }
        }
        destroy() {
          for (const t2 of this.nodes)
            mx(t2);
        }
      }, t.aR = O, t.aS = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.aT = Xm, t.aU = _p, t.aV = um, t.aW = xy, t.aX = by, t.aY = Lm, t.aZ = Cb, t.a_ = rl, t.aa = Km, t.ab = Hm, t.ac = Da, t.ad = za, t.ae = re2, t.af = class {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e22) {
          return Z(t2.expression.evaluate(e22));
        }
        interpolate(t2, e22, r2) {
          return { x: Mn(t2.x, e22.x, r2), y: Mn(t2.y, e22.y, r2), z: Mn(t2.z, e22.z, r2), azimuthal: Mn(t2.azimuthal, e22.azimuthal, r2), polar: Mn(t2.polar, e22.polar, r2) };
        }
      }, t.ag = Aa, t.ah = (t2) => Ns(Es(t2)), t.ai = $s, t.aj = Fs, t.ak = B, t.al = _a2, t.am = Wi, t.an = T, t.ao = Oh, t.ap = (t2) => Ns(Cs(t2)), t.aq = An, t.ar = Pa, t.as = class {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e22) {
          return function([t3, e3]) {
            const r2 = Z([1, t3, e3]);
            return { x: r2.x, y: r2.y, z: r2.z };
          }(t2.expression.evaluate(e22));
        }
        interpolate(t2, e22, r2) {
          return { x: Mn(t2.x, e22.x, r2), y: Mn(t2.y, e22.y, r2), z: Mn(t2.z, e22.z, r2) };
        }
      }, t.at = function(t2, e22, r2 = 0, n2 = true) {
        const i2 = new x(r2, r2), s2 = t2.sub(i2), a2 = e22.add(i2), o2 = [s2, new x(a2.x, s2.y), a2, new x(s2.x, a2.y)];
        return n2 && o2.push(s2.clone()), o2;
      }, t.au = function(t2, e22) {
        const r2 = [];
        for (let n2 = 0; n2 < t2.length; n2++) {
          const i2 = P(n2 - 1, -1, t2.length - 1), s2 = P(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h22 = l2.add(u2).unit().mult(-1 * e22 / Math.sin(c2 / 2));
          r2.push(a2.add(h22));
        }
        return r2;
      }, t.av = Ey, t.aw = Ep, t.ax = function(e22, r2, n2 = 0) {
        return t.v.fromValues(((r2.x - n2) * e22.scale - e22.x) * Cr, (r2.y * e22.scale - e22.y) * Cr, rp(r2.z, r2.y));
      }, t.ay = sx, t.az = function(t2) {
        let e22 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e22 = Math.min(e22, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return { min: new x(e22, r2), max: new x(n2, i2) };
      }, t.b = Qh, t.b$ = 0, t.b0 = Ho, t.b1 = tl, t.b2 = Wo, t.b3 = function(t2, e22, r2) {
        const n2 = Math.sqrt(t2 * t2 + e22 * e22 + r2 * r2), i2 = n2 > 0 ? Math.acos(r2 / n2) * b : 0;
        let s2 = 0 !== t2 || 0 !== e22 ? Math.atan2(-e22, -t2) * b + 90 : 0;
        return s2 < 0 && (s2 += 360), [n2, s2, i2];
      }, t.b4 = Rg, t.b5 = Ug, t.b6 = Vg, t.b7 = Jo, t.b8 = class extends Xo {
        constructor(t2) {
          super(t2), this.current = nl;
        }
        set(t2, e22, r2) {
          if (this.fetchUniformLocation(t2, e22)) {
            for (let t3 = 0; t3 < 9; t3++)
              if (r2[t3] !== this.current[t3]) {
                this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                break;
              }
          }
        }
      }, t.b9 = Qo, t.bA = function(e22, r2) {
        const n2 = [0, 0, 0], i2 = Dh(_h(r2.canonical));
        return t.v.transformMat4(n2, n2, i2), t.v.transformMat4(n2, n2, e22), n2;
      }, t.bB = (t2) => ({ u_camera_to_center_distance: new Wo(t2), u_extrude_scale: new sl(t2), u_device_pixel_ratio: new Wo(t2), u_matrix: new rl(t2), u_inv_rot_matrix: new rl(t2), u_merc_center: new Ho(t2), u_tile_id: new Jo(t2), u_zoom_transition: new Wo(t2), u_up_dir: new Jo(t2), u_emissive_strength: new Wo(t2) }), t.bC = (t2) => ({ u_matrix: new rl(t2), u_pixels_to_tile_units: new sl(t2), u_device_pixel_ratio: new Wo(t2), u_units_to_pixels: new Ho(t2), u_dash_image: new Ko(t2), u_gradient_image: new Ko(t2), u_image_height: new Wo(t2), u_texsize: new Ho(t2), u_tile_units_to_pixels: new Wo(t2), u_alpha_discard_threshold: new Wo(t2), u_trim_offset: new Ho(t2), u_emissive_strength: new Wo(t2) }), t.bD = (t2) => ({ u_matrix: new rl(t2), u_texsize: new Ho(t2), u_pixels_to_tile_units: new sl(t2), u_device_pixel_ratio: new Wo(t2), u_image: new Ko(t2), u_units_to_pixels: new Ho(t2), u_tile_units_to_pixels: new Wo(t2), u_alpha_discard_threshold: new Wo(t2) }), t.bE = io, t.bF = lm, t.bG = dm, t.bH = Np, t.bI = (t2, e22, r2, n2, i2, s2) => {
        const a2 = t2.transform, o2 = "globe" === a2.projection.name;
        let l2;
        if ("map" === s2.paint.get("circle-pitch-alignment"))
          if (o2) {
            const t3 = Lh(a2.zoom, e22.canonical) * a2._pixelsPerMercatorPixel;
            l2 = Float32Array.from([t3, 0, 0, t3]);
          } else
            l2 = a2.calculatePixelsToTileUnitsMatrix(r2);
        else
          l2 = new Float32Array([a2.pixelsToGLUnits[0], 0, 0, a2.pixelsToGLUnits[1]]);
        const u2 = { u_camera_to_center_distance: t2.transform.getCameraToCenterDistance(a2.projection), u_matrix: t2.translatePosMatrix(e22.projMatrix, r2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Wt.devicePixelRatio, u_extrude_scale: l2, u_inv_rot_matrix: Up, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s2.paint.get("circle-emissive-strength") };
        if (o2) {
          u2.u_inv_rot_matrix = n2, u2.u_merc_center = i2, u2.u_tile_id = [e22.canonical.x, e22.canonical.y, 1 << e22.canonical.z], u2.u_zoom_transition = Oh(a2.zoom);
          const t3 = i2[0] * Cr, r3 = i2[1] * Cr;
          u2.u_up_dir = a2.projection.upVector(new Kc(0, 0, 0), t3, r3);
        }
        return u2;
      }, t.bJ = _v, t.bK = (t2, e22, r2, n2, i2) => {
        const s2 = t2.transform;
        return { u_matrix: bv(t2, e22, r2, n2), u_texsize: e22.imageAtlasTexture ? e22.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: s2.calculatePixelsToTileUnitsMatrix(e22), u_device_pixel_ratio: i2, u_image: 0, u_tile_units_to_pixels: vv(e22, s2), u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
      }, t.bL = (t2, e22, r2, n2, i2, s2, a2) => {
        const o2 = t2.transform, l2 = o2.calculatePixelsToTileUnitsMatrix(e22);
        return { u_matrix: bv(t2, e22, r2, n2), u_pixels_to_tile_units: l2, u_device_pixel_ratio: s2, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i2, u_texsize: wv(r2) && e22.lineAtlasTexture ? e22.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: vv(e22, t2.transform), u_alpha_discard_threshold: 0, u_trim_offset: a2, u_emissive_strength: r2.paint.get("line-emissive-strength") };
      }, t.bM = L, t.bN = nf, t.bO = lv, t.bP = Qc, t.bQ = tv, t.bR = $x, t.bS = 450, t.bT = 7, t.bU = Mh, t.bV = Ch, t.bW = Ua, t.bX = mo, t.bY = co, t.bZ = 1, t.b_ = 771, t.ba = A, t.bb = function(t2, e22, r2) {
        const n2 = Oh(r2.zoom), i2 = t2.style.map._antialias, s2 = e22.options.extStandardDerivativesForceOff || t2.terrain && t2.terrain.exaggeration() > 0;
        return 0 === n2 && !i2 && !s2;
      }, t.bc = function(e22) {
        const r2 = e22.pixelsPerMeter, n2 = r2 / Qh(1, e22.center.lat), i2 = t.m.identity(new Float64Array(16));
        return t.m.translate(i2, i2, [e22.point.x, e22.point.y, 0]), t.m.scale(i2, i2, [n2, n2, r2]), Float32Array.from(i2);
      }, t.bd = se, t.be = Ih, t.bf = function(t2) {
        const e22 = np - 5;
        t2 = k(t2, -e22, e22) / e22 * 90;
        const r2 = Math.pow(Math.abs(Math.sin(_(t2))), 3);
        return Math.round(r2 * (fh.length - 1));
      }, t.bg = function(e22, r2, n2, i2) {
        const s2 = r2.getNorth(), a2 = r2.getSouth(), o2 = r2.getWest(), l2 = r2.getEast(), u2 = 1 << e22.z, c2 = l2 - o2, h22 = s2 - a2, p2 = c2 / ph, f2 = -h22 / fh[n2], d2 = [0, p2, 0, f2, 0, 0, s2, o2, 0];
        if (e22.z > 0) {
          const e3 = 180 / i2;
          t.bx.multiply(d2, d2, [e3 / c2 + 1, 0, 0, 0, e3 / h22 + 1, 0, -0.5 * e3 / p2, 0.5 * e3 / f2, 1]);
        }
        return d2[2] = u2, d2[5] = e22.x, d2[8] = e22.y, d2;
      }, t.bh = Dh, t.bi = _h, t.bj = function(e22, r2, n2) {
        const i2 = t.m.identity(new Float64Array(16)), s2 = (r2 / (1 << e22) - 0.5) * Math.PI * 2;
        return t.m.rotateY(i2, n2.globeMatrix, s2), Float32Array.from(i2);
      }, t.bk = class {
        isDataAvailableAtPoint(t2) {
          const e22 = this._source();
          if (this.isUsingMockSource() || !e22 || t2.y < 0 || t2.y > 1)
            return false;
          const r2 = e22.getSource().maxzoom, n2 = 1 << r2, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), a2 = Math.floor(t2.y * n2), o2 = this.findDEMTileFor(new Hc(r2, i2, r2, s2, a2));
          return !(!o2 || !o2.dem);
        }
        getAtPointOrZero(t2, e22 = 0) {
          return this.getAtPoint(t2, e22) || 0;
        }
        getAtPoint(t2, e22, r2 = true) {
          if (this.isUsingMockSource())
            return null;
          null == e22 && (e22 = null);
          const n2 = this._source();
          if (!n2)
            return e22;
          if (t2.y < 0 || t2.y > 1)
            return e22;
          const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Hc(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
          if (!u2 || !u2.dem)
            return e22;
          const c2 = u2.dem, h22 = 1 << u2.tileID.canonical.z, p2 = (o2 * h22 - u2.tileID.canonical.x) * c2.dim, f2 = (t2.y * h22 - u2.tileID.canonical.y) * c2.dim, d2 = Math.floor(p2), m2 = Math.floor(f2);
          return (r2 ? this.exaggeration() : 1) * Mn(Mn(c2.get(d2, m2), c2.get(d2, m2 + 1), f2 - m2), Mn(c2.get(d2 + 1, m2), c2.get(d2 + 1, m2 + 1), f2 - m2), p2 - d2);
        }
        getAtTileOffset(t2, e22, r2) {
          const n2 = 1 << t2.canonical.z;
          return this.getAtPointOrZero(new lp(t2.wrap + (t2.canonical.x + e22 / Cr) / n2, (t2.canonical.y + r2 / Cr) / n2));
        }
        getAtTileOffsetFunc(e22, r2, n2, i2) {
          return (s2) => {
            const a2 = this.getAtTileOffset(e22, s2.x, s2.y), o2 = i2.upVector(e22.canonical, s2.x, s2.y), l2 = i2.upVectorScale(e22.canonical, r2, n2).metersToTile;
            return t.v.scale(o2, o2, a2 * l2), o2;
          };
        }
        getForTilePoints(t2, e22, r2, n2) {
          if (this.isUsingMockSource())
            return false;
          const i2 = Wd.create(this, t2, n2);
          return !!i2 && (e22.forEach((t3) => {
            t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
          }), true);
        }
        getMinMaxForTile(t2) {
          if (this.isUsingMockSource())
            return null;
          const e22 = this.findDEMTileFor(t2);
          if (!e22 || !e22.dem)
            return null;
          const r2 = e22.dem.tree, n2 = e22.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
          let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
          for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[o2]; e3++) {
            s2 *= 2, a2 *= 2;
            const t3 = 2 * Math.floor(a2) + Math.floor(s2);
            o2 = r2.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
          }
          return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t2, e22, r2) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t2) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t2) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
        getMinMaxForVisibleTiles() {
          const t2 = this.visibleDemTiles;
          if (0 === t2.length)
            return null;
          let e22 = false, r2 = Number.MAX_VALUE, n2 = Number.MIN_VALUE;
          for (const i2 of t2) {
            const t3 = this.getMinMaxForTile(i2.tileID);
            t3 && (r2 = Math.min(r2, t3.min), n2 = Math.max(n2, t3.max), e22 = true);
          }
          return e22 ? { min: r2, max: n2 } : null;
        }
      }, t.bl = Yc, t.bm = Do, t.bn = gh, t.bo = $a, t.bp = ao, t.bq = Ng, t.br = Nv, t.bs = eb, t.bt = Bg, t.bu = tf, t.bv = function(t2, e22) {
        return [Math.pow(t2[0], 2.2) * e22, Math.pow(t2[1], 2.2) * e22, Math.pow(t2[2], 2.2) * e22];
      }, t.bw = function(t2) {
        return [Math.pow(t2[0], 1 / 2.2), Math.pow(t2[1], 1 / 2.2), Math.pow(t2[2], 1 / 2.2)];
      }, t.by = Lh, t.bz = 256, t.c = k, t.c$ = e, t.c0 = ho, t.c1 = function(t2, e22, r2, n2, i2) {
        return k((t2 - e22) / (r2 - e22) * (i2 - n2) + n2, n2, i2);
      }, t.c2 = bi, t.c3 = oh, t.c4 = sp, t.c5 = lx, t.c6 = [1, 1, 1], t.c7 = Wd, t.c8 = cx, t.c9 = eo, t.cA = U, t.cB = (t2) => Ns(Ds(t2)), t.cC = ga, t.cD = ft, t.cE = S, t.cF = function() {
        return !!document.fullscreenElement || !!document.webkitFullscreenElement;
      }, t.cG = I, t.cH = ap, t.cI = Ph, t.cJ = function([t2, e22, r2]) {
        const n2 = Math.hypot(t2, e22, r2), i2 = Math.atan2(t2, r2), s2 = 0.5 * Math.PI - Math.acos(-e22 / n2);
        return new Zh(w(i2), w(s2));
      }, t.cK = tp, t.cL = qh, t.cM = n, t.cN = jh, t.cO = Fh, t.cP = function(e22) {
        const r2 = [0, 0, 0], n2 = t.m.identity(new Float64Array(16));
        return t.m.multiply(n2, e22.pixelMatrix, e22.globeMatrix), t.v.transformMat4(r2, r2, n2), new x(r2[0], r2[1]);
      }, t.cQ = function(t2) {
        const e22 = t2.navigator ? t2.navigator.userAgent : null;
        return !!function(t3) {
          if (null == W) {
            const e3 = t3.navigator ? t3.navigator.userAgent : null;
            W = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
          }
          return W;
        }(t2) && e22 && (e22.match("Version/15.4") || e22.match("Version/15.5") || e22.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, t.cR = C, t.cS = class {
        constructor(t2, e22, r2) {
          this._transformRequestFn = t2, this._customAccessToken = e22, this._silenceAuthErrors = !!r2, this._createSkuToken();
        }
        _createSkuToken() {
          const t2 = function() {
            let t3 = "";
            for (let e22 = 0; e22 < 10; e22++)
              t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", h, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t2, e22) {
          return this._transformRequestFn && this._transformRequestFn(t2, e22) || { url: t2 };
        }
        normalizeStyleURL(t2, r2) {
          if (!_t(t2))
            return t2;
          const n2 = kt(t2);
          return n2.params.push(`sdk=js-${e}`), n2.path = `/styles/v1${n2.path}`, this._makeAPIURL(n2, this._customAccessToken || r2);
        }
        normalizeGlyphsURL(t2, e22) {
          if (!_t(t2))
            return t2;
          const r2 = kt(t2);
          return r2.path = `/fonts/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e22);
        }
        normalizeModelURL(t2, e22) {
          if (!_t(t2))
            return t2;
          const r2 = kt(t2);
          return r2.path = `/models/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e22);
        }
        normalizeSourceURL(t2, e22, r2, n2) {
          if (!_t(t2))
            return t2;
          const i2 = kt(t2);
          return i2.path = `/v4/${i2.authority}.json`, i2.params.push("secure"), r2 && i2.params.push(`language=${r2}`), n2 && i2.params.push(`worldview=${n2}`), this._makeAPIURL(i2, this._customAccessToken || e22);
        }
        normalizeSpriteURL(t2, e22, r2, n2) {
          const i2 = kt(t2);
          return _t(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e22}${r2}`, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += `${e22}${r2}`, Tt(i2));
        }
        normalizeTileURL(t2, e22, r2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !_t(t2))
            return t2;
          const s2 = kt(t2);
          s2.path = s2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e22 || r2 && "raster" !== s2.authority && 512 === r2 ? "@2x" : ""}${i.supported ? ".webp" : "$1"}`), "raster" === s2.authority ? s2.path = `/${n.RASTER_URL_PREFIX}${s2.path}` : (s2.path = s2.path.replace(/^.+\/v4\//, "/"), s2.path = `/${n.TILE_URL_VERSION}${s2.path}`);
          const a2 = this._customAccessToken || function(t3) {
            for (const e3 of t3) {
              const t4 = e3.match(/^access_token=(.*)$/);
              if (t4)
                return t4[1];
            }
            return null;
          }(s2.params) || n.ACCESS_TOKEN;
          return n.REQUIRE_ACCESS_TOKEN && a2 && this._skuToken && s2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s2, a2);
        }
        canonicalizeTileURL(t2, e22) {
          const r2 = kt(t2);
          if (!r2.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r2.path.match(/\.[\w]+$/))
            return t2;
          let i2 = "mapbox://";
          r2.path.match(/^\/raster\/v1\//) ? i2 += `raster/${r2.path.replace(`/${n.RASTER_URL_PREFIX}/`, "")}` : i2 += `tiles/${r2.path.replace(`/${n.TILE_URL_VERSION}/`, "")}`;
          let s2 = r2.params;
          return e22 && (s2 = s2.filter((t3) => !t3.match(/^access_token=/))), s2.length && (i2 += `?${s2.join("&")}`), i2;
        }
        canonicalizeTileset(t2, e22) {
          const r2 = !!e22 && _t(e22), n2 = [];
          for (const e3 of t2.tiles || [])
            wt(e3) ? n2.push(this.canonicalizeTileURL(e3, r2)) : n2.push(e3);
          return n2;
        }
        _makeAPIURL(t2, e22) {
          const r2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", i2 = kt(n.API_URL);
          if (t2.protocol = i2.protocol, t2.authority = i2.authority, "http" === t2.protocol) {
            const e3 = t2.params.indexOf("secure");
            e3 >= 0 && t2.params.splice(e3, 1);
          }
          if ("/" !== i2.path && (t2.path = `${i2.path}${t2.path}`), !n.REQUIRE_ACCESS_TOKEN)
            return Tt(t2);
          if (e22 = e22 || n.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!e22)
              throw new Error(`An API access token is required to use Mapbox GL. ${r2}`);
            if ("s" === e22[0])
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r2}`);
          }
          return t2.params = t2.params.filter((t3) => -1 === t3.indexOf("access_token")), t2.params.push(`access_token=${e22 || ""}`), Tt(t2);
        }
      }, t.cT = function(t2, e22) {
        e22 ? jt.add(t2) : jt.delete(t2);
      }, t.cU = i, t.cV = Vt, t.cW = Ft, t.cX = bt, t.cY = Rt, t.cZ = function(t2) {
        jt.delete(t2);
      }, t.c_ = z, t.ca = class {
        constructor() {
          this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [];
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(t2) {
          const e22 = Dx(new x(0, 0), new x(Cr, Cr), t2), r2 = [];
          for (const n2 of this._activeRegions) {
            if (n2.hiddenByOverlap)
              continue;
            if (!Bx(e22, n2))
              continue;
            const i2 = Cx(n2.min, n2.max, t2);
            r2.push({ min: i2.min, max: i2.max, sourceId: this._sourceIds[n2.priority], footprint: n2.footprint, footprintTileId: n2.tileId });
          }
          return r2;
        }
        setSources(t2) {
          this._setSources(t2.map((t3) => ({ getSourceId: () => t3.cache.id, getFootprints: () => {
            const e22 = [];
            for (const r2 of t3.cache.getVisibleCoordinates()) {
              const n2 = t3.cache.getTile(r2).buckets[t3.layer];
              if (n2)
                for (const t4 of n2.getNodesInfo()) {
                  const n3 = t4.node;
                  n3.footprint && e22.push({ footprint: n3.footprint, id: r2.toUnwrapped() });
                }
            }
            return e22;
          } })));
        }
        _addSource(t2) {
          const e22 = t2.getFootprints();
          if (0 !== e22.length) {
            for (const t3 of e22) {
              if (!t3.footprint)
                continue;
              const e3 = Dx(t3.footprint.min, t3.footprint.max, t3.id);
              this._activeRegions.push({ min: e3.min, max: e3.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t3.id, footprint: t3.footprint });
            }
            this._sourceIds.push(t2.getSourceId());
          }
        }
        _computeReplacement() {
          this._activeRegions.sort((t3, e22) => t3.priority - e22.priority || zx(t3.min, e22.min) || zx(t3.max, e22.max));
          let t2 = this._activeRegions.length !== this._prevRegions.length;
          if (!t2) {
            let e22 = 0, r2 = 0;
            for (; !t2 && e22 !== this._activeRegions.length; ) {
              const n2 = this._activeRegions[e22], i2 = this._prevRegions[r2];
              t2 = n2.priority !== i2.priority || !Ex(n2, i2), ++e22, ++r2;
            }
          }
          if (t2) {
            ++this._updateTime;
            const t3 = (t4) => {
              const e22 = this._activeRegions;
              if (t4 >= e22.length)
                return t4;
              const r2 = e22[t4].priority;
              for (; t4 < e22.length && e22[t4].priority === r2; )
                ++t4;
              return t4;
            };
            if (this._sourceIds.length > 1) {
              let e22 = 0, r2 = t3(e22);
              for (; e22 !== r2; ) {
                let n2 = e22;
                const i2 = e22;
                for (; n2 !== r2; ) {
                  const t4 = this._activeRegions[n2];
                  t4.hiddenByOverlap = false;
                  for (let e3 = 0; e3 < i2; e3++) {
                    const r3 = this._activeRegions[e3];
                    if (!r3.hiddenByOverlap && Bx(t4, r3) && (t4.hiddenByOverlap = Lx(t4.footprint, t4.tileId, r3.footprint, r3.tileId), t4.hiddenByOverlap))
                      break;
                  }
                  ++n2;
                }
                e22 = r2, r2 = t3(e22);
              }
            }
          }
        }
        _setSources(t2) {
          [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
          for (let e22 = t2.length - 1; e22 >= 0; e22--)
            this._addSource(t2[e22]);
          this._computeReplacement();
        }
      }, t.cb = Ga, t.cc = zg, t.cd = fo, t.ce = class {
        constructor(t2) {
          this._createGrid(t2), this._createPoles(t2);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t2 of this._poleSegments)
            t2.destroy();
          for (const t2 of this._gridSegments)
            t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(t2, e22) {
          const r2 = new $a(), n2 = new ao(), i2 = [], s2 = t2 + 1 + 2, a2 = e22[0] + 1, o2 = e22[0] + 1 + (1 + e22.length), l2 = (t3, e3, r3) => {
            let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
            return n3 += r3 ? 24575 : 0, [n3, e3];
          };
          for (let t3 = 0; t3 < s2; ++t3)
            r2.emplaceBack(...l2(t3, 0, true));
          for (let t3 = 0; t3 < a2; ++t3)
            for (let e3 = 0; e3 < s2; ++e3)
              r2.emplaceBack(...l2(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
          for (let t3 = 0; t3 < e22.length; ++t3) {
            const n3 = e22[t3];
            for (let t4 = 0; t4 < s2; ++t4)
              r2.emplaceBack(...l2(t4, n3, true));
          }
          for (let t3 = 0; t3 < e22.length; ++t3) {
            const a3 = n2.length, l3 = e22[t3] + 1 + 2, u2 = new ao();
            for (let r3 = 0; r3 < l3 - 1; r3++) {
              const i3 = r3 === l3 - 2, a4 = i3 ? s2 * (o2 - e22.length + t3 - r3) : s2;
              for (let t4 = 0; t4 < s2 - 1; t4++) {
                const e3 = r3 * s2 + t4;
                0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u2.emplaceBack(e3 + 1, e3, e3 + a4), u2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + a4), n2.emplaceBack(e3 + a4, e3 + a4 + 1, e3 + 1));
              }
            }
            const c2 = Do.simpleSegment(0, a3, r2.length, n2.length - a3);
            for (let t4 = 0; t4 < u2.uint16.length; t4 += 3)
              n2.emplaceBack(u2.uint16[t4], u2.uint16[t4 + 1], u2.uint16[t4 + 2]);
            const h22 = Do.simpleSegment(0, a3, r2.length, n2.length - a3);
            i2.push({ withoutSkirts: c2, withSkirts: h22 });
          }
          return { vertices: r2, indices: n2, segments: i2 };
        }
        _createGrid(t2) {
          const e22 = this._fillGridMeshWithLods(ph, fh);
          this._gridSegments = e22.segments, this._gridBuffer = t2.createVertexBuffer(e22.vertices, Yc.members), this._gridIndexBuffer = t2.createIndexBuffer(e22.indices, true);
        }
        _createPoles(t2) {
          const e22 = new ao();
          for (let t3 = 0; t3 <= ph; t3++)
            e22.emplaceBack(0, t3 + 1, t3 + 2);
          this._poleIndexBuffer = t2.createIndexBuffer(e22, true);
          const r2 = new co(), n2 = new co(), i2 = new co(), s2 = new co();
          this._poleSegments = [];
          for (let t3 = 0, e3 = 0; t3 < lh; t3++) {
            const a2 = 360 / (1 << t3);
            r2.emplaceBack(0, -ch, 0, 0.5, 0), n2.emplaceBack(0, -ch, 0, 0.5, 1), i2.emplaceBack(0, -ch, 0, 0.5, 0.5), s2.emplaceBack(0, -ch, 0, 0.5, 0.5);
            for (let t4 = 0; t4 <= ph; t4++) {
              let e4 = t4 / ph, o2 = 0;
              const l2 = Mn(0, a2, e4), [u2, c2, h22] = Th(Nh, $h, l2, ch);
              r2.emplaceBack(u2, c2, h22, e4, o2), n2.emplaceBack(u2, c2, h22, e4, 1 - o2);
              const p2 = _(l2);
              e4 = 0.5 + 0.5 * Math.sin(p2), o2 = 0.5 + 0.5 * Math.cos(p2), i2.emplaceBack(u2, c2, h22, e4, o2), s2.emplaceBack(u2, c2, h22, e4, 1 - o2);
            }
            this._poleSegments.push(Do.simpleSegment(e3, 0, 66, 64)), e3 += 66;
          }
          this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, qc, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, qc, false), this._texturedPoleNorthVertexBuffer = t2.createVertexBuffer(i2, qc, false), this._texturedPoleSouthVertexBuffer = t2.createVertexBuffer(s2, qc, false);
        }
        getGridBuffers(t2, e22) {
          return [this._gridBuffer, this._gridIndexBuffer, e22 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
        }
        getPoleBuffers(t2, e22) {
          return [e22 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e22 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
        }
      }, t.cf = function(t2) {
        return jt.has(t2);
      }, t.cg = op, t.ch = Z, t.ci = function(t2) {
        return t2({ pluginStatus: fa, pluginURL: da }), ga.on("pluginStateChange", t2), t2;
      }, t.cj = iy, t.ck = ny, t.cl = pt, t.cm = ma, t.cn = _t, t.co = N, t.cp = function(t2, e22, r2) {
        return "custom" === t2.type ? new Dv(t2, e22) : new Ov[t2.type](t2, e22, r2);
      }, t.cq = function(t2) {
        const e22 = t2.indexOf(Ca);
        return e22 >= 0 ? t2.slice(0, e22) : t2;
      }, t.cr = (t2) => Ns(zs(t2)), t.cs = (t2) => Ns(Ts(t2)), t.ct = (t2) => Ns(Bs(t2)), t.cu = function(t2) {
        return t2.indexOf(Ca) >= 0;
      }, t.cv = function(t2) {
        const e22 = t2.indexOf(Ca);
        return e22 >= 0 ? t2.slice(e22 + 1) : "";
      }, t.cw = Xi, t.cx = function(t2) {
        const e22 = [], r2 = t2.id;
        return void 0 === r2 && e22.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e22.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e22.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e22;
      }, t.cy = (t2) => Ns(Ss(t2)), t.cz = (t2) => Ns(bs(t2)), t.d = _, t.d0 = function(t2, e22) {
        rt = t2, nt = e22;
      }, t.d1 = function(t2, e22, r2 = false) {
        if (fa === ua || fa === ca || fa === ha)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        da = Wt.resolveURL(t2), fa = ua, pa = e22, ya(), r2 || va();
      }, t.d2 = xa, t.d3 = function() {
        eb().acquire(Jv);
      }, t.d4 = function() {
        const t2 = tb;
        t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(Jv), tb = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, t.d5 = Qv, t.d6 = function(t2) {
        const e22 = at();
        if (!e22)
          return;
        const r2 = e22.delete(et);
        t2 && r2.catch(t2).then(() => t2());
      }, t.d7 = Wv, t.d8 = ab, t.d9 = function(t2) {
        nb = Wt.resolveURL(t2), sb || (sb = new Nv(eb(), new ee())), sb.broadcast("setDracoUrl", nb);
      }, t.da = E, t.db = Kd, t.dc = p, t.dd = ud, t.de = Wf, t.df = y, t.dg = fd, t.dh = class extends ee {
        constructor(t2, e22, r2, n2, i2, s2) {
          super(), this.actor = t2, this.layerIndex = e22, this.availableImages = r2, this.loadVectorData = i2 || Kv, this.loading = {}, this.loaded = {}, this.deduped = new Xv(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler, this.brightness = s2;
        }
        loadTile(t2, e22) {
          const r2 = t2.uid, n2 = t2 && t2.request, i2 = n2 && n2.collectResourceTiming, s2 = this.loading[r2] = new Yv(t2);
          s2.abort = this.loadVectorData(t2, (a2, o2) => {
            const l2 = !this.loading[r2];
            if (delete this.loading[r2], l2 || a2 || !o2)
              return s2.status = "done", l2 || (this.loaded[r2] = s2), e22(a2);
            const u2 = o2.rawData, c2 = {};
            o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new ld(new Cd(u2));
            const h22 = () => {
              s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r3) => {
                if (t3 || !r3)
                  return e22(t3);
                const s3 = {};
                if (i2) {
                  const t4 = $t(n2);
                  t4.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t4)));
                }
                e22(null, B({ rawTileData: u2.slice(0) }, r3, c2, s3));
              });
            };
            this.isSpriteLoaded ? h22() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(h22, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h22();
            }), this.loaded = this.loaded || {}, this.loaded[r2] = s2;
          });
        }
        reloadTile(t2, e22) {
          const r2 = this.loaded, n2 = t2.uid, i2 = this;
          if (r2 && r2[n2]) {
            const s2 = r2[n2];
            s2.showCollisionBoxes = t2.showCollisionBoxes, s2.projection = t2.projection, s2.brightness = t2.brightness, s2.tileTransform = zy(t2.tileID.canonical, t2.projection), s2.extraShadowCaster = t2.extraShadowCaster;
            const a2 = (t3, r3) => {
              const n3 = s2.reloadCallback;
              n3 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n3)), e22(t3, r3);
            };
            "parsing" === s2.status ? s2.reloadCallback = a2 : "done" === s2.status && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
          } else
            e22(null, void 0);
        }
        abortTile(t2, e22) {
          const r2 = t2.uid, n2 = this.loading[r2];
          n2 && (n2.abort && n2.abort(), delete this.loading[r2]), e22();
        }
        removeTile(t2, e22) {
          const r2 = this.loaded, n2 = t2.uid;
          r2 && r2[n2] && delete r2[n2], e22();
        }
      }, t.di = $t, t.dj = dt, t.dk = Hd, t.dl = function(t2) {
        let e22 = 0;
        if (new Uint32Array(t2, 0, 1)[0] !== mb) {
          const r2 = new Uint32Array(t2, 0, 7), [, , n2, i2, s2, a2] = r2;
          e22 = r2.byteLength + i2 + s2 + a2 + s2, (n2 !== t2.byteLength || e22 >= t2.byteLength) && q("Invalid b3dm header information.");
        }
        return _b2(t2, e22);
      }, t.dm = function(t2, e22) {
        const r2 = zb(t2);
        for (const t3 of r2) {
          for (const e3 of t3.meshes)
            Eb(e3);
          t3.lights && (t3.lightMeshIndex = t3.meshes.length, t3.meshes.push(Bb(t3.lights, e22)));
        }
        return r2;
      }, t.dn = Ix, t.dp = Uv, t.dq = ba, t.dr = function(t2) {
        ot(), it && it.then((e22) => {
          e22.keys().then((r2) => {
            for (let n2 = 0; n2 < r2.length - t2; n2++)
              e22.delete(r2[n2]);
          });
        });
      }, t.f = function(e22, r2) {
        const { x: n2, y: i2 } = e22.point, s2 = Vh(n2, i2, e22.worldSize / e22._pixelsPerMercatorPixel, 0, 0);
        return t.m.multiply(s2, s2, Ch(_h(r2)));
      }, t.g = J, t.i = fm, t.j = pm, t.k = lg, t.l = ep, t.n = Mn, t.o = Jy, t.p = function(t2, e22) {
        const r2 = {};
        for (let n2 = 0; n2 < e22.length; n2++) {
          const i2 = e22[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.r = tx, t.s = function(t2, e22, r2) {
        t2[4 * e22 + 0] = r2[0], t2[4 * e22 + 1] = r2[1], t2[4 * e22 + 2] = r2[2], t2[4 * e22 + 3] = r2[3];
      }, t.t = Kc, t.u = function(t2, e22, r2, n2, i2) {
        const s2 = 5 * e22 + 2;
        t2.float32[s2 + 0] = r2, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
      }, t.w = P, t.x = Sh, t.y = function(t2, e22, r2, n2, i2, s2, a2, o2, l2) {
        if ("globe" === l2.name)
          return Sh(t2, e22, new Kc(r2, n2, i2), false);
        const u2 = zy({ z: r2, x: n2, y: i2 }, l2);
        return new oh([(s2 + u2.x / u2.scale) * e22, e22 * (u2.y / u2.scale), a2], [(s2 + u2.x2 / u2.scale) * e22, e22 * (u2.y2 / u2.scale), o2]);
      }, t.z = function(t2, e22, r2) {
        let n2 = 0;
        for (let i2 = 0; i2 < 2; ++i2) {
          const s2 = r2 ? r2[i2] : 0;
          t2[i2] > s2 && (n2 += (t2[i2] - s2) * (t2[i2] - s2)), e22[i2] < s2 && (n2 += (s2 - e22[i2]) * (s2 - e22[i2]));
        }
        return n2;
      };
    });
    define2(["./shared"], function(e) {
      function t(e22) {
        if ("number" == typeof e22 || "boolean" == typeof e22 || "string" == typeof e22 || null == e22)
          return JSON.stringify(e22);
        if (Array.isArray(e22)) {
          let r3 = "[";
          for (const o2 of e22)
            r3 += `${t(o2)},`;
          return `${r3}]`;
        }
        let r2 = "{";
        for (const o2 of Object.keys(e22).sort())
          r2 += `${o2}:${t(e22[o2])},`;
        return `${r2}}`;
      }
      function r(r2) {
        let o2 = "";
        for (const i2 of e.aS)
          o2 += `/${t(r2[i2])}`;
        return o2;
      }
      class o {
        constructor(e22) {
          this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e22 && this.replace(e22);
        }
        replace(e22, t2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e22, [], t2);
        }
        update(t2, o2, i2) {
          this._options = i2;
          for (const r2 of t2)
            this._layerConfigs[r2.id] = r2, (this._layers[r2.id] = e.cp(r2, this.scope, this._options)).compileFilter(), this.keyCache[r2.id] && delete this.keyCache[r2.id];
          for (const e22 of o2)
            delete this.keyCache[e22], delete this._layerConfigs[e22], delete this._layers[e22];
          this.familiesBySource = {};
          const s2 = function(e22, t3) {
            const o3 = {};
            for (let i4 = 0; i4 < e22.length; i4++) {
              const s3 = t3 && t3[e22[i4].id] || r(e22[i4]);
              t3 && (t3[e22[i4].id] = s3);
              let n2 = o3[s3];
              n2 || (n2 = o3[s3] = []), n2.push(e22[i4]);
            }
            const i3 = [];
            for (const e3 in o3)
              i3.push(o3[e3]);
            return i3;
          }(e.da(this._layerConfigs), this.keyCache);
          for (const e22 of s2) {
            const t3 = e22.map((e3) => this._layers[e3.id]), r2 = t3[0];
            if ("none" === r2.visibility)
              continue;
            const o3 = r2.source || "";
            let i3 = this.familiesBySource[o3];
            i3 || (i3 = this.familiesBySource[o3] = {});
            const s3 = r2.sourceLayer || "_geojsonTileLayer";
            let n2 = i3[s3];
            n2 || (n2 = i3[s3] = []), n2.push(t3);
          }
        }
      }
      class i {
        loadTile(t2, r2) {
          const { uid: o2, encoding: i2, rawImageData: s2, padding: n2 } = t2, a2 = ImageBitmap && s2 instanceof ImageBitmap ? this.getImageData(s2, n2) : s2;
          r2(null, new e.db(o2, a2, i2, n2 < 1));
        }
        getImageData(e22, t2) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e22.width, e22.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e22.width, this.offscreenCanvas.height = e22.height, this.offscreenCanvasContext.drawImage(e22, 0, 0, e22.width, e22.height);
          const r2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e22.width + 2 * t2, e22.height + 2 * t2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r2;
        }
      }
      function s(e22, t2) {
        if (0 !== e22.length) {
          n(e22[0], t2);
          for (var r2 = 1; r2 < e22.length; r2++)
            n(e22[r2], !t2);
        }
      }
      function n(e22, t2) {
        for (var r2 = 0, o2 = 0, i2 = 0, s2 = e22.length, n2 = s2 - 1; i2 < s2; n2 = i2++) {
          var a2 = (e22[i2][0] - e22[n2][0]) * (e22[n2][1] + e22[i2][1]), l2 = r2 + a2;
          o2 += Math.abs(r2) >= Math.abs(a2) ? r2 - l2 + a2 : a2 - l2 + r2, r2 = l2;
        }
        r2 + o2 >= 0 != !!t2 && e22.reverse();
      }
      var a = e.dc(function e22(t2, r2) {
        var o2, i2 = t2 && t2.type;
        if ("FeatureCollection" === i2)
          for (o2 = 0; o2 < t2.features.length; o2++)
            e22(t2.features[o2], r2);
        else if ("GeometryCollection" === i2)
          for (o2 = 0; o2 < t2.geometries.length; o2++)
            e22(t2.geometries[o2], r2);
        else if ("Feature" === i2)
          e22(t2.geometry, r2);
        else if ("Polygon" === i2)
          s(t2.coordinates, r2);
        else if ("MultiPolygon" === i2)
          for (o2 = 0; o2 < t2.coordinates.length; o2++)
            s(t2.coordinates[o2], r2);
        return t2;
      });
      const l = e.dd.prototype.toGeoJSON;
      var h = { exports: {} }, u = e.df, c = e.de.VectorTileFeature, d = f;
      function f(e22, t2) {
        this.options = t2 || {}, this.features = e22, this.length = e22.length;
      }
      function p(e22, t2) {
        this.id = "number" == typeof e22.id ? e22.id : void 0, this.type = e22.type, this.rawGeometry = 1 === e22.type ? [e22.geometry] : e22.geometry, this.properties = e22.tags, this.extent = t2 || 4096;
      }
      f.prototype.feature = function(e22) {
        return new p(this.features[e22], this.options.extent);
      }, p.prototype.loadGeometry = function() {
        var e22 = this.rawGeometry;
        this.geometry = [];
        for (var t2 = 0; t2 < e22.length; t2++) {
          for (var r2 = e22[t2], o2 = [], i2 = 0; i2 < r2.length; i2++)
            o2.push(new u(r2[i2][0], r2[i2][1]));
          this.geometry.push(o2);
        }
        return this.geometry;
      }, p.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e22 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, o2 = 1 / 0, i2 = -1 / 0, s2 = 0; s2 < e22.length; s2++)
          for (var n2 = e22[s2], a2 = 0; a2 < n2.length; a2++) {
            var l2 = n2[a2];
            t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), o2 = Math.min(o2, l2.y), i2 = Math.max(i2, l2.y);
          }
        return [t2, o2, r2, i2];
      }, p.prototype.toGeoJSON = c.prototype.toGeoJSON;
      var g = e.dg, m = d;
      function y(e22) {
        var t2 = new g();
        return function(e3, t3) {
          for (var r2 in e3.layers)
            t3.writeMessage(3, v, e3.layers[r2]);
        }(e22, t2), t2.finish();
      }
      function v(e22, t2) {
        var r2;
        t2.writeVarintField(15, e22.version || 1), t2.writeStringField(1, e22.name || ""), t2.writeVarintField(5, e22.extent || 4096);
        var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (r2 = 0; r2 < e22.length; r2++)
          o2.feature = e22.feature(r2), t2.writeMessage(2, w, o2);
        var i2 = o2.keys;
        for (r2 = 0; r2 < i2.length; r2++)
          t2.writeStringField(3, i2[r2]);
        var s2 = o2.values;
        for (r2 = 0; r2 < s2.length; r2++)
          t2.writeMessage(4, I, s2[r2]);
      }
      function w(e22, t2) {
        var r2 = e22.feature;
        void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, x, e22), t2.writeVarintField(3, r2.type), t2.writeMessage(4, b, r2);
      }
      function x(e22, t2) {
        var r2 = e22.feature, o2 = e22.keys, i2 = e22.values, s2 = e22.keycache, n2 = e22.valuecache;
        for (var a2 in r2.properties) {
          var l2 = r2.properties[a2], h22 = s2[a2];
          if (null !== l2) {
            void 0 === h22 && (o2.push(a2), s2[a2] = h22 = o2.length - 1), t2.writeVarint(h22);
            var u2 = typeof l2;
            "string" !== u2 && "boolean" !== u2 && "number" !== u2 && (l2 = JSON.stringify(l2));
            var c2 = u2 + ":" + l2, d2 = n2[c2];
            void 0 === d2 && (i2.push(l2), n2[c2] = d2 = i2.length - 1), t2.writeVarint(d2);
          }
        }
      }
      function S(e22, t2) {
        return (t2 << 3) + (7 & e22);
      }
      function M(e22) {
        return e22 << 1 ^ e22 >> 31;
      }
      function b(e22, t2) {
        for (var r2 = e22.loadGeometry(), o2 = e22.type, i2 = 0, s2 = 0, n2 = r2.length, a2 = 0; a2 < n2; a2++) {
          var l2 = r2[a2], h22 = 1;
          1 === o2 && (h22 = l2.length), t2.writeVarint(S(1, h22));
          for (var u2 = 3 === o2 ? l2.length - 1 : l2.length, c2 = 0; c2 < u2; c2++) {
            1 === c2 && 1 !== o2 && t2.writeVarint(S(2, u2 - 1));
            var d2 = l2[c2].x - i2, f2 = l2[c2].y - s2;
            t2.writeVarint(M(d2)), t2.writeVarint(M(f2)), i2 += d2, s2 += f2;
          }
          3 === o2 && t2.writeVarint(S(7, 1));
        }
      }
      function I(e22, t2) {
        var r2 = typeof e22;
        "string" === r2 ? t2.writeStringField(1, e22) : "boolean" === r2 ? t2.writeBooleanField(7, e22) : "number" === r2 && (e22 % 1 != 0 ? t2.writeDoubleField(3, e22) : e22 < 0 ? t2.writeSVarintField(6, e22) : t2.writeVarintField(5, e22));
      }
      h.exports = y, h.exports.fromVectorTileJs = y, h.exports.fromGeojsonVt = function(e22, t2) {
        t2 = t2 || {};
        var r2 = {};
        for (var o2 in e22)
          r2[o2] = new m(e22[o2].features, t2), r2[o2].name = o2, r2[o2].version = t2.version, r2[o2].extent = t2.extent;
        return y({ layers: r2 });
      }, h.exports.GeoJSONWrapper = m;
      var k = e.dc(h.exports);
      const P = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e22) => e22 }, _ = Math.fround || (L = new Float32Array(1), (e22) => (L[0] = +e22, L[0]));
      var L;
      const T = 3, C = 5, O = 6;
      class j {
        constructor(e22) {
          this.options = Object.assign(Object.create(P), e22), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e22) {
          const { log: t2, minZoom: r2, maxZoom: o2 } = this.options;
          t2 && console.time("total time");
          const i2 = `prepare ${e22.length} points`;
          t2 && console.time(i2), this.points = e22;
          const s2 = [];
          for (let t3 = 0; t3 < e22.length; t3++) {
            const r3 = e22[t3];
            if (!r3.geometry)
              continue;
            const [o3, i3] = r3.geometry.coordinates, n3 = _(z(o3)), a2 = _(D(i3));
            s2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && s2.push(0);
          }
          let n2 = this.trees[o2 + 1] = this._createTree(s2);
          t2 && console.timeEnd(i2);
          for (let e3 = o2; e3 >= r2; e3--) {
            const r3 = +Date.now();
            n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - r3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e22, t2) {
          let r2 = ((e22[0] + 180) % 360 + 360) % 360 - 180;
          const o2 = Math.max(-90, Math.min(90, e22[1]));
          let i2 = 180 === e22[2] ? 180 : ((e22[2] + 180) % 360 + 360) % 360 - 180;
          const s2 = Math.max(-90, Math.min(90, e22[3]));
          if (e22[2] - e22[0] >= 360)
            r2 = -180, i2 = 180;
          else if (r2 > i2) {
            const e3 = this.getClusters([r2, o2, 180, s2], t2), n3 = this.getClusters([-180, o2, i2, s2], t2);
            return e3.concat(n3);
          }
          const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(z(r2), D(s2), z(i2), D(o2)), l2 = n2.data, h22 = [];
          for (const e3 of a2) {
            const t3 = this.stride * e3;
            h22.push(l2[t3 + C] > 1 ? Z(l2, t3, this.clusterProps) : this.points[l2[t3 + T]]);
          }
          return h22;
        }
        getChildren(e22) {
          const t2 = this._getOriginId(e22), r2 = this._getOriginZoom(e22), o2 = "No cluster with the specified id.", i2 = this.trees[r2];
          if (!i2)
            throw new Error(o2);
          const s2 = i2.data;
          if (t2 * this.stride >= s2.length)
            throw new Error(o2);
          const n2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), a2 = i2.within(s2[t2 * this.stride], s2[t2 * this.stride + 1], n2), l2 = [];
          for (const t3 of a2) {
            const r3 = t3 * this.stride;
            s2[r3 + 4] === e22 && l2.push(s2[r3 + C] > 1 ? Z(s2, r3, this.clusterProps) : this.points[s2[r3 + T]]);
          }
          if (0 === l2.length)
            throw new Error(o2);
          return l2;
        }
        getLeaves(e22, t2, r2) {
          const o2 = [];
          return this._appendLeaves(o2, e22, t2 = t2 || 10, r2 = r2 || 0, 0), o2;
        }
        getTile(e22, t2, r2) {
          const o2 = this.trees[this._limitZoom(e22)], i2 = Math.pow(2, e22), { extent: s2, radius: n2 } = this.options, a2 = n2 / s2, l2 = (r2 - a2) / i2, h22 = (r2 + 1 + a2) / i2, u2 = { features: [] };
          return this._addTileFeatures(o2.range((t2 - a2) / i2, l2, (t2 + 1 + a2) / i2, h22), o2.data, t2, r2, i2, u2), 0 === t2 && this._addTileFeatures(o2.range(1 - a2 / i2, l2, 1, h22), o2.data, i2, r2, i2, u2), t2 === i2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / i2, h22), o2.data, -1, r2, i2, u2), u2.features.length ? u2 : null;
        }
        getClusterExpansionZoom(e22) {
          let t2 = this._getOriginZoom(e22) - 1;
          for (; t2 <= this.options.maxZoom; ) {
            const r2 = this.getChildren(e22);
            if (t2++, 1 !== r2.length)
              break;
            e22 = r2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e22, t2, r2, o2, i2) {
          const s2 = this.getChildren(t2);
          for (const t3 of s2) {
            const s3 = t3.properties;
            if (s3 && s3.cluster ? i2 + s3.point_count <= o2 ? i2 += s3.point_count : i2 = this._appendLeaves(e22, s3.cluster_id, r2, o2, i2) : i2 < o2 ? i2++ : e22.push(t3), e22.length === r2)
              break;
          }
          return i2;
        }
        _createTree(t2) {
          const r2 = new e.aZ(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e22 = 0; e22 < t2.length; e22 += this.stride)
            r2.add(t2[e22], t2[e22 + 1]);
          return r2.finish(), r2.data = t2, r2;
        }
        _addTileFeatures(e22, t2, r2, o2, i2, s2) {
          for (const n2 of e22) {
            const e3 = n2 * this.stride, a2 = t2[e3 + C] > 1;
            let l2, h22, u2;
            if (a2)
              l2 = F(t2, e3, this.clusterProps), h22 = t2[e3], u2 = t2[e3 + 1];
            else {
              const r3 = this.points[t2[e3 + T]];
              l2 = r3.properties;
              const [o3, i3] = r3.geometry.coordinates;
              h22 = z(o3), u2 = D(i3);
            }
            const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (h22 * i2 - r2)), Math.round(this.options.extent * (u2 * i2 - o2))]], tags: l2 };
            let d2;
            d2 = a2 || this.options.generateId ? t2[e3 + T] : this.points[t2[e3 + T]].id, void 0 !== d2 && (c2.id = d2), s2.features.push(c2);
          }
        }
        _limitZoom(e22) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e22), this.options.maxZoom + 1));
        }
        _cluster(e22, t2) {
          const { radius: r2, extent: o2, reduce: i2, minPoints: s2 } = this.options, n2 = r2 / (o2 * Math.pow(2, t2)), a2 = e22.data, l2 = [], h22 = this.stride;
          for (let r3 = 0; r3 < a2.length; r3 += h22) {
            if (a2[r3 + 2] <= t2)
              continue;
            a2[r3 + 2] = t2;
            const o3 = a2[r3], u2 = a2[r3 + 1], c2 = e22.within(a2[r3], a2[r3 + 1], n2), d2 = a2[r3 + C];
            let f2 = d2;
            for (const e3 of c2) {
              const r4 = e3 * h22;
              a2[r4 + 2] > t2 && (f2 += a2[r4 + C]);
            }
            if (f2 > d2 && f2 >= s2) {
              let e3, s3 = o3 * d2, n3 = u2 * d2, p2 = -1;
              const g2 = ((r3 / h22 | 0) << 5) + (t2 + 1) + this.points.length;
              for (const o4 of c2) {
                const l3 = o4 * h22;
                if (a2[l3 + 2] <= t2)
                  continue;
                a2[l3 + 2] = t2;
                const u3 = a2[l3 + C];
                s3 += a2[l3] * u3, n3 += a2[l3 + 1] * u3, a2[l3 + 4] = g2, i2 && (e3 || (e3 = this._map(a2, r3, true), p2 = this.clusterProps.length, this.clusterProps.push(e3)), i2(e3, this._map(a2, l3)));
              }
              a2[r3 + 4] = g2, l2.push(s3 / f2, n3 / f2, 1 / 0, g2, -1, f2), i2 && l2.push(p2);
            } else {
              for (let e3 = 0; e3 < h22; e3++)
                l2.push(a2[r3 + e3]);
              if (f2 > 1)
                for (const e3 of c2) {
                  const r4 = e3 * h22;
                  if (!(a2[r4 + 2] <= t2)) {
                    a2[r4 + 2] = t2;
                    for (let e4 = 0; e4 < h22; e4++)
                      l2.push(a2[r4 + e4]);
                  }
                }
            }
          }
          return l2;
        }
        _getOriginId(e22) {
          return e22 - this.points.length >> 5;
        }
        _getOriginZoom(e22) {
          return (e22 - this.points.length) % 32;
        }
        _map(e22, t2, r2) {
          if (e22[t2 + C] > 1) {
            const o3 = this.clusterProps[e22[t2 + O]];
            return r2 ? Object.assign({}, o3) : o3;
          }
          const o2 = this.points[e22[t2 + T]].properties, i2 = this.options.map(o2);
          return r2 && i2 === o2 ? Object.assign({}, i2) : i2;
        }
      }
      function Z(e22, t2, r2) {
        return { type: "Feature", id: e22[t2 + T], properties: F(e22, t2, r2), geometry: { type: "Point", coordinates: [(o2 = e22[t2], 360 * (o2 - 0.5)), E(e22[t2 + 1])] } };
        var o2;
      }
      function F(e22, t2, r2) {
        const o2 = e22[t2 + C], i2 = o2 >= 1e4 ? `${Math.round(o2 / 1e3)}k` : o2 >= 1e3 ? Math.round(o2 / 100) / 10 + "k" : o2, s2 = e22[t2 + O], n2 = -1 === s2 ? {} : Object.assign({}, r2[s2]);
        return Object.assign(n2, { cluster: true, cluster_id: e22[t2 + T], point_count: o2, point_count_abbreviated: i2 });
      }
      function z(e22) {
        return e22 / 360 + 0.5;
      }
      function D(e22) {
        const t2 = Math.sin(e22 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function E(e22) {
        const t2 = (180 - 360 * e22) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      var J = { exports: {} };
      J.exports = function() {
        function e22(r3, o3, i3, s3) {
          for (var n3, a3 = s3, l3 = i3 - o3 >> 1, h3 = i3 - o3, u3 = r3[o3], c3 = r3[o3 + 1], d3 = r3[i3], f3 = r3[i3 + 1], p3 = o3 + 3; p3 < i3; p3 += 3) {
            var g3 = t2(r3[p3], r3[p3 + 1], u3, c3, d3, f3);
            if (g3 > a3)
              n3 = p3, a3 = g3;
            else if (g3 === a3) {
              var m3 = Math.abs(p3 - l3);
              m3 < h3 && (n3 = p3, h3 = m3);
            }
          }
          a3 > s3 && (n3 - o3 > 3 && e22(r3, o3, n3, s3), r3[n3 + 2] = a3, i3 - n3 > 3 && e22(r3, n3, i3, s3));
        }
        function t2(e3, t3, r3, o3, i3, s3) {
          var n3 = i3 - r3, a3 = s3 - o3;
          if (0 !== n3 || 0 !== a3) {
            var l3 = ((e3 - r3) * n3 + (t3 - o3) * a3) / (n3 * n3 + a3 * a3);
            l3 > 1 ? (r3 = i3, o3 = s3) : l3 > 0 && (r3 += n3 * l3, o3 += a3 * l3);
          }
          return (n3 = e3 - r3) * n3 + (a3 = t3 - o3) * a3;
        }
        function r2(e3, t3, r3, i3) {
          var s3 = { id: void 0 === e3 ? null : e3, type: t3, geometry: r3, tags: i3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e4) {
            var t4 = e4.geometry, r4 = e4.type;
            if ("Point" === r4 || "MultiPoint" === r4 || "LineString" === r4)
              o2(e4, t4);
            else if ("Polygon" === r4 || "MultiLineString" === r4)
              for (var i4 = 0; i4 < t4.length; i4++)
                o2(e4, t4[i4]);
            else if ("MultiPolygon" === r4)
              for (i4 = 0; i4 < t4.length; i4++)
                for (var s4 = 0; s4 < t4[i4].length; s4++)
                  o2(e4, t4[i4][s4]);
          }(s3), s3;
        }
        function o2(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3 += 3)
            e3.minX = Math.min(e3.minX, t3[r3]), e3.minY = Math.min(e3.minY, t3[r3 + 1]), e3.maxX = Math.max(e3.maxX, t3[r3]), e3.maxY = Math.max(e3.maxY, t3[r3 + 1]);
        }
        function i2(e3, t3, o3, l3) {
          if (t3.geometry) {
            var h3 = t3.geometry.coordinates, u3 = t3.geometry.type, c3 = Math.pow(o3.tolerance / ((1 << o3.maxZoom) * o3.extent), 2), d3 = [], f3 = t3.id;
            if (o3.promoteId ? f3 = t3.properties[o3.promoteId] : o3.generateId && (f3 = l3 || 0), "Point" === u3)
              s2(h3, d3);
            else if ("MultiPoint" === u3)
              for (var p3 = 0; p3 < h3.length; p3++)
                s2(h3[p3], d3);
            else if ("LineString" === u3)
              n2(h3, d3, c3, false);
            else if ("MultiLineString" === u3) {
              if (o3.lineMetrics) {
                for (p3 = 0; p3 < h3.length; p3++)
                  n2(h3[p3], d3 = [], c3, false), e3.push(r2(f3, "LineString", d3, t3.properties));
                return;
              }
              a2(h3, d3, c3, false);
            } else if ("Polygon" === u3)
              a2(h3, d3, c3, true);
            else {
              if ("MultiPolygon" !== u3) {
                if ("GeometryCollection" === u3) {
                  for (p3 = 0; p3 < t3.geometry.geometries.length; p3++)
                    i2(e3, { id: f3, geometry: t3.geometry.geometries[p3], properties: t3.properties }, o3, l3);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (p3 = 0; p3 < h3.length; p3++) {
                var g3 = [];
                a2(h3[p3], g3, c3, true), d3.push(g3);
              }
            }
            e3.push(r2(f3, u3, d3, t3.properties));
          }
        }
        function s2(e3, t3) {
          t3.push(l2(e3[0])), t3.push(h22(e3[1])), t3.push(0);
        }
        function n2(t3, r3, o3, i3) {
          for (var s3, n3, a3 = 0, u3 = 0; u3 < t3.length; u3++) {
            var c3 = l2(t3[u3][0]), d3 = h22(t3[u3][1]);
            r3.push(c3), r3.push(d3), r3.push(0), u3 > 0 && (a3 += i3 ? (s3 * d3 - c3 * n3) / 2 : Math.sqrt(Math.pow(c3 - s3, 2) + Math.pow(d3 - n3, 2))), s3 = c3, n3 = d3;
          }
          var f3 = r3.length - 3;
          r3[2] = 1, e22(r3, 0, f3, o3), r3[f3 + 2] = 1, r3.size = Math.abs(a3), r3.start = 0, r3.end = r3.size;
        }
        function a2(e3, t3, r3, o3) {
          for (var i3 = 0; i3 < e3.length; i3++) {
            var s3 = [];
            n2(e3[i3], s3, r3, o3), t3.push(s3);
          }
        }
        function l2(e3) {
          return e3 / 360 + 0.5;
        }
        function h22(e3) {
          var t3 = Math.sin(e3 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function u2(e3, t3, o3, i3, s3, n3, a3, l3) {
          if (i3 /= t3, n3 >= (o3 /= t3) && a3 < i3)
            return e3;
          if (a3 < o3 || n3 >= i3)
            return null;
          for (var h3 = [], u3 = 0; u3 < e3.length; u3++) {
            var f3 = e3[u3], g3 = f3.geometry, m3 = f3.type, y3 = 0 === s3 ? f3.minX : f3.minY, v3 = 0 === s3 ? f3.maxX : f3.maxY;
            if (y3 >= o3 && v3 < i3)
              h3.push(f3);
            else if (!(v3 < o3 || y3 >= i3)) {
              var w3 = [];
              if ("Point" === m3 || "MultiPoint" === m3)
                c2(g3, w3, o3, i3, s3);
              else if ("LineString" === m3)
                d2(g3, w3, o3, i3, s3, false, l3.lineMetrics);
              else if ("MultiLineString" === m3)
                p2(g3, w3, o3, i3, s3, false);
              else if ("Polygon" === m3)
                p2(g3, w3, o3, i3, s3, true);
              else if ("MultiPolygon" === m3)
                for (var x3 = 0; x3 < g3.length; x3++) {
                  var S3 = [];
                  p2(g3[x3], S3, o3, i3, s3, true), S3.length && w3.push(S3);
                }
              if (w3.length) {
                if (l3.lineMetrics && "LineString" === m3) {
                  for (x3 = 0; x3 < w3.length; x3++)
                    h3.push(r2(f3.id, m3, w3[x3], f3.tags));
                  continue;
                }
                "LineString" !== m3 && "MultiLineString" !== m3 || (1 === w3.length ? (m3 = "LineString", w3 = w3[0]) : m3 = "MultiLineString"), "Point" !== m3 && "MultiPoint" !== m3 || (m3 = 3 === w3.length ? "Point" : "MultiPoint"), h3.push(r2(f3.id, m3, w3, f3.tags));
              }
            }
          }
          return h3.length ? h3 : null;
        }
        function c2(e3, t3, r3, o3, i3) {
          for (var s3 = 0; s3 < e3.length; s3 += 3) {
            var n3 = e3[s3 + i3];
            n3 >= r3 && n3 <= o3 && (t3.push(e3[s3]), t3.push(e3[s3 + 1]), t3.push(e3[s3 + 2]));
          }
        }
        function d2(e3, t3, r3, o3, i3, s3, n3) {
          for (var a3, l3, h3 = f2(e3), u3 = 0 === i3 ? m2 : y2, c3 = e3.start, d3 = 0; d3 < e3.length - 3; d3 += 3) {
            var p3 = e3[d3], v3 = e3[d3 + 1], w3 = e3[d3 + 2], x3 = e3[d3 + 3], S3 = e3[d3 + 4], M3 = 0 === i3 ? p3 : v3, b3 = 0 === i3 ? x3 : S3, I3 = false;
            n3 && (a3 = Math.sqrt(Math.pow(p3 - x3, 2) + Math.pow(v3 - S3, 2))), M3 < r3 ? b3 > r3 && (l3 = u3(h3, p3, v3, x3, S3, r3), n3 && (h3.start = c3 + a3 * l3)) : M3 > o3 ? b3 < o3 && (l3 = u3(h3, p3, v3, x3, S3, o3), n3 && (h3.start = c3 + a3 * l3)) : g2(h3, p3, v3, w3), b3 < r3 && M3 >= r3 && (l3 = u3(h3, p3, v3, x3, S3, r3), I3 = true), b3 > o3 && M3 <= o3 && (l3 = u3(h3, p3, v3, x3, S3, o3), I3 = true), !s3 && I3 && (n3 && (h3.end = c3 + a3 * l3), t3.push(h3), h3 = f2(e3)), n3 && (c3 += a3);
          }
          var k3 = e3.length - 3;
          p3 = e3[k3], v3 = e3[k3 + 1], w3 = e3[k3 + 2], (M3 = 0 === i3 ? p3 : v3) >= r3 && M3 <= o3 && g2(h3, p3, v3, w3), k3 = h3.length - 3, s3 && k3 >= 3 && (h3[k3] !== h3[0] || h3[k3 + 1] !== h3[1]) && g2(h3, h3[0], h3[1], h3[2]), h3.length && t3.push(h3);
        }
        function f2(e3) {
          var t3 = [];
          return t3.size = e3.size, t3.start = e3.start, t3.end = e3.end, t3;
        }
        function p2(e3, t3, r3, o3, i3, s3) {
          for (var n3 = 0; n3 < e3.length; n3++)
            d2(e3[n3], t3, r3, o3, i3, s3, false);
        }
        function g2(e3, t3, r3, o3) {
          e3.push(t3), e3.push(r3), e3.push(o3);
        }
        function m2(e3, t3, r3, o3, i3, s3) {
          var n3 = (s3 - t3) / (o3 - t3);
          return e3.push(s3), e3.push(r3 + (i3 - r3) * n3), e3.push(1), n3;
        }
        function y2(e3, t3, r3, o3, i3, s3) {
          var n3 = (s3 - r3) / (i3 - r3);
          return e3.push(t3 + (o3 - t3) * n3), e3.push(s3), e3.push(1), n3;
        }
        function v2(e3, t3) {
          for (var o3 = [], i3 = 0; i3 < e3.length; i3++) {
            var s3, n3 = e3[i3], a3 = n3.type;
            if ("Point" === a3 || "MultiPoint" === a3 || "LineString" === a3)
              s3 = w2(n3.geometry, t3);
            else if ("MultiLineString" === a3 || "Polygon" === a3) {
              s3 = [];
              for (var l3 = 0; l3 < n3.geometry.length; l3++)
                s3.push(w2(n3.geometry[l3], t3));
            } else if ("MultiPolygon" === a3)
              for (s3 = [], l3 = 0; l3 < n3.geometry.length; l3++) {
                for (var h3 = [], u3 = 0; u3 < n3.geometry[l3].length; u3++)
                  h3.push(w2(n3.geometry[l3][u3], t3));
                s3.push(h3);
              }
            o3.push(r2(n3.id, a3, s3, n3.tags));
          }
          return o3;
        }
        function w2(e3, t3) {
          var r3 = [];
          r3.size = e3.size, void 0 !== e3.start && (r3.start = e3.start, r3.end = e3.end);
          for (var o3 = 0; o3 < e3.length; o3 += 3)
            r3.push(e3[o3] + t3, e3[o3 + 1], e3[o3 + 2]);
          return r3;
        }
        function x2(e3, t3) {
          if (e3.transformed)
            return e3;
          var r3, o3, i3, s3 = 1 << e3.z, n3 = e3.x, a3 = e3.y;
          for (r3 = 0; r3 < e3.features.length; r3++) {
            var l3 = e3.features[r3], h3 = l3.geometry, u3 = l3.type;
            if (l3.geometry = [], 1 === u3)
              for (o3 = 0; o3 < h3.length; o3 += 2)
                l3.geometry.push(S2(h3[o3], h3[o3 + 1], t3, s3, n3, a3));
            else
              for (o3 = 0; o3 < h3.length; o3++) {
                var c3 = [];
                for (i3 = 0; i3 < h3[o3].length; i3 += 2)
                  c3.push(S2(h3[o3][i3], h3[o3][i3 + 1], t3, s3, n3, a3));
                l3.geometry.push(c3);
              }
          }
          return e3.transformed = true, e3;
        }
        function S2(e3, t3, r3, o3, i3, s3) {
          return [Math.round(r3 * (e3 * o3 - i3)), Math.round(r3 * (t3 * o3 - s3))];
        }
        function M2(e3, t3, r3, o3, i3) {
          for (var s3 = t3 === i3.maxZoom ? 0 : i3.tolerance / ((1 << t3) * i3.extent), n3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r3, y: o3, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a3 = 0; a3 < e3.length; a3++) {
            n3.numFeatures++, b2(n3, e3[a3], s3, i3);
            var l3 = e3[a3].minX, h3 = e3[a3].minY, u3 = e3[a3].maxX, c3 = e3[a3].maxY;
            l3 < n3.minX && (n3.minX = l3), h3 < n3.minY && (n3.minY = h3), u3 > n3.maxX && (n3.maxX = u3), c3 > n3.maxY && (n3.maxY = c3);
          }
          return n3;
        }
        function b2(e3, t3, r3, o3) {
          var i3 = t3.geometry, s3 = t3.type, n3 = [];
          if ("Point" === s3 || "MultiPoint" === s3)
            for (var a3 = 0; a3 < i3.length; a3 += 3)
              n3.push(i3[a3]), n3.push(i3[a3 + 1]), e3.numPoints++, e3.numSimplified++;
          else if ("LineString" === s3)
            I2(n3, i3, e3, r3, false, false);
          else if ("MultiLineString" === s3 || "Polygon" === s3)
            for (a3 = 0; a3 < i3.length; a3++)
              I2(n3, i3[a3], e3, r3, "Polygon" === s3, 0 === a3);
          else if ("MultiPolygon" === s3)
            for (var l3 = 0; l3 < i3.length; l3++) {
              var h3 = i3[l3];
              for (a3 = 0; a3 < h3.length; a3++)
                I2(n3, h3[a3], e3, r3, true, 0 === a3);
            }
          if (n3.length) {
            var u3 = t3.tags || null;
            if ("LineString" === s3 && o3.lineMetrics) {
              for (var c3 in u3 = {}, t3.tags)
                u3[c3] = t3.tags[c3];
              u3.mapbox_clip_start = i3.start / i3.size, u3.mapbox_clip_end = i3.end / i3.size;
            }
            var d3 = { geometry: n3, type: "Polygon" === s3 || "MultiPolygon" === s3 ? 3 : "LineString" === s3 || "MultiLineString" === s3 ? 2 : 1, tags: u3 };
            null !== t3.id && (d3.id = t3.id), e3.features.push(d3);
          }
        }
        function I2(e3, t3, r3, o3, i3, s3) {
          var n3 = o3 * o3;
          if (o3 > 0 && t3.size < (i3 ? n3 : o3))
            r3.numPoints += t3.length / 3;
          else {
            for (var a3 = [], l3 = 0; l3 < t3.length; l3 += 3)
              (0 === o3 || t3[l3 + 2] > n3) && (r3.numSimplified++, a3.push(t3[l3]), a3.push(t3[l3 + 1])), r3.numPoints++;
            i3 && function(e4, t4) {
              for (var r4 = 0, o4 = 0, i4 = e4.length, s4 = i4 - 2; o4 < i4; s4 = o4, o4 += 2)
                r4 += (e4[o4] - e4[s4]) * (e4[o4 + 1] + e4[s4 + 1]);
              if (r4 > 0 === t4)
                for (o4 = 0, i4 = e4.length; o4 < i4 / 2; o4 += 2) {
                  var n4 = e4[o4], a4 = e4[o4 + 1];
                  e4[o4] = e4[i4 - 2 - o4], e4[o4 + 1] = e4[i4 - 1 - o4], e4[i4 - 2 - o4] = n4, e4[i4 - 1 - o4] = a4;
                }
            }(a3, s3), e3.push(a3);
          }
        }
        function k2(e3, t3) {
          var r3 = (t3 = this.options = function(e4, t4) {
            for (var r4 in t4)
              e4[r4] = t4[r4];
            return e4;
          }(Object.create(this.options), t3)).debug;
          if (r3 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t3.promoteId && t3.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var o3 = function(e4, t4) {
            var r4 = [];
            if ("FeatureCollection" === e4.type)
              for (var o4 = 0; o4 < e4.features.length; o4++)
                i2(r4, e4.features[o4], t4, o4);
            else
              i2(r4, "Feature" === e4.type ? e4 : { geometry: e4 }, t4);
            return r4;
          }(e3, t3);
          this.tiles = {}, this.tileCoords = [], r3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o3 = function(e4, t4) {
            var r4 = t4.buffer / t4.extent, o4 = e4, i3 = u2(e4, 1, -1 - r4, r4, 0, -1, 2, t4), s3 = u2(e4, 1, 1 - r4, 2 + r4, 0, -1, 2, t4);
            return (i3 || s3) && (o4 = u2(e4, 1, -r4, 1 + r4, 0, -1, 2, t4) || [], i3 && (o4 = v2(i3, 1).concat(o4)), s3 && (o4 = o4.concat(v2(s3, -1)))), o4;
          }(o3, t3)).length && this.splitTile(o3, 0, 0, 0), r3 && (o3.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function P2(e3, t3, r3) {
          return 32 * ((1 << e3) * r3 + t3) + e3;
        }
        return k2.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, k2.prototype.splitTile = function(e3, t3, r3, o3, i3, s3, n3) {
          for (var a3 = [e3, t3, r3, o3], l3 = this.options, h3 = l3.debug; a3.length; ) {
            o3 = a3.pop(), r3 = a3.pop(), t3 = a3.pop(), e3 = a3.pop();
            var c3 = 1 << t3, d3 = P2(t3, r3, o3), f3 = this.tiles[d3];
            if (!f3 && (h3 > 1 && console.time("creation"), f3 = this.tiles[d3] = M2(e3, t3, r3, o3, l3), this.tileCoords.push({ z: t3, x: r3, y: o3 }), h3)) {
              h3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, r3, o3, f3.numFeatures, f3.numPoints, f3.numSimplified), console.timeEnd("creation"));
              var p3 = "z" + t3;
              this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
            }
            if (f3.source = e3, i3) {
              if (t3 === l3.maxZoom || t3 === i3)
                continue;
              var g3 = 1 << i3 - t3;
              if (r3 !== Math.floor(s3 / g3) || o3 !== Math.floor(n3 / g3))
                continue;
            } else if (t3 === l3.indexMaxZoom || f3.numPoints <= l3.indexMaxPoints)
              continue;
            if (f3.source = null, 0 !== e3.length) {
              h3 > 1 && console.time("clipping");
              var m3, y3, v3, w3, x3, S3, b3 = 0.5 * l3.buffer / l3.extent, I3 = 0.5 - b3, k3 = 0.5 + b3, _2 = 1 + b3;
              m3 = y3 = v3 = w3 = null, x3 = u2(e3, c3, r3 - b3, r3 + k3, 0, f3.minX, f3.maxX, l3), S3 = u2(e3, c3, r3 + I3, r3 + _2, 0, f3.minX, f3.maxX, l3), e3 = null, x3 && (m3 = u2(x3, c3, o3 - b3, o3 + k3, 1, f3.minY, f3.maxY, l3), y3 = u2(x3, c3, o3 + I3, o3 + _2, 1, f3.minY, f3.maxY, l3), x3 = null), S3 && (v3 = u2(S3, c3, o3 - b3, o3 + k3, 1, f3.minY, f3.maxY, l3), w3 = u2(S3, c3, o3 + I3, o3 + _2, 1, f3.minY, f3.maxY, l3), S3 = null), h3 > 1 && console.timeEnd("clipping"), a3.push(m3 || [], t3 + 1, 2 * r3, 2 * o3), a3.push(y3 || [], t3 + 1, 2 * r3, 2 * o3 + 1), a3.push(v3 || [], t3 + 1, 2 * r3 + 1, 2 * o3), a3.push(w3 || [], t3 + 1, 2 * r3 + 1, 2 * o3 + 1);
            }
          }
        }, k2.prototype.getTile = function(e3, t3, r3) {
          var o3 = this.options, i3 = o3.extent, s3 = o3.debug;
          if (e3 < 0 || e3 > 24)
            return null;
          var n3 = 1 << e3, a3 = P2(e3, t3 = (t3 % n3 + n3) % n3, r3);
          if (this.tiles[a3])
            return x2(this.tiles[a3], i3);
          s3 > 1 && console.log("drilling down to z%d-%d-%d", e3, t3, r3);
          for (var l3, h3 = e3, u3 = t3, c3 = r3; !l3 && h3 > 0; )
            h3--, u3 = Math.floor(u3 / 2), c3 = Math.floor(c3 / 2), l3 = this.tiles[P2(h3, u3, c3)];
          return l3 && l3.source ? (s3 > 1 && console.log("found parent tile z%d-%d-%d", h3, u3, c3), s3 > 1 && console.time("drilling down"), this.splitTile(l3.source, h3, u3, c3, e3, t3, r3), s3 > 1 && console.timeEnd("drilling down"), this.tiles[a3] ? x2(this.tiles[a3], i3) : null) : null;
        }, function(e3, t3) {
          return new k2(e3, t3);
        };
      }();
      var N = e.dc(J.exports);
      function Y(t2, r2) {
        const o2 = t2.tileID.canonical;
        if (!this._geoJSONIndex)
          return r2(null, null);
        const i2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
        if (!i2)
          return r2(null, null);
        const s2 = new class {
          constructor(t3) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.J, this.length = t3.length, this._features = t3;
          }
          feature(t3) {
            return new class {
              constructor(t4) {
                this._feature = t4, this.extent = e.J, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
              }
              loadGeometry() {
                if (1 === this._feature.type) {
                  const t4 = [];
                  for (const r3 of this._feature.geometry)
                    t4.push([new e.P(r3[0], r3[1])]);
                  return t4;
                }
                {
                  const t4 = [];
                  for (const r3 of this._feature.geometry) {
                    const o3 = [];
                    for (const t5 of r3)
                      o3.push(new e.P(t5[0], t5[1]));
                    t4.push(o3);
                  }
                  return t4;
                }
              }
              toGeoJSON(e22, t4, r3) {
                return l.call(this, e22, t4, r3);
              }
            }(this._features[t3]);
          }
        }(i2.features);
        let n2 = k(s2);
        0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), r2(null, { vectorTile: s2, rawData: n2.buffer });
      }
      class G extends e.dh {
        constructor(e22, t2, r2, o2, i2, s2) {
          super(e22, t2, r2, o2, Y, s2), i2 && (this.loadGeoJSON = i2);
        }
        loadData(t2, r2) {
          const o2 = t2 && t2.request, i2 = o2 && o2.collectResourceTiming;
          this.loadGeoJSON(t2, (s2, n2) => {
            if (s2 || !n2)
              return r2(s2);
            if ("object" != typeof n2)
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            {
              a(n2, true);
              try {
                if (t2.filter) {
                  const r3 = e.cw(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === r3.result)
                    throw new Error(r3.value.map((e22) => `${e22.key}: ${e22.message}`).join(", "));
                  const o3 = n2.features.filter((e22) => r3.value.evaluate({ zoom: 0 }, e22));
                  n2 = { type: "FeatureCollection", features: o3 };
                }
                this._geoJSONIndex = t2.cluster ? new j(function({ superclusterOptions: t3, clusterProperties: r3 }) {
                  if (!r3 || !t3)
                    return t3;
                  const o3 = {}, i3 = {}, s3 = { accumulated: null, zoom: 0 }, n3 = { properties: null }, a2 = Object.keys(r3);
                  for (const t4 of a2) {
                    const [s4, n4] = r3[t4], a3 = e.cw(n4), l3 = e.cw("string" == typeof s4 ? [s4, ["accumulated"], ["get", t4]] : s4);
                    o3[t4] = a3.value, i3[t4] = l3.value;
                  }
                  return t3.map = (e22) => {
                    n3.properties = e22;
                    const t4 = {};
                    for (const e3 of a2)
                      t4[e3] = o3[e3].evaluate(s3, n3);
                    return t4;
                  }, t3.reduce = (e22, t4) => {
                    n3.properties = t4;
                    for (const t5 of a2)
                      s3.accumulated = e22[t5], e22[t5] = i3[t5].evaluate(s3, n3);
                  }, t3;
                }(t2)).load(n2.features) : N(n2, t2.geojsonVtOptions);
              } catch (s3) {
                return r2(s3);
              }
              this.loaded = {};
              const l2 = {};
              if (i2) {
                const r3 = e.di(o2);
                r3 && (l2.resourceTiming = {}, l2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r3)));
              }
              r2(null, l2);
            }
          });
        }
        reloadTile(e22, t2) {
          const r2 = this.loaded;
          return r2 && r2[e22.uid] ? super.reloadTile(e22, t2) : this.loadTile(e22, t2);
        }
        loadGeoJSON(t2, r2) {
          if (t2.request)
            e.a1(t2.request, r2);
          else {
            if ("string" != typeof t2.data)
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            try {
              return r2(null, JSON.parse(t2.data));
            } catch (e22) {
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(e22, t2) {
          try {
            t2(null, this._geoJSONIndex.getClusterExpansionZoom(e22.clusterId));
          } catch (e3) {
            t2(e3);
          }
        }
        getClusterChildren(e22, t2) {
          try {
            t2(null, this._geoJSONIndex.getChildren(e22.clusterId));
          } catch (e3) {
            t2(e3);
          }
        }
        getClusterLeaves(e22, t2) {
          try {
            t2(null, this._geoJSONIndex.getLeaves(e22.clusterId, e22.limit, e22.offset));
          } catch (e3) {
            t2(e3);
          }
        }
      }
      class W {
        constructor(t2, r2) {
          this.tileID = new e.O(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t2.projection, this.brightness = r2;
        }
        parse(t2, r2, o2, i2) {
          this.status = "parsing";
          const s2 = new e.O(o2.tileID.overscaledZ, o2.tileID.wrap, o2.tileID.canonical.z, o2.tileID.canonical.x, o2.tileID.canonical.y), n2 = {}, a2 = r2.familiesBySource[o2.source], l2 = new e.dk(s2, o2.promoteId);
          return l2.bucketLayerIDs = [], e.dl(t2).then((t3) => {
            if (!t3)
              return i2(new Error("Could not parse tile"));
            const r3 = e.dm(t3, 1 / e.cg(o2.tileID.canonical)), h22 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("MAPBOX_mesh_features"), u2 = new e.al(this.zoom, { brightness: this.brightness });
            for (const o3 in a2)
              for (const i3 of a2[o3]) {
                const o4 = i3[0], a3 = t3.json.extensionsUsed;
                o4.recalculate(u2, []);
                const l3 = new e.dn(r3, s2, a3 && a3.includes("MAPBOX_mesh_features"), this.brightness);
                h22 || (l3.needsUpload = true), n2[o4.fqid] = l3, l3.evaluate(o4);
              }
            this.status = "done", i2(null, { buckets: n2, featureIndex: l2 });
          }).catch((e22) => i2(new Error(e22.message)));
        }
      }
      class X {
        constructor(e22, t2, r2, o2, i2, s2) {
          this.actor = e22, this.layerIndex = t2, this.brightness = s2, this.loading = {}, this.loaded = {};
        }
        loadTile(t2, r2) {
          const o2 = t2.uid, i2 = this.loading[o2] = new W(t2, this.brightness);
          e.dj(t2.request, (e22, s2) => {
            const n2 = !this.loading[o2];
            return delete this.loading[o2], n2 || e22 ? (i2.status = "done", n2 || (this.loaded[o2] = i2), r2(e22)) : s2 && 0 !== s2.byteLength ? void i2.parse(s2, this.layerIndex, t2, (e3, t3) => {
              i2.status = "done", this.loaded = this.loaded || {}, this.loaded[o2] = i2, e3 || !t3 ? r2(e3) : r2(null, t3);
            }) : (i2.status = "done", this.loaded[o2] = i2, r2());
          });
        }
        reloadTile(e22, t2) {
          const r2 = this.loaded, o2 = e22.uid;
          if (r2 && r2[o2]) {
            const i2 = r2[o2];
            i2.projection = e22.projection, i2.brightness = e22.brightness;
            const s2 = (r3, o3) => {
              i2.reloadCallback && (delete i2.reloadCallback, this.loadTile(e22, t2)), t2(r3, o3);
            };
            "parsing" === i2.status ? i2.reloadCallback = s2 : "done" === i2.status && this.loadTile(e22, t2);
          }
        }
        abortTile(e22, t2) {
          const r2 = e22.uid;
          this.loading[r2] && delete this.loading[r2], t2();
        }
        removeTile(e22, t2) {
          const r2 = this.loaded, o2 = e22.uid;
          r2 && r2[o2] && delete r2[o2], t2();
        }
      }
      class q {
        constructor(t2) {
          this.self = t2, this.actor = new e.dp(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.o({ name: "mercator" }), this.workerSourceTypes = { vector: e.dh, geojson: G, "batched-model": X }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e22, t3) => {
            if (this.workerSourceTypes[e22])
              throw new Error(`Worker source with name "${e22}" already registered.`);
            this.workerSourceTypes[e22] = t3;
          }, this.self.registerRTLTextPlugin = (t3) => {
            if (e.dq.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.dq.applyArabicShaping = t3.applyArabicShaping, e.dq.processBidirectionalText = t3.processBidirectionalText, e.dq.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          };
        }
        clearCaches(e22, t2, r2) {
          delete this.layerIndexes[e22], delete this.availableImages[e22], delete this.workerSources[e22], delete this.demWorkerSources[e22], r2();
        }
        checkIfReady(e22, t2, r2) {
          r2();
        }
        setReferrer(e22, t2) {
          this.referrer = t2;
        }
        spriteLoaded(t2, { scope: r2, isLoaded: o2 }) {
          if (this.isSpriteLoaded[t2] || (this.isSpriteLoaded[t2] = {}), this.isSpriteLoaded[t2][r2] = o2, this.workerSources[t2] && this.workerSources[t2][r2])
            for (const i2 in this.workerSources[t2][r2]) {
              const s2 = this.workerSources[t2][r2][i2];
              for (const t3 in s2)
                s2[t3] instanceof e.dh && (s2[t3].isSpriteLoaded = o2, s2[t3].fire(new e.a8("isSpriteLoaded")));
            }
        }
        setImages(e22, { scope: t2, images: r2 }, o2) {
          if (this.availableImages[e22] || (this.availableImages[e22] = {}), this.availableImages[e22][t2] = r2, this.workerSources[e22] && this.workerSources[e22][t2]) {
            for (const o3 in this.workerSources[e22][t2]) {
              const i2 = this.workerSources[e22][t2][o3];
              for (const e3 in i2)
                i2[e3].availableImages = r2;
            }
            o2();
          } else
            o2();
        }
        setProjection(t2, r2) {
          this.projections[t2] = e.o(r2);
        }
        setBrightness(e22, t2, r2) {
          this.brightness = t2, r2();
        }
        setLayers(e22, t2, r2) {
          this.getLayerIndex(e22, t2.scope).replace(t2.layers, t2.options), r2();
        }
        updateLayers(e22, t2, r2) {
          this.getLayerIndex(e22, t2.scope).update(t2.layers, t2.removedIds, t2.options), r2();
        }
        loadTile(e22, t2, r2) {
          t2.projection = this.projections[e22] || this.defaultProjection, this.getWorkerSource(e22, t2.type, t2.source, t2.scope).loadTile(t2, r2);
        }
        loadDEMTile(e22, t2, r2) {
          this.getDEMWorkerSource(e22, t2.source, t2.scope).loadTile(t2, r2);
        }
        reloadTile(e22, t2, r2) {
          t2.projection = this.projections[e22] || this.defaultProjection, this.getWorkerSource(e22, t2.type, t2.source, t2.scope).reloadTile(t2, r2);
        }
        abortTile(e22, t2, r2) {
          this.getWorkerSource(e22, t2.type, t2.source, t2.scope).abortTile(t2, r2);
        }
        removeTile(e22, t2, r2) {
          this.getWorkerSource(e22, t2.type, t2.source, t2.scope).removeTile(t2, r2);
        }
        removeSource(e22, t2, r2) {
          if (!(this.workerSources[e22] && this.workerSources[e22][t2.scope] && this.workerSources[e22][t2.scope][t2.type] && this.workerSources[e22][t2.scope][t2.type][t2.source]))
            return;
          const o2 = this.workerSources[e22][t2.scope][t2.type][t2.source];
          delete this.workerSources[e22][t2.scope][t2.type][t2.source], void 0 !== o2.removeSource ? o2.removeSource(t2, r2) : r2();
        }
        loadWorkerSource(e22, t2, r2) {
          try {
            this.self.importScripts(t2.url), r2();
          } catch (e3) {
            r2(e3.toString());
          }
        }
        syncRTLPluginState(t2, r2, o2) {
          try {
            e.dq.setState(r2);
            const t3 = e.dq.getPluginURL();
            if (e.dq.isLoaded() && !e.dq.isParsed() && null != t3) {
              this.self.importScripts(t3);
              const r3 = e.dq.isParsed();
              o2(r3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r3);
            }
          } catch (e22) {
            o2(e22.toString());
          }
        }
        setDracoUrl(e22, t2) {
          this.dracoUrl = t2;
        }
        getAvailableImages(e22, t2) {
          this.availableImages[e22] || (this.availableImages[e22] = {});
          let r2 = this.availableImages[e22][t2];
          return r2 || (r2 = []), r2;
        }
        getLayerIndex(e22, t2) {
          this.layerIndexes[e22] || (this.layerIndexes[e22] = {});
          let r2 = this.layerIndexes[e22][t2];
          return r2 || (r2 = this.layerIndexes[e22][t2] = new o(), r2.scope = t2), r2;
        }
        getWorkerSource(e22, t2, r2, o2) {
          if (this.workerSources[e22] || (this.workerSources[e22] = {}), this.workerSources[e22][o2] || (this.workerSources[e22][o2] = {}), this.workerSources[e22][o2][t2] || (this.workerSources[e22][o2][t2] = {}), this.isSpriteLoaded[e22] || (this.isSpriteLoaded[e22] = {}), !this.workerSources[e22][o2][t2][r2]) {
            const i2 = { send: (t3, r3, o3, i3, s2, n2) => {
              this.actor.send(t3, r3, o3, e22, s2, n2);
            }, scheduler: this.actor.scheduler };
            this.workerSources[e22][o2][t2][r2] = new this.workerSourceTypes[t2](i2, this.getLayerIndex(e22, o2), this.getAvailableImages(e22, o2), this.isSpriteLoaded[e22][o2], void 0, this.brightness);
          }
          return this.workerSources[e22][o2][t2][r2];
        }
        getDEMWorkerSource(e22, t2, r2) {
          return this.demWorkerSources[e22] || (this.demWorkerSources[e22] = {}), this.demWorkerSources[e22][r2] || (this.demWorkerSources[e22][r2] = {}), this.demWorkerSources[e22][r2][t2] || (this.demWorkerSources[e22][r2][t2] = new i()), this.demWorkerSources[e22][r2][t2];
        }
        enforceCacheSizeLimit(t2, r2) {
          e.dr(r2);
        }
        getWorkerPerformanceMetrics(e22, t2, r2) {
          r2(void 0, void 0);
        }
      }
      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new q(self)), q;
    });
    define2(["./shared"], function(e) {
      function t(e22, i2) {
        if (Array.isArray(e22)) {
          if (!Array.isArray(i2) || e22.length !== i2.length)
            return false;
          for (let o2 = 0; o2 < e22.length; o2++)
            if (!t(e22[o2], i2[o2]))
              return false;
          return true;
        }
        if ("object" == typeof e22 && null !== e22 && null !== i2) {
          if ("object" != typeof i2)
            return false;
          if (Object.keys(e22).length !== Object.keys(i2).length)
            return false;
          for (const o2 in e22)
            if (!t(e22[o2], i2[o2]))
              return false;
          return true;
        }
        return e22 === i2;
      }
      var i = o;
      function o(e22) {
        return !function(e3) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var e4, t3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
            try {
              t3 = new Worker(o2), e4 = true;
            } catch (t4) {
              e4 = false;
            }
            return t3 && t3.terminate(), URL.revokeObjectURL(o2), e4;
          }() ? function() {
            var e4 = document.createElement("canvas");
            e4.width = e4.height = 1;
            var t3 = e4.getContext("2d");
            if (!t3)
              return false;
            var i2 = t3.getImageData(0, 0, 1, 1);
            return i2 && i2.width === e4.width;
          }() ? (void 0 === r[t2 = e3 && e3.failIfMajorPerformanceCaveat] && (r[t2] = function(e4) {
            var t3, i2 = function(e52) {
              var t4 = document.createElement("canvas"), i3 = Object.create(o.webGLContextAttributes);
              return i3.failIfMajorPerformanceCaveat = e52, t4.getContext("webgl2", i3);
            }(e4);
            if (!i2)
              return false;
            try {
              t3 = i2.createShader(i2.VERTEX_SHADER);
            } catch (e52) {
              return false;
            }
            return !(!t3 || i2.isContextLost()) && (i2.shaderSource(t3, "void main() {}"), i2.compileShader(t3), true === i2.getShaderParameter(t3, i2.COMPILE_STATUS));
          }(t2)), r[t2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
          var t2;
        }(e22);
      }
      var r = {};
      function s(e22, t2, i2) {
        const o2 = document.createElement(e22);
        return null != t2 && (o2.className = t2), i2 && i2.appendChild(o2), o2;
      }
      function n(e22, t2, i2) {
        const o2 = document.createElementNS("http://www.w3.org/2000/svg", e22);
        for (const e3 of Object.keys(t2))
          o2.setAttributeNS(null, e3, String(t2[e3]));
        return i2 && i2.appendChild(o2), o2;
      }
      o.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      const a = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, l = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
      let c;
      function h() {
        a && l && (c = a[l], a[l] = "none");
      }
      function _() {
        a && l && (a[l] = c);
      }
      function d(e22) {
        e22.preventDefault(), e22.stopPropagation(), window.removeEventListener("click", d, true);
      }
      function u() {
        window.addEventListener("click", d, true), window.setTimeout(() => {
          window.removeEventListener("click", d, true);
        }, 0);
      }
      function p(e22, t2) {
        const i2 = e22.getBoundingClientRect();
        return g(e22, i2, t2);
      }
      function m(e22, t2) {
        const i2 = e22.getBoundingClientRect(), o2 = [];
        for (let r2 = 0; r2 < t2.length; r2++)
          o2.push(g(e22, i2, t2[r2]));
        return o2;
      }
      function f(e22) {
        return void 0 !== window.InstallTrigger && 2 === e22.button && e22.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e22.button;
      }
      function g(t2, i2, o2) {
        const r2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
        return new e.P((o2.clientX - i2.left) * r2, (o2.clientY - i2.top) * r2);
      }
      class v {
        constructor() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = true;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(e22, t2) {
          this._updatedSourceCaches[e22] = t2, this.setDirty();
        }
        discardSourceCacheUpdate(e22) {
          delete this._updatedSourceCaches[e22];
        }
        updateLayer(e22) {
          const t2 = e22.scope;
          this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._updatedLayers[t2].add(e22.id), this.setDirty();
        }
        removeLayer(e22) {
          const t2 = e22.scope;
          this._removedLayers[t2] = this._removedLayers[t2] || {}, this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._removedLayers[t2][e22.id] = e22, this._updatedLayers[t2].delete(e22.id), this._updatedPaintProps.delete(e22.fqid), this.setDirty();
        }
        getRemovedLayer(e22) {
          return this._removedLayers[e22.scope] ? this._removedLayers[e22.scope][e22.id] : null;
        }
        discardLayerRemoval(e22) {
          this._removedLayers[e22.scope] && delete this._removedLayers[e22.scope][e22.id];
        }
        getLayerUpdatesByScope() {
          const e22 = {};
          for (const t2 in this._updatedLayers)
            e22[t2] = e22[t2] || {}, e22[t2].updatedIds = Array.from(this._updatedLayers[t2].values());
          for (const t2 in this._removedLayers)
            e22[t2] = e22[t2] || {}, e22[t2].removedIds = Object.keys(this._removedLayers[t2]);
          return e22;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(e22) {
          this._updatedPaintProps.add(e22.fqid), this.setDirty();
        }
        getUpdatedImages() {
          return Array.from(this._updatedImages.values());
        }
        updateImage(e22) {
          this._updatedImages.add(e22), this.setDirty();
        }
        resetUpdatedImages() {
          this._updatedImages.clear();
        }
        reset() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
        }
      }
      const x = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class y {
        constructor(e22, t2, i2, o2, r2, s2) {
          this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.instanceCount = s2, this.context = e22;
          const n2 = e22.gl;
          this.buffer = n2.createBuffer(), e22.bindVertexBuffer.set(this.buffer), n2.bufferData(n2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? n2.DYNAMIC_DRAW : n2.STATIC_DRAW), this.dynamicDraw || r2 || t2.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e22) {
          const t2 = this.context.gl;
          this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e22.arrayBuffer);
        }
        enableAttributes(e22, t2) {
          for (let i2 = 0; i2 < this.attributes.length; i2++) {
            const o2 = t2.attributes[this.attributes[i2].name];
            void 0 !== o2 && e22.enableVertexAttribArray(o2);
          }
        }
        setVertexAttribPointers(e22, t2, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r2 = this.attributes[o2], s2 = t2.attributes[r2.name];
            void 0 !== s2 && e22.vertexAttribPointer(s2, r2.components, e22[x[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
          }
        }
        setVertexAttribDivisor(e22, t2, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r2 = t2.attributes[this.attributes[o2].name];
            void 0 !== r2 && this.instanceCount && this.instanceCount > 0 && e22.vertexAttribDivisor(r2, i2);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class b {
        constructor(e22) {
          this.gl = e22.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e22) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class w extends b {
        getDefault() {
          return e.C.transparent;
        }
        set(e22) {
          const t2 = this.current;
          (e22.r !== t2.r || e22.g !== t2.g || e22.b !== t2.b || e22.a !== t2.a || this.dirty) && (this.gl.clearColor(e22.r, e22.g, e22.b, e22.a), this.current = e22, this.dirty = false);
        }
      }
      class T extends b {
        getDefault() {
          return 1;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.clearDepth(e22), this.current = e22, this.dirty = false);
        }
      }
      class E extends b {
        getDefault() {
          return 0;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.clearStencil(e22), this.current = e22, this.dirty = false);
        }
      }
      class C extends b {
        getDefault() {
          return [true, true, true, true];
        }
        set(e22) {
          const t2 = this.current;
          (e22[0] !== t2[0] || e22[1] !== t2[1] || e22[2] !== t2[2] || e22[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class I extends b {
        getDefault() {
          return true;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.depthMask(e22), this.current = e22, this.dirty = false);
        }
      }
      class S extends b {
        getDefault() {
          return 255;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.stencilMask(e22), this.current = e22, this.dirty = false);
        }
      }
      class M extends b {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e22) {
          const t2 = this.current;
          (e22.func !== t2.func || e22.ref !== t2.ref || e22.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e22.func, e22.ref, e22.mask), this.current = e22, this.dirty = false);
        }
      }
      class L extends b {
        getDefault() {
          const e22 = this.gl;
          return [e22.KEEP, e22.KEEP, e22.KEEP];
        }
        set(e22) {
          const t2 = this.current;
          (e22[0] !== t2[0] || e22[1] !== t2[1] || e22[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e22[0], e22[1], e22[2]), this.current = e22, this.dirty = false);
        }
      }
      class P extends b {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e22 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e22, this.dirty = false;
        }
      }
      class D extends b {
        getDefault() {
          return [0, 1];
        }
        set(e22) {
          const t2 = this.current;
          (e22[0] !== t2[0] || e22[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e22[0], e22[1]), this.current = e22, this.dirty = false);
        }
      }
      class A extends b {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e22 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e22, this.dirty = false;
        }
      }
      class R extends b {
        getDefault() {
          return this.gl.LESS;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.depthFunc(e22), this.current = e22, this.dirty = false);
        }
      }
      class z extends b {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e22 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e22, this.dirty = false;
        }
      }
      class O extends b {
        getDefault() {
          const e22 = this.gl;
          return [e22.ONE, e22.ZERO, e22.ONE, e22.ZERO];
        }
        set(e22) {
          const t2 = this.current;
          (e22[0] !== t2[0] || e22[1] !== t2[1] || e22[2] !== t2[2] || e22[3] !== t2[3] || this.dirty) && (this.gl.blendFuncSeparate(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class F extends b {
        getDefault() {
          return e.C.transparent;
        }
        set(e22) {
          const t2 = this.current;
          (e22.r !== t2.r || e22.g !== t2.g || e22.b !== t2.b || e22.a !== t2.a || this.dirty) && (this.gl.blendColor(e22.r, e22.g, e22.b, e22.a), this.current = e22, this.dirty = false);
        }
      }
      class B extends b {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e22, e22), this.current = e22, this.dirty = false);
        }
      }
      class k extends b {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e22 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e22, this.dirty = false;
        }
      }
      class N extends b {
        getDefault() {
          return this.gl.BACK;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.cullFace(e22), this.current = e22, this.dirty = false);
        }
      }
      class U extends b {
        getDefault() {
          return this.gl.CCW;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.frontFace(e22), this.current = e22, this.dirty = false);
        }
      }
      let G = class extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.useProgram(e22), this.current = e22, this.dirty = false);
        }
      };
      class j extends b {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e22) {
          (e22 !== this.current || this.dirty) && (this.gl.activeTexture(e22), this.current = e22, this.dirty = false);
        }
      }
      class V extends b {
        getDefault() {
          const e22 = this.gl;
          return [0, 0, e22.drawingBufferWidth, e22.drawingBufferHeight];
        }
        set(e22) {
          const t2 = this.current;
          (e22[0] !== t2[0] || e22[1] !== t2[1] || e22[2] !== t2[2] || e22[3] !== t2[3] || this.dirty) && (this.gl.viewport(e22[0], e22[1], e22[2], e22[3]), this.current = e22, this.dirty = false);
        }
      }
      class Z extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindFramebuffer(t2.FRAMEBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class W extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindRenderbuffer(t2.RENDERBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class H extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindTexture(t2.TEXTURE_2D, e22), this.current = e22, this.dirty = false;
        }
      }
      class q extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindBuffer(t2.ARRAY_BUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class $ extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          const t2 = this.gl;
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class X extends b {
        getDefault() {
          return null;
        }
        set(e22) {
          this.gl && (e22 !== this.current || this.dirty) && (this.gl.bindVertexArray(e22), this.current = e22, this.dirty = false);
        }
      }
      class J extends b {
        getDefault() {
          return 4;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_ALIGNMENT, e22), this.current = e22, this.dirty = false;
        }
      }
      class Y extends b {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e22), this.current = e22, this.dirty = false;
        }
      }
      class K extends b {
        getDefault() {
          return false;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e22), this.current = e22, this.dirty = false;
        }
      }
      class Q extends b {
        constructor(e22, t2) {
          super(e22), this.context = e22, this.parent = t2;
        }
        getDefault() {
          return null;
        }
      }
      class ee extends Q {
        setDirty() {
          this.dirty = true;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e22, 0), this.current = e22, this.dirty = false;
        }
      }
      class te extends Q {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e22), this.current = e22, this.dirty = false;
        }
      }
      class ie extends Q {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e22) {
          if (e22 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferTexture2D(t2.FRAMEBUFFER, this.attachment(), t2.TEXTURE_2D, e22, 0), this.current = e22, this.dirty = false;
        }
      }
      class oe extends te {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class re2 {
        constructor(e22, t2, i2, o2, r2) {
          this.context = e22, this.width = t2, this.height = i2;
          const s2 = this.framebuffer = e22.gl.createFramebuffer();
          o2 && (this.colorAttachment = new ee(e22, s2)), r2 && (this.depthAttachmentType = r2, this.depthAttachment = "renderbuffer" === r2 ? new te(e22, s2) : new ie(e22, s2));
        }
        destroy() {
          const e22 = this.context.gl;
          if (this.colorAttachment) {
            const t2 = this.colorAttachment.get();
            t2 && e22.deleteTexture(t2);
          }
          if (this.depthAttachment && this.depthAttachmentType)
            if ("renderbuffer" === this.depthAttachmentType) {
              const t2 = this.depthAttachment.get();
              t2 && e22.deleteRenderbuffer(t2);
            } else {
              const t2 = this.depthAttachment.get();
              t2 && e22.deleteTexture(t2);
            }
          e22.deleteFramebuffer(this.framebuffer);
        }
      }
      class se {
        constructor(e22, t2) {
          this.gl = e22, this.clearColor = new w(this), this.clearDepth = new T(this), this.clearStencil = new E(this), this.colorMask = new C(this), this.depthMask = new I(this), this.stencilMask = new S(this), this.stencilFunc = new M(this), this.stencilOp = new L(this), this.stencilTest = new P(this), this.depthRange = new D(this), this.depthTest = new A(this), this.depthFunc = new R(this), this.blend = new z(this), this.blendFunc = new O(this), this.blendColor = new F(this), this.blendEquation = new B(this), this.cullFace = new k(this), this.cullFaceSide = new N(this), this.frontFace = new U(this), this.program = new G(this), this.activeTexture = new j(this), this.viewport = new V(this), this.bindFramebuffer = new Z(this), this.bindRenderbuffer = new W(this), this.bindTexture = new H(this), this.bindVertexBuffer = new q(this), this.bindElementBuffer = new $(this), this.bindVertexArrayOES = new X(this), this.pixelStoreUnpack = new J(this), this.pixelStoreUnpackPremultiplyAlpha = new Y(this), this.pixelStoreUnpackFlipY = new K(this), this.options = t2 ? { ...t2 } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e22.getExtension("EXT_texture_filter_anisotropic") || e22.getExtension("MOZ_EXT_texture_filter_anisotropic") || e22.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e22.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e22.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e22.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e22.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e22.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e22.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e22.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e22.getParameter(e22.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(t2, i2, o2) {
          return new e.I(this, t2, i2, o2);
        }
        createVertexBuffer(e22, t2, i2, o2, r2) {
          return new y(this, e22, t2, i2, o2, r2);
        }
        createRenderbuffer(e22, t2, i2) {
          const o2 = this.gl, r2 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, e22, t2, i2), this.bindRenderbuffer.set(null), r2;
        }
        createFramebuffer(e22, t2, i2, o2) {
          return new re2(this, e22, t2, i2, o2);
        }
        clear({ color: e22, depth: t2, stencil: i2, colorMask: o2 }) {
          const r2 = this.gl;
          let s2 = 0;
          e22 && (s2 |= r2.COLOR_BUFFER_BIT, this.clearColor.set(e22), this.colorMask.set(o2 || [true, true, true, true])), void 0 !== t2 && (s2 |= r2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (s2 |= r2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), r2.clear(s2);
        }
        setCullFace(e22) {
          false === e22.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e22.mode), this.frontFace.set(e22.frontFace));
        }
        setDepthMode(e22) {
          e22.func !== this.gl.ALWAYS || e22.mask ? (this.depthTest.set(true), this.depthFunc.set(e22.func), this.depthMask.set(e22.mask), this.depthRange.set(e22.range)) : this.depthTest.set(false);
        }
        setStencilMode(e22) {
          e22.test.func !== this.gl.ALWAYS || e22.mask ? (this.stencilTest.set(true), this.stencilMask.set(e22.mask), this.stencilOp.set([e22.fail, e22.depthFail, e22.pass]), this.stencilFunc.set({ func: e22.test.func, ref: e22.ref, mask: e22.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(i2) {
          t(i2.blendFunction, e.a.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i2.blendFunction), this.blendColor.set(i2.blendColor), i2.blendEquation ? this.blendEquation.set(i2.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(i2.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      class ne {
        constructor(e22 = 0, t2 = 0, i2 = 0, o2 = 0) {
          if (isNaN(e22) || e22 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e22, this.bottom = t2, this.left = i2, this.right = o2;
        }
        interpolate(t2, i2, o2) {
          return null != i2.top && null != t2.top && (this.top = e.n(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.n(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.n(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.n(t2.right, i2.right, o2)), this;
        }
        getCenter(t2, i2) {
          const o2 = e.c((this.left + t2 - this.right) / 2, 0, t2), r2 = e.c((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e.P(o2, r2);
        }
        equals(e22) {
          return this.top === e22.top && this.bottom === e22.bottom && this.left === e22.left && this.right === e22.right;
        }
        clone() {
          return new ne(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function ae(t2, i2) {
        const o2 = e.g(t2, 3);
        e.m.fromQuat(t2, i2), e.s(t2, 3, o2);
      }
      function le(t2, i2) {
        const o2 = e.q.identity([]);
        return e.q.rotateZ(o2, o2, -i2), e.q.rotateX(o2, o2, -t2), o2;
      }
      function ce(t2, i2) {
        const o2 = [t2[0], t2[1], 0], r2 = [i2[0], i2[1], 0];
        if (e.v.length(o2) >= 1e-15) {
          const t3 = e.v.normalize([], o2);
          e.v.scale(r2, t3, e.v.dot(r2, t3)), i2[0] = r2[0], i2[1] = r2[1];
        }
        const s2 = e.v.cross([], i2, t2);
        if (e.v.len(s2) < 1e-15)
          return null;
        const n2 = Math.atan2(-s2[1], s2[0]);
        return le(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), n2);
      }
      class he {
        constructor(e22, t2) {
          this.position = e22, this.orientation = t2;
        }
        get position() {
          return this._position;
        }
        set position(t2) {
          if (t2) {
            const i2 = t2 instanceof e.M ? t2 : new e.M(t2[0], t2[1], t2[2]);
            this._renderWorldCopies && (i2.x = e.w(i2.x, 0, 1)), this._position = i2;
          } else
            this._position = null;
        }
        lookAtPoint(t2, i2) {
          if (this.orientation = null, !this.position)
            return;
          const o2 = this.position, r2 = this._elevation ? this._elevation.getAtPointOrZero(e.M.fromLngLat(t2)) : 0, s2 = e.M.fromLngLat(t2, r2), n2 = [s2.x - o2.x, s2.y - o2.y, s2.z - o2.z];
          i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = ce(n2, i2);
        }
        setPitchBearing(t2, i2) {
          this.orientation = le(e.d(t2), e.d(-i2));
        }
      }
      class _e {
        constructor(t2, i2) {
          this._transform = e.m.identity([]), this.orientation = i2, this.position = t2;
        }
        get mercatorPosition() {
          const t2 = this.position;
          return new e.M(t2[0], t2[1], t2[2]);
        }
        get position() {
          const t2 = e.g(this._transform, 3);
          return [t2[0], t2[1], t2[2]];
        }
        set position(t2) {
          var i2;
          t2 && e.s(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t2) {
          this._orientation = t2 || e.q.identity([]), t2 && ae(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e22 = this.forward(), t2 = this.right();
          return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e22[0] * e22[0] + e22[1] * e22[1]), -e22[2]) };
        }
        setPitchBearing(e22, t2) {
          this._orientation = le(e22, t2), ae(this._transform, this._orientation);
        }
        forward() {
          const t2 = e.g(this._transform, 2);
          return [-t2[0], -t2[1], -t2[2]];
        }
        up() {
          const t2 = e.g(this._transform, 1);
          return [-t2[0], -t2[1], -t2[2]];
        }
        right() {
          const t2 = e.g(this._transform, 0);
          return [t2[0], t2[1], t2[2]];
        }
        getCameraToWorld(t2, i2) {
          const o2 = new Float64Array(16);
          return e.m.invert(o2, this.getWorldToCamera(t2, i2)), o2;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(t2, i2, o2) {
          const r2 = this.position;
          e.v.scale(r2, r2, -t2);
          const s2 = new Float64Array(16);
          return e.m.fromScaling(s2, [o2, o2, o2]), e.m.translate(s2, s2, r2), s2[10] *= i2, s2;
        }
        getWorldToCamera(t2, i2) {
          const o2 = new Float64Array(16), r2 = new Float64Array(4), s2 = this.position;
          return e.q.conjugate(r2, this._orientation), e.v.scale(s2, s2, -t2), e.m.fromQuat(o2, r2), e.m.translate(o2, o2, s2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
        }
        getCameraToClipPerspective(t2, i2, o2, r2) {
          const s2 = new Float64Array(16);
          return e.m.perspective(s2, t2, i2, o2, r2), s2;
        }
        getCameraToClipOrthographic(t2, i2, o2, r2, s2, n2) {
          const a2 = new Float64Array(16);
          return e.m.ortho(a2, t2, i2, o2, r2, s2, n2), a2;
        }
        getDistanceToElevation(t2, i2 = false) {
          const o2 = 0 === t2 ? 0 : e.b(t2, i2 ? e.l(this.position[1]) : this.position[1]), r2 = this.forward();
          return (o2 - this.position[2]) / r2[2];
        }
        clone() {
          return new _e([...this.position], [...this.orientation]);
        }
      }
      const de = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, ue = Math.tan(85 * Math.PI / 180);
      function pe(t2, i2, o2, r2, s2, n2, a2) {
        const l2 = e.m.create();
        if (o2)
          if ("globe" === n2.name) {
            const t3 = e.f(s2, i2);
            e.m.multiply(l2, l2, t3);
          } else {
            const t3 = e.h.invert([], a2);
            l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], r2 || e.m.rotateZ(l2, l2, s2.angle);
          }
        else
          e.m.multiply(l2, s2.labelPlaneMatrix, t2);
        return l2;
      }
      function me(e22, t2, i2, o2, r2, s2, n2) {
        const a2 = pe(e22, t2, i2, o2, r2, s2, n2);
        return "globe" === s2.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
      }
      function fe(t2, i2, o2, r2, s2, n2, a2) {
        if (o2) {
          if ("globe" === n2.name) {
            const l2 = pe(t2, i2, o2, r2, s2, n2, a2);
            return e.m.invert(l2, l2), e.m.multiply(l2, t2, l2), l2;
          }
          {
            const i3 = e.m.clone(t2), o3 = e.m.identity([]);
            return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.m.multiply(i3, i3, o3), r2 || e.m.rotateZ(i3, i3, -s2.angle), i3;
          }
        }
        return s2.glCoordMatrix;
      }
      function ge(t2, i2, o2, r2) {
        const s2 = [t2, i2, o2, 1];
        o2 ? e.e.transformMat4(s2, s2, r2) : Me(s2, s2, r2);
        const n2 = s2[3];
        return s2[0] /= n2, s2[1] /= n2, s2[2] /= n2, s2;
      }
      function ve(e22, t2) {
        return Math.min(0.5 + e22 / t2 * 0.5, 1.5);
      }
      function xe(e22, t2) {
        const i2 = e22[0] / e22[3], o2 = e22[1] / e22[3];
        return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
      }
      function ye(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22) {
        const _2 = o2.transform, d2 = r2 ? t2.textSizeData : t2.iconSizeData, u2 = e.i(d2, o2.transform.zoom), p2 = "globe" === _2.projection.name, m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], f2 = r2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
        f2.clear();
        let g2 = null;
        p2 && (g2 = r2 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
        const v2 = t2.lineVertexArray, x2 = r2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, y2 = o2.transform.width / o2.transform.height;
        let b2, w2 = false;
        for (let r3 = 0; r3 < x2.length; r3++) {
          const p3 = x2.get(r3), { numGlyphs: T2, writingMode: E2 } = p3;
          if (E2 !== e.W.vertical || w2 || b2 === e.W.horizontal || (w2 = true), b2 = E2, (p3.hidden || E2 === e.W.vertical) && !w2) {
            Se(T2, f2);
            continue;
          }
          w2 = false;
          const C2 = new e.P(p3.tileAnchorX, p3.tileAnchorY);
          let { x: I2, y: S2, z: M2 } = _2.projection.projectTilePoint(C2.x, C2.y, h22.canonical);
          if (c2) {
            const [e22, t3, i3] = c2(C2);
            I2 += e22, S2 += t3, M2 += i3;
          }
          const L2 = [I2, S2, M2, 1];
          if (e.e.transformMat4(L2, L2, i2), !xe(L2, m2)) {
            Se(T2, f2);
            continue;
          }
          const P2 = L2[3], D2 = ve(o2.transform.getCameraToCenterDistance(_2.projection), P2), A2 = e.j(d2, u2, p3), R2 = a2 ? A2 / D2 : A2 * D2, z2 = ge(I2, S2, M2, s2);
          if (z2[3] <= 0) {
            Se(T2, f2);
            continue;
          }
          let O2 = {};
          const F2 = a2 ? null : c2, B2 = Te(p3, R2, false, l2, i2, s2, n2, t2.glyphOffsetArray, v2, f2, g2, z2, C2, O2, y2, F2, _2.projection, h22, a2);
          w2 = B2.useVertical, F2 && B2.needsFlipping && (O2 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && Te(p3, R2, true, l2, i2, s2, n2, t2.glyphOffsetArray, v2, f2, g2, z2, C2, O2, y2, F2, _2.projection, h22, a2).notEnoughRoom) && Se(T2, f2);
        }
        r2 ? (t2.text.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.text.globeExtVertexBuffer && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(f2), g2 && t2.icon.globeExtVertexBuffer && t2.icon.globeExtVertexBuffer.updateData(g2));
      }
      function be(e22, t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2) {
        const { lineStartIndex: f2, glyphStartIndex: g2, segment: v2 } = a2, x2 = g2 + a2.numGlyphs, y2 = f2 + a2.lineLength, b2 = t2.getoffsetX(g2), w2 = t2.getoffsetX(x2 - 1), T2 = Ie(e22 * b2, i2, o2, r2, s2, n2, v2, f2, y2, l2, c2, h22, _2, d2, true, u2, p2, m2);
        if (!T2)
          return null;
        const E2 = Ie(e22 * w2, i2, o2, r2, s2, n2, v2, f2, y2, l2, c2, h22, _2, d2, true, u2, p2, m2);
        return E2 ? { first: T2, last: E2 } : null;
      }
      function we(t2, i2, o2, r2) {
        return t2 === e.W.horizontal && Math.abs(r2) > Math.abs(o2) ? { useVertical: true } : t2 === e.W.vertical ? r2 > 0 ? { needsFlipping: true } : null : i2 !== de.unknown && function(e22, t3) {
          return 0 === e22 || Math.abs(t3 / e22) > ue;
        }(o2, r2) ? i2 === de.flipRequired ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
      }
      function Te(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2, v2, x2) {
        const y2 = i2 / 24, b2 = t2.lineOffsetX * y2, w2 = t2.lineOffsetY * y2, { lineStartIndex: T2, glyphStartIndex: E2, numGlyphs: C2, segment: I2, writingMode: S2, flipState: M2 } = t2, L2 = T2 + t2.lineLength, P2 = (t3) => {
          if (_2) {
            const [i4, o4, r4] = t3.up, s3 = h22.length;
            e.u(_2, s3 + 0, i4, o4, r4), e.u(_2, s3 + 1, i4, o4, r4), e.u(_2, s3 + 2, i4, o4, r4), e.u(_2, s3 + 3, i4, o4, r4);
          }
          const [i3, o3, r3] = t3.point;
          e.k(h22, i3, o3, r3, t3.angle);
        };
        if (C2 > 1) {
          const e22 = be(y2, l2, b2, w2, o2, d2, u2, t2, c2, n2, p2, f2, false, g2, v2, x2);
          if (!e22)
            return { notEnoughRoom: true };
          if (r2 && !o2) {
            let [i3, o3, r3] = e22.first.point, [s3, n3, l3] = e22.last.point;
            [i3, o3] = ge(i3, o3, r3, a2), [s3, n3] = ge(s3, n3, l3, a2);
            const c3 = we(S2, M2, (s3 - i3) * m2, n3 - o3);
            if (t2.flipState = c3 && c3.needsFlipping ? de.flipRequired : de.flipNotRequired, c3)
              return c3;
          }
          P2(e22.first);
          for (let e3 = E2 + 1; e3 < E2 + C2 - 1; e3++) {
            const t3 = Ie(y2 * l2.getoffsetX(e3), b2, w2, o2, d2, u2, I2, T2, L2, c2, n2, p2, f2, false, false, g2, v2, x2);
            if (!t3)
              return h22.length -= 4 * (e3 - E2), { notEnoughRoom: true };
            P2(t3);
          }
          P2(e22.last);
        } else {
          if (r2 && !o2) {
            const i4 = ge(u2.x, u2.y, 0, s2), o3 = T2 + I2 + 1, r3 = new e.P(c2.getx(o3), c2.gety(o3)), n3 = ge(r3.x, r3.y, 0, s2), a3 = n3[3] > 0 ? n3 : Ce(u2, r3, i4, 1, s2, void 0, g2, v2.canonical), l3 = we(S2, M2, (a3[0] - i4[0]) * m2, a3[1] - i4[1]);
            if (t2.flipState = l3 && l3.needsFlipping ? de.flipRequired : de.flipNotRequired, l3)
              return l3;
          }
          const i3 = Ie(y2 * l2.getoffsetX(E2), b2, w2, o2, d2, u2, I2, T2, L2, c2, n2, p2, f2, false, false, g2, v2, x2);
          if (!i3)
            return { notEnoughRoom: true };
          P2(i3);
        }
        return {};
      }
      function Ee(e22, t2, i2, o2, r2) {
        const { x: s2, y: n2, z: a2 } = o2.projectTilePoint(e22.x, e22.y, t2);
        if (!r2)
          return ge(s2, n2, a2, i2);
        const [l2, c2, h22] = r2(e22);
        return ge(s2 + l2, n2 + c2, a2 + h22, i2);
      }
      function Ce(t2, i2, o2, r2, s2, n2, a2, l2) {
        const c2 = Ee(t2.sub(i2)._unit()._add(t2), l2, s2, a2, n2);
        return e.v.sub(c2, o2, c2), e.v.normalize(c2, c2), e.v.scaleAndAdd(c2, o2, c2, r2);
      }
      function Ie(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2, v2) {
        const x2 = r2 ? t2 - i2 : t2 + i2;
        let y2 = x2 > 0 ? 1 : -1, b2 = 0;
        r2 && (y2 *= -1, b2 = Math.PI), y2 < 0 && (b2 += Math.PI);
        let w2 = l2 + a2 + (y2 > 0 ? 0 : 1) | 0, T2 = s2, E2 = s2, C2 = 0, I2 = 0;
        const S2 = Math.abs(x2), M2 = [], L2 = [];
        let P2 = n2, D2 = P2;
        const A2 = () => Ce(D2, P2, E2, S2 - C2 + 1, _2, u2, f2, g2.canonical);
        for (; C2 + I2 <= S2; ) {
          if (w2 += y2, w2 < l2 || w2 >= c2)
            return null;
          if (E2 = T2, D2 = P2, M2.push(E2), p2 && L2.push(D2), P2 = new e.P(h22.getx(w2), h22.gety(w2)), T2 = d2[w2], !T2) {
            const e22 = Ee(P2, g2.canonical, _2, f2, u2);
            T2 = e22[3] > 0 ? d2[w2] = e22 : A2();
          }
          C2 += I2, I2 = e.v.distance(E2, T2);
        }
        m2 && u2 && (d2[w2] && (T2 = A2(), I2 = e.v.distance(E2, T2)), d2[w2] = T2);
        const R2 = (S2 - C2) / I2, z2 = P2.sub(D2)._mult(R2)._add(D2), O2 = e.v.sub([], T2, E2), F2 = e.v.scaleAndAdd([], E2, O2, R2);
        let B2 = [0, 0, 1], k2 = O2[0], N2 = O2[1];
        if (v2 && (B2 = f2.upVector(g2.canonical, z2.x, z2.y), 0 !== B2[0] || 0 !== B2[1] || 1 !== B2[2])) {
          const t3 = [B2[2], 0, -B2[0]], i3 = e.v.cross([], B2, t3);
          e.v.normalize(t3, t3), e.v.normalize(i3, i3), k2 = e.v.dot(O2, t3), N2 = e.v.dot(O2, i3);
        }
        if (o2) {
          const t3 = e.v.cross([], B2, O2);
          e.v.normalize(t3, t3), e.v.scaleAndAdd(F2, F2, t3, o2 * y2);
        }
        const U2 = b2 + Math.atan2(N2, k2);
        return M2.push(F2), p2 && L2.push(z2), { point: F2, angle: U2, path: M2, tilePath: L2, up: B2 };
      }
      function Se(e22, t2) {
        const i2 = t2.length, o2 = i2 + 4 * e22;
        t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
      }
      function Me(e22, t2, i2) {
        const o2 = t2[0], r2 = t2[1];
        return e22[0] = i2[0] * o2 + i2[4] * r2 + i2[12], e22[1] = i2[1] * o2 + i2[5] * r2 + i2[13], e22[3] = i2[3] * o2 + i2[7] * r2 + i2[15], e22;
      }
      const Le = (e22, t2, i2) => (1 - i2) * e22 + i2 * t2, Pe = (e22) => e22 * e22 * e22 * e22 * e22;
      class De {
        constructor(t2, i2, o2, r2, s2, n2, a2) {
          this.tileSize = 512, this._renderWorldCopies = void 0 === s2 || s2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setProjection(n2), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.L(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new ne(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new _e(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false;
        }
        clone() {
          const e22 = new De(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return e22._elevation = this._elevation, e22._centerAltitude = this._centerAltitude, e22._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e22.tileSize = this.tileSize, e22.mercatorFromTransition = this.mercatorFromTransition, e22.width = this.width, e22.height = this.height, e22.cameraElevationReference = this.cameraElevationReference, e22._center = this._center, e22._setZoom(this.zoom), e22._seaLevelZoom = this._seaLevelZoom, e22.angle = this.angle, e22._fov = this._fov, e22._pitch = this._pitch, e22._nearZ = this._nearZ, e22._farZ = this._farZ, e22._averageElevation = this._averageElevation, e22._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e22._unmodified = this._unmodified, e22._edgeInsets = this._edgeInsets.clone(), e22._camera = this._camera.clone(), e22._calcMatrices(), e22.freezeTileCoverage = this.freezeTileCoverage, e22.frustumCorners = this.frustumCorners, e22;
        }
        get isOrthographic() {
          return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e22) {
          this._elevation !== e22 && (this._elevation = e22, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return "globe" !== this.projection.name && !this.isOrthographic;
        }
        updateElevation(e22, t2 = false) {
          const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e22 || i2) && this._constrainCamera(t2), this._calcMatrices();
        }
        getProjection() {
          return e.p(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(i2) {
          this.projectionOptions = i2 || { name: "mercator" };
          const o2 = this.projection ? this.getProjection() : void 0;
          this.projection = e.o(this.projectionOptions);
          const r2 = !t(o2, this.getProjection());
          return r2 && this._calcMatrices(), this.mercatorFromTransition = false, r2;
        }
        setOrthographicProjectionAtLowPitch(e22) {
          return this._orthographicProjectionAtLowPitch !== e22 && (this._orthographicProjectionAtLowPitch = e22, this._calcMatrices(), true);
        }
        setMercatorFromTransition() {
          const t2 = this.projection.name;
          this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.o({ name: "mercator" });
          const i2 = t2 !== this.projection.name;
          return i2 && this._calcMatrices(), i2;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e22) {
          this._minZoom !== e22 && (this._minZoom = e22, this.zoom = Math.max(this.zoom, e22));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e22) {
          this._maxZoom !== e22 && (this._maxZoom = e22, this.zoom = Math.min(this.zoom, e22));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e22) {
          this._minPitch !== e22 && (this._minPitch = e22, this.pitch = Math.max(this.pitch, e22));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e22) {
          this._maxPitch !== e22 && (this._maxPitch = e22, this.pitch = Math.min(this.pitch, e22));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
        }
        set renderWorldCopies(e22) {
          void 0 === e22 ? e22 = true : null === e22 && (e22 = false), this._renderWorldCopies = e22;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const e22 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e22));
        }
        get cameraWorldSize() {
          const e22 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e22));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return e.b(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.P(this.width, this.height);
        }
        get bearing() {
          return e.w(this.rotation, -180, 180);
        }
        set bearing(e22) {
          this.rotation = e22;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t2) {
          const i2 = -t2 * Math.PI / 180;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = e.h.create(), e.h.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t2) {
          const i2 = e.c(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const e22 = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / e22);
        }
        set fov(t2) {
          t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.d(t2), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e22) {
          this._averageElevation = e22, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e22) {
          const t2 = Math.min(Math.max(e22, this.minZoom), this.maxZoom);
          this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e22) {
          this._zoom = e22, this.scale = this.zoomScale(e22), this.tileZoom = Math.floor(e22), this.zoomFraction = e22 - this.tileZoom;
        }
        _updateCameraOnTerrain() {
          const e22 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t2 = this.elevation && e22 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || e22 === Number.NEGATIVE_INFINITY && (!t2 || !this._centerAltitude))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const i2 = this._elevation;
          t2 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i2.exaggeration() && this._centerAltitudeValidForExaggeration !== i2.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i2.exaggeration(), this._centerAltitudeValidForExaggeration = i2.exaggeration()) : (this._centerAltitude = e22 || 0, this._centerAltitudeValidForExaggeration = i2.exaggeration()), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
          let r2 = 0, s2 = 0;
          for (let n2 = 0; n2 < i2.length; n2++) {
            const a2 = new e.P(i2[n2][0] * this.width, o2 + i2[n2][1] * (this.height - o2)), l2 = t2.pointCoordinate(a2);
            if (!l2)
              continue;
            const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
            r2 += l2[3] * c2, s2 += c2;
          }
          return 0 === s2 ? NaN : r2 / s2;
        }
        get center() {
          return this._center;
        }
        set center(e22) {
          e22.lat === this._center.lat && e22.lng === this._center.lng || (this._unmodified = false, this._center = e22, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (null == this._seaLevelZoom || !this._elevation)
            return;
          const e22 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e22), r2 = this._mercatorZfromZoom(this._maxZoom), s2 = Math.max(o2 - i2, r2);
          this._setZoom(this._zoomFromMercatorZ(s2));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e22) {
          this._edgeInsets.equals(e22) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e22, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t2) {
          const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
          let o2;
          o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
          const r2 = e.v.length(e.v.sub([], this._camera.position, o2));
          return e.c(this._zoomFromMercatorZ(r2), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t2) {
          if (!this.height)
            return;
          if (!t2.position && !t2.orientation)
            return;
          this._updateCameraState();
          let i2 = false;
          if (t2.orientation && !e.q.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
            const o2 = [t2.position.x, t2.position.y, t2.position.z];
            e.v.exactEquals(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
          }
          i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t2 = this._camera.position, i2 = new he();
          return i2.position = new e.M(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
        }
        _setCameraOrientation(t2) {
          if (!e.q.length(t2))
            return false;
          e.q.normalize(t2, t2);
          const i2 = e.v.transformQuat([], [0, 0, -1], t2), o2 = e.v.transformQuat([], [0, -1, 0], t2);
          if (o2[2] < 0)
            return false;
          const r2 = ce(i2, o2);
          return !!r2 && (this._camera.orientation = r2, true);
        }
        _setCameraPosition(t2) {
          const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r2 = this.cameraToCenterDistance;
          t2[2] = e.c(t2[2], r2 / o2, r2 / i2), this._camera.position = t2;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e22) {
          return this._edgeInsets.equals(e22);
        }
        interpolatePadding(e22, t2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e22, t2, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e22) {
          const t2 = (e22.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e22.tileSize));
          return Math.max(0, t2);
        }
        getVisibleUnwrappedCoordinates(t2) {
          const i2 = [new e.U(0, t2)];
          if (this.renderWorldCopies) {
            const o2 = this.pointCoordinate(new e.P(0, 0)), r2 = this.pointCoordinate(new e.P(this.width, 0)), s2 = this.pointCoordinate(new e.P(this.width, this.height)), n2 = this.pointCoordinate(new e.P(0, this.height)), a2 = Math.floor(Math.min(o2.x, r2.x, s2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, s2.x, n2.x)), c2 = 1;
            for (let o3 = a2 - c2; o3 <= l2 + c2; o3++)
              0 !== o3 && i2.push(new e.U(o3, t2));
          }
          return i2;
        }
        isLODDisabled(e22) {
          return (!e22 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCoverForShadows(t2, i2, o2) {
          let r2 = [];
          if (0 === i2[0] && 0 === i2[1])
            return r2;
          for (const o3 of t2) {
            const t3 = o3.canonical, s3 = o3.overscaledZ, n2 = o3.wrap, a2 = 1 << t3.z, l2 = t3.x + 1 < a2, c2 = t3.x > 0, h22 = t3.y + 1 < a2, _2 = t3.y > 0, d2 = o3.wrap - (c2 ? 0 : 1), u2 = o3.wrap + (l2 ? 0 : 1), p2 = c2 ? t3.x - 1 : a2 - 1, m2 = l2 ? t3.x + 1 : 0;
            i2[0] < 0 ? (r2.push(new e.O(s3, u2, t3.z, m2, t3.y)), i2[1] < 0 && h22 && (r2.push(new e.O(s3, n2, t3.z, t3.x, t3.y + 1)), r2.push(new e.O(s3, u2, t3.z, m2, t3.y + 1))), i2[1] > 0 && _2 && (r2.push(new e.O(s3, n2, t3.z, t3.x, t3.y - 1)), r2.push(new e.O(s3, u2, t3.z, m2, t3.y - 1)))) : i2[0] > 0 ? (r2.push(new e.O(s3, d2, t3.z, p2, t3.y)), i2[1] < 0 && h22 && (r2.push(new e.O(s3, n2, t3.z, t3.x, t3.y + 1)), r2.push(new e.O(s3, d2, t3.z, p2, t3.y + 1))), i2[1] > 0 && _2 && (r2.push(new e.O(s3, n2, t3.z, t3.x, t3.y - 1)), r2.push(new e.O(s3, d2, t3.z, p2, t3.y - 1)))) : i2[1] < 0 && h22 ? r2.push(new e.O(s3, n2, t3.z, t3.x, t3.y + 1)) : _2 && r2.push(new e.O(s3, n2, t3.z, t3.x, t3.y - 1));
          }
          if (r2.length > 1) {
            r2.sort((e3, t4) => e3.overscaledZ - t4.overscaledZ || e3.wrap - t4.wrap || e3.canonical.z - t4.canonical.z || e3.canonical.x - t4.canonical.x || e3.canonical.y - t4.canonical.y);
            let e22 = 0, t3 = 0;
            for (; t3 < r2.length; )
              r2[t3].equals(r2[e22]) ? ++t3 : r2[++e22] = r2[t3++];
            r2.length = e22 + 1;
          }
          const s2 = [];
          for (const e22 of r2)
            r2.some((t3) => e22.isChildOf(t3)) || s2.push(e22);
          return r2 = s2.filter((e22) => !t2.some((t3) => !!(e22.overscaledZ < o2 && t3.isChildOf(e22)) || e22.equals(t3) || e22.isChildOf(t3))), r2;
        }
        coveringTiles(t2) {
          let i2 = this.coveringZoomLevel(t2);
          const o2 = i2, r2 = this.elevation && this.elevation.exaggeration(), s2 = r2 && !t2.isTerrainDEM, n2 = "mercator" === this.projection.name;
          if (void 0 !== t2.minzoom && i2 < t2.minzoom)
            return [];
          void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
          const a2 = this.locationCoordinate(this.center), l2 = this.center.lat, c2 = 1 << i2, h22 = [c2 * a2.x, c2 * a2.y, 0], _2 = "globe" === this.projection.name, d2 = !_2, u2 = e.F.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, d2), p2 = _2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), m2 = c2 * e.b(1, this.center.lat), f2 = this._camera.position[2] / e.b(1, this.center.lat), g2 = [c2 * p2.x, c2 * p2.y, f2 * (d2 ? 1 : m2)], v2 = _2 || r2, x2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), y2 = this.isLODDisabled(true) ? i2 : 0;
          let b2;
          if (this._elevation && t2.isTerrainDEM)
            b2 = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const e22 = this._elevation.getMinMaxForVisibleTiles();
            b2 = e22 ? e22.max : this._centerAltitude;
          } else
            b2 = this._centerAltitude;
          const w2 = t2.isTerrainDEM ? -b2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T2 = this.projection.isReprojectedInTileSpace ? e.r(this) : 1, E2 = (t3) => {
            const i3 = 1 / 4e4, o3 = new e.M(t3.x + i3, t3.y, t3.z), r3 = new e.M(t3.x, t3.y + i3, t3.z), s3 = t3.toLngLat(), n3 = o3.toLngLat(), a3 = r3.toLngLat(), l3 = this.locationCoordinate(s3), c3 = this.locationCoordinate(n3), h3 = this.locationCoordinate(a3), _3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), d3 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
            return Math.sqrt(_3 * d3) * T2 / i3;
          }, C2 = (t3) => {
            const i3 = b2, o3 = w2;
            return { aabb: e.y(this, c2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
          }, I2 = [];
          let S2 = [];
          const M2 = i2, L2 = t2.reparseOverscaled ? o2 : i2, P2 = (e22) => e22 * e22, D2 = P2((f2 - this._centerAltitude) * m2), A2 = (e22) => {
            if (!this._elevation || !e22.tileID || !n2)
              return;
            const t3 = this._elevation.getMinMaxForTile(e22.tileID), i3 = e22.aabb;
            t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e22.shouldSplit = R2(e22), e22.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, R2 = (t3) => {
            if (t3.zoom < y2)
              return true;
            if (t3.zoom === M2)
              return false;
            if (null != t3.shouldSplit)
              return t3.shouldSplit;
            const i3 = t3.aabb.distanceX(g2), r3 = t3.aabb.distanceY(g2);
            let n3 = D2, a3 = 1;
            if (_2) {
              n3 = P2(t3.aabb.distanceZ(g2));
              const i4 = Math.pow(2, t3.zoom), o3 = e.l((t3.y + 1) / i4), r4 = e.l(t3.y / i4), s3 = Math.min(Math.max(l2, o3), r4), c4 = e.a0(s3) / e.a0(l2);
              if (a3 = s3 === l2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c4 / this._mercatorScaleRatio), this.zoom <= e.Z && t3.zoom === M2 - 1 && c4 >= 0.9)
                return true;
            } else if (s2 && (n3 = P2(t3.aabb.distanceZ(g2) * m2)), this.projection.isReprojectedInTileSpace && o2 <= 5) {
              const i4 = Math.pow(2, t3.zoom), o3 = E2(new e.M((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
              a3 = o3 > 0.85 ? 1 : o3;
            }
            const c3 = i3 * i3 + r3 * r3 + n3, h3 = P2((1 << M2 - t3.zoom) * x2 * a3 * ((e22, t4) => {
              if (t4 * P2(0.707) < e22)
                return 1;
              const i4 = Math.sqrt(t4 / e22);
              return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(n3, D2), c3));
            return c3 < h3;
          };
          if (this.renderWorldCopies)
            for (let e22 = 1; e22 <= 3; e22++)
              I2.push(C2(-e22)), I2.push(C2(e22));
          for (I2.push(C2(0)); I2.length > 0; ) {
            const o3 = I2.pop(), r3 = o3.x, a3 = o3.y;
            let l3 = o3.fullyVisible;
            const d3 = () => "globe" === this.projection.name && (0 === o3.y || o3.y === (1 << o3.zoom) - 1);
            if (!l3) {
              let t3 = v2 ? o3.aabb.intersects(u2) : o3.aabb.intersectsFlat(u2);
              if (0 === t3 && d3()) {
                const i3 = new e.t(o3.zoom, r3, a3);
                t3 = e.x(this, c2, i3, true).intersects(u2);
              }
              if (0 === t3)
                continue;
              l3 = 2 === t3;
            }
            if (o3.zoom !== M2 && R2(o3))
              for (let t3 = 0; t3 < 4; t3++) {
                const i3 = (r3 << 1) + t3 % 2, h3 = (a3 << 1) + (t3 >> 1), d4 = { aabb: n2 ? o3.aabb.quadrant(t3) : e.y(this, c2, o3.zoom + 1, i3, h3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: h3, wrap: o3.wrap, fullyVisible: l3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                s2 && !_2 && (d4.tileID = new e.O(o3.zoom + 1 === M2 ? L2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, h3), A2(d4)), I2.push(d4);
              }
            else {
              const s3 = o3.zoom === M2 ? L2 : o3.zoom;
              if (t2.minzoom && t2.minzoom > s3)
                continue;
              if (!l3) {
                let t3 = v2 ? o3.aabb.intersectsPrecise(u2) : o3.aabb.intersectsPreciseFlat(u2);
                if (0 === t3 && d3()) {
                  const i3 = new e.t(o3.zoom, r3, a3);
                  t3 = e.x(this, c2, i3, true).intersectsPrecise(u2);
                }
                if (0 === t3)
                  continue;
              }
              const n3 = h22[0] - (0.5 + r3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), _3 = h22[1] - 0.5 - a3, p3 = o3.tileID ? o3.tileID : new e.O(s3, o3.wrap, o3.zoom, r3, a3);
              S2.push({ tileID: p3, distanceSq: n3 * n3 + _3 * _3 });
            }
          }
          if (this.fogCullDistSq) {
            const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
            S2 = S2.filter((r3) => {
              const s3 = [0, 0, 0, 1], n3 = [e.J, e.J, 0, 1], a3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
              e.e.transformMat4(s3, s3, a3), e.e.transformMat4(n3, n3, a3);
              const l3 = e.e.min([], s3, n3), c3 = e.e.max([], s3, n3), h3 = e.z(l3, c3);
              if (0 === h3)
                return true;
              let _3 = false;
              const d3 = this._elevation;
              if (d3 && h3 > i3 && 0 !== o3) {
                const i4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                let s4;
                t2.isTerrainDEM || (s4 = d3.getMinMaxForTile(r3.tileID)), s4 || (s4 = { min: w2, max: b2 });
                const n4 = e._(this.rotation), a4 = [n4[0] * e.J, n4[1] * e.J, s4.max];
                e.v.transformMat4(a4, a4, i4), _3 = (1 - a4[1]) * this.height * 0.5 < o3;
              }
              return h3 < i3 || _3;
            });
          }
          return S2.sort((e22, t3) => e22.distanceSq - t3.distanceSq).map((e22) => e22.tileID);
        }
        resize(e22, t2) {
          this.width = e22, this.height = t2, this.pixelsToGLUnits = [2 / e22, -2 / t2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e22) {
          return Math.pow(2, e22);
        }
        scaleZoom(e22) {
          return Math.log(e22) / Math.LN2;
        }
        project(t2) {
          const i2 = e.c(t2.lat, -e.A, e.A), o2 = this.projection.project(t2.lng, i2);
          return new e.P(o2.x * this.worldSize, o2.y * this.worldSize);
        }
        unproject(e22) {
          return this.projection.unproject(e22.x / this.worldSize, e22.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / e.b(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t2, i2) {
          let o2, r2;
          const s2 = this.centerPoint;
          if ("globe" === this.projection.name) {
            const e22 = this.worldSize;
            o2 = (i2.x - s2.x) / e22, r2 = (i2.y - s2.y) / e22;
          } else {
            const e22 = this.pointCoordinate(i2), t3 = this.pointCoordinate(s2);
            o2 = e22.x - t3.x, r2 = e22.y - t3.y;
          }
          const n2 = this.locationCoordinate(t2);
          this.setLocation(new e.M(n2.x - o2, n2.y - r2));
        }
        setLocation(e22) {
          this.center = this.coordinateLocation(e22), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(e22) {
          return this.projection.locationPoint(this, e22);
        }
        locationPoint3D(e22) {
          return this.projection.locationPoint(this, e22, true);
        }
        pointLocation(e22) {
          return this.coordinateLocation(this.pointCoordinate(e22));
        }
        pointLocation3D(e22) {
          return this.coordinateLocation(this.pointCoordinate3D(e22));
        }
        locationCoordinate(t2, i2) {
          const o2 = i2 ? e.b(i2, t2.lat) : void 0, r2 = this.projection.project(t2.lng, t2.lat);
          return new e.M(r2.x, r2.y, o2);
        }
        coordinateLocation(e22) {
          return this.projection.unproject(e22.x, e22.y);
        }
        pointRayIntersection(t2, i2) {
          const o2 = null != i2 ? i2 : this._centerAltitude, r2 = [t2.x, t2.y, 0, 1], s2 = [t2.x, t2.y, 1, 1];
          e.e.transformMat4(r2, r2, this.pixelMatrixInverse), e.e.transformMat4(s2, s2, this.pixelMatrixInverse);
          const n2 = s2[3];
          e.e.scale(r2, r2, 1 / r2[3]), e.e.scale(s2, s2, 1 / n2);
          const a2 = r2[2], l2 = s2[2];
          return { p0: r2, p1: s2, t: a2 === l2 ? 0 : (o2 - a2) / (l2 - a2) };
        }
        screenPointToMercatorRay(t2) {
          const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
          return e.e.transformMat4(i2, i2, this.pixelMatrixInverse), e.e.transformMat4(o2, o2, this.pixelMatrixInverse), e.e.scale(i2, i2, 1 / i2[3]), e.e.scale(o2, o2, 1 / o2[3]), i2[2] = e.b(i2[2], this._center.lat) * this.worldSize, o2[2] = e.b(o2[2], this._center.lat) * this.worldSize, e.e.scale(i2, i2, 1 / this.worldSize), e.e.scale(o2, o2, 1 / this.worldSize), new e.R([i2[0], i2[1], i2[2]], e.v.normalize([], e.v.sub([], o2, i2)));
        }
        rayIntersectionCoordinate(t2) {
          const { p0: i2, p1: o2, t: r2 } = t2, s2 = e.b(i2[2], this._center.lat), n2 = e.b(o2[2], this._center.lat);
          return new e.M(e.n(i2[0], o2[0], r2) / this.worldSize, e.n(i2[1], o2[1], r2) / this.worldSize, e.n(s2, n2, r2));
        }
        pointCoordinate(e22, t2 = this._centerAltitude) {
          return this.projection.pointCoordinate(this, e22.x, e22.y, t2);
        }
        pointCoordinate3D(t2) {
          if (!this.elevation)
            return this.pointCoordinate(t2);
          let i2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
          if (i2)
            return new e.M(i2[0], i2[1], i2[2]);
          let o2 = 0, r2 = this.horizonLineFromTop();
          if (t2.y > r2)
            return this.pointCoordinate(t2);
          const s2 = 0.02 * r2, n2 = t2.clone();
          for (let t3 = 0; t3 < 10 && r2 - o2 > s2; t3++) {
            n2.y = e.n(o2, r2, 0.66);
            const t4 = this.projection.pointCoordinate3D(this, n2.x, n2.y);
            t4 ? (r2 = n2.y, i2 = t4) : o2 = n2.y;
          }
          return i2 ? new e.M(i2[0], i2[1], i2[2]) : this.pointCoordinate(t2);
        }
        isPointAboveHorizon(e22) {
          return this.projection.isPointAboveHorizon(this, e22);
        }
        isPointOnSurface(t2) {
          if (t2.y < 0 || t2.y > this.height || t2.x < 0 || t2.x > this.width)
            return false;
          if (this.elevation || this.zoom >= e.G)
            return !this.isPointAboveHorizon(t2);
          const i2 = this.pointCoordinate(t2);
          return i2.y >= 0 && i2.y <= 1;
        }
        _coordinatePoint(t2, i2) {
          const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
          return e.e.transformMat4(r2, r2, this.pixelMatrix), r2[3] > 0 ? new e.P(r2[0] / r2[3], r2[1] / r2[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, r2 = this.width - this._edgeInsets.right, s2 = this.pointLocation3D(new e.P(i2, t2)), n2 = this.pointLocation3D(new e.P(r2, t2)), a2 = this.pointLocation3D(new e.P(r2, o2)), l2 = this.pointLocation3D(new e.P(i2, o2));
          let c2 = Math.min(s2.lng, n2.lng, a2.lng, l2.lng), h22 = Math.max(s2.lng, n2.lng, a2.lng, l2.lng), _2 = Math.min(s2.lat, n2.lat, a2.lat, l2.lat), d2 = Math.max(s2.lat, n2.lat, a2.lat, l2.lat);
          const u2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = "globe" === this.projection.name ? 1 : 4, m2 = (t3, i3, o3, r3, s3) => {
            const n3 = (t3 + o3) / 2, a3 = (i3 + r3) / 2, l3 = new e.P(n3, a3), { lng: f2, lat: g2 } = this.pointLocation3D(l3), v2 = Math.max(0, c2 - f2, _2 - g2, f2 - h22, g2 - d2);
            c2 = Math.min(c2, f2), h22 = Math.max(h22, f2), _2 = Math.min(_2, g2), d2 = Math.max(d2, g2), (s3 < p2 || v2 > u2) && (m2(t3, i3, n3, a3, s3 + 1), m2(n3, a3, o3, r3, s3 + 1));
          };
          if (m2(i2, t2, r2, t2, 1), m2(r2, t2, r2, o2, 1), m2(r2, o2, i2, o2, 1), m2(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
            const [t3, i3] = e.B(this);
            t3 ? (d2 = 90, h22 = 180, c2 = -180) : i3 && (_2 = -90, h22 = 180, c2 = -180);
          }
          return new e.D(new e.L(c2, _2), new e.L(h22, d2));
        }
        _getBoundsRectangular(t2, i2) {
          const { top: o2, left: r2 } = this._edgeInsets, s2 = this.height - this._edgeInsets.bottom, n2 = this.width - this._edgeInsets.right, a2 = new e.P(r2, o2), l2 = new e.P(n2, o2), c2 = new e.P(n2, s2), h22 = new e.P(r2, s2);
          let _2 = this.pointCoordinate(a2, t2), d2 = this.pointCoordinate(l2, t2);
          const u2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h22, i2), m2 = (e22, t3) => (t3.y - e22.y) / (t3.x - e22.x);
          return _2.y > 1 && d2.y >= 0 ? _2 = new e.M((1 - p2.y) / m2(p2, _2) + p2.x, 1) : _2.y < 0 && d2.y <= 1 && (_2 = new e.M(-p2.y / m2(p2, _2) + p2.x, 0)), d2.y > 1 && _2.y >= 0 ? d2 = new e.M((1 - u2.y) / m2(u2, d2) + u2.x, 1) : d2.y < 0 && _2.y <= 1 && (d2 = new e.M(-u2.y / m2(u2, d2) + u2.x, 0)), new e.D().extend(this.coordinateLocation(_2)).extend(this.coordinateLocation(d2)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(u2));
        }
        _getBoundsRectangularTerrain() {
          const e22 = this.elevation;
          if (!e22.visibleDemTiles.length || e22.isUsingMockSource())
            return this._getBoundsRectangular(0, 0);
          const t2 = e22.visibleDemTiles.reduce((e3, t3) => {
            if (t3.dem) {
              const i2 = t3.dem.tree;
              e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(t2.min * e22.exaggeration(), t2.max * e22.exaggeration());
        }
        getBounds() {
          return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(e22 = true) {
          const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
          return e22 ? Math.max(0, i2) : i2;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t2) {
          this.maxBounds = t2, this.minLat = -e.A, this.maxLat = e.A, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.E(this.minLng) * this.tileSize, this.worldMaxX = e.E(this.maxLng) * this.tileSize, this.worldMinY = e.H(this.maxLat) * this.tileSize, this.worldMaxY = e.H(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(e22, t2) {
          return this.projection.createTileMatrix(this, t2, e22);
        }
        calculateDistanceTileData(t2) {
          const i2 = t2.key, o2 = this._distanceTileDataCache;
          if (o2[i2])
            return o2[i2];
          const r2 = t2.canonical, s2 = 1 / this.height, n2 = this.cameraWorldSize, a2 = n2 / this.zoomScale(r2.z), l2 = (r2.x + Math.pow(2, r2.z) * t2.wrap) * a2, c2 = r2.y * a2, h22 = this.point;
          h22.x *= n2 / this.worldSize, h22.y *= n2 / this.worldSize;
          const _2 = this.angle, d2 = Math.sin(-_2), u2 = -Math.cos(-_2);
          return o2[i2] = { bearing: [d2, u2], center: [(h22.x - l2) * s2, (h22.y - c2) * s2], scale: a2 / e.J * s2 }, o2[i2];
        }
        calculateFogTileMatrix(t2) {
          const i2 = t2.key, o2 = this._fogTileMatrixCache;
          if (o2[i2])
            return o2[i2];
          const r2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
          return e.m.multiply(r2, this.worldToFogMatrix, r2), o2[i2] = new Float32Array(r2), o2[i2];
        }
        calculateProjMatrix(t2, i2 = false, o2 = false) {
          const r2 = t2.key;
          let s2;
          if (s2 = o2 ? this._expandedProjMatrixCache : i2 ? this._alignedProjMatrixCache : this._projMatrixCache, s2[r2])
            return s2[r2];
          const n2 = this.calculatePosMatrix(t2, this.worldSize);
          let a2;
          return a2 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o2 ? this.expandedFarZProjMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, e.m.multiply(n2, a2, n2), s2[r2] = new Float32Array(n2), s2[r2];
        }
        calculatePixelsToTileUnitsMatrix(t2) {
          const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
          if (o2[i2])
            return o2[i2];
          const r2 = e.K(t2, this);
          return o2[i2] = r2, o2[i2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if ("globe" === this.projection.name) {
            const t2 = 1 / this.worldSize, i2 = e.m.fromScaling([], [t2, t2, t2]);
            return e.m.multiply(i2, i2, this.globeMatrix), i2;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || "globe" === this.projection.name)
            return;
          const t2 = this._elevation;
          this._updateCameraState();
          const i2 = e.b(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), r2 = this._camera.forward(), s2 = e.b(1, this._center.lat);
          o2[2] /= s2, r2[2] /= s2, e.v.normalize(r2, r2);
          const n2 = t2.raycast(o2, r2, t2.exaggeration());
          if (n2) {
            const t3 = e.v.scaleAndAdd([], o2, r2, n2), i3 = new e.M(t3[0], t3[1], e.b(t3[2], e.l(t3[1]))), a2 = (i3.z + e.v.length([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * s2])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t2 = false) {
          if (!this._elevation)
            return;
          const i2 = this._elevation, o2 = e.b(1, this._center.lat) * this.worldSize, r2 = this._computeCameraPosition(o2), s2 = i2.getAtPointOrZero(new e.M(...r2)), n2 = this.pixelsPerMeter / this.worldSize * s2, a2 = this._minimumHeightOverTerrain(), l2 = r2[2] - n2;
          if (l2 <= a2)
            if (l2 < 0 || t2) {
              const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [r2[0], r2[1], t3.z - r2[2]], o3 = e.v.length(i3);
              i3[2] -= (a2 - l2) / this._pixelsPerMercatorPixel;
              const s3 = e.v.length(i3);
              if (0 === s3)
                return;
              e.v.scale(i3, i3, o3 / s3 * this._pixelsPerMercatorPixel), this._camera.position = [r2[0], r2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = true;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t2) {
            const i3 = this.center;
            return i3.lat = e.c(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.c(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
          }
          const i2 = this._unmodified, { x: o2, y: r2 } = this.point;
          let s2 = 0, n2 = o2, a2 = r2;
          const l2 = this.width / 2, c2 = this.height / 2, h22 = this.worldMinY * this.scale, _2 = this.worldMaxY * this.scale;
          if (r2 - c2 < h22 && (a2 = h22 + c2), r2 + c2 > _2 && (a2 = _2 - c2), _2 - h22 < this.height && (s2 = Math.max(s2, this.height / (_2 - h22)), a2 = (_2 + h22) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const e22 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e22 + t3) / 2;
            n2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, n2 - l2 < e22 && (n2 = e22 + l2), n2 + l2 > t3 && (n2 = t3 - l2), t3 - e22 < this.width && (s2 = Math.max(s2, this.width / (t3 - e22)), n2 = (t3 + e22) / 2);
          }
          n2 === o2 && a2 === r2 || (this.center = this.unproject(new e.P(n2, a2))), s2 && (this.zoom += this.scaleZoom(s2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
        }
        _minZoomForBounds() {
          let e22 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (e22 = Math.max(e22, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e22;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t2 = this.centerOffset, i2 = "globe" === this.projection.name, o2 = this.pixelsPerMeter;
          "globe" === this.projection.name && (this._mercatorScaleRatio = e.b(1, this.center.lat) / e.b(1, e.$));
          const r2 = e.N(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, r2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const s2 = "meters" === this.projection.zAxisUnit ? o2 : 1, n2 = this._camera.getWorldToCamera(this.worldSize, s2);
          let a2;
          const l2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (l2[8] = 2 * -t2.x / this.width, l2[9] = 2 * t2.y / this.height, this.isOrthographic) {
            let e22 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), i3 = e22 * this.aspect, o3 = -i3, r3 = -e22;
            i3 -= t2.x, o3 -= t2.x, e22 += t2.y, r3 += t2.y, a2 = this._camera.getCameraToClipOrthographic(o3, i3, r3, e22, this._nearZ, this._farZ), ((e3, t3, i4, o4) => {
              for (let r4 = 0; r4 < 16; r4++)
                e3[r4] = Le(t3[r4], i4[r4], o4);
            })(a2, a2, l2, Pe(this.pitch >= 15 ? 1 : this.pitch / 15));
          } else
            a2 = l2;
          const c2 = e.m.mul([], l2, n2);
          let h22 = e.m.mul([], a2, n2);
          if (this.projection.isReprojectedInTileSpace) {
            const t3 = this.locationCoordinate(this.center), i3 = e.m.identity([]);
            e.m.translate(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.m.multiply(i3, i3, e.Q(this)), e.m.translate(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.m.multiply(h22, h22, i3), e.m.multiply(c2, c2, i3), this.inverseAdjustmentMatrix = e.S(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (this.mercatorMatrix = e.m.scale([], h22, [this.worldSize, this.worldSize, this.worldSize / s2, 1]), this.projMatrix = h22, this.invProjMatrix = e.m.invert(new Float64Array(16), this.projMatrix), i2) {
            const i3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            i3[8] = 2 * -t2.x / this.width, i3[9] = 2 * t2.y / this.height, this.expandedFarZProjMatrix = e.m.mul([], i3, n2);
          } else
            this.expandedFarZProjMatrix = this.projMatrix;
          const _2 = e.m.invert([], a2);
          this.frustumCorners = e.T.fromInvProjectionMatrix(_2, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.F.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i2);
          const d2 = new Float32Array(16);
          e.m.identity(d2), e.m.scale(d2, d2, [1, -1, 1]), e.m.rotateX(d2, d2, this._pitch), e.m.rotateZ(d2, d2, this.angle);
          const u2 = e.m.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = e.m.clone(u2);
          const p2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          u2[8] = 2 * -t2.x / this.width, u2[9] = 2 * (t2.y + p2) / this.height, this.skyboxMatrix = e.m.multiply(d2, u2, d2);
          const m2 = this.point, f2 = m2.x, g2 = m2.y, v2 = this.width % 2 / 2, x2 = this.height % 2 / 2, y2 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = f2 - Math.round(f2) + y2 * v2 + b2 * x2, T2 = g2 - Math.round(g2) + y2 * x2 + b2 * v2, E2 = new Float64Array(h22);
          if (e.m.translate(E2, E2, [w2 > 0.5 ? w2 - 1 : w2, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = E2, h22 = e.m.create(), e.m.scale(h22, h22, [this.width / 2, -this.height / 2, 1]), e.m.translate(h22, h22, [1, -1, 0]), this.labelPlaneMatrix = h22, h22 = e.m.create(), e.m.scale(h22, h22, [1, -1, 1]), e.m.translate(h22, h22, [-1, -1, 0]), e.m.scale(h22, h22, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h22, this.pixelMatrix = e.m.multiply(new Float64Array(16), this.labelPlaneMatrix, c2), this._calcFogMatrices(), this._distanceTileDataCache = {}, h22 = e.m.invert(new Float64Array(16), this.pixelMatrix), !h22)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = h22, "globe" === this.projection.name || this.mercatorFromTransition) {
            this.globeMatrix = e.V(this);
            const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = e.v.transformMat4(t3, t3, n2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = h22;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r2 = 1 / this.height / this._pixelsPerMercatorPixel, s2 = [t2, t2, i2];
          e.v.scale(s2, s2, r2), e.v.scale(o2, o2, -1), e.v.multiply(o2, o2, s2);
          const n2 = e.m.create();
          e.m.translate(n2, n2, o2), e.m.scale(n2, n2, s2), this.mercatorFogMatrix = n2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r2);
        }
        _computeCameraPosition(e22) {
          const t2 = (e22 = e22 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, r2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e22 / this.worldSize * this._centerAltitude;
          return [o2.x / this.worldSize - i2[0] * r2, o2.y / this.worldSize - i2[1] * r2, e22 / this.worldSize * this._centerAltitude - i2[2] * r2];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t2) {
          const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], r2 = t2[2];
          let s2 = 1;
          this.projection.wrap && (this.center = this.center.wrap()), r2 > 0 && (s2 = Math.min((i2 - o2) / r2, 1)), this._camera.position = e.v.scaleAndAdd([], this._camera.position, t2, s2), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r2 } = this._camera.getPitchBearing(), s2 = e.b(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.d(this._maxPitch)), a2 = Math.max((t2[2] - s2) / Math.cos(o2), n2), l2 = this._zoomFromMercatorZ(a2);
          e.v.scaleAndAdd(t2, t2, i2, a2), this._pitch = e.c(o2, e.d(this.minPitch), e.d(this.maxPitch)), this.angle = e.w(r2, -Math.PI, Math.PI), this._setZoom(e.c(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.M(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e22) {
          return Math.pow(2, e22) * this.tileSize;
        }
        _mercatorZfromZoom(e22) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e22);
        }
        _minimumHeightOverTerrain() {
          const e22 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
          return this._mercatorZfromZoom(e22);
        }
        _zoomFromMercatorZ(e22) {
          return this.scaleZoom(this.cameraToCenterDistance / (e22 * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t2) {
          let i2 = 0, o2 = e.G, r2 = 0, s2 = 1 / 0;
          for (; o2 - i2 > 1e-6 && o2 > i2; ) {
            const e22 = i2 + 0.5 * (o2 - i2), n2 = this.tileSize * Math.pow(2, e22), a2 = this.getCameraToCenterDistance(this.projection, e22, n2), l2 = this.scaleZoom(a2 / (t2 * this.tileSize)), c2 = Math.abs(e22 - l2);
            c2 < s2 && (s2 = c2, r2 = e22), e22 < l2 ? i2 = e22 : o2 = e22;
          }
          return r2;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (e.X("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t2, i2) {
          const o2 = Math.min(t2.x, i2.x), r2 = Math.max(t2.x, i2.x), s2 = Math.min(t2.y, i2.y), n2 = Math.max(t2.y, i2.y);
          if (s2 < this.horizonLineFromTop(false))
            return true;
          if ("mercator" !== this.projection.name)
            return false;
          const a2 = [new e.P(o2, s2), new e.P(r2, n2), new e.P(o2, n2), new e.P(r2, s2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
          for (const e22 of a2) {
            const t3 = this.pointRayIntersection(e22);
            if (t3.t < 0)
              return true;
            const i3 = this.rayIntersectionCoordinate(t3);
            if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + e.Y(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
        }
        zoomDeltaToMovement(t2, i2) {
          const o2 = e.v.length(e.v.sub([], this._camera.position, t2)), r2 = this._zoomFromMercatorZ(o2) + i2;
          return o2 - this._mercatorZfromZoom(r2);
        }
        getCameraPoint() {
          if ("globe" === this.projection.name) {
            const t2 = function([t3, i2, o2], r2) {
              const s2 = [t3, i2, o2, 1];
              e.e.transformMat4(s2, s2, r2);
              const n2 = s2[3] = Math.max(s2[3], 1e-6);
              return s2[0] /= n2, s2[1] /= n2, s2[2] /= n2, s2;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new e.P(t2[0], t2[1]);
          }
          {
            const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new e.P(0, t2));
          }
        }
        getCameraToCenterDistance(t2, i2 = this.zoom, o2 = this.worldSize) {
          const r2 = e.N(t2, i2, this.width, this.height, 1024), s2 = t2.pixelSpaceConversion(this.center.lat, o2, r2);
          let n2 = 0.5 / Math.tan(0.5 * this._fov) * this.height * s2;
          return this.isOrthographic && (n2 = Le(1, n2, Pe(this.pitch >= 15 ? 1 : this.pitch / 15))), n2;
        }
        getWorldToCameraMatrix() {
          const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
          return "globe" === this.projection.name && e.m.multiply(t2, t2, this.globeMatrix), t2;
        }
        getFrustum(t2) {
          return e.F.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t2, "meters" === this.projection.zAxisUnit);
        }
      }
      function Ae(e22) {
        const { userImage: t2 } = e22;
        return !!(t2 && t2.render && t2.render()) && (e22.data.replace(new Uint8Array(t2.data.buffer)), true);
      }
      class Re extends e.a6 {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = true;
        }
        createScope(t2) {
          this.images[t2] = {}, this.loaded[t2] = false, this.updatedImages[t2] = {}, this.patterns[t2] = {}, this.callbackDispatchedThisFrame[t2] = {}, this.atlasImage[t2] = new e.a5({ width: 1, height: 1 });
        }
        isLoaded() {
          for (const e22 in this.loaded)
            if (!this.loaded[e22])
              return false;
          return true;
        }
        setLoaded(e22, t2) {
          if (this.loaded[t2] !== e22 && (this.loaded[t2] = e22, e22)) {
            for (const { ids: e3, callback: i2 } of this.requestors)
              this._notify(e3, t2, i2);
            this.requestors = [];
          }
        }
        hasImage(e22, t2) {
          return !!this.getImage(e22, t2);
        }
        getImage(e22, t2) {
          return this.images[t2][e22];
        }
        addImage(e22, t2, i2) {
          this._validate(e22, i2) && (this.images[t2][e22] = i2);
        }
        _validate(t2, i2) {
          let o2 = true;
          return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.a7(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.a7(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.a7(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
        }
        _validateStretch(e22, t2) {
          if (!e22)
            return true;
          let i2 = 0;
          for (const o2 of e22) {
            if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1])
              return false;
            i2 = o2[1];
          }
          return true;
        }
        _validateContent(e22, t2) {
          return !(e22 && (4 !== e22.length || e22[0] < 0 || t2.data.width < e22[0] || e22[1] < 0 || t2.data.height < e22[1] || e22[2] < 0 || t2.data.width < e22[2] || e22[3] < 0 || t2.data.height < e22[3] || e22[2] < e22[0] || e22[3] < e22[1]));
        }
        updateImage(e22, t2, i2) {
          i2.version = this.images[t2][e22].version + 1, this.images[t2][e22] = i2, this.updatedImages[t2][e22] = true;
        }
        removeImage(e22, t2) {
          const i2 = this.images[t2][e22];
          delete this.images[t2][e22], delete this.patterns[t2][e22], i2.userImage && i2.userImage.onRemove && i2.userImage.onRemove();
        }
        listImages(e22) {
          return Object.keys(this.images[e22]);
        }
        getImages(e22, t2, i2) {
          let o2 = true;
          const r2 = !!this.loaded[t2];
          if (!r2)
            for (const i3 of e22)
              this.images[t2][i3] || (o2 = false);
          r2 || o2 ? this._notify(e22, t2, i2) : this.requestors.push({ ids: e22, scope: t2, callback: i2 });
        }
        getUpdatedImages(e22) {
          return this.updatedImages[e22];
        }
        _notify(t2, i2, o2) {
          const r2 = {};
          for (const o3 of t2) {
            this.images[i2][o3] || this.fire(new e.a8("styleimagemissing", { id: o3 }));
            const t3 = this.images[i2][o3];
            t3 ? r2[o3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.X(`Image "${o3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          o2(null, r2);
        }
        getPixelSize(e22) {
          const { width: t2, height: i2 } = this.atlasImage[e22];
          return { width: t2, height: i2 };
        }
        getPattern(t2, i2) {
          const o2 = this.patterns[i2][t2], r2 = this.getImage(t2, i2);
          if (!r2)
            return null;
          if (o2 && o2.position.version === r2.version)
            return o2.position;
          if (o2)
            o2.position.version = r2.version;
          else {
            const o3 = { w: r2.data.width + 2, h: r2.data.height + 2, x: 0, y: 0 }, s2 = new e.ab(o3, r2);
            this.patterns[i2][t2] = { bin: o3, position: s2 };
          }
          return this._updatePatternAtlas(i2), this.patterns[i2][t2].position;
        }
        bind(t2, i2) {
          const o2 = t2.gl;
          let r2 = this.atlasTexture[i2];
          r2 ? this.dirty && (r2.update(this.atlasImage[i2]), this.dirty = false) : (r2 = new e.a9(t2, this.atlasImage[i2], o2.RGBA), this.atlasTexture[i2] = r2), r2.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(t2) {
          const i2 = [];
          for (const e22 in this.patterns[t2])
            i2.push(this.patterns[t2][e22].bin);
          const { w: o2, h: r2 } = e.aa(i2), s2 = this.atlasImage[t2];
          s2.resize({ width: o2 || 1, height: r2 || 1 });
          for (const i3 in this.patterns[t2]) {
            const { bin: o3 } = this.patterns[t2][i3], r3 = o3.x + 1, n2 = o3.y + 1, a2 = this.images[t2][i3].data, l2 = a2.width, c2 = a2.height;
            e.a5.copy(a2, s2, { x: 0, y: 0 }, { x: r3, y: n2 }, { width: l2, height: c2 }), e.a5.copy(a2, s2, { x: 0, y: c2 - 1 }, { x: r3, y: n2 - 1 }, { width: l2, height: 1 }), e.a5.copy(a2, s2, { x: 0, y: 0 }, { x: r3, y: n2 + c2 }, { width: l2, height: 1 }), e.a5.copy(a2, s2, { x: l2 - 1, y: 0 }, { x: r3 - 1, y: n2 }, { width: 1, height: c2 }), e.a5.copy(a2, s2, { x: 0, y: 0 }, { x: r3 + l2, y: n2 }, { width: 1, height: c2 });
          }
          this.dirty = true;
        }
        beginFrame() {
          for (const e22 in this.images)
            this.callbackDispatchedThisFrame[e22] = {};
        }
        dispatchRenderCallbacks(e22, t2) {
          for (const i2 of e22) {
            if (this.callbackDispatchedThisFrame[t2][i2])
              continue;
            this.callbackDispatchedThisFrame[t2][i2] = true;
            const e3 = this.images[t2][i2];
            Ae(e3) && this.updateImage(i2, t2, e3);
          }
        }
      }
      const ze = new e.ac({ anchor: new e.ad(e.ae.light.anchor), position: new e.af(e.ae.light.position), color: new e.ad(e.ae.light.color), intensity: new e.ad(e.ae.light.intensity) });
      class Oe extends e.a6 {
        constructor(t2, i2 = "flat") {
          super(), this._transitionable = new e.ag(ze), this.setLight(t2, i2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t2, i2, o2 = {}) {
          this._validate(e.ah, t2, o2) || (this._transitionable.setTransitionOrValue(t2), this.id = i2);
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t2, i2, o2) {
          return (!o2 || false !== o2.validate) && e.ai(this, t2.call(e.aj, e.ak({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.ae })));
        }
      }
      const Fe = new e.ac({ source: new e.ad(e.ae.terrain.source), exaggeration: new e.ad(e.ae.terrain.exaggeration) });
      let Be = class extends e.a6 {
        constructor(t2, i2, o2, r2) {
          super(), this.scope = o2, this._transitionable = new e.ag(Fe, o2, r2), this._transitionable.setTransitionOrValue(t2, r2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e22, t2) {
          this._transitionable.setTransitionOrValue(e22, t2);
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        getExaggeration(t2) {
          return this._transitioning.possiblyEvaluate(new e.al(t2)).get("exaggeration");
        }
        isZoomDependent() {
          const t2 = this._transitionable._values.exaggeration;
          return null != t2 && null != t2.value && null != t2.value.expression && t2.value.expression instanceof e.am;
        }
      };
      const ke = 45, Ne = 65, Ue = 0.05;
      function Ge(t2, i2, o2, r2) {
        const s2 = e.an(ke, Ne, o2), [n2, a2] = je(t2, r2);
        let l2 = 1 - Math.min(1, Math.exp((i2 - n2) / (a2 - n2) * -6));
        return l2 *= l2 * l2, l2 = Math.min(1, 1.00747 * l2), l2 * s2 * t2.alpha;
      }
      function je(e22, t2) {
        const i2 = 0.5 / Math.tan(0.5 * t2);
        return [e22.range[0] + i2, e22.range[1] + i2];
      }
      function Ve(t2, i2, o2, r2, s2) {
        const n2 = e.v.transformMat4([], [i2, o2, r2], s2.mercatorFogMatrix);
        return Ge(t2, e.v.length(n2), s2.pitch, s2._fov);
      }
      function Ze(t2, i2, o2, r2, s2, n2, a2) {
        const l2 = [[o2, r2, 0], [s2, r2, 0], [s2, n2, 0], [o2, n2, 0]];
        let c2 = Number.MAX_VALUE, h22 = -Number.MAX_VALUE;
        for (const t3 of l2) {
          const o3 = e.v.transformMat4([], t3, i2), r3 = e.v.length(o3);
          c2 = Math.min(c2, r3), h22 = Math.max(h22, r3);
        }
        return [Ge(t2, c2, a2.pitch, a2._fov), Ge(t2, h22, a2.pitch, a2._fov)];
      }
      const We = new e.ac({ range: new e.ad(e.ae.fog.range), color: new e.ad(e.ae.fog.color), "high-color": new e.ad(e.ae.fog["high-color"]), "space-color": new e.ad(e.ae.fog["space-color"]), "horizon-blend": new e.ad(e.ae.fog["horizon-blend"]), "star-intensity": new e.ad(e.ae.fog["star-intensity"]), "vertical-range": new e.ad(e.ae.fog["vertical-range"]) });
      class He extends e.a6 {
        constructor(t2, i2) {
          super(), this._transitionable = new e.ag(We), this.set(t2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2;
        }
        get state() {
          const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.ao(t2.zoom), r2 = this.properties.get("range"), s2 = [0.5, 3];
          return { range: i2 ? [e.n(s2[0], r2[0], o2), e.n(s2[1], r2[1], o2)] : r2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t2, i2 = {}) {
          if (this._validate(e.ap, t2, i2))
            return;
          const o2 = e.ak({}, t2);
          for (const t3 of Object.keys(e.ae.fog))
            void 0 === o2[t3] && (o2[t3] = e.ae.fog[t3].default);
          this._transitionable.setTransitionOrValue(o2);
        }
        getOpacity(t2) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const i2 = this.properties && this.properties.get("color") || 1;
          return ("globe" === this._transform.projection.name ? 1 : e.an(ke, Ne, t2)) * i2.a;
        }
        getOpacityAtLatLng(t2, i2) {
          return this._transform.projection.supportsFog ? function(t3, i3, o2) {
            const r2 = e.M.fromLngLat(i3), s2 = o2.elevation ? o2.elevation.getAtPointOrZero(r2) : 0;
            return Ve(t3, r2.x, r2.y, s2, o2);
          }(this.state, t2, i2) : 0;
        }
        getOpacityForTile(t2) {
          if (!this._transform.projection.supportsFog)
            return [1, 1];
          const i2 = this._transform.calculateFogTileMatrix(t2.toUnwrapped());
          return Ze(this.state, i2, 0, 0, e.J, e.J, this._transform);
        }
        getOpacityForBounds(e22, t2, i2, o2, r2) {
          return this._transform.projection.supportsFog ? Ze(this.state, e22, t2, i2, o2, r2, this._transform) : [1, 1];
        }
        getFovAdjustedRange(e22) {
          return this._transform.projection.supportsFog ? je(this.state, e22) : [0, 1];
        }
        isVisibleOnFrustum(t2) {
          if (!this._transform.projection.supportsFog)
            return false;
          const i2 = [4, 5, 6, 7];
          for (const o2 of i2) {
            const i3 = t2.points[o2];
            let r2;
            if (i3[2] >= 0)
              r2 = i3;
            else {
              const s2 = t2.points[o2 - 4];
              r2 = e.aq(s2, i3, s2[2] / (s2[2] - i3[2]));
            }
            if (Ve(this.state, r2[0], r2[1], 0, this._transform) >= Ue)
              return true;
          }
          return false;
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        _validate(t2, i2, o2) {
          return (!o2 || false !== o2.validate) && e.ai(this, t2.call(e.aj, e.ak({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.ae })));
        }
      }
      class qe extends e.a6 {
        constructor(t2, i2, o2, r2) {
          super(), this.scope = o2, this._options = t2, this.properties = new e.ar(i2), this._transitionable = new e.ag(i2, o2, new Map(r2)), this._transitionable.setTransitionOrValue(t2.properties), this._transitioning = this._transitionable.untransitioned();
        }
        updateConfig(e22) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(e22));
        }
        updateTransitions(e22) {
          this._transitioning = this._transitionable.transitioned(e22, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e22) {
          this.properties = this._transitioning.possiblyEvaluate(e22);
        }
        get() {
          return this._options.properties = this._transitionable.serialize(), this._options;
        }
        set(e22, t2) {
          this._options = e22, this._transitionable.setTransitionOrValue(e22.properties, t2);
        }
        shadowsEnabled() {
          return !!this.properties && true === this.properties.get("cast-shadows");
        }
      }
      const $e = new e.ac({ color: new e.ad(e.ae.properties_light_ambient.color), intensity: new e.ad(e.ae.properties_light_ambient.intensity) }), Xe = new e.ac({ direction: new e.as(e.ae.properties_light_directional.direction), color: new e.ad(e.ae.properties_light_directional.color), intensity: new e.ad(e.ae.properties_light_directional.intensity), "cast-shadows": new e.ad(e.ae.properties_light_directional["cast-shadows"]), "shadow-intensity": new e.ad(e.ae.properties_light_directional["shadow-intensity"]) });
      class Je {
        constructor(e22, t2, i2, o2) {
          this.screenBounds = e22, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
        }
        static createFromScreenPoints(t2, i2) {
          let o2, r2;
          if (t2 instanceof e.P || "number" == typeof t2[0]) {
            const s2 = e.P.convert(t2);
            o2 = [s2], r2 = i2.isPointAboveHorizon(s2);
          } else {
            const s2 = e.P.convert(t2[0]), n2 = e.P.convert(t2[1]);
            o2 = [s2, n2], r2 = e.at(s2, n2).every((e22) => i2.isPointAboveHorizon(e22));
          }
          return new Je(o2, i2.getCameraPoint(), r2, i2);
        }
        isPointQuery() {
          return 1 === this.screenBounds.length;
        }
        bufferedScreenGeometry(t2) {
          return e.at(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
        }
        bufferedCameraGeometry(t2) {
          const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r2 = e.at(i2, o2, 0, false);
          return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r2[3] = this.cameraPoint)), e.au(r2, t2);
        }
        bufferedCameraGeometryGlobe(t2) {
          const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], r2 = e.at(i2, o2, t2), s2 = this.cameraPoint.clone();
          switch (3 * ((s2.y > i2.y) + (s2.y > o2.y)) + ((s2.x > i2.x) + (s2.x > o2.x))) {
            case 0:
              r2[0] = s2, r2[4] = s2.clone();
              break;
            case 1:
              r2.splice(1, 0, s2);
              break;
            case 2:
              r2[1] = s2;
              break;
            case 3:
              r2.splice(4, 0, s2);
              break;
            case 5:
              r2.splice(2, 0, s2);
              break;
            case 6:
              r2[3] = s2;
              break;
            case 7:
              r2.splice(3, 0, s2);
              break;
            case 8:
              r2[2] = s2;
          }
          return r2;
        }
        containsTile(t2, i2, o2, r2 = 0) {
          const s2 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, n2 = o2 ? this._bufferedCameraMercator(s2, i2) : this._bufferedScreenMercator(s2, i2);
          let a2 = t2.tileID.wrap + (n2.unwrapped ? r2 : 0);
          const l2 = n2.polygon.map((i3) => e.av(t2.tileTransform, i3, a2));
          if (!e.aw(l2, 0, 0, e.J, e.J))
            return;
          a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r2 : 0);
          const c2 = this.screenGeometryMercator.polygon.map((i3) => e.ax(t2.tileTransform, i3, a2)), h22 = c2.map((t3) => new e.P(t3[0], t3[1])), _2 = i2.getFreeCameraOptions().position || new e.M(0, 0, 0), d2 = e.ax(t2.tileTransform, _2, a2), u2 = c2.map((t3) => {
            const i3 = e.v.sub(t3, t3, d2);
            return e.v.normalize(i3, i3), new e.R(d2, i3);
          }), p2 = e.ay(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: h22, tilespaceRays: u2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (m2 = e.az(l2), m2.min.x = e.c(m2.min.x, 0, e.J), m2.min.y = e.c(m2.min.y, 0, e.J), m2.max.x = e.c(m2.max.x, 0, e.J), m2.max.y = e.c(m2.max.y, 0, e.J), m2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
          var m2;
        }
        _bufferedScreenMercator(e22, t2) {
          const i2 = Qe(e22);
          if (this._screenRaycastCache[i2])
            return this._screenRaycastCache[i2];
          {
            let o2;
            return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e22), t2) : { polygon: this.bufferedScreenGeometry(e22).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
          }
        }
        _bufferedCameraMercator(e22, t2) {
          const i2 = Qe(e22);
          if (this._cameraRaycastCache[i2])
            return this._cameraRaycastCache[i2];
          {
            let o2;
            return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e22), t2) : { polygon: this.bufferedCameraGeometry(e22).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
          }
        }
        _projectAndResample(t2, i2) {
          const o2 = function(t3, i3) {
            const o3 = e.m.multiply([], i3.pixelMatrix, i3.globeMatrix), r3 = [0, -e.aC, 0, 1], s2 = [0, e.aC, 0, 1], n2 = [0, 0, 0, 1];
            e.e.transformMat4(r3, r3, o3), e.e.transformMat4(s2, s2, o3), e.e.transformMat4(n2, n2, o3);
            const a2 = new e.P(r3[0] / r3[3], r3[1] / r3[3]), l2 = new e.P(s2[0] / s2[3], s2[1] / s2[3]), c2 = e.aA(t3, a2) && r3[3] < n2[3], h22 = e.aA(t3, l2) && s2[3] < n2[3];
            if (!c2 && !h22)
              return null;
            const _2 = function(e22, t4, i4) {
              for (let o4 = 1; o4 < e22.length; o4++) {
                const r4 = Ke(t4.pointCoordinate3D(e22[o4 - 1]).x), s3 = Ke(t4.pointCoordinate3D(e22[o4]).x);
                if (i4 < 0) {
                  if (r4 < s3)
                    return { idx: o4, t: -r4 / (s3 - 1 - r4) };
                } else if (s3 < r4)
                  return { idx: o4, t: (1 - r4) / (s3 + 1 - r4) };
              }
              return null;
            }(t3, i3, c2 ? -1 : 1);
            if (!_2)
              return null;
            const { idx: d2, t: u2 } = _2;
            let p2 = d2 > 1 ? Ye(t3.slice(0, d2), i3) : [], m2 = d2 < t3.length ? Ye(t3.slice(d2), i3) : [];
            p2 = p2.map((t4) => new e.P(Ke(t4.x), t4.y)), m2 = m2.map((t4) => new e.P(Ke(t4.x), t4.y));
            const f2 = [...p2];
            0 === f2.length && f2.push(m2[m2.length - 1]);
            const g2 = e.n(f2[f2.length - 1].y, (0 === m2.length ? p2[0] : m2[0]).y, u2);
            let v2;
            return v2 = c2 ? [new e.P(0, g2), new e.P(0, 0), new e.P(1, 0), new e.P(1, g2)] : [new e.P(1, g2), new e.P(1, 1), new e.P(0, 1), new e.P(0, g2)], f2.push(...v2), 0 === m2.length ? f2.push(p2[0]) : f2.push(...m2), { polygon: f2.map((t4) => new e.M(t4.x, t4.y)), unwrapped: false };
          }(t2, i2);
          if (o2)
            return o2;
          const r2 = function(t3, i3) {
            let o3 = false, r3 = -1 / 0, s2 = 0;
            for (let e22 = 0; e22 < t3.length - 1; e22++)
              t3[e22].x > r3 && (r3 = t3[e22].x, s2 = e22);
            for (let e22 = 0; e22 < t3.length - 1; e22++) {
              const i4 = (s2 + e22) % (t3.length - 1), r4 = t3[i4], n3 = t3[i4 + 1];
              Math.abs(r4.x - n3.x) > 0.5 && (r4.x < n3.x ? (r4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (n3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
            }
            const n2 = e.E(i3.center.lng);
            return o3 && n2 < Math.abs(n2 - 1) && t3.forEach((e22) => {
              e22.x -= 1;
            }), { polygon: t3, unwrapped: o3 };
          }(Ye(t2, i2).map((t3) => new e.P(Ke(t3.x), t3.y)), i2);
          return { polygon: r2.polygon.map((t3) => new e.M(t3.x, t3.y)), unwrapped: r2.unwrapped };
        }
      }
      function Ye(t2, i2) {
        return e.aB(t2, (e22) => {
          const t3 = i2.pointCoordinate3D(e22);
          e22.x = t3.x, e22.y = t3.y;
        }, 1 / 256);
      }
      function Ke(e22) {
        return e22 < 0 ? 1 + e22 % 1 : e22 % 1;
      }
      function Qe(e22) {
        return 100 * e22 | 0;
      }
      function et(t2, i2, o2, r2, s2) {
        const n2 = function(o3, r3) {
          if (o3)
            return s2(o3);
          if (r3) {
            t2.url && r3.tiles && t2.tiles && delete t2.tiles;
            const o4 = e.p(e.ak(r3, t2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            r3.vector_layers && (o4.vectorLayers = r3.vector_layers, o4.vectorLayerIds = o4.vectorLayers.map((e22) => e22.id)), o4.tiles = i2.canonicalizeTileset(o4, t2.url), s2(null, o4);
          }
        };
        return t2.url ? e.a1(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, r2), e.a2.Source), n2) : e.a4.frame(() => n2(null, t2));
      }
      class tt {
        constructor(t2, i2, o2) {
          this.bounds = e.D.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
        }
        validateBounds(e22) {
          return Array.isArray(e22) && 4 === e22.length ? [Math.max(-180, e22[0]), Math.max(-90, e22[1]), Math.min(180, e22[2]), Math.min(90, e22[3])] : [-180, -90, 180, 90];
        }
        contains(t2) {
          const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.E(this.bounds.getWest()) * i2), r2 = Math.floor(e.H(this.bounds.getNorth()) * i2), s2 = Math.ceil(e.E(this.bounds.getEast()) * i2), n2 = Math.ceil(e.H(this.bounds.getSouth()) * i2);
          return t2.x >= o2 && t2.x < s2 && t2.y >= r2 && t2.y < n2;
        }
      }
      class it extends e.a6 {
        constructor(t2, i2, o2, r2) {
          if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.ak(this, e.p(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.ak({ type: "vector" }, i2), this._collectResourceTiming = !!i2.collectResourceTiming, 512 !== this.tileSize)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r2), this._tileWorkers = {}, this._deduped = new e.aD();
        }
        load(t2) {
          this._loaded = false, this.fire(new e.a8("dataloading", { dataType: "source" }));
          const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
          this._tileJSONRequest = et(this._options, this.map._requestManager, i2, o2, (r2, s2) => {
            this._tileJSONRequest = null, this._loaded = true, r2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.a7(r2))) : s2 && (e.ak(this, s2), s2.bounds && (this.tileBounds = new tt(s2.bounds, this.minzoom, this.maxzoom)), e.aH(s2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r2);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t2 = e.aE(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t2));
        }
        setTiles(e22) {
          return this._options.tiles = e22, this.reload(), this;
        }
        setUrl(e22) {
          return this.url = e22, this._options.url = e22, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e.ak({}, this._options);
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, e.a2.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e.a4.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t2.isExtraShadowCaster };
          if (r2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state)
            "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", r2, s2.bind(this));
          else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
            t2.request = t2.actor.send("loadTile", r2, s2.bind(this), void 0, true);
          else {
            const i3 = e.aF.call({ deduped: this._deduped }, r2, (e22, i4) => {
              e22 || !i4 ? s2.call(this, e22) : (r2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", r2, s2.bind(this), void 0, true));
            }, true);
            t2.request = { cancel: i3 };
          }
          function s2(o3, r3) {
            return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r3 && r3.resourceTiming && (t2.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && t2.setExpiryData(r3), t2.loadVectorData(r3, this.map.painter), e.aG(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
          }
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.actor && e22.actor.send("abortTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(e22) {
          e22.actor && e22.actor.send("removeTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope }), e22.destroy();
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class ot extends e.a6 {
        constructor(t2, i2, o2, r2) {
          super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.ak({ type: "raster" }, i2), e.ak(this, e.p(i2, ["url", "scheme", "tileSize"]));
        }
        load(t2) {
          this._loaded = false, this.fire(new e.a8("dataloading", { dataType: "source" })), this._tileJSONRequest = et(this._options, this.map._requestManager, null, null, (i2, o2) => {
            this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.a7(i2)) : o2 && (e.ak(this, o2), o2.bounds && (this.tileBounds = new tt(o2.bounds, this.minzoom, this.maxzoom)), e.aH(o2.tiles), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t2 = e.aE(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t2));
        }
        setTiles(e22) {
          return this._options.tiles = e22, this.reload(), this;
        }
        setUrl(e22) {
          return this.url = e22, this._options.url = e22, this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return e.ak({}, this._options);
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loadTile(t2, i2) {
          const o2 = e.a4.devicePixelRatio >= 2, r2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
          t2.request = e.a3(this.map._requestManager.transformRequest(r2, e.a2.Tile), (o3, r3, s2, n2) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : r3 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: s2, expires: n2 }), t2.setTexture(r3, this.map.painter), t2.state = "loaded", e.aG(this.dispatcher), void i2(null)) : i2(null)));
        }
        abortTile(e22, t2) {
          e22.request && (e22.request.cancel(), delete e22.request), t2();
        }
        unloadTile(t2, i2) {
          t2.texture && t2.texture instanceof e.a9 ? (t2.destroy(true), t2.texture && t2.texture instanceof e.a9 && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), i2();
        }
        hasTransition() {
          return false;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      const rt = { vector: it, raster: ot, "raster-dem": class extends ot {
        constructor(t2, i2, o2, r2) {
          super(t2, i2, o2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.ak({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function r2(e22, o3) {
            e22 && (t2.state = "errored", i2(e22)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
          }
          t2.request = e.a3(this.map._requestManager.transformRequest(o2, e.a2.Tile), (function(o3, s2, n2, a2) {
            if (delete t2.request, t2.aborted)
              t2.state = "unloaded", i2(null);
            else if (o3)
              t2.state = "errored", i2(o3);
            else if (s2) {
              this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n2, expires: a2 });
              const i3 = ImageBitmap && s2 instanceof ImageBitmap && e.aI(), o4 = 1 - (s2.width - e.aJ(s2.width)) / 2;
              o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
              const l2 = i3 ? s2 : e.a4.getImageData(s2, o4), c2 = { uid: t2.uid, coord: t2.tileID, source: this.id, scope: this.scope, rawImageData: l2, encoding: this.encoding, padding: o4 };
              t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c2, r2.bind(this), void 0, true));
            }
          }).bind(this));
        }
        _getNeighboringTiles(t2) {
          const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + o2) % o2, s2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, n2 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
          return l2[new e.O(t2.overscaledZ, s2, i2.z, r2, i2.y).key] = { backfilled: false }, l2[new e.O(t2.overscaledZ, a2, i2.z, n2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.O(t2.overscaledZ, s2, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l2[new e.O(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.O(t2.overscaledZ, a2, i2.z, n2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.O(t2.overscaledZ, s2, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l2[new e.O(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.O(t2.overscaledZ, a2, i2.z, n2, i2.y + 1).key] = { backfilled: false }), l2;
        }
      }, geojson: class extends e.a6 {
        constructor(t2, i2, o2, r2) {
          super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r2), this._data = i2.data, this._options = e.ak({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const s2 = e.J / this.tileSize;
          this.workerOptions = e.ak({ source: this.id, scope: this.scope, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * s2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * s2, extent: e.J, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.J, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * s2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
        }
        onAdd(e22) {
          this.map = e22, this.setData(this._data);
        }
        setData(e22) {
          return this._data = e22, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e22, t2) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e22, source: this.id, scope: this.scope }, t2), this;
        }
        getClusterChildren(e22, t2) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e22, source: this.id, scope: this.scope }, t2), this;
        }
        getClusterLeaves(e22, t2, i2, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e22, limit: t2, offset: i2 }, o2), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new e.a8("dataloading", { dataType: "source" })), this._loaded = false;
          const t2 = e.ak({}, this.workerOptions);
          t2.scope = this.scope;
          const i2 = this._data;
          "string" == typeof i2 ? (t2.request = this.map._requestManager.transformRequest(e.a4.resolveURL(i2), e.a2.Source), t2.request.collectResourceTiming = this._collectResourceTiming) : t2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t2, (t3, i3) => {
            if (this._loaded = true, this._pendingLoad = null, t3)
              this.fire(new e.a7(t3));
            else {
              const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.a8("data", t4)), this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t2, i2) {
          const o2 = t2.actor ? "reloadTile" : "loadTile";
          t2.actor = this.actor;
          const r2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, scope: this.scope, pixelRatio: e.a4.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0 };
          t2.request = this.actor.send(o2, r2, (e22, r3) => (delete t2.request, t2.destroy(), t2.aborted ? i2(null) : e22 ? i2(e22) : (t2.loadVectorData(r3, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
        }
        abortTile(e22) {
          e22.request && (e22.request.cancel(), delete e22.request), e22.aborted = true;
        }
        unloadTile(e22) {
          this.actor.send("removeTile", { uid: e22.uid, type: this.type, source: this.id, scope: this.scope }), e22.destroy();
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return e.ak({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends e.aK {
        constructor(e22, t2, i2, o2) {
          super(e22, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
        }
        load() {
          this._loaded = false;
          const t2 = this.options;
          this.urls = [];
          for (const i2 of t2.urls)
            this.urls.push(this.map._requestManager.transformRequest(i2, e.a2.Source).url);
          e.aL(this.urls, (t3, i2) => {
            this._loaded = true, t3 ? this.fire(new e.a7(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t2) {
          if (this.video) {
            const i2 = this.video.seekable;
            t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.a7(new e.aM(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e22) {
          this.map || (this.map = e22, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.a9(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: e.aK, model: class extends e.a6 {
        constructor(e22, t2, i2, o2) {
          super(), this.id = e22, this.type = "model", this.models = [], this._loaded = false, this._options = t2;
        }
        load() {
          const t2 = [];
          for (const i2 in this._options.models) {
            const o2 = this._options.models[i2], r2 = e.aO(this.map._requestManager.transformRequest(o2.uri, e.a2.Model).url).then((t3) => {
              if (!t3)
                return;
              const r3 = e.aP(t3), s2 = new e.aQ(i2, o2.position, o2.orientation, r3);
              s2.computeBoundsAndApplyParent(), this.models.push(s2);
            }).catch((t3) => {
              this.fire(new e.a7(new Error(`Could not load model ${i2} from ${o2.uri}: ${t3.message}`)));
            });
            t2.push(r2);
          }
          return Promise.allSettled(t2).then(() => {
            this._loaded = true, this.fire(new e.a8("data", { dataType: "source", sourceDataType: "metadata" }));
          }).catch((t3) => {
            this.fire(new e.a7(new Error(`Could not load models: ${t3.message}`)));
          });
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        hasTransition() {
          return false;
        }
        loaded() {
          return this._loaded;
        }
        getModels() {
          return this.models;
        }
        loadTile(e22, t2) {
        }
        serialize() {
          return { type: "model" };
        }
      }, "batched-model": class extends e.a6 {
        constructor(e22, t2, i2, o2) {
          super(), this.type = "batched-model", this.id = e22, this.tileSize = 512, this._options = t2, this.tiles = this._options.tiles, this.maxzoom = t2.maxzoom || 19, this.minzoom = t2.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i2, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o2);
        }
        onAdd(e22) {
          this.map = e22, this.load();
        }
        load(t2) {
          this._loaded = false, this.fire(new e.a8("dataloading", { dataType: "source" }));
          const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map._worldview;
          this._tileJSONRequest = et(this._options, this.map._requestManager, i2, o2, (r2, s2) => {
            this._tileJSONRequest = null, this._loaded = true, r2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.a7(r2))) : s2 && (e.ak(this, s2), s2.bounds && (this.tileBounds = new tt(s2.bounds, this.minzoom, this.maxzoom)), e.aH(s2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(r2);
          });
        }
        hasTransition() {
          return false;
        }
        hasTile(e22) {
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, e.a2.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0 };
          if (t2.actor && "expired" !== t2.state)
            if ("loading" === t2.state)
              t2.reloadCallback = i2;
            else {
              if (t2.buckets) {
                const e22 = Object.values(t2.buckets);
                for (const t3 of e22)
                  t3.dirty = true;
                return void (t2.state = "loaded");
              }
              t2.request = t2.actor.send("reloadTile", r2, s2.bind(this));
            }
          else
            t2.actor = this.dispatcher.getActor(), t2.request = t2.actor.send("loadTile", r2, s2.bind(this), void 0, true);
          function s2(e22, o3) {
            return t2.aborted ? i2(null) : e22 && 404 !== e22.status ? i2(e22) : (o3 && (o3.resourceTiming && (t2.resourceTiming = o3.resourceTiming), this.map._refreshExpiredTiles && t2.setExpiryData(o3), t2.buckets = { ...t2.buckets, ...o3.buckets }), t2.state = "loaded", void i2(null));
          }
        }
        serialize() {
          return e.ak({}, this._options);
        }
      }, canvas: class extends e.aK {
        constructor(t2, i2, o2, r2) {
          super(t2, i2, o2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e22) => !Array.isArray(e22) || 2 !== e22.length || e22.some((e3) => "number" != typeof e3)) || this.fire(new e.a7(new e.aM(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.a7(new e.aM(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.a7(new e.aM(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.a7(new e.aM(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.a7(new e.aM(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.a7(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e22) {
          this.map = e22, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
            return;
          if (0 === Object.keys(this.tiles).length)
            return;
          const i2 = this.map.painter.context;
          this.texture ? !t2 && !this._playing || this.texture instanceof e.aN || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.a9(i2, this.canvas, i2.gl.RGBA, { premultiply: true }), this._prepareData(i2);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e22 of [this.canvas.width, this.canvas.height])
            if (isNaN(e22) || e22 <= 0)
              return true;
          return false;
        }
      }, custom: class extends e.a6 {
        constructor(t2, i2, o2, r2) {
          super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(r2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.a7(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.a7(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new tt(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.ak(this, e.p(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return e.p(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = true, this.fire(new e.a8("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.a8("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t2) {
          this._map = t2, this._loaded = false, this.fire(new e.a8("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
        }
        onRemove(e22) {
          this._implementation.onRemove && this._implementation.onRemove(e22);
        }
        hasTile(e22) {
          if (this._implementation.hasTile) {
            const { x: t2, y: i2, z: o2 } = e22.canonical;
            return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
          }
          return !this.tileBounds || this.tileBounds.contains(e22.canonical);
        }
        loadTile(e22, t2) {
          const { x: i2, y: o2, z: r2 } = e22.tileID.canonical, s2 = new AbortController();
          e22.request = Promise.resolve(this._implementation.loadTile({ x: i2, y: o2, z: r2 }, { signal: s2.signal })).then((function(i3) {
            return delete e22.request, e22.aborted ? (e22.state = "unloaded", t2(null)) : void 0 === i3 ? (e22.state = "errored", t2(null)) : null === i3 ? (this.loadTileData(e22, { width: this.tileSize, height: this.tileSize, data: null }), e22.state = "loaded", t2(null)) : function(e3) {
              return e3 instanceof ImageData || e3 instanceof HTMLCanvasElement || e3 instanceof ImageBitmap || e3 instanceof HTMLImageElement;
            }(i3) ? (this.loadTileData(e22, i3), e22.state = "loaded", void t2(null)) : (e22.state = "errored", t2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }).bind(this)).catch((i3) => {
            20 !== i3.code && (e22.state = "errored", t2(i3));
          }), e22.request.cancel = () => s2.abort();
        }
        loadTileData(e22, t2) {
          e22.setTexture(t2, this._map.painter);
        }
        unloadTile(t2, i2) {
          if (t2.texture && t2.texture instanceof e.a9 ? (t2.destroy(true), t2.texture && t2.texture instanceof e.a9 && this._map.painter.saveTileTexture(t2.texture)) : t2.destroy(), this._implementation.unloadTile) {
            const { x: e22, y: i3, z: o2 } = t2.tileID.canonical;
            this._implementation.unloadTile({ x: e22, y: i3, z: o2 });
          }
          i2();
        }
        abortTile(e22, t2) {
          e22.request && e22.request.cancel && (e22.request.cancel(), delete e22.request), t2();
        }
        hasTransition() {
          return false;
        }
        _coveringTiles() {
          return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e22) => ({ x: e22.canonical.x, y: e22.canonical.y, z: e22.canonical.z }));
        }
        _clearTiles() {
          const t2 = e.aE(this.id, this.scope);
          this._map.style.clearSource(t2);
        }
        _update() {
          this.fire(new e.a8("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, st = function(t2, i2, o2, r2) {
        const s2 = new rt[i2.type](t2, i2, o2, r2);
        if (s2.id !== t2)
          throw new Error(`Expected Source id to be ${t2} instead of ${s2.id}`);
        return e.aR(["load", "abort", "unload", "serialize", "prepare"], s2), s2;
      };
      function nt(t2, i2) {
        const o2 = e.m.identity([]);
        return e.m.scale(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.m.translate(o2, o2, [1, -1, 0]), e.m.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped())), Float32Array.from(o2);
      }
      function at(e22, t2, i2, o2, r2, s2, n2, a2 = false) {
        const l2 = e22.tilesIn(o2, n2, a2);
        l2.sort(ct);
        const c2 = [];
        for (const o3 of l2)
          c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e22._state, o3, r2, s2, nt(e22.transform, o3.tile.tileID), a2) });
        const h22 = function(e3) {
          const t3 = {}, i3 = {};
          for (const o3 of e3) {
            const e4 = o3.queryResults, r3 = o3.wrappedTileID, s3 = i3[r3] = i3[r3] || {};
            for (const i4 in e4) {
              const o4 = e4[i4], r4 = s3[i4] = s3[i4] || {}, n3 = t3[i4] = t3[i4] || [];
              for (const e52 of o4)
                r4[e52.featureIndex] || (r4[e52.featureIndex] = true, n3.push(e52));
            }
          }
          return t3;
        }(c2);
        for (const t3 in h22)
          h22[t3].forEach((t4) => {
            const i3 = t4.feature, o3 = i3.layer;
            o3 && "background" !== o3.type && "sky" !== o3.type && "slot" !== o3.type && (i3.source = o3.source, o3["source-layer"] && (i3.sourceLayer = o3["source-layer"]), i3.state = void 0 !== i3.id ? e22.getFeatureState(o3["source-layer"], i3.id) : {});
          });
        return h22;
      }
      function lt(e22, t2) {
        const i2 = e22.getRenderableIds().map((t3) => e22.getTileByID(t3)), o2 = [], r2 = {};
        for (let e3 = 0; e3 < i2.length; e3++) {
          const s2 = i2[e3], n2 = s2.tileID.canonical.key;
          r2[n2] || (r2[n2] = true, s2.querySourceFeatures(o2, t2));
        }
        return o2;
      }
      function ct(e22, t2) {
        const i2 = e22.tileID, o2 = t2.tileID;
        return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
      }
      class ht {
        constructor(e22) {
          this.style = e22;
        }
        processLayersChanged() {
          this.layers = [];
          for (const e22 in this.style._mergedLayers) {
            const t2 = this.style._mergedLayers[e22];
            if ("fill-extrusion" === t2.type)
              this.layers.push(t2);
            else if ("model" === t2.type) {
              const e3 = this.style.getLayerSource(t2);
              e3 && "batched-model" === e3.type && this.layers.push(t2);
            }
          }
        }
        updateZOffset(e22, t2) {
          this.currentBuildingBuckets = [];
          for (let e3 = 0; e3 < this.layers.length; ++e3) {
            const i3 = this.layers[e3], o2 = this.style.getLayerSourceCache(i3);
            let r2 = 1;
            "fill-extrusion" === i3.type && (r2 = i3.paint.get("fill-extrusion-opacity") > 0 ? i3.paint.get("fill-extrusion-vertical-scale") : 0);
            let s2 = o2 ? o2.getTile(t2) : null;
            if (!s2 && o2 && t2.canonical.z > o2.getSource().minzoom) {
              let e4 = t2.scaledTo(Math.min(o2.getSource().maxzoom, t2.overscaledZ - 1));
              for (; e4.overscaledZ >= o2.getSource().minzoom && (s2 = o2.getTile(e4), !s2 && 0 !== e4.overscaledZ); )
                e4 = e4.scaledTo(e4.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: s2 ? s2.getBucket(i3) : null, tileID: s2 ? s2.tileID : t2, verticalScale: r2 });
          }
          e22.hasAnyZOffset = false;
          let i2 = false;
          for (let o2 = 0; o2 < e22.symbolInstances.length; o2++) {
            const r2 = e22.symbolInstances.get(o2), s2 = r2.zOffset, n2 = this._getHeightAtTileOffset(t2, r2.tileAnchorX, r2.tileAnchorY);
            r2.zOffset = -1 !== n2 ? n2 : s2, i2 || s2 === r2.zOffset || (i2 = true), e22.hasAnyZOffset || 0 === r2.zOffset || (e22.hasAnyZOffset = true);
          }
          i2 && (e22.zOffsetBuffersNeedUpload = true, e22.zOffsetSortDirty = true);
        }
        _mapCoordToOverlappingTile(t2, i2, o2, r2) {
          let s2 = i2, n2 = o2;
          if (t2.canonical.z !== r2.canonical.z) {
            const a2 = r2.canonical, l2 = 1 / (1 << t2.canonical.z - a2.z);
            s2 = (i2 + t2.canonical.x * e.J) * l2 - a2.x * e.J | 0, n2 = (o2 + t2.canonical.y * e.J) * l2 - a2.y * e.J | 0;
          }
          return { tileX: s2, tileY: n2 };
        }
        _getHeightAtTileOffset(e22, t2, i2) {
          let o2, r2;
          for (let s2 = 0; s2 < this.layers.length; ++s2) {
            if ("fill-extrusion" !== this.layers[s2].type)
              continue;
            const { bucket: n2, tileID: a2, verticalScale: l2 } = this.currentBuildingBuckets[s2];
            if (!n2)
              continue;
            const { tileX: c2, tileY: h22 } = this._mapCoordToOverlappingTile(e22, t2, i2, a2), _2 = n2.getHeightAtTileCoord(c2, h22);
            _2 && void 0 !== _2.height && (_2.hidden ? o2 = _2.height : r2 = Math.max(_2.height * l2, r2 || 0));
          }
          if (void 0 !== r2)
            return r2;
          for (let r3 = 0; r3 < this.layers.length; ++r3) {
            if ("model" !== this.layers[r3].type)
              continue;
            const { bucket: s2, tileID: n2 } = this.currentBuildingBuckets[r3];
            if (!s2)
              continue;
            const { tileX: a2, tileY: l2 } = this._mapCoordToOverlappingTile(e22, t2, i2, n2), c2 = s2.getHeightAtTileCoord(a2, l2);
            if (c2 && !c2.hidden)
              return void 0 === c2.height && void 0 !== o2 ? Math.min(c2.maxHeight, o2) * c2.verticalScale : (c2.height || 0) * c2.verticalScale;
          }
          return -1;
        }
      }
      function _t(t2, i2) {
        const o2 = {};
        for (const e22 in t2)
          "ref" !== e22 && (o2[e22] = t2[e22]);
        return e.aS.forEach((e22) => {
          e22 in i2 && (o2[e22] = i2[e22]);
        }), o2;
      }
      function dt(e22) {
        e22 = e22.slice();
        const t2 = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < e22.length; i2++)
          t2[e22[i2].id] = e22[i2];
        for (let i2 = 0; i2 < e22.length; i2++)
          "ref" in e22[i2] && (e22[i2] = _t(e22[i2], t2[e22[i2].ref]));
        return e22;
      }
      const ut = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", setImportUrl: "setImportUrl", setImportData: "setImportData", setImportConfig: "setImportConfig" };
      function pt(e22, t2, i2) {
        i2.push({ command: ut.addSource, args: [e22, t2[e22]] });
      }
      function mt(e22, t2, i2) {
        t2.push({ command: ut.removeSource, args: [e22] }), i2[e22] = true;
      }
      function ft(e22, t2, i2, o2) {
        mt(e22, i2, o2), pt(e22, t2, i2);
      }
      function gt(e22, i2, o2) {
        let r2;
        for (r2 in e22[o2])
          if (e22[o2].hasOwnProperty(r2) && "data" !== r2 && !t(e22[o2][r2], i2[o2][r2]))
            return false;
        for (r2 in i2[o2])
          if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !t(e22[o2][r2], i2[o2][r2]))
            return false;
        return true;
      }
      function vt(e22, i2, o2, r2, s2, n2) {
        let a2;
        for (a2 in i2 = i2 || {}, e22 = e22 || {})
          e22.hasOwnProperty(a2) && (t(e22[a2], i2[a2]) || o2.push({ command: n2, args: [r2, a2, i2[a2], s2] }));
        for (a2 in i2)
          i2.hasOwnProperty(a2) && !e22.hasOwnProperty(a2) && (t(e22[a2], i2[a2]) || o2.push({ command: n2, args: [r2, a2, i2[a2], s2] }));
      }
      function xt(e22) {
        return e22.id;
      }
      function yt(e22, t2) {
        return e22[t2.id] = t2, e22;
      }
      class bt {
        constructor(e22, t2) {
          this.reset(e22, t2);
        }
        reset(e22, t2) {
          this.points = e22 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t2) {
          if (1 === this.points.length)
            return this.points[0];
          t2 = e.c(t2, 0, 1);
          let i2 = 1, o2 = this._distances[i2];
          const r2 = t2 * this.paddedLength + this.padding;
          for (; o2 < r2 && i2 < this._distances.length; )
            o2 = this._distances[++i2];
          const s2 = i2 - 1, n2 = this._distances[s2], a2 = o2 - n2, l2 = a2 > 0 ? (r2 - n2) / a2 : 0;
          return this.points[s2].mult(1 - l2).add(this.points[i2].mult(l2));
        }
      }
      class wt {
        constructor(e22, t2, i2) {
          const o2 = this.boxCells = [], r2 = this.circleCells = [];
          this.xCellCount = Math.ceil(e22 / i2), this.yCellCount = Math.ceil(t2 / i2);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
            o2.push([]), r2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e22, this.height = t2, this.xScale = this.xCellCount / e22, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e22, t2, i2, o2, r2) {
          this._forEachCell(t2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e22), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
        }
        insertCircle(e22, t2, i2, o2) {
          this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e22), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
        }
        _insertBoxCell(e22, t2, i2, o2, r2, s2) {
          this.boxCells[r2].push(s2);
        }
        _insertCircleCell(e22, t2, i2, o2, r2, s2) {
          this.circleCells[r2].push(s2);
        }
        _query(e22, t2, i2, o2, r2, s2) {
          if (i2 < 0 || e22 > this.width || o2 < 0 || t2 > this.height)
            return !r2 && [];
          const n2 = [];
          if (e22 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
            if (r2)
              return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++)
              n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
              n2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
            }
            return s2 ? n2.filter(s2) : n2;
          }
          return this._forEachCell(e22, t2, i2, o2, this._queryCell, n2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, s2), r2 ? n2.length > 0 : n2;
        }
        _queryCircle(e22, t2, i2, o2, r2) {
          const s2 = e22 - i2, n2 = e22 + i2, a2 = t2 - i2, l2 = t2 + i2;
          if (n2 < 0 || s2 > this.width || l2 < 0 || a2 > this.height)
            return !o2 && [];
          const c2 = [];
          return this._forEachCell(s2, a2, n2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e22, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c2.length > 0 : c2;
        }
        query(e22, t2, i2, o2, r2) {
          return this._query(e22, t2, i2, o2, false, r2);
        }
        hitTest(e22, t2, i2, o2, r2) {
          return this._query(e22, t2, i2, o2, true, r2);
        }
        hitTestCircle(e22, t2, i2, o2) {
          return this._queryCircle(e22, t2, i2, true, o2);
        }
        _queryCell(e22, t2, i2, o2, r2, s2, n2, a2) {
          const l2 = n2.seenUids, c2 = this.boxCells[r2];
          if (null !== c2) {
            const r3 = this.bboxes;
            for (const h3 of c2)
              if (!l2.box[h3]) {
                l2.box[h3] = true;
                const c3 = 4 * h3;
                if (e22 <= r3[c3 + 2] && t2 <= r3[c3 + 3] && i2 >= r3[c3 + 0] && o2 >= r3[c3 + 1] && (!a2 || a2(this.boxKeys[h3]))) {
                  if (n2.hitTest)
                    return s2.push(true), true;
                  s2.push({ key: this.boxKeys[h3], x1: r3[c3], y1: r3[c3 + 1], x2: r3[c3 + 2], y2: r3[c3 + 3] });
                }
              }
          }
          const h22 = this.circleCells[r2];
          if (null !== h22) {
            const r3 = this.circles;
            for (const c3 of h22)
              if (!l2.circle[c3]) {
                l2.circle[c3] = true;
                const h3 = 3 * c3;
                if (this._circleAndRectCollide(r3[h3], r3[h3 + 1], r3[h3 + 2], e22, t2, i2, o2) && (!a2 || a2(this.circleKeys[c3]))) {
                  if (n2.hitTest)
                    return s2.push(true), true;
                  {
                    const e3 = r3[h3], t3 = r3[h3 + 1], i3 = r3[h3 + 2];
                    s2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e22, t2, i2, o2, r2, s2, n2, a2) {
          const l2 = n2.circle, c2 = n2.seenUids, h22 = this.boxCells[r2];
          if (null !== h22) {
            const e3 = this.bboxes;
            for (const t3 of h22)
              if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3])))
                  return s2.push(true), true;
              }
          }
          const _2 = this.circleCells[r2];
          if (null !== _2) {
            const e3 = this.circles;
            for (const t3 of _2)
              if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3])))
                  return s2.push(true), true;
              }
          }
        }
        _forEachCell(e22, t2, i2, o2, r2, s2, n2, a2) {
          const l2 = this._convertToXCellCoord(e22), c2 = this._convertToYCellCoord(t2), h22 = this._convertToXCellCoord(i2), _2 = this._convertToYCellCoord(o2);
          for (let d2 = l2; d2 <= h22; d2++)
            for (let l3 = c2; l3 <= _2; l3++)
              if (r2.call(this, e22, t2, i2, o2, this.xCellCount * l3 + d2, s2, n2, a2))
                return;
        }
        _convertToXCellCoord(e22) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e22 * this.xScale)));
        }
        _convertToYCellCoord(e22) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e22 * this.yScale)));
        }
        _circlesCollide(e22, t2, i2, o2, r2, s2) {
          const n2 = o2 - e22, a2 = r2 - t2, l2 = i2 + s2;
          return l2 * l2 > n2 * n2 + a2 * a2;
        }
        _circleAndRectCollide(e22, t2, i2, o2, r2, s2, n2) {
          const a2 = (s2 - o2) / 2, l2 = Math.abs(e22 - (o2 + a2));
          if (l2 > a2 + i2)
            return false;
          const c2 = (n2 - r2) / 2, h22 = Math.abs(t2 - (r2 + c2));
          if (h22 > c2 + i2)
            return false;
          if (l2 <= a2 || h22 <= c2)
            return true;
          const _2 = l2 - a2, d2 = h22 - c2;
          return _2 * _2 + d2 * d2 <= i2 * i2;
        }
      }
      const Tt = 100;
      class Et {
        constructor(e22, t2, i2 = new wt(e22.width + 200, e22.height + 200, 25), o2 = new wt(e22.width + 200, e22.height + 200, 25)) {
          this.transform = e22, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e22._pitch) * e22.cameraToCenterDistance, this.screenRightBoundary = e22.width + Tt, this.screenBottomBoundary = e22.height + Tt, this.gridRightBoundary = e22.width + 200, this.gridBottomBoundary = e22.height + 200, this.fogState = t2;
        }
        placeCollisionBox(e22, t2, i2, o2, r2, s2, n2, a2) {
          let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h22 = i2.projectedAnchorZ;
          const _2 = i2.elevation, d2 = i2.tileID, u2 = e22.getProjection();
          if (_2 && d2) {
            const [e3, t3, o3] = u2.upVector(d2.canonical, i2.tileAnchorX, i2.tileAnchorY), r3 = u2.upVectorScale(d2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            l2 += e3 * _2 * r3, c2 += t3 * _2 * r3, h22 += o3 * _2 * r3;
          }
          const p2 = this.projectAndGetPerspectiveRatio(n2, l2, c2, h22, i2.tileID, "globe" === u2.name || !!_2 || this.transform.pitch > 0, u2), m2 = s2 * p2.perspectiveRatio, f2 = (i2.x1 * t2 + o2.x - i2.padding) * m2 + p2.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * m2 + p2.point.y, v2 = (i2.x2 * t2 + o2.x + i2.padding) * m2 + p2.point.x, x2 = (i2.y2 * t2 + o2.y + i2.padding) * m2 + p2.point.y, y2 = p2.perspectiveRatio <= 0.55 || p2.occluded;
          return !this.isInsideGrid(f2, g2, v2, x2) || !r2 && this.grid.hitTest(f2, g2, v2, x2, a2) || y2 ? { box: [], offscreen: false, occluded: p2.occluded } : { box: [f2, g2, v2, x2], offscreen: this.isOffscreen(f2, g2, v2, x2), occluded: false };
        }
        placeCollisionCircles(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2) {
          const f2 = [], g2 = this.transform.elevation, v2 = t2.getProjection(), x2 = g2 ? g2.getAtTileOffsetFunc(m2, this.transform.center.lat, this.transform.worldSize, v2) : null, y2 = new e.P(o2.tileAnchorX, o2.tileAnchorY);
          let { x: b2, y: w2, z: T2 } = v2.projectTilePoint(y2.x, y2.y, m2.canonical);
          if (x2) {
            const [e22, t3, i3] = x2(y2);
            b2 += e22, w2 += t3, T2 += i3;
          }
          const E2 = "globe" === v2.name, C2 = this.projectAndGetPerspectiveRatio(a2, b2, w2, T2, m2, E2 || !!g2 || this.transform.pitch > 0, v2), { perspectiveRatio: I2 } = C2, S2 = (_2 ? n2 / I2 : n2 * I2) / e.aV, M2 = ge(b2, w2, T2, l2), L2 = C2.signedDistanceFromCamera > 0 ? be(S2, s2, o2.lineOffsetX * S2, o2.lineOffsetY * S2, false, M2, y2, o2, r2, l2, {}, g2 && !_2 ? x2 : null, _2 && !!g2, v2, m2, _2) : null;
          let P2 = false, D2 = false, A2 = true;
          if (L2 && !C2.occluded) {
            const t3 = 0.5 * u2 * I2 + p2, o3 = new e.P(-100, -100), r3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), s3 = new bt(), { first: n3, last: a3 } = L2, l3 = n3.path.length;
            let _3 = [];
            for (let e22 = l3 - 1; e22 >= 1; e22--)
              _3.push(n3.path[e22]);
            for (let e22 = 1; e22 < a3.path.length; e22++)
              _3.push(a3.path[e22]);
            const m3 = 2.5 * t3;
            c2 && (_3 = _3.map(([e22, t4, i3], o4) => (x2 && !E2 && (i3 = x2(o4 < l3 - 1 ? n3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2])[2]), ge(e22, t4, i3, c2))), _3.some((e22) => e22[3] <= 0) && (_3 = []));
            let g3 = [];
            if (_3.length > 0) {
              let t4 = 1 / 0, i3 = -1 / 0, s4 = 1 / 0, n4 = -1 / 0;
              for (const e22 of _3)
                t4 = Math.min(t4, e22[0]), s4 = Math.min(s4, e22[1]), i3 = Math.max(i3, e22[0]), n4 = Math.max(n4, e22[1]);
              i3 >= o3.x && t4 <= r3.x && n4 >= o3.y && s4 <= r3.y && (g3 = [_3.map((t5) => new e.P(t5[0], t5[1]))], (t4 < o3.x || i3 > r3.x || s4 < o3.y || n4 > r3.y) && (g3 = e.aT(g3, o3.x, o3.y, r3.x, r3.y)));
            }
            for (const e22 of g3) {
              s3.reset(e22, 0.25 * t3);
              let o4 = 0;
              o4 = s3.length <= 0.5 * t3 ? 1 : Math.ceil(s3.paddedLength / m3) + 1;
              for (let e3 = 0; e3 < o4; e3++) {
                const r4 = e3 / Math.max(o4 - 1, 1), n4 = s3.lerp(r4), a4 = n4.x + Tt, l4 = n4.y + Tt;
                f2.push(a4, l4, t3, 0);
                const c3 = a4 - t3, _4 = l4 - t3, u3 = a4 + t3, p3 = l4 + t3;
                if (A2 = A2 && this.isOffscreen(c3, _4, u3, p3), D2 = D2 || this.isInsideGrid(c3, _4, u3, p3), !i2 && this.grid.hitTestCircle(a4, l4, t3, d2) && (P2 = true, !h22))
                  return { circles: [], offscreen: false, collisionDetected: P2, occluded: false };
              }
            }
          }
          return { circles: !h22 && P2 || !D2 ? [] : f2, offscreen: A2, collisionDetected: P2, occluded: C2.occluded };
        }
        queryRenderedSymbols(t2) {
          if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          const i2 = [];
          let o2 = 1 / 0, r2 = 1 / 0, s2 = -1 / 0, n2 = -1 / 0;
          for (const a3 of t2) {
            const t3 = new e.P(a3.x + Tt, a3.y + Tt);
            o2 = Math.min(o2, t3.x), r2 = Math.min(r2, t3.y), s2 = Math.max(s2, t3.x), n2 = Math.max(n2, t3.y), i2.push(t3);
          }
          const a2 = this.grid.query(o2, r2, s2, n2).concat(this.ignoredGrid.query(o2, r2, s2, n2)), l2 = {}, c2 = {};
          for (const t3 of a2) {
            const o3 = t3.key;
            if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
              continue;
            const r3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
            e.aU(i2, r3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
          }
          return c2;
        }
        insertCollisionBox(e22, t2, i2, o2, r2) {
          (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, e22[0], e22[1], e22[2], e22[3]);
        }
        insertCollisionCircles(e22, t2, i2, o2, r2) {
          const s2 = t2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 };
          for (let t3 = 0; t3 < e22.length; t3 += 4)
            s2.insertCircle(n2, e22[t3], e22[t3 + 1], e22[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(t2, i2, o2, r2, s2, n2, a2) {
          const l2 = [i2, o2, r2, 1];
          let c2 = false;
          if (r2 || this.transform.pitch > 0) {
            if (e.e.transformMat4(l2, l2, t2), this.fogState && s2 && "globe" !== a2.name) {
              const t3 = function(t4, i3, o3, r3, s3, n3) {
                const a3 = n3.calculateFogTileMatrix(s3), l3 = [i3, o3, r3];
                return e.v.transformMat4(l3, l3, a3), Ge(t4, e.v.length(l3), n3.pitch, n3._fov);
              }(this.fogState, i2, o2, r2, s2.toUnwrapped(), this.transform);
              c2 = t3 > 0.9;
            }
          } else
            Me(l2, l2, t2);
          const h22 = l2[3];
          return { point: new e.P((l2[0] / h22 + 1) / 2 * this.transform.width + Tt, (-l2[1] / h22 + 1) / 2 * this.transform.height + Tt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h22 * 0.5, 1.5), signedDistanceFromCamera: h22, occluded: n2 && l2[2] > h22 || c2 };
        }
        isOffscreen(e22, t2, i2, o2) {
          return i2 < Tt || e22 >= this.screenRightBoundary || o2 < Tt || t2 > this.screenBottomBoundary;
        }
        isInsideGrid(e22, t2, i2, o2) {
          return i2 >= 0 && e22 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t2 = e.m.identity([]);
          return e.m.translate(t2, t2, [-100, -100, 0]), t2;
        }
      }
      function Ct(t2, i2, o2) {
        const r2 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
        return e.m.multiply(new Float32Array(16), t2.projMatrix, r2);
      }
      function It(e22, t2, i2) {
        if (t2.projection.name === i2.projection.name)
          return e22.projMatrix;
        const o2 = i2.clone();
        return o2.setProjection(t2.projection), Ct(o2, t2.getProjection(), e22);
      }
      function St(e22, t2, i2) {
        return t2.name === i2.projection.name ? e22.projMatrix : Ct(i2, t2, e22);
      }
      class Mt {
        constructor(e22, t2, i2, o2) {
          this.opacity = e22 ? Math.max(0, Math.min(1, e22.opacity + (e22.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class Lt {
        constructor(e22, t2, i2, o2, r2, s2 = false) {
          this.text = new Mt(e22 ? e22.text : null, t2, i2, r2), this.icon = new Mt(e22 ? e22.icon : null, t2, o2, r2), this.clipped = s2;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Pt {
        constructor(e22, t2, i2, o2 = false) {
          this.text = e22, this.icon = t2, this.skipFade = i2, this.clipped = o2;
        }
      }
      class Dt {
        constructor() {
          this.invProjMatrix = e.m.create(), this.viewportMatrix = e.m.create(), this.circles = [];
        }
      }
      class At {
        constructor(e22, t2, i2, o2, r2) {
          this.bucketInstanceId = e22, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
        }
      }
      class Rt {
        constructor(e22) {
          this.crossSourceCollisions = e22, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e22) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e22]) {
            const t2 = ++this.maxGroupID;
            this.collisionGroups[e22] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
          }
          return this.collisionGroups[e22];
        }
      }
      function zt(t2, i2, o2, r2, s2) {
        const { horizontalAlign: n2, verticalAlign: a2 } = e.aY(t2), l2 = -(n2 - 0.5) * i2, c2 = -(a2 - 0.5) * o2, h22 = e.aW(t2, r2);
        return new e.P(l2 + h22[0] * s2, c2 + h22[1] * s2);
      }
      function Ot(t2, i2, o2, r2, s2) {
        const n2 = new e.P(t2, i2);
        return o2 && n2._rotate(r2 ? s2 : -s2), n2;
      }
      class Ft {
        constructor(e22, t2, i2, o2, r2, s2) {
          this.transform = e22.clone(), this.projection = e22.projection.name, this.collisionIndex = new Et(this.transform, r2), this.buildingIndex = s2, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new Rt(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t2, i2, o2, r2) {
          const s2 = o2.getBucket(i2), n2 = o2.latestFeatureIndex;
          if (!s2 || !n2 || i2.fqid !== s2.layerIds[0])
            return;
          const a2 = s2.layers[0].layout, l2 = o2.collisionBoxArray, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h22 = o2.tileSize / e.J, _2 = o2.tileID.toUnwrapped();
          this.transform.setProjection(s2.projection);
          const d2 = (u2 = o2.tileID, p2 = s2.getProjection(), m2 = this.transform, p2.name === this.projection ? m2.calculateProjMatrix(u2.toUnwrapped()) : Ct(m2, p2, u2));
          var u2, p2, m2;
          const f2 = "map" === a2.get("text-pitch-alignment"), g2 = "map" === a2.get("text-rotation-alignment");
          i2.compileFilter();
          const v2 = i2.dynamicFilter(), x2 = i2.dynamicFilterNeedsFeature(), y2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), b2 = me(d2, o2.tileID.canonical, f2, g2, this.transform, s2.getProjection(), y2);
          let w2 = null;
          if (f2) {
            const t3 = fe(d2, o2.tileID.canonical, f2, g2, this.transform, s2.getProjection(), y2);
            w2 = e.m.multiply([], this.transform.labelPlaneMatrix, t3);
          }
          let T2 = null;
          v2 && o2.latestFeatureIndex && (T2 = { unwrappedTileID: _2, dynamicFilter: v2, dynamicFilterNeedsFeature: x2, featureIndex: o2.latestFeatureIndex }), this.retainedQueryData[s2.bucketInstanceId] = new At(s2.bucketInstanceId, n2, s2.sourceLayerIndex, s2.index, o2.tileID);
          const E2 = { bucket: s2, layout: a2, posMatrix: d2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T2, scale: c2, textPixelRatio: h22, holdingForFade: o2.holdingForFade(), collisionBoxArray: l2, partiallyEvaluatedTextSize: e.i(s2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.i(s2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s2.sourceID) };
          if (r2)
            for (const e22 of s2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3 } = e22;
              t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3, parameters: E2 });
            }
          else
            t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: s2.symbolInstances.length, parameters: E2 });
        }
        attemptAnchorPlacement(e22, t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2) {
          const { textOffset0: v2, textOffset1: x2, crossTileID: y2 } = _2, b2 = [v2, x2], w2 = zt(e22, i2, o2, b2, r2), T2 = this.collisionIndex.placeCollisionBox(u2, r2, t2, Ot(w2.x, w2.y, s2, n2, this.transform.angle), h22, a2, l2, c2.predicate);
          if (m2) {
            const e3 = u2.getSymbolInstanceIconSize(g2, this.transform.zoom, _2.placedIconSymbolIndex);
            if (0 === this.collisionIndex.placeCollisionBox(u2, e3, m2, Ot(w2.x, w2.y, s2, n2, this.transform.angle), h22, a2, l2, c2.predicate).box.length)
              return;
          }
          if (T2.box.length > 0) {
            let t3;
            return this.prevPlacement && this.prevPlacement.variableOffsets[y2] && this.prevPlacement.placements[y2] && this.prevPlacement.placements[y2].text && (t3 = this.prevPlacement.variableOffsets[y2].anchor), this.variableOffsets[y2] = { textOffset: b2, width: i2, height: o2, anchor: e22, textScale: r2, prevAnchor: t3 }, this.markUsedJustification(u2, e22, _2, p2), u2.allowVerticalPlacement && (this.markUsedOrientation(u2, p2, _2), this.placedOrientations[y2] = p2), { shift: w2, placedGlyphBoxes: T2 };
          }
        }
        placeLayerBucketPart(t2, i2, o2, r2) {
          const { bucket: s2, layout: n2, posMatrix: a2, textLabelPlaneMatrix: l2, labelToScreenMatrix: c2, clippingData: h22, textPixelRatio: _2, holdingForFade: d2, collisionBoxArray: u2, partiallyEvaluatedTextSize: p2, partiallyEvaluatedIconSize: m2, collisionGroup: f2 } = t2.parameters, g2 = n2.get("text-optional"), v2 = n2.get("icon-optional"), x2 = n2.get("text-allow-overlap"), y2 = n2.get("icon-allow-overlap"), b2 = "map" === n2.get("text-rotation-alignment"), w2 = "map" === n2.get("text-pitch-alignment"), T2 = "viewport-y" === n2.get("symbol-z-order"), E2 = n2.get("symbol-z-elevate");
          this.transform.setProjection(s2.projection);
          let C2 = x2 && (y2 || !s2.hasIconData() || v2), I2 = y2 && (x2 || !s2.hasTextData() || g2);
          !s2.collisionArrays && u2 && s2.deserializeCollisionBoxes(u2), o2 && r2 && s2.updateCollisionDebugBuffers(this.transform.zoom, u2);
          const S2 = (t3, r3, u3) => {
            const { crossTileID: T3, numVerticalGlyphVertices: E3 } = t3;
            if (h22) {
              const o3 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let r4 = null;
              if (h22.dynamicFilterNeedsFeature) {
                const e22 = this.retainedQueryData[s2.bucketInstanceId];
                r4 = h22.featureIndex.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e22.bucketIndex, sourceLayerIndex: e22.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, h22.dynamicFilter)(o3, r4, this.retainedQueryData[s2.bucketInstanceId].tileID.canonical, new e.P(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(h22.unwrappedTileID)))
                return this.placements[T3] = new Pt(false, false, false, true), void i2.add(T3);
            }
            if (i2.has(T3))
              return;
            if (d2)
              return void (this.placements[T3] = new Pt(false, false, false));
            let S3 = false, M2 = false, L2 = true, P2 = false, D2 = false, A2 = null, R2 = { box: null, offscreen: null, occluded: null }, z2 = { box: null, offscreen: null, occluded: null }, O2 = null, F2 = null, B2 = null, k2 = 0, N2 = 0, U2 = 0;
            u3.textFeatureIndex ? k2 = u3.textFeatureIndex : t3.useRuntimeCollisionCircles && (k2 = t3.featureIndex), u3.verticalTextFeatureIndex && (N2 = u3.verticalTextFeatureIndex);
            const G2 = (e22) => {
              e22.tileID = this.retainedQueryData[s2.bucketInstanceId].tileID;
              const i3 = this.transform.elevation;
              e22.elevation = t3.zOffset + (i3 ? i3.getAtTileOffset(e22.tileID, e22.tileAnchorX, e22.tileAnchorY) : 0);
            }, j2 = u3.textBox;
            if (j2) {
              G2(j2);
              const i3 = (i4) => {
                let o4 = e.W.horizontal;
                if (s2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e22 = this.prevPlacement.placedOrientations[T3];
                  e22 && (this.placedOrientations[T3] = e22, o4 = e22, this.markUsedOrientation(s2, o4, t3));
                }
                return o4;
              }, o3 = (t4, i4) => {
                if (s2.allowVerticalPlacement && E3 > 0 && u3.verticalTextBox) {
                  for (const o4 of s2.writingModes)
                    if (o4 === e.W.vertical ? (R2 = i4(), z2 = R2) : R2 = t4(), R2 && R2.box && R2.box.length)
                      break;
                } else
                  R2 = t4();
              };
              if (n2.get("text-variable-anchor")) {
                let l3 = n2.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[T3]) {
                  const e22 = this.prevPlacement.variableOffsets[T3];
                  l3.indexOf(e22.anchor) > 0 && (l3 = l3.filter((t4) => t4 !== e22.anchor), l3.unshift(e22.anchor));
                }
                const c3 = (e22, i4, o4) => {
                  const n3 = s2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r3), c4 = (e22.x2 - e22.x1) * n3 + 2 * e22.padding, h4 = (e22.y2 - e22.y1) * n3 + 2 * e22.padding, d3 = t3.hasIconTextFit && !y2 ? i4 : null;
                  d3 && G2(d3);
                  let u4 = { box: [], offscreen: false, occluded: false };
                  const g3 = x2 ? 2 * l3.length : l3.length;
                  for (let i5 = 0; i5 < g3; ++i5) {
                    const g4 = this.attemptAnchorPlacement(l3[i5 % l3.length], e22, c4, h4, n3, b2, w2, _2, a2, f2, i5 >= l3.length, t3, r3, s2, o4, d3, p2, m2);
                    if (g4 && (u4 = g4.placedGlyphBoxes, u4 && u4.box && u4.box.length)) {
                      S3 = true, A2 = g4.shift;
                      break;
                    }
                  }
                  return u4;
                };
                o3(() => c3(j2, u3.iconBox, e.W.horizontal), () => {
                  const t4 = u3.verticalTextBox;
                  return t4 && G2(t4), s2.allowVerticalPlacement && !(R2 && R2.box && R2.box.length) && E3 > 0 && t4 ? c3(t4, u3.verticalIconBox, e.W.vertical) : { box: null, offscreen: null, occluded: null };
                }), R2 && (S3 = R2.box, L2 = R2.offscreen, P2 = R2.occluded);
                const h3 = i3(!(!R2 || !R2.box));
                if (!S3 && this.prevPlacement) {
                  const e22 = this.prevPlacement.variableOffsets[T3];
                  e22 && (this.variableOffsets[T3] = e22, this.markUsedJustification(s2, e22.anchor, t3, h3));
                }
              } else {
                const n3 = (i4, o4) => {
                  const n4 = s2.getSymbolInstanceTextSize(p2, t3, this.transform.zoom, r3), l3 = this.collisionIndex.placeCollisionBox(s2, n4, i4, new e.P(0, 0), x2, _2, a2, f2.predicate);
                  return l3 && l3.box && l3.box.length && (this.markUsedOrientation(s2, o4, t3), this.placedOrientations[T3] = o4), l3;
                };
                o3(() => n3(j2, e.W.horizontal), () => {
                  const t4 = u3.verticalTextBox;
                  return s2.allowVerticalPlacement && E3 > 0 && t4 ? (G2(t4), n3(t4, e.W.vertical)) : { box: null, offscreen: null, occluded: null };
                }), i3(!!(R2 && R2.box && R2.box.length));
              }
            }
            if (O2 = R2, S3 = O2 && O2.box && O2.box.length > 0, L2 = O2 && O2.offscreen, P2 = O2 && O2.occluded, t3.useRuntimeCollisionCircles) {
              const i3 = s2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r4 = e.j(s2.textSizeData, p2, i3), h3 = n2.get("text-padding");
              F2 = this.collisionIndex.placeCollisionCircles(s2, x2, i3, s2.lineVertexArray, s2.glyphOffsetArray, r4, a2, l2, c2, o2, w2, f2.predicate, t3.collisionCircleDiameter * r4 / e.aV, h3, this.retainedQueryData[s2.bucketInstanceId].tileID), S3 = x2 || F2.circles.length > 0 && !F2.collisionDetected, L2 = L2 && F2.offscreen, P2 = F2.occluded;
            }
            if (u3.iconFeatureIndex && (U2 = u3.iconFeatureIndex), u3.iconBox) {
              const i3 = (i4) => {
                G2(i4);
                const o3 = t3.hasIconTextFit && A2 ? Ot(A2.x, A2.y, b2, w2, this.transform.angle) : new e.P(0, 0), r4 = s2.getSymbolInstanceIconSize(m2, this.transform.zoom, t3.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(s2, r4, i4, o3, y2, _2, a2, f2.predicate);
              };
              z2 && z2.box && z2.box.length && u3.verticalIconBox ? (B2 = i3(u3.verticalIconBox), M2 = B2.box.length > 0) : (B2 = i3(u3.iconBox), M2 = B2.box.length > 0), L2 = L2 && B2.offscreen, D2 = B2.occluded;
            }
            const V2 = g2 || 0 === t3.numHorizontalGlyphVertices && 0 === E3, Z2 = v2 || 0 === t3.numIconVertices;
            if (V2 || Z2 ? Z2 ? V2 || (M2 = M2 && S3) : S3 = M2 && S3 : M2 = S3 = M2 && S3, S3 && O2 && O2.box && this.collisionIndex.insertCollisionBox(O2.box, n2.get("text-ignore-placement"), s2.bucketInstanceId, z2 && z2.box && N2 ? N2 : k2, f2.ID), M2 && B2 && this.collisionIndex.insertCollisionBox(B2.box, n2.get("icon-ignore-placement"), s2.bucketInstanceId, U2, f2.ID), F2 && (S3 && this.collisionIndex.insertCollisionCircles(F2.circles, n2.get("text-ignore-placement"), s2.bucketInstanceId, k2, f2.ID), o2)) {
              const e22 = s2.bucketInstanceId;
              let t4 = this.collisionCircleArrays[e22];
              void 0 === t4 && (t4 = this.collisionCircleArrays[e22] = new Dt());
              for (let e3 = 0; e3 < F2.circles.length; e3 += 4)
                t4.circles.push(F2.circles[e3 + 0]), t4.circles.push(F2.circles[e3 + 1]), t4.circles.push(F2.circles[e3 + 2]), t4.circles.push(F2.collisionDetected ? 1 : 0);
            }
            const W2 = "globe" !== s2.projection.name;
            C2 = C2 && (W2 || !P2), I2 = I2 && (W2 || !D2), this.placements[T3] = new Pt(S3 || C2, M2 || I2, L2 || s2.justReloaded), i2.add(T3);
          };
          if (E2 && this.buildingIndex && (this.buildingIndex.updateZOffset(s2, this.retainedQueryData[s2.bucketInstanceId].tileID), s2.updateZOffset()), T2) {
            const t3 = s2.getSortedSymbolIndexes(this.transform.angle);
            for (let e22 = t3.length - 1; e22 >= 0; --e22) {
              const i3 = t3[e22];
              S2(s2.symbolInstances.get(i3), i3, s2.collisionArrays[i3]);
            }
            s2.hasAnyZOffset && e.X(`${s2.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
          } else if (s2.hasAnyZOffset) {
            const e22 = s2.getSortedIndexesByZOffset();
            for (let t3 = 0; t3 < e22.length; ++t3) {
              const i3 = e22[t3];
              S2(s2.symbolInstances.get(i3), i3, s2.collisionArrays[i3]);
            }
          } else
            for (let e22 = t2.symbolInstanceStart; e22 < t2.symbolInstanceEnd; e22++)
              S2(s2.symbolInstances.get(e22), e22, s2.collisionArrays[e22]);
          if (o2 && s2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[s2.bucketInstanceId];
            e.m.invert(t3.invProjMatrix, a2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          s2.justReloaded = false;
        }
        markUsedJustification(t2, i2, o2, r2) {
          const { leftJustifiedTextSymbolIndex: s2, centerJustifiedTextSymbolIndex: n2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h22 = e.aX(i2), _2 = r2 === e.W.vertical ? l2 : "left" === h22 ? s2 : "center" === h22 ? n2 : "right" === h22 ? a2 : -1;
          s2 >= 0 && (t2.text.placedSymbolArray.get(s2).crossTileID = _2 >= 0 && s2 !== _2 ? 0 : c2), n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = _2 >= 0 && n2 !== _2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = _2 >= 0 && a2 !== _2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = _2 >= 0 && l2 !== _2 ? 0 : c2);
        }
        markUsedOrientation(t2, i2, o2) {
          const r2 = i2 === e.W.horizontal || i2 === e.W.horizontalOnly ? i2 : 0, s2 = i2 === e.W.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h22 = t2.text.placedSymbolArray;
          n2 >= 0 && (h22.get(n2).placedOrientation = r2), a2 >= 0 && (h22.get(a2).placedOrientation = r2), l2 >= 0 && (h22.get(l2).placedOrientation = r2), c2 >= 0 && (h22.get(c2).placedOrientation = s2);
        }
        commit(e22) {
          this.commitTime = e22, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
          const o2 = t2 ? t2.symbolFadeChange(e22) : 1, r2 = t2 ? t2.opacities : {}, s2 = t2 ? t2.variableOffsets : {}, n2 = t2 ? t2.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], s3 = r2[e3];
            s3 ? (this.opacities[e3] = new Lt(s3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== s3.text.placed || t3.icon !== s3.icon.placed) : (this.opacities[e3] = new Lt(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
          }
          for (const e3 in r2) {
            const t3 = r2[e3];
            if (!this.opacities[e3]) {
              const r3 = new Lt(t3, o2, false, false);
              r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in s2)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = s2[e3]);
          for (const e3 in n2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = n2[e3]);
          i2 ? this.lastPlacementChangeTime = e22 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e22);
        }
        updateLayerOpacities(e22, t2) {
          const i2 = /* @__PURE__ */ new Set();
          for (const o2 of t2) {
            const t3 = o2.getBucket(e22);
            t3 && o2.latestFeatureIndex && e22.fqid === t3.layerIds[0] && (this.updateBucketOpacities(t3, i2, o2.collisionBoxArray), t3.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t3, o2.tileID), t3.updateZOffset()));
          }
        }
        updateBucketOpacities(t2, i2, o2) {
          t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
          const r2 = t2.layers[0].layout, s2 = !!t2.layers[0].dynamicFilter(), n2 = new Lt(null, 0, false, false, true), a2 = r2.get("text-allow-overlap"), l2 = r2.get("icon-allow-overlap"), c2 = r2.get("text-variable-anchor"), h22 = "map" === r2.get("text-rotation-alignment"), _2 = "map" === r2.get("text-pitch-alignment"), d2 = new Lt(null, 0, a2 && (l2 || !t2.hasIconData() || r2.get("icon-optional")), l2 && (a2 || !t2.hasTextData() || r2.get("text-optional")), true);
          !t2.collisionArrays && o2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(o2);
          const u2 = (e22, t3, i3) => {
            for (let o3 = 0; o3 < t3 / 4; o3++)
              e22.opacityVertexArray.emplaceBack(i3);
          };
          let p2 = 0;
          for (let o3 = 0; o3 < t2.symbolInstances.length; o3++) {
            const r3 = t2.symbolInstances.get(o3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: l3, crossTileID: m2, numIconVertices: f2 } = r3, g2 = i2.has(m2);
            let v2 = this.opacities[m2];
            g2 ? v2 = n2 : v2 || (v2 = d2, this.opacities[m2] = v2), i2.add(m2);
            const x2 = a3 > 0 || l3 > 0, y2 = f2 > 0, b2 = this.placedOrientations[m2], w2 = b2 === e.W.vertical, T2 = b2 === e.W.horizontal || b2 === e.W.horizontalOnly;
            if (!x2 && !y2 || v2.isHidden() || p2++, x2) {
              const e22 = Wt(v2.text);
              u2(t2.text, a3, w2 ? Ht : e22), u2(t2.text, l3, T2 ? Ht : e22);
              const i3 = v2.text.isHidden(), { leftJustifiedTextSymbolIndex: o4, centerJustifiedTextSymbolIndex: s3, rightJustifiedTextSymbolIndex: n3, verticalPlacedTextSymbolIndex: c3 } = r3, h3 = t2.text.placedSymbolArray, _3 = i3 || w2 ? 1 : 0;
              o4 >= 0 && (h3.get(o4).hidden = _3), s3 >= 0 && (h3.get(s3).hidden = _3), n3 >= 0 && (h3.get(n3).hidden = _3), c3 >= 0 && (h3.get(c3).hidden = i3 || T2 ? 1 : 0);
              const d3 = this.variableOffsets[m2];
              d3 && this.markUsedJustification(t2, d3.anchor, r3, b2);
              const p3 = this.placedOrientations[m2];
              p3 && (this.markUsedJustification(t2, "left", r3, p3), this.markUsedOrientation(t2, p3, r3));
            }
            if (y2) {
              const e22 = Wt(v2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o4 } = r3, s3 = t2.icon.placedSymbolArray, n3 = v2.icon.isHidden() ? 1 : 0;
              i3 >= 0 && (u2(t2.icon, f2, w2 ? Ht : e22), s3.get(i3).hidden = n3), o4 >= 0 && (u2(t2.icon, r3.numVerticalIconVertices, T2 ? Ht : e22), s3.get(o4).hidden = n3);
            }
            if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
              const i3 = t2.collisionArrays[o3];
              if (i3) {
                let o4 = new e.P(0, 0), n3 = true;
                if (i3.textBox || i3.verticalTextBox) {
                  if (c2) {
                    const e22 = this.variableOffsets[m2];
                    e22 ? (o4 = zt(e22.anchor, e22.width, e22.height, e22.textOffset, e22.textScale), h22 && o4._rotate(_2 ? this.transform.angle : -this.transform.angle)) : n3 = false;
                  }
                  s2 && (n3 = !v2.clipped), i3.textBox && Bt(t2.textCollisionBox.collisionVertexArray, v2.text.placed, !n3 || w2, o4.x, o4.y), i3.verticalTextBox && Bt(t2.textCollisionBox.collisionVertexArray, v2.text.placed, !n3 || T2, o4.x, o4.y);
                }
                const a4 = n3 && Boolean(!T2 && i3.verticalIconBox);
                i3.iconBox && Bt(t2.iconCollisionBox.collisionVertexArray, v2.icon.placed, a4, r3.hasIconTextFit ? o4.x : 0, r3.hasIconTextFit ? o4.y : 0), i3.verticalIconBox && Bt(t2.iconCollisionBox.collisionVertexArray, v2.icon.placed, !a4, r3.hasIconTextFit ? o4.x : 0, r3.hasIconTextFit ? o4.y : 0);
              }
            }
          }
          if (t2.fullyClipped = 0 === p2, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
            const e22 = this.collisionCircleArrays[t2.bucketInstanceId];
            t2.placementInvProjMatrix = e22.invProjMatrix, t2.placementViewportMatrix = e22.viewportMatrix, t2.collisionCircleArray = e22.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
          }
        }
        symbolFadeChange(e22) {
          return 0 === this.fadeDuration ? 1 : (e22 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e22) {
          return Math.max(0, (this.transform.zoom - e22) / 1.5);
        }
        hasTransitions(e22) {
          return this.stale || e22 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e22, t2) {
          const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
          return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e22;
        }
        setStale() {
          this.stale = true;
        }
      }
      function Bt(e22, t2, i2, o2, r2) {
        e22.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e22.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e22.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e22.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
      }
      const kt = Math.pow(2, 25), Nt = Math.pow(2, 24), Ut = Math.pow(2, 17), Gt = Math.pow(2, 16), jt = Math.pow(2, 9), Vt = Math.pow(2, 8), Zt = Math.pow(2, 1);
      function Wt(e22) {
        if (0 === e22.opacity && !e22.placed)
          return 0;
        if (1 === e22.opacity && e22.placed)
          return 4294967295;
        const t2 = e22.placed ? 1 : 0, i2 = Math.floor(127 * e22.opacity);
        return i2 * kt + t2 * Nt + i2 * Ut + t2 * Gt + i2 * jt + t2 * Vt + i2 * Zt + t2;
      }
      const Ht = 0;
      class qt {
        constructor(e22) {
          this._sortAcrossTiles = "viewport-y" !== e22.layout.get("symbol-z-order") && void 0 !== e22.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(e22, t2, i2, o2, r2) {
          const s2 = this._bucketParts;
          for (; this._currentTileIndex < e22.length; )
            if (t2.getBucketParts(s2, o2, e22[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, s2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < s2.length; ) {
            const e3 = s2[this._currentPartIndex];
            if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r2())
              return true;
          }
          return false;
        }
      }
      class $t {
        constructor(e22, t2, i2, o2, r2, s2, n2, a2, l2) {
          this.placement = new Ft(e22, r2, s2, n2, a2, l2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t2, i2, o2, r2) {
          const s2 = e.a4.now(), n2 = () => {
            const t3 = e.a4.now() - s2;
            return !this._forceFullPlacement && t3 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const s3 = i2[t2[this._currentPlacementIndex]], a2 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === s3.type && (!s3.minzoom || s3.minzoom <= a2) && (!s3.maxzoom || s3.maxzoom > a2)) {
              const t3 = s3, i3 = t3.layout.get("symbol-z-elevate"), a3 = this._inProgressLayer = this._inProgressLayer || new qt(t3), l2 = e.aE(s3.source, s3.scope);
              if (a3.continuePlacement(i3 ? r2[l2] : o2[l2], this.placement, this._showCollisionBoxes, s3, n2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e22) {
          return this.placement.commit(e22), this.placement;
        }
      }
      const Xt = 512 / e.J / 2;
      class Jt {
        constructor(t2, i2, o2) {
          this.tileID = t2, this.bucketInstanceId = o2, this.index = new e.aZ(i2.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const r2 = t2.canonical.x * e.J, s2 = t2.canonical.y * e.J;
          for (let e22 = 0; e22 < i2.length; e22++) {
            const { key: t3, crossTileID: o3, tileAnchorX: n2, tileAnchorY: a2 } = i2.get(e22), l2 = Math.floor((r2 + n2) * Xt), c2 = Math.floor((s2 + a2) * Xt);
            this.index.add(l2, c2), this.keys.push(t3), this.crossTileIDs.push(o3);
          }
          this.index.finish();
        }
        findMatches(t2, i2, o2) {
          const r2 = this.tileID.canonical.z < i2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i2.canonical.z), s2 = Xt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z), n2 = i2.canonical.x * e.J, a2 = i2.canonical.y * e.J;
          for (let e22 = 0; e22 < t2.length; e22++) {
            const i3 = t2.get(e22);
            if (i3.crossTileID)
              continue;
            const { key: l2, tileAnchorX: c2, tileAnchorY: h22 } = i3, _2 = Math.floor((n2 + c2) * s2), d2 = Math.floor((a2 + h22) * s2), u2 = this.index.range(_2 - r2, d2 - r2, _2 + r2, d2 + r2);
            for (const e3 of u2) {
              const t3 = this.crossTileIDs[e3];
              if (this.keys[e3] === l2 && !o2.has(t3)) {
                o2.add(t3), i3.crossTileID = t3;
                break;
              }
            }
          }
        }
      }
      class Yt {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Kt {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e22) {
          const t2 = Math.round((e22 - this.lng) / 360);
          if (0 !== t2)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const r2 = i2[e4];
                r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), o2[r2.tileID.key] = r2;
              }
              this.indexes[e3] = o2;
            }
          this.lng = e22;
        }
        addBucket(e22, t2, i2) {
          if (this.indexes[e22.overscaledZ] && this.indexes[e22.overscaledZ][e22.key]) {
            if (this.indexes[e22.overscaledZ][e22.key].bucketInstanceId === t2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e22.overscaledZ, this.indexes[e22.overscaledZ][e22.key]);
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
            t2.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e22.overscaledZ] || (this.usedCrossTileIDs[e22.overscaledZ] = /* @__PURE__ */ new Set());
          const o2 = this.usedCrossTileIDs[e22.overscaledZ];
          for (const i3 in this.indexes) {
            const r2 = this.indexes[i3];
            if (Number(i3) > e22.overscaledZ)
              for (const i4 in r2) {
                const s2 = r2[i4];
                s2.tileID.isChildOf(e22) && s2.findMatches(t2.symbolInstances, e22, o2);
              }
            else {
              const s2 = r2[e22.scaledTo(Number(i3)).key];
              s2 && s2.findMatches(t2.symbolInstances, e22, o2);
            }
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
            const r2 = t2.symbolInstances.get(e3);
            r2.crossTileID || (r2.crossTileID = i2.generate(), o2.add(r2.crossTileID));
          }
          return void 0 === this.indexes[e22.overscaledZ] && (this.indexes[e22.overscaledZ] = {}), this.indexes[e22.overscaledZ][e22.key] = new Jt(e22, t2.symbolInstances, t2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e22, t2) {
          for (const i2 of t2.crossTileIDs)
            this.usedCrossTileIDs[e22].delete(i2);
        }
        removeStaleBuckets(e22) {
          let t2 = false;
          for (const i2 in this.indexes) {
            const o2 = this.indexes[i2];
            for (const r2 in o2)
              e22[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], t2 = true);
          }
          return t2;
        }
      }
      class Qt {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Yt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e22, t2, i2, o2) {
          let r2 = this.layerIndexes[e22.fqid];
          void 0 === r2 && (r2 = this.layerIndexes[e22.fqid] = new Kt());
          let s2 = false;
          const n2 = {};
          "globe" !== o2.name && r2.handleWrapJump(i2);
          for (const i3 of t2) {
            const t3 = i3.getBucket(e22);
            t3 && e22.fqid === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r2.addBucket(i3.tileID, t3, this.crossTileIDs) && (s2 = true), n2[t3.bucketInstanceId] = true);
          }
          return r2.removeStaleBuckets(n2) && (s2 = true), s2;
        }
        pruneUnusedLayers(e22) {
          const t2 = {};
          e22.forEach((e3) => {
            t2[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t2[e3] || delete this.layerIndexes[e3];
        }
      }
      var ei = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", ti = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color) {\n#ifdef INDICATOR_CUTOUT\nfloat holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,vec2 pos,vec2 lod_coord) {vec2 size=vec2(textureSize(image,0));vec2 dx=dFdx(lod_coord.xy*size);vec2 dy=dFdy(lod_coord.xy*size);float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}", ii = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", oi = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ri = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", si = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ni = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", ai = "#ifdef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);vec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return (texCoord.xxyy+vec2(1.5,0.5).xyxy)/texResolution.xxyy;}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;vec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texture(u_image0,c.yz),texture(u_image0,c.xz),texture(u_image0,c.yw),texture(u_image0,c.xw)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;vec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texture(u_image1,c.yz),texture(u_image1,c.xz),texture(u_image1,c.yw),texture(u_image1,c.xw)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texture(u_image0,texCoord);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texture(u_image1,texCoord);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", li = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", ci = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef NATIVE\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
      const hi = [];
      fi(ei, hi), fi(ii, hi), fi(ti, hi);
      const _i = { "_prelude_fog.vertex.glsl": si, "_prelude_terrain.vertex.glsl": ri, "_prelude_shadow.vertex.glsl": li, "_prelude_fog.fragment.glsl": ni, "_prelude_shadow.fragment.glsl": ci, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": ai }, di = {};
      gi("", ri), gi(ni, si), gi(ci, li), gi(ai, "");
      const ui = gi(ti, ii), pi = ei;
      var mi = { background: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), circle: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: gi("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: gi('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: gi("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: gi("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), fill: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutline: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nuniform float u_emissive_strength;in float v_height;void main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=max(0.01,cutoff_opacity(u_cutoff_params,ground.z));if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff < 0.01 && centroid_pos.x !=0.0));gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: gi("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nout vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: gi('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,v_depth));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);v_depth=gl_Position.w;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: gi("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;HANDLE_WIREFRAME_DEBUG;\n#endif\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: gi("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    \nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), linePattern: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float pattern_x=v_linesofar/pattern_size.x*aspect;float x=mod(pattern_x,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_ground(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), raster: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;void main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), symbolIcon: gi('#include "_prelude_lighting.glsl"\nuniform sampler2D u_texture;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\nin float v_fade_opacity;in vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nuniform mediump float u_icon_saturation;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nlowp float alpha=opacity*v_fade_opacity;vec4 out_color;\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b)*alpha;\n#else\nout_color=texture(u_texture,v_tex_a)*alpha;\n#endif\n#ifdef SATURATION\nvec3 luma=vec3(dot(out_color.rgb,vec3(0.2126,0.7152,0.0722)));out_color.rgb=mix(luma,out_color.rgb,u_icon_saturation);\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nv_tex_a=a_tex/u_texsize;\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\nv_fade_opacity=out_fade_opacity;}'), symbolSDF: gi('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\nuniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}'), symbolTextAndIcon: gi('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout float v_draw_halo;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nfloat out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}'), terrainRaster: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,v_depth,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}'), terrainDepth: gi("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: gi('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', oi), skyboxGradient: gi('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', oi), skyboxCapture: gi("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: gi('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: gi('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nreturn vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=local_pos;\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1);v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: gi("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: gi("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}") };
      function fi(e22, t2) {
        const i2 = e22.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
        for (let e3 of i2)
          if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
            e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const i3 = e3.split(" ");
            for (const e4 of i3)
              t2.includes(e4) || t2.push(e4);
          }
      }
      function gi(e22, t2) {
        const i2 = /#include\s+"([^"]+)"/g, o2 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let r2 = t2.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        r2 && (r2 = r2.map((e3) => {
          const t3 = e3.split(" ");
          return t3[t3.length - 1];
        }), r2 = [...new Set(r2)]);
        const s2 = {}, n2 = [], a2 = [];
        if (e22 = e22.replace(i2, (e3, t3) => (a2.push(t3), "")), (t2 = t2.replace(i2, (e3, t3) => (n2.push(t3), ""))).includes("flat out"))
          return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
        let l2 = [...hi];
        fi(e22, l2), fi(t2, l2);
        for (const e3 of [...n2, ...a2])
          _i[e3] || console.error(`Undefined include: ${e3}`), di[e3] || (di[e3] = [], fi(_i[e3], di[e3])), l2 = [...l2, ...di[e3]];
        return { fragmentSource: e22 = e22.replace(o2, (e3, t3, i3, o3, r3) => (s2[r3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
in ${i3} ${o3} ${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "initialize" === t3 ? `
#ifdef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    in ${i3} ${o3} ${r3};
#endif
` : "initialize-attribute" === t3 ? "" : void 0)), vertexSource: t2 = t2.replace(o2, (e3, t3, i3, o3, r3) => {
          const n3 = "float" === o3 ? "vec2" : o3, a3 = r3.match(/color/) ? "color" : n3;
          return "define-attribute-vertex-shader-only" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
in ${i3} ${o3} a_${r3};
#endif
` : s2[r3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${n3} a_${r3};
out ${i3} ${o3} ${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "initialize" === t3 ? "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = a_${r3};
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = unpack_mix_${a3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    in ${i3} ${o3} a_${r3};
    out ${i3} ${o3} ${r3};
#endif
` : "initialize-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    ${r3} = a_${r3};
#endif
` : void 0 : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
in ${i3} ${n3} a_${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "define-instanced" === t3 ? "mat4" === a3 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${r3}0;
in vec4 a_${r3}1;
in vec4 a_${r3}2;
in vec4 a_${r3}3;
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i3} ${n3} a_${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "initialize-attribute-custom" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${r3}
    ${i3} ${o3} ${r3} = a_${r3};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = a_${r3};
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = unpack_mix_${a3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
`;
        }), staticAttributes: r2, usedDefines: l2, vertexIncludes: n2, fragmentIncludes: a2 };
      }
      class vi {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(e22, t2, i2, o2, r2, s2, n2, a2) {
          this.context = e22;
          let l2 = this.boundPaintVertexBuffers.length !== o2.length;
          for (let e3 = 0; !l2 && e3 < o2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== o2[e3] && (l2 = true);
          let c2 = this.boundDynamicVertexBuffers.length !== n2.length;
          for (let e3 = 0; !c2 && e3 < n2.length; e3++)
            this.boundDynamicVertexBuffers[e3] !== n2[e3] && (c2 = true);
          if (!this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || l2 || c2 || this.boundIndexBuffer !== r2 || this.boundVertexOffset !== s2)
            this.freshBind(t2, i2, o2, r2, s2, n2, a2);
          else {
            e22.bindVertexArrayOES.set(this.vao);
            for (const i3 of n2)
              i3 && (i3.bind(), a2 && i3.instanceCount && i3.setVertexAttribDivisor(e22.gl, t2, a2));
            r2 && r2.dynamicDraw && r2.bind();
          }
        }
        freshBind(e22, t2, i2, o2, r2, s2, n2) {
          const a2 = e22.numAttributes, l2 = this.context, c2 = l2.gl;
          this.vao && this.destroy(), this.vao = l2.gl.createVertexArray(), l2.bindVertexArrayOES.set(this.vao), this.boundProgram = e22, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffers = s2, t2.enableAttributes(c2, e22), t2.bind(), t2.setVertexAttribPointers(c2, e22, r2);
          for (const t3 of i2)
            t3.enableAttributes(c2, e22), t3.bind(), t3.setVertexAttribPointers(c2, e22, r2);
          for (const t3 of s2)
            t3 && (t3.enableAttributes(c2, e22), t3.bind(), t3.setVertexAttribPointers(c2, e22, r2), n2 && t3.instanceCount && t3.setVertexAttribDivisor(c2, e22, n2));
          o2 && o2.bind(), l2.currentNumAttributes = a2;
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function xi(t2, i2) {
        const o2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
        return [new e.M(0, r2 / o2).toLngLat().lat, new e.M(0, (r2 + 1) / o2).toLngLat().lat];
      }
      function yi(t2, i2, o2, r2, s2, n2, a2) {
        const l2 = t2.context, c2 = l2.gl, h22 = o2.hillshadeFBO;
        if (!h22)
          return;
        t2.prepareDrawTile();
        const _2 = t2.isTileAffectedByFog(i2), d2 = t2.getOrCreateProgram("hillshade", { overrideFog: _2 });
        l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h22.colorAttachment.get());
        const u2 = ((t3, i3, o3, r3) => {
          const s3 = o3.paint.get("hillshade-shadow-color"), n3 = o3.paint.get("hillshade-highlight-color"), a3 = o3.paint.get("hillshade-accent-color"), l3 = o3.paint.get("hillshade-emissive-strength");
          let c3 = e.d(o3.paint.get("hillshade-illumination-direction"));
          if ("viewport" === o3.paint.get("hillshade-illumination-anchor"))
            c3 -= t3.transform.angle;
          else if (t3.style && t3.style.enable3dLights() && t3.style.directionalLight) {
            const i4 = t3.style.directionalLight.properties.get("direction"), o4 = e.b3(i4.x, i4.y, i4.z);
            c3 = e.d(o4[1]);
          }
          const h3 = !t3.options.moving;
          return { u_matrix: r3 || t3.transform.calculateProjMatrix(i3.tileID.toUnwrapped(), h3), u_image: 0, u_latrange: xi(0, i3.tileID), u_light: [o3.paint.get("hillshade-exaggeration"), c3], u_shadow: s3, u_highlight: n3, u_emissive_strength: l3, u_accent: a3 };
        })(t2, o2, r2, t2.terrain ? i2.projMatrix : null);
        t2.uploadCommonUniforms(l2, d2, i2.toUnwrapped());
        const { tileBoundsBuffer: p2, tileBoundsIndexBuffer: m2, tileBoundsSegments: f2 } = t2.getTileBoundsBuffers(o2);
        d2.draw(t2, c2.TRIANGLES, s2, n2, a2, e.b5.disabled, u2, r2.id, p2, m2, f2);
      }
      function bi(t2, i2, o2) {
        if (!i2.needsDEMTextureUpload)
          return;
        const r2 = t2.context, s2 = r2.gl;
        r2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
        const n2 = o2.getPixels();
        i2.demTexture ? i2.demTexture.update(n2, { premultiply: false }) : i2.demTexture = new e.a9(r2, n2, s2.R32F, { premultiply: false }), i2.needsDEMTextureUpload = false;
      }
      function wi(t2, i2, o2) {
        const r2 = t2.context, s2 = r2.gl;
        if (!i2.dem)
          return;
        const n2 = i2.dem;
        if (r2.activeTexture.set(s2.TEXTURE1), bi(t2, i2, n2), !i2.demTexture)
          return;
        i2.demTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE);
        const a2 = n2.dim;
        r2.activeTexture.set(s2.TEXTURE0);
        let l2 = i2.hillshadeFBO;
        if (!l2) {
          const t3 = new e.a9(r2, { width: a2, height: a2, data: null }, s2.RGBA);
          t3.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), l2 = i2.hillshadeFBO = r2.createFramebuffer(a2, a2, true, "renderbuffer"), l2.colorAttachment.set(t3.texture);
        }
        r2.bindFramebuffer.set(l2.framebuffer), r2.viewport.set([0, 0, a2, a2]);
        const { tileBoundsBuffer: c2, tileBoundsIndexBuffer: h22, tileBoundsSegments: _2 } = t2.getMercatorTileBoundsBuffers(), d2 = [];
        t2.linearFloatFilteringSupported() && d2.push("TERRAIN_DEM_FLOAT_FORMAT"), t2.getOrCreateProgram("hillshadePrepare", { defines: d2 }).draw(t2, s2.TRIANGLES, e.b4.disabled, e.b6.disabled, e.a.unblended, e.b5.disabled, ((t3, i3) => {
          const o3 = i3.stride, r3 = e.m.create();
          return e.m.ortho(r3, 0, e.J, -e.J, 0, 0, 1), e.m.translate(r3, r3, [0, -e.J, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ };
        })(i2.tileID, n2), o2.id, c2, h22, _2), i2.needsHillshadePrepare = false;
      }
      const Ti = (t2) => ({ u_matrix: new e.a_(t2), u_image0: new e.a$(t2), u_skirt_height: new e.b2(t2), u_ground_shadow_factor: new e.b7(t2) }), Ei = (e22, t2, i2) => ({ u_matrix: e22, u_image0: 0, u_skirt_height: t2, u_ground_shadow_factor: i2 }), Ci = (e22, t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2) => ({ u_proj_matrix: Float32Array.from(e22), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: r2, u_merc_center: s2, u_image0: 0, u_frustum_tl: n2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h22, u_globe_radius: _2, u_viewport: d2, u_grid_matrix: p2 ? Float32Array.from(p2) : new Float32Array(9), u_skirt_height: u2 }), Ii = (t2, i2) => {
        if (i2 > 0 && t2.terrain && e.X("Cutoff is currently disabled on terrain"), i2 <= 0 || t2.terrain)
          return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
        const o2 = t2.transform, r2 = Math.max(Math.abs(o2._zoom - (t2.minCutoffZoom - 1)), 1), s2 = o2.isLODDisabled(false) ? e.an(60, 45, o2.pitch) : e.an(30, 15, o2.pitch), n2 = o2._farZ - o2._nearZ, a2 = i2 * o2.height, l2 = ((1 - (c2 = s2)) * o2.cameraToCenterDistance + c2 * (o2._farZ + a2)) * r2;
        var c2;
        return { shouldRenderCutoff: s2 < 1, uniformValues: { u_cutoff_params: [o2._nearZ, o2._farZ, (l2 - o2._nearZ) / n2, (l2 - a2 - o2._nearZ) / n2] } };
      };
      function Si(e22, t2) {
        return null != e22 && null != t2 && !(!e22.hasData() || !t2.hasData()) && null != e22.demTexture && null != t2.demTexture && e22.tileID.key !== t2.tileID.key;
      }
      const Mi = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e22, t2, i2, o2, r2) {
          if (e22 in this.operations) {
            const t3 = this.operations[e22];
            t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
          } else
            this.operations[e22] = { startTime: o2, phase: 0, duration: r2, from: t2, to: i2, queued: null };
        }
        getMorphValuesForProxy(e22) {
          if (!(e22 in this.operations))
            return null;
          const t2 = this.operations[e22];
          return { from: t2.from, to: t2.to, phase: t2.phase };
        }
        update(e22) {
          for (const t2 in this.operations) {
            const i2 = this.operations[t2];
            for (i2.phase = (e22 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
              if (!this._nextOp(i2, e22)) {
                delete this.operations[t2];
                break;
              }
          }
        }
        _nextOp(e22, t2) {
          return !!e22.queued && (e22.from = e22.to, e22.to = e22.queued, e22.queued = null, e22.phase = 0, e22.startTime = t2, true);
        }
        _validOp(e22) {
          return e22.from.hasData() && e22.to.hasData();
        }
      }(), Li = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
      function Pi(e22, t2, i2) {
        if (0 === t2)
          return 0;
        const o2 = t2 < 1 && 514 === i2 ? 0.25 / t2 : 1;
        return 6 * Math.pow(1.5, 22 - e22) * Math.max(t2, 1) * o2;
      }
      function Di(e22, t2) {
        const i2 = 1 << e22.z;
        return !t2 && (0 === e22.x || e22.x === i2 - 1) || 0 === e22.y || e22.y === i2 - 1;
      }
      const Ai = (e22) => ({ u_matrix: e22 });
      function Ri(t2, i2, o2, r2, s2) {
        if (s2 > 0) {
          const n2 = e.a4.now(), a2 = (n2 - t2.timeAdded) / s2, l2 = i2 ? (n2 - i2.timeAdded) / s2 : -1, c2 = o2.getSource(), h22 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), _2 = !i2 || Math.abs(i2.tileID.overscaledZ - h22) > Math.abs(t2.tileID.overscaledZ - h22), d2 = _2 && t2.refreshedUponExpiration ? 1 : e.c(_2 ? a2 : 1 - l2, 0, 1);
          return t2.refreshedUponExpiration && a2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class zi extends e.bq {
        constructor(t2) {
          const i2 = { type: "raster-dem", maxzoom: t2.transform.maxZoom }, o2 = new e.br(e.bs(), null), r2 = st("mock-dem", i2, o2, t2.style);
          super("mock-dem", r2, false), r2.setEventedParent(this), this._sourceLoaded = true;
        }
        _loadTile(e22, t2) {
          e22.state = "loaded", t2(null);
        }
      }
      class Oi extends e.bq {
        constructor(t2) {
          const i2 = st("proxy", { type: "geojson", maxzoom: t2.transform.maxZoom }, new e.br(e.bs(), null), t2.style);
          super("proxy", i2, false), i2.setEventedParent(this), this.map = this.getSource().map = t2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(t2, i2, o2) {
          if (t2.freezeTileCoverage)
            return;
          this.transform = t2;
          const r2 = t2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
            if (i3[o3.key] = "", !this._tiles[o3.key]) {
              const i4 = new e.bt(o3, this._source.tileSize * o3.overscaleFactor(), t2.tileZoom);
              i4.state = "loaded", this._tiles[o3.key] = i4;
            }
            return i3;
          }, {});
          for (const e22 in this._tiles)
            e22 in r2 || (this.freeFBO(e22), this._tiles[e22].unloadVectorData(), delete this._tiles[e22]);
        }
        freeFBO(e22) {
          const t2 = this.proxyCachedFBO[e22];
          if (void 0 !== t2) {
            const i2 = Object.values(t2);
            this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e22];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e22) => e22.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Fi extends e.O {
        constructor(e22, t2, i2) {
          super(e22.overscaledZ, e22.wrap, e22.canonical.z, e22.canonical.x, e22.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
        }
      }
      class Bi extends e.bk {
        constructor(t2, i2) {
          super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t2.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
            this._style.map.triggerRepaint();
          }), t2.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
            this._style.map.triggerRepaint();
          }), t2.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
            this.invalidateRenderCache = true, this._style.map.triggerRepaint();
          }), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [o2, r2, s2] = function(t3) {
            const i3 = new e.bo(), o3 = new e.bp(), r3 = 131;
            i3.reserve(17161), o3.reserve(33800);
            const s3 = e.J / 128, n3 = e.J + s3 / 2, a3 = n3 + s3;
            for (let t4 = -s3; t4 < a3; t4 += s3)
              for (let o4 = -s3; o4 < a3; o4 += s3) {
                const r4 = o4 < 0 || o4 > n3 || t4 < 0 || t4 > n3 ? 24575 : 0, s4 = e.c(Math.round(o4), 0, e.J), a4 = e.c(Math.round(t4), 0, e.J);
                i3.emplaceBack(s4 + r4, a4);
              }
            const l2 = (e22, t4) => {
              const i4 = t4 * r3 + e22;
              o3.emplaceBack(i4 + 1, i4, i4 + r3), o3.emplaceBack(i4 + r3, i4 + r3 + 1, i4 + 1);
            };
            for (let e22 = 1; e22 < 129; e22++)
              for (let t4 = 1; t4 < 129; t4++)
                l2(t4, e22);
            return [0, 129].forEach((e22) => {
              for (let t4 = 0; t4 < 130; t4++)
                l2(t4, e22), l2(e22, t4);
            }), [i3, o3, 32768];
          }(), n2 = t2.context;
          this.gridBuffer = n2.createVertexBuffer(o2, e.bl.members), this.gridIndexBuffer = n2.createIndexBuffer(r2), this.gridSegments = e.bm.simpleSegment(0, 0, o2.length, r2.length), this.gridNoSkirtSegments = e.bm.simpleSegment(0, 0, o2.length, s2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Oi(i2.map), this.orthoMatrix = e.m.create(), e.m.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.J, 0, e.J, 0, 1);
          const a2 = n2.gl;
          this._overlapStencilMode = new e.b6({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new zi(i2.map), this._pendingGroundEffectLayers = [];
        }
        set style(e22) {
          e22.on("data", this._onStyleDataEvent.bind(this)), this._style = e22, this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(t2, i2, o2) {
          if (t2 && t2.terrain) {
            this._style !== t2 && (this.style = t2, this._evaluationZoom = void 0);
            const r2 = t2.terrain.properties, s2 = 0 === t2.terrain.drapeRenderMode, n2 = t2.terrain.isZoomDependent();
            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.a4.now();
            const a2 = t2.terrain && t2.terrain.scope, l2 = r2.get("source"), c2 = s2 ? this._mockSourceCache : t2.getSourceCache(l2, a2);
            if (!c2)
              return void e.X(`Couldn't find terrain source "${l2}".`);
            if (this.sourceCache = c2, this._exaggeration = n2 ? this.calculateExaggeration(i2) : r2.get("exaggeration"), !i2.projection.requiresDraping && n2 && 0 === this._exaggeration)
              return void this._disable();
            this.enabled = true;
            const h22 = () => {
              this.sourceCache.used && e.X(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const t3 = this.getScaledDemTileSize();
              this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h22(), this._initializing = true), h22(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true, this._previousZoom = i2.zoom;
          } else
            this._disable();
        }
        calculateExaggeration(t2) {
          const i2 = this._previousCameraAltitude, o2 = t2.getFreeCameraOptions().position.z / t2.pixelsPerMeter * t2.worldSize;
          this._previousCameraAltitude = o2;
          const r2 = null != i2 ? o2 - i2 : Number.MAX_VALUE;
          if (Math.abs(r2) < 2)
            return this._exaggeration;
          const s2 = t2.zoom, n2 = this._style.terrain;
          if (!this._previousUpdateTimestamp)
            return n2.getExaggeration(s2);
          let a2 = s2 - this._previousZoom;
          const l2 = this._previousUpdateTimestamp;
          let c2 = s2;
          null != this._evaluationZoom && (c2 = this._evaluationZoom, Math.abs(s2 - c2) > 0.5 && (a2 = 0.5 * (s2 - c2 + a2)), a2 * r2 < 0 && (c2 += a2)), this._evaluationZoom = c2;
          const h22 = n2.getExaggeration(c2), _2 = h22 === n2.getExaggeration(Math.max(0, c2 - 0.1));
          if (_2 && Math.abs(h22 - this._exaggeration) < 0.01)
            return h22;
          let d2 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l2));
          return (_2 || h22 < 0.1 || Math.abs(a2) < 1e-4) && (d2 = Math.min(0.2, 4 * d2)), e.n(this._exaggeration, h22, d2);
        }
        resetTileLookupCache(e22) {
          this._findCoveringTileCache[e22] = {};
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(e22) {
          e22.coord && "source" === e22.dataType ? this._clearRenderCacheForTile(e22.sourceCacheId, e22.coord) : "style" === e22.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e22 in this._style._mergedSourceCaches)
              this._style._mergedSourceCaches[e22].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e22) => e22.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e22 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e22, e22];
        }
        set useVertexMorphing(e22) {
          this._useVertexMorphing = e22;
        }
        updateTileBinding(t2) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i2 = this.proxySourceCache, o2 = this.painter.transform;
          this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.M.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
          const r2 = this.proxyCoords = i2.getIds().map((e22) => {
            const t3 = i2.getTileByID(e22).tileID;
            return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
          });
          !function(t3, i3) {
            const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r3 = new e.P(o3.x, o3.y);
            t3.sort((t4, i4) => {
              if (i4.overscaledZ - t4.overscaledZ)
                return i4.overscaledZ - t4.overscaledZ;
              const o4 = new e.P(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), s3 = new e.P(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), n3 = r3.mult(1 << t4.canonical.z);
              return n3.x -= 0.5, n3.y -= 0.5, n3.distSqr(o4) - n3.distSqr(s3);
            });
          }(r2, this.painter);
          const s2 = this.proxyToSource || {};
          this.proxyToSource = {}, r2.forEach((e22) => {
            this.proxyToSource[e22.key] = {};
          }), this.terrainTileForTile = {};
          const n2 = this._style._mergedSourceCaches;
          for (const e22 in n2) {
            const i3 = n2[e22];
            if (!i3.used)
              continue;
            if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e22], s2), i3.usedForTerrain)
              continue;
            const o3 = t2[e22];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
          }
          this.proxiedCoords[i2.id] = r2.map((e22) => new Fi(e22, e22.key, this.orthoMatrix)), this._assignTerrainTiles(r2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(s2), this.renderingToTexture = false;
          const a2 = {};
          this._visibleDemTiles = [];
          for (const e22 of this.proxyCoords) {
            const t3 = this.terrainTileForTile[e22.key];
            if (!t3)
              continue;
            const i3 = t3.tileID.key;
            i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
          }
        }
        _assignTerrainTiles(e22) {
          this._initializing || e22.forEach((e3) => {
            if (this.terrainTileForTile[e3.key])
              return;
            const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
            t2 && (this.terrainTileForTile[e3.key] = t2);
          });
        }
        _prepareDEMTextures() {
          const e22 = this.painter.context, t2 = e22.gl;
          for (const i2 in this.terrainTileForTile) {
            const o2 = this.terrainTileForTile[i2], r2 = o2.dem;
            !r2 || o2.demTexture && !o2.needsDEMTextureUpload || (e22.activeTexture.set(t2.TEXTURE1), bi(this.painter, o2, r2));
          }
        }
        _prepareDemTileUniforms(e22, t2, i2, o2) {
          if (!t2 || null == t2.demTexture)
            return false;
          const r2 = e22.tileID.canonical, s2 = Math.pow(2, t2.tileID.canonical.z - r2.z), n2 = o2 || "";
          return i2[`u_dem_tl${n2}`] = [r2.x * s2 % 1, r2.y * s2 % 1], i2[`u_dem_scale${n2}`] = s2, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const t2 = this.painter.context, i2 = t2.gl;
          if (!this._emptyDepthBufferTexture) {
            const o2 = new e.a5({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new e.a9(t2, o2, i2.RGBA, { premultiply: false });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let e22 = 0;
          const t2 = this._visibleDemTiles.reduce((t3, i2) => {
            if (!i2.dem)
              return t3;
            const o2 = i2.dem.tree.minimums[0];
            return o2 > 0 && e22++, t3 + o2;
          }, 0);
          return e22 ? t2 / e22 : 0;
        }
        _updateEmptyDEMTexture() {
          const t2 = this.painter.context, i2 = t2.gl;
          t2.activeTexture.set(i2.TEXTURE2);
          const o2 = this._getLoadedAreaMinimum(), [r2, s2] = (() => {
            const t3 = new e.bu({ width: 1, height: 1 }, new Float32Array([o2]));
            return [i2.R32F, t3];
          })();
          this._emptyDEMTextureDirty = false;
          let n2 = this._emptyDEMTexture;
          return n2 ? n2.update(s2, { premultiply: false }) : n2 = this._emptyDEMTexture = new e.a9(t2, s2, r2, { premultiply: false }), n2;
        }
        setupElevationDraw(t2, i2, o2) {
          const r2 = this.painter.context, s2 = r2.gl, n2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 };
          n2.u_exaggeration = this.exaggeration();
          let a2 = null, l2 = null, c2 = 1;
          if (o2 && o2.morphing && this._useVertexMorphing) {
            const e22 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
            c2 = o2.morphing.phase, e22 && i3 && (this._prepareDemTileUniforms(t2, e22, n2, "_prev") && (l2 = e22), this._prepareDemTileUniforms(t2, i3, n2) && (a2 = i3));
          }
          const h22 = (e22) => e22 && e22.demTexture && this.painter.linearFloatFilteringSupported() ? s2.LINEAR : s2.NEAREST, _2 = (e22) => {
            n2.u_dem_size = 1 === e22.size[0] ? 1 : e22.size[0] - 2;
          };
          if (l2 && a2)
            r2.activeTexture.set(s2.TEXTURE2), a2.demTexture.bind(h22(a2), s2.CLAMP_TO_EDGE), r2.activeTexture.set(s2.TEXTURE4), l2.demTexture.bind(h22(l2), s2.CLAMP_TO_EDGE), a2.demTexture && _2(a2.demTexture), n2.u_dem_lerp = c2;
          else {
            a2 = this.terrainTileForTile[t2.tileID.key], r2.activeTexture.set(s2.TEXTURE2);
            const e22 = this._prepareDemTileUniforms(t2, a2, n2) ? a2.demTexture : this.emptyDEMTexture;
            e22.bind(h22(a2), s2.CLAMP_TO_EDGE), _2(e22);
          }
          if (r2.activeTexture.set(s2.TEXTURE3), o2 && o2.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), this._depthFBO && (n2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), n2.u_depth_size_inv = [1, 1]), o2 && o2.useMeterToDem && a2) {
            const t3 = (1 << a2.tileID.canonical.z) * e.b(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            n2.u_meter_to_dem = t3;
          }
          if (o2 && o2.labelPlaneMatrixInv && (n2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r2, n2), "globe" === this.painter.transform.projection.name) {
            const e22 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
            i2.setGlobeUniformValues(r2, e22);
          }
        }
        globeUniformValues(t2, i2, o2) {
          const r2 = t2.projection;
          return { u_tile_tl_up: r2.upVector(i2, 0, 0), u_tile_tr_up: r2.upVector(i2, e.J, 0), u_tile_br_up: r2.upVector(i2, e.J, e.J), u_tile_bl_up: r2.upVector(i2, 0, e.J), u_tile_up_scale: o2 ? e.bn(1) : r2.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
        }
        renderToBackBuffer(t2) {
          const i2 = this.painter, o2 = this.painter.context;
          0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, r2, s2) {
            if ("globe" === t3.transform.projection.name)
              !function(t4, i4, o4, r3, s3) {
                const n2 = t4.context, a2 = n2.gl;
                let l2, c2;
                const h22 = t4.transform, _2 = e.bb(t4, n2, h22), d2 = (e22, i5) => {
                  if (c2 === i5)
                    return;
                  const o5 = [Li[i5], "PROJECTION_GLOBE_VIEW"];
                  _2 && o5.push("CUSTOM_ANTIALIASING");
                  const r4 = t4.isTileAffectedByFog(e22);
                  l2 = t4.getOrCreateProgram("globeRaster", { defines: o5, overrideFog: r4 }), c2 = i5;
                }, u2 = t4.colorModeForRenderPass(), p2 = new e.b4(a2.LEQUAL, e.b4.ReadWrite, t4.depthRangeFor3D);
                Mi.update(s3);
                const m2 = e.bc(h22), f2 = [e.E(h22.center.lng), e.H(h22.center.lat)], g2 = t4.globeSharedBuffers, v2 = [h22.width * e.a4.devicePixelRatio, h22.height * e.a4.devicePixelRatio], x2 = Float32Array.from(h22.globeMatrix), y2 = { useDenormalizedUpVectorScale: true };
                {
                  const h3 = t4.transform, _3 = Pi(h3.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                  c2 = -1;
                  const b2 = a2.TRIANGLES;
                  for (const c3 of r3) {
                    const r4 = o4.getTile(c3), w2 = e.b6.disabled, T2 = i4.prevTerrainTileForTile[c3.key], E2 = i4.terrainTileForTile[c3.key];
                    Si(T2, E2) && Mi.newMorphing(c3.key, T2, E2, s3, 250), n2.activeTexture.set(a2.TEXTURE0), r4.texture && r4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                    const C2 = Mi.getMorphValuesForProxy(c3.key), I2 = C2 ? 1 : 0;
                    C2 && e.bd(y2, { morphing: { srcDemTile: C2.from, dstDemTile: C2.to, phase: e.ba(C2.phase) } });
                    const S2 = e.be(c3.canonical), M2 = e.bf(S2.getCenter().lat), L2 = e.bg(c3.canonical, S2, M2, h3.worldSize / h3._pixelsPerMercatorPixel), P2 = e.bh(e.bi(c3.canonical)), D2 = Ci(h3.expandedFarZProjMatrix, x2, m2, P2, e.ao(h3.zoom), f2, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v2, _3, L2);
                    if (d2(c3, I2), l2 && (i4.setupElevationDraw(r4, l2, y2), t4.uploadCommonUniforms(n2, l2, c3.toUnwrapped()), g2)) {
                      const [i5, o5, r5] = g2.getGridBuffers(M2, 0 !== _3);
                      l2.draw(t4, b2, p2, w2, u2, e.b5.backCCW, D2, "globe_raster", i5, o5, r5);
                    }
                  }
                }
                if (g2 && (t4.renderDefaultNorthPole || t4.renderDefaultSouthPole)) {
                  const s4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  _2 && s4.push("CUSTOM_ANTIALIASING"), l2 = t4.getOrCreateProgram("globeRaster", { defines: s4 });
                  for (const s5 of r3) {
                    const { x: r4, y: c3, z: _3 } = s5.canonical, d3 = 0 === c3, m3 = c3 === (1 << _3) - 1, [x3, b2, w2, T2] = g2.getPoleBuffers(_3, false);
                    if (T2 && (d3 || m3)) {
                      const c4 = o4.getTile(s5);
                      n2.activeTexture.set(a2.TEXTURE0), c4.texture && c4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      let g3 = e.bj(_3, r4, h22);
                      const E2 = e.bh(e.bi(s5.canonical)), C2 = (i5, o5) => i5.draw(t4, a2.TRIANGLES, p2, e.b6.disabled, u2, e.b5.disabled, Ci(h22.expandedFarZProjMatrix, g3, g3, E2, 0, f2, h22.frustumCorners.TL, h22.frustumCorners.TR, h22.frustumCorners.BR, h22.frustumCorners.BL, h22.globeCenterInViewSpace, h22.globeRadius, v2, 0), "globe_pole_raster", o5, w2, T2);
                      i4.setupElevationDraw(c4, l2, y2), t4.uploadCommonUniforms(n2, l2, s5.toUnwrapped()), d3 && t4.renderDefaultNorthPole && C2(l2, x3), m3 && t4.renderDefaultSouthPole && (g3 = e.m.scale(e.m.create(), g3, [1, -1, 1]), C2(l2, b2));
                    }
                  }
                }
              }(t3, i3, o3, r2, s2);
            else {
              const n2 = t3.context, a2 = n2.gl;
              let l2, c2;
              const h22 = t3.shadowRenderer, _2 = Ii(t3, t3.longestCutoffRange), d2 = (e22) => {
                if (c2 === e22)
                  return;
                const i4 = [];
                i4.push(Li[e22]), _2.shouldRenderCutoff && i4.push("RENDER_CUTOFF"), l2 = t3.getOrCreateProgram("terrainRaster", { defines: i4 }), c2 = e22;
              }, u2 = t3.colorModeForRenderPass(), p2 = new e.b4(a2.LEQUAL, e.b4.ReadWrite, t3.depthRangeFor3D);
              Mi.update(s2);
              const m2 = t3.transform, f2 = Pi(m2.zoom, i3.exaggeration(), i3.sourceCache._source.tileSize);
              let g2 = [0, 0, 0];
              if (h22) {
                const e22 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                e22 && i4 && (g2 = wr(e22, i4));
              }
              {
                c2 = -1;
                const v2 = a2.TRIANGLES, [x2, y2] = [i3.gridIndexBuffer, i3.gridSegments];
                for (const c3 of r2) {
                  const r3 = o3.getTile(c3), b2 = e.b6.disabled, w2 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                  Si(w2, T2) && Mi.newMorphing(c3.key, w2, T2, s2, 250), n2.activeTexture.set(a2.TEXTURE0), r3.texture && r3.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                  const E2 = Mi.getMorphValuesForProxy(c3.key), C2 = E2 ? 1 : 0;
                  let I2;
                  E2 && (I2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: e.ba(E2.phase) } });
                  const S2 = Ei(c3.projMatrix, Di(c3.canonical, m2.renderWorldCopies) ? f2 / 10 : f2, g2);
                  if (d2(C2), !l2)
                    continue;
                  i3.setupElevationDraw(r3, l2, I2);
                  const M2 = c3.toUnwrapped();
                  h22 && h22.setupShadows(M2, l2), t3.uploadCommonUniforms(n2, l2, M2, null, _2), l2.draw(t3, v2, p2, b2, u2, e.b5.backCCW, S2, "terrain_raster", i3.gridBuffer, x2, y2);
                }
              }
            }
          }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
        }
        renderBatch(t2) {
          if (0 === this._drapedRenderBatches.length)
            return t2 + 1;
          this.renderingToTexture = true;
          const i2 = this.painter, o2 = this.painter.context, r2 = this.proxySourceCache, s2 = this.proxiedCoords[r2.id], n2 = this._drapedRenderBatches.shift(), a2 = i2.style.order, l2 = [];
          let c2 = 0;
          for (const h22 of s2) {
            const s3 = r2.getTileByID(h22.proxyTileKey), _2 = r2.proxyCachedFBO[h22.key] ? r2.proxyCachedFBO[h22.key][t2] : void 0, d2 = void 0 !== _2 ? r2.renderCache[_2] : this.pool[c2++], u2 = void 0 !== _2;
            if (s3.texture = d2.tex, u2 && !d2.dirty) {
              l2.push(s3.tileID);
              continue;
            }
            let p2;
            o2.bindFramebuffer.set(d2.fb.framebuffer), this.renderedToTile = false, d2.dirty && (o2.clear({ color: e.C.transparent, stencil: 0 }), d2.dirty = false);
            for (let e22 = n2.start; e22 <= n2.end; ++e22) {
              const t3 = i2.style._mergedLayers[a2[e22]];
              if (t3.isHidden(i2.transform.zoom))
                continue;
              const r3 = i2.style.getLayerSourceCache(t3), s4 = r3 ? this.proxyToSource[h22.key][r3.id] : [h22];
              if (!s4)
                continue;
              const n3 = s4;
              o2.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p2 !== (r3 ? r3.id : null) && (this._setupStencil(d2, s4, t3, r3), p2 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, n3);
            }
            if (0 === this._drapedRenderBatches.length)
              for (const e22 of this._pendingGroundEffectLayers) {
                const t3 = i2.style._mergedLayers[a2[e22]];
                if (t3.isHidden(i2.transform.zoom))
                  continue;
                const r3 = i2.style.getLayerSourceCache(t3), s4 = r3 ? this.proxyToSource[h22.key][r3.id] : [h22];
                if (!s4)
                  continue;
                const n3 = s4;
                o2.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p2 !== (r3 ? r3.id : null) && (this._setupStencil(d2, s4, t3, r3), p2 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, n3);
              }
            this.renderedToTile ? (d2.dirty = true, l2.push(s3.tileID)) : u2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(l2));
          }
          return this.renderToBackBuffer(l2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), n2.end + 1;
        }
        postRender() {
        }
        isLayerOrderingCorrect(e22) {
          const t2 = e22.order.length;
          let i2 = -1, o2 = t2;
          for (let r2 = 0; r2 < t2; ++r2)
            this._style.isLayerDraped(e22._mergedLayers[e22.order[r2]]) ? i2 = Math.max(i2, r2) : o2 = Math.min(o2, r2);
          return o2 > i2;
        }
        getMinElevationBelowMSL() {
          let e22 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
            e22 = Math.min(e22, t2.dem.tree.minimums[0]);
          }), 0 === e22 ? e22 : (e22 - 30) * this._exaggeration;
        }
        raycast(e22, t2, i2) {
          if (!this._visibleDemTiles)
            return null;
          const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
            const r2 = o3.tileID, s2 = 1 << r2.overscaledZ, { x: n2, y: a2 } = r2.canonical, l2 = n2 / s2, c2 = (n2 + 1) / s2, h22 = a2 / s2, _2 = (a2 + 1) / s2;
            return { minx: l2, miny: h22, maxx: c2, maxy: _2, t: o3.dem.tree.raycastRoot(l2, h22, c2, _2, e22, t2, i2), tile: o3 };
          });
          o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
          for (const r2 of o2) {
            if (null == r2.t)
              return null;
            const o3 = r2.tile.dem.tree.raycast(r2.minx, r2.miny, r2.maxx, r2.maxy, e22, t2, i2);
            if (null != o3)
              return o3;
          }
          return null;
        }
        _createFBO() {
          const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
          t2.activeTexture.set(i2.TEXTURE0);
          const r2 = new e.a9(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
          r2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          const s2 = t2.createFramebuffer(o2[0], o2[1], true, null);
          return s2.colorAttachment.set(r2.texture), s2.depthAttachment = new oe(t2, s2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, s2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : s2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: s2, tex: r2, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._debugParams.disableRenderCache)
            return true;
          if (this._style.hasLightTransitions())
            return true;
          for (const e22 in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[e22].hasTransition())
              return true;
          return this._style.order.some((e22) => {
            const t2 = this._style._mergedLayers[e22], i2 = t2.isHidden(this.painter.transform.zoom);
            return "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t2 = false;
          for (const e22 of this._style.getSources())
            if (e22 instanceof it) {
              t2 = true;
              break;
            }
          if (!t2)
            return;
          const i2 = {};
          for (let t3 = 0; t3 < this._style.order.length; ++t3) {
            const o2 = this._style._mergedLayers[this._style.order[t3]], r2 = this._style.getLayerSourceCache(o2);
            if (r2 && !i2[r2.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e.am) {
              i2[r2.id] = true;
              for (const e22 of this.proxyCoords) {
                const t4 = this.proxyToSource[e22.key][r2.id];
                if (t4)
                  for (const e3 of t4)
                    this._clearRenderCacheForTile(r2.id, e3);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let e22 = false;
          for (const t3 in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[t3]._source instanceof ot) {
              e22 = true;
              break;
            }
          if (!e22)
            return;
          const t2 = {};
          for (let e3 = 0; e3 < this._style.order.length; ++e3) {
            const i2 = this._style._mergedLayers[this._style.order[e3]], o2 = this._style.getLayerSourceCache(i2);
            if (!o2 || t2[o2.id])
              continue;
            if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type)
              continue;
            const r2 = i2.paint.get("raster-fade-duration");
            for (const e4 of this.proxyCoords) {
              const t3 = this.proxyToSource[e4.key][o2.id];
              if (t3)
                for (const e52 of t3) {
                  const t4 = Ri(o2.getTile(e52), o2.findLoadedParent(e52, 0), o2, this.painter.transform, r2);
                  (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e52);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          const t2 = this._style.order, i2 = t2.length;
          if (0 === i2)
            return;
          const o2 = [];
          this._pendingGroundEffectLayers = [];
          let r2, s2 = 0, n2 = this._style._mergedLayers[t2[s2]];
          for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++s2 < i2; )
            n2 = this._style._mergedLayers[t2[s2]];
          for (; s2 < i2; ++s2) {
            const e22 = this._style._mergedLayers[t2[s2]];
            e22.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e22) ? void 0 === r2 && (r2 = s2) : ("fill-extrusion" === e22.type && this._pendingGroundEffectLayers.push(s2), void 0 !== r2 && (o2.push({ start: r2, end: s2 - 1 }), r2 = void 0)));
          }
          if (void 0 !== r2 && o2.push({ start: r2, end: s2 - 1 }), 0 !== o2.length) {
            const t3 = o2[o2.length - 1];
            this._pendingGroundEffectLayers.every((e22) => e22 > t3.end) || e.X("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
          }
          this._drapedRenderBatches = o2;
        }
        _setupRenderCache(e22) {
          const t2 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (this.invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
              const e3 = Object.values(t2.proxyCachedFBO);
              t2.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const o3 = Object.values(e3[i3]);
                t2.renderCachePool.push(...o3);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const i2 = this.proxyCoords, o2 = this._tilesDirty;
          for (let r3 = i2.length - 1; r3 >= 0; r3--) {
            const s2 = i2[r3];
            if (t2.getTileByID(s2.key), void 0 !== t2.proxyCachedFBO[s2.key]) {
              const i3 = e22[s2.key], r4 = this.proxyToSource[s2.key];
              let n2 = 0;
              for (const e3 in r4) {
                const t3 = r4[e3], s3 = i3[e3];
                if (!s3 || s3.length !== t3.length || t3.some((t4, i4) => t4 !== s3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                  n2 = -1;
                  break;
                }
                ++n2;
              }
              for (const e3 in t2.proxyCachedFBO[s2.key])
                t2.renderCache[t2.proxyCachedFBO[s2.key][e3]].dirty = n2 < 0 || n2 !== Object.values(i3).length;
            }
          }
          const r2 = [...this._drapedRenderBatches];
          r2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
          for (const e3 of r2)
            for (const o3 of i2) {
              if (t2.proxyCachedFBO[o3.key])
                continue;
              let i3 = t2.renderCachePool.pop();
              void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e22, t2, i2, o2) {
          if (!o2 || !this._sourceTilesOverlap[o2.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const r2 = this.painter.context, s2 = r2.gl;
          if (t2.length <= 1)
            return void (this._overlapStencilType = false);
          let n2;
          if (i2.isTileClipped())
            n2 = t2.length, this._overlapStencilMode.test = { func: s2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            n2 = 1, this._overlapStencilMode.test = { func: s2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + n2 > 255 && (r2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
        }
        stencilModeForRTTOverlap(t2) {
          return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t2.key]), this._overlapStencilMode) : e.b6.disabled;
        }
        _renderTileClippingMasks(t2, i2) {
          const o2 = this.painter, r2 = this.painter.context, s2 = r2.gl;
          o2._tileClippingMaskIDs = {}, r2.setColorMode(e.a.disabled), r2.setDepthMode(e.b4.disabled);
          const n2 = o2.getOrCreateProgram("clippingMask");
          for (const r3 of t2) {
            const t3 = o2._tileClippingMaskIDs[r3.key] = --i2;
            n2.draw(o2, s2.TRIANGLES, e.b4.disabled, new e.b6({ func: s2.ALWAYS, mask: 0 }, t3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), e.a.disabled, e.b5.disabled, Ai(r3.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
          }
        }
        pointCoordinate(t2) {
          const i2 = this.painter.transform;
          if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height)
            return null;
          const o2 = [t2.x, t2.y, 1, 1];
          e.e.transformMat4(o2, o2, i2.pixelMatrixInverse), e.e.scale(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
          const r2 = i2._camera.position, s2 = e.b(1, i2.center.lat), n2 = [r2[0], r2[1], r2[2] / s2, 0], a2 = e.v.subtract([], o2.slice(0, 3), n2);
          e.v.normalize(a2, a2);
          const l2 = this.raycast(n2, a2, this._exaggeration);
          return null !== l2 && l2 ? (e.v.scaleAndAdd(n2, n2, a2, l2), n2[3] = n2[2], n2[2] *= s2, n2) : null;
        }
        drawDepth() {
          const t2 = this.painter, i2 = t2.context, o2 = this.proxySourceCache, r2 = Math.ceil(t2.width), s2 = Math.ceil(t2.height);
          if (!this._depthFBO || this._depthFBO.width === r2 && this._depthFBO.height === s2 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
            const t3 = i2.gl, o3 = i2.createFramebuffer(r2, s2, true, "renderbuffer");
            i2.activeTexture.set(t3.TEXTURE0);
            const n2 = new e.a9(i2, { width: r2, height: s2, data: null }, t3.RGBA);
            n2.bind(t3.NEAREST, t3.CLAMP_TO_EDGE), o3.colorAttachment.set(n2.texture);
            const a2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r2, s2);
            o3.depthAttachment.set(a2), this._depthFBO = o3, this._depthTexture = n2;
          }
          i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r2, s2]), function(t3, i3, o3, r3) {
            if ("globe" === t3.transform.projection.name)
              return;
            const s3 = t3.context, n2 = s3.gl;
            s3.clear({ depth: 1 });
            const a2 = t3.getOrCreateProgram("terrainDepth"), l2 = new e.b4(n2.LESS, e.b4.ReadWrite, t3.depthRangeFor3D);
            for (const s4 of r3) {
              const r4 = o3.getTile(s4), c2 = Ei(s4.projMatrix, 0, [0, 0, 0]);
              i3.setupElevationDraw(r4, a2), a2.draw(t3, n2.TRIANGLES, l2, e.b6.disabled, e.a.unblended, e.b5.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
            }
          }(t2, this, o2, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(t2, i2, o2) {
          if (t2.getSource() instanceof e.aK)
            return this._setupProxiedCoordsForImageSource(t2, i2, o2);
          this._findCoveringTileCache[t2.id] = this._findCoveringTileCache[t2.id] || {};
          const r2 = this.proxiedCoords[t2.id] = [], s2 = this.proxyCoords;
          for (let e22 = 0; e22 < s2.length; e22++) {
            const i3 = s2[e22], n3 = this._findTileCoveringTileID(i3, t2);
            if (n3) {
              const e3 = this._createProxiedId(i3, n3, o2[i3.key] && o2[i3.key][t2.id]);
              r2.push(e3), this.proxyToSource[i3.key][t2.id] = [e3];
            }
          }
          let n2 = false;
          const a2 = /* @__PURE__ */ new Set();
          for (let e22 = 0; e22 < i2.length; e22++) {
            const s3 = t2.getTile(i2[e22]);
            if (!s3 || !s3.hasData())
              continue;
            const l2 = this._findTileCoveringTileID(s3.tileID, this.proxySourceCache);
            if (l2 && l2.tileID.canonical.z !== s3.tileID.canonical.z) {
              const e3 = this.proxyToSource[l2.tileID.key][t2.id], i3 = this._createProxiedId(l2.tileID, s3, o2[l2.tileID.key] && o2[l2.tileID.key][t2.id]);
              e3 ? e3.splice(e3.length - 1, 0, i3) : this.proxyToSource[l2.tileID.key][t2.id] = [i3];
              const c2 = this.proxyToSource[l2.tileID.key][t2.id];
              a2.has(c2) || a2.add(c2), r2.push(i3), n2 = true;
            }
          }
          if (this._sourceTilesOverlap[t2.id] = n2, n2 && this._debugParams.sortTilesHiZFirst)
            for (const e22 of a2)
              e22.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ);
        }
        _setupProxiedCoordsForImageSource(t2, i2, o2) {
          if (!t2.getSource().loaded())
            return;
          const r2 = this.proxiedCoords[t2.id] = [], s2 = this.proxyCoords, n2 = t2.getSource(), a2 = n2.tileID;
          if (!a2)
            return;
          const l2 = new e.P(a2.x, a2.y)._div(1 << a2.z), c2 = n2.coordinates.map(e.M.fromLngLat).reduce((e22, t3) => (e22.min.x = Math.min(e22.min.x, t3.x - l2.x), e22.min.y = Math.min(e22.min.y, t3.y - l2.y), e22.max.x = Math.max(e22.max.x, t3.x - l2.x), e22.max.y = Math.max(e22.max.y, t3.y - l2.y), e22), { min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h22 = (t3, i3) => {
            const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r3 = t3.canonical.y / (1 << t3.canonical.z), s3 = e.J / (1 << t3.canonical.z), n3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
            return o3 + s3 < n3 + c2.min.x || o3 > n3 + c2.max.x || r3 + s3 < a3 + c2.min.y || r3 > a3 + c2.max.y;
          };
          for (let e22 = 0; e22 < s2.length; e22++) {
            const n3 = s2[e22];
            for (let e3 = 0; e3 < i2.length; e3++) {
              const s3 = t2.getTile(i2[e3]);
              if (!s3 || !s3.hasData())
                continue;
              if (h22(n3, s3.tileID))
                continue;
              const a3 = this._createProxiedId(n3, s3, o2[n3.key] && o2[n3.key][t2.id]), l3 = this.proxyToSource[n3.key][t2.id];
              l3 ? l3.push(a3) : this.proxyToSource[n3.key][t2.id] = [a3], r2.push(a3);
            }
          }
        }
        _createProxiedId(t2, i2, o2) {
          let r2 = this.orthoMatrix;
          if (o2) {
            const e22 = o2.find((e3) => e3.key === i2.tileID.key);
            if (e22)
              return e22;
          }
          if (i2.tileID.key !== t2.key) {
            const o3 = t2.canonical.z - i2.tileID.canonical.z;
            let s2, n2, a2;
            r2 = e.m.create();
            const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
            o3 > 0 ? (s2 = e.J >> o3, n2 = s2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), a2 = s2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (s2 = e.J << -o3, n2 = e.J * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), a2 = e.J * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.m.ortho(r2, 0, s2, 0, s2, 0, 1), e.m.translate(r2, r2, [n2, a2, 0]);
          }
          return new Fi(i2.tileID, t2.key, r2);
        }
        _findTileCoveringTileID(t2, i2) {
          let o2 = i2.getTile(t2);
          if (o2 && o2.hasData())
            return o2;
          const r2 = this._findCoveringTileCache[i2.id], s2 = r2[t2.key];
          if (o2 = s2 ? i2.getTileByID(s2) : null, o2 && o2.hasData() || null === s2)
            return o2;
          let n2 = o2 ? o2.tileID : t2, a2 = n2.overscaledZ;
          const l2 = i2.getSource().minzoom, c2 = [];
          if (!s2) {
            const r3 = i2.getSource().maxzoom;
            if (t2.canonical.z >= r3) {
              const o3 = t2.canonical.z - r3;
              i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), n2 = new e.O(a2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (a2 = r3, n2 = new e.O(a2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3));
            }
            n2.key !== t2.key && (c2.push(n2.key), o2 = i2.getTile(n2));
          }
          const h22 = (e22) => {
            c2.forEach((t3) => {
              r2[t3] = e22;
            }), c2.length = 0;
          };
          for (a2 -= 1; a2 >= l2 && (!o2 || !o2.hasData()); a2--) {
            o2 && h22(o2.tileID.key);
            const e22 = n2.calculateScaledKey(a2);
            if (o2 = i2.getTileByID(e22), o2 && o2.hasData())
              break;
            const t3 = r2[e22];
            if (null === t3)
              break;
            void 0 === t3 ? c2.push(e22) : o2 = i2.getTileByID(t3);
          }
          return h22(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
        }
        findDEMTileFor(e22) {
          return this.enabled ? this._findTileCoveringTileID(e22, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e22, t2) {
          let i2 = this._tilesDirty[e22];
          i2 || (i2 = this._tilesDirty[e22] = {}), i2[t2.key] = true;
        }
      }
      function ki(t2, i2, o2) {
        const r2 = function(t3, i3, o3) {
          const r3 = e.v.dot(i3, t3), s3 = e.v.dot(o3, [0.2126, 0.7152, 0.0722]), n3 = (e22, t4, i4) => (1 - i4) * e22 + i4 * t4, a3 = n3(1 - 0.3 * Math.min(s3, 1), 1, Math.min(r3 + 1, 1));
          return n3(0.92, 1, Math.asin(e.c(i3[2], -1, 1)) / Math.PI + 0.5) * a3;
        }(t2, [0, 0, 1], i2), s2 = [0, 0, 0];
        e.v.scale(s2, o2.slice(0, 3), r2);
        const n2 = [0, 0, 0];
        e.v.scale(n2, i2.slice(0, 3), t2[2]);
        const a2 = [0, 0, 0];
        return e.v.add(a2, s2, n2), e.bw(a2);
      }
      const Ni = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Ui = ["stars", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbolSDF", "symbolIcon", "symbolTextAndIcon"];
      class Gi {
        static cacheKey(e22, t2, i2, o2) {
          let r2 = `${t2}${o2 ? o2.cacheKey : ""}`;
          for (const t3 of i2)
            e22.usedDefines.includes(t3) && (r2 += `/${t3}`);
          return r2;
        }
        constructor(t2, i2, o2, r2, s2, n2) {
          const a2 = t2.gl;
          this.program = a2.createProgram(), this.configuration = r2, this.name = i2, this.fixedDefines = [...n2];
          const l2 = r2 ? r2.getBinderAttributes() : [], c2 = (o2.staticAttributes || []).concat(l2);
          let h22 = r2 ? r2.defines() : [];
          h22 = h22.concat(n2.map((e22) => `#define ${e22}`));
          const _2 = "#version 300 es\n";
          let d2 = _2 + h22.concat("precision mediump float;", pi, ui.fragmentSource).join("\n");
          for (const e22 of o2.fragmentIncludes)
            d2 += `
${_i[e22]}`;
          d2 += `
${o2.fragmentSource}`;
          let u2 = _2 + h22.concat("precision highp float;", pi, ui.vertexSource).join("\n");
          for (const e22 of o2.vertexIncludes)
            u2 += `
${_i[e22]}`;
          u2 += `
${o2.vertexSource}`;
          const p2 = a2.createShader(a2.FRAGMENT_SHADER);
          if (a2.isContextLost())
            return void (this.failedToCreate = true);
          a2.shaderSource(p2, d2), a2.compileShader(p2), a2.attachShader(this.program, p2);
          const m2 = a2.createShader(a2.VERTEX_SHADER);
          if (a2.isContextLost())
            this.failedToCreate = true;
          else {
            a2.shaderSource(m2, u2), a2.compileShader(m2), a2.attachShader(this.program, m2), this.attributes = {}, this.numAttributes = c2.length;
            for (let e22 = 0; e22 < this.numAttributes; e22++)
              if (c2[e22]) {
                const t3 = c2[e22].startsWith("a_") ? c2[e22] : `a_${c2[e22]}`;
                a2.bindAttribLocation(this.program, e22, t3), this.attributes[t3] = e22;
              }
            a2.linkProgram(this.program), a2.deleteShader(m2), a2.deleteShader(p2), this.fixedUniforms = s2(t2), this.binderUniforms = r2 ? r2.getUniforms(t2) : [], n2.includes("TERRAIN") && (this.terrainUniforms = ((t3) => ({ u_dem: new e.a$(t3), u_dem_prev: new e.a$(t3), u_dem_tl: new e.b0(t3), u_dem_scale: new e.b2(t3), u_dem_tl_prev: new e.b0(t3), u_dem_scale_prev: new e.b2(t3), u_dem_size: new e.b2(t3), u_dem_lerp: new e.b2(t3), u_exaggeration: new e.b2(t3), u_depth: new e.a$(t3), u_depth_size_inv: new e.b0(t3), u_meter_to_dem: new e.b2(t3), u_label_plane_matrix_inv: new e.a_(t3) }))(t2)), n2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.b7(t3), u_tile_tr_up: new e.b7(t3), u_tile_br_up: new e.b7(t3), u_tile_bl_up: new e.b7(t3), u_tile_up_scale: new e.b2(t3) }))(t2)), n2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.a_(t3), u_fog_range: new e.b0(t3), u_fog_color: new e.b9(t3), u_fog_horizon_blend: new e.b2(t3), u_fog_vertical_limit: new e.b0(t3), u_fog_temporal_offset: new e.b2(t3), u_frustum_tl: new e.b7(t3), u_frustum_tr: new e.b7(t3), u_frustum_br: new e.b7(t3), u_frustum_bl: new e.b7(t3), u_globe_pos: new e.b7(t3), u_globe_radius: new e.b2(t3), u_globe_transition: new e.b2(t3), u_is_globe: new e.a$(t3), u_viewport: new e.b0(t3) }))(t2)), n2.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t3) => ({ u_cutoff_params: new e.b9(t3) }))(t2)), n2.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t3) => ({ u_lighting_ambient_color: new e.b7(t3), u_lighting_directional_dir: new e.b7(t3), u_lighting_directional_color: new e.b7(t3), u_ground_radiance: new e.b7(t3) }))(t2)), n2.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t3) => ({ u_light_matrix_0: new e.a_(t3), u_light_matrix_1: new e.a_(t3), u_fade_range: new e.b0(t3), u_shadow_normal_offset: new e.b7(t3), u_shadow_intensity: new e.b2(t3), u_shadow_texel_size: new e.b2(t3), u_shadow_map_resolution: new e.b2(t3), u_shadow_direction: new e.b7(t3), u_shadow_bias: new e.b7(t3), u_shadowmap_0: new e.a$(t3), u_shadowmap_1: new e.a$(t3) }))(t2));
          }
        }
        setTerrainUniformValues(e22, t2) {
          if (!this.terrainUniforms)
            return;
          const i2 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t2)
              i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setGlobeUniformValues(e22, t2) {
          if (!this.globeUniforms)
            return;
          const i2 = this.globeUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t2)
              i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setFogUniformValues(e22, t2) {
          if (!this.fogUniforms)
            return;
          const i2 = this.fogUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t2)
              i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setCutoffUniformValues(e22, t2) {
          if (!this.cutoffUniforms)
            return;
          const i2 = this.cutoffUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t2)
              i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setLightsUniformValues(e22, t2) {
          if (!this.lightsUniforms)
            return;
          const i2 = this.lightsUniforms;
          if (!this.failedToCreate) {
            e22.program.set(this.program);
            for (const e3 in t2)
              i2[e3].set(this.program, e3, t2[e3]);
          }
        }
        setShadowUniformValues(e22, t2) {
          if (this.failedToCreate || !this.shadowUniforms)
            return;
          const i2 = this.shadowUniforms;
          e22.program.set(this.program);
          for (const e3 in t2)
            i2[e3].set(this.program, e3, t2[e3]);
        }
        _drawDebugWireframe(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22) {
          const _2 = t2.options.wireframe;
          if (false === _2.terrain && false === _2.layers2D && false === _2.layers3D)
            return;
          const d2 = t2.context;
          if (!(() => !(!_2.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!_2.layers2D || t2._terrain && t2._terrain.renderingToTexture || !Ni.includes(this.name)) || !(!_2.layers3D || !Ui.includes(this.name)))())
            return;
          const u2 = d2.gl, p2 = t2.wireframeDebugCache.getLinesFromTrianglesBuffer(t2.frameCounter, s2, d2);
          if (!p2)
            return;
          const m2 = [...this.fixedDefines];
          m2.push("DEBUG_WIREFRAME");
          const f2 = t2.getOrCreateProgram(this.name, { config: this.configuration, defines: m2 });
          d2.program.set(f2.program);
          const g2 = (e22, t3, i3) => {
            if (t3[e22] && i3[e22])
              for (const o3 in t3[e22])
                i3[e22][o3] && i3[e22][o3].set(i3.program, o3, t3[e22][o3].current);
          };
          c2 && c2.setUniforms(f2.program, d2, f2.binderUniforms, a2, { zoom: l2 }), g2("fixedUniforms", this, f2), g2("terrainUniforms", this, f2), g2("globeUniforms", this, f2), g2("fogUniforms", this, f2), g2("lightsUniforms", this, f2), g2("shadowUniforms", this, f2), p2.bind(), d2.setColorMode(new e.a([u2.ONE, u2.ONE_MINUS_SRC_ALPHA, u2.ZERO, u2.ONE], e.C.transparent, [true, true, true, false])), d2.setDepthMode(new e.b4(i2.func === u2.LESS ? u2.LEQUAL : i2.func, e.b4.ReadOnly, i2.range)), d2.setStencilMode(e.b6.disabled);
          const v2 = 3 * n2.primitiveLength * 2, x2 = 3 * n2.primitiveOffset * 2 * 2;
          h22 && h22 > 1 ? u2.drawElementsInstanced(u2.LINES, v2, u2.UNSIGNED_SHORT, x2, h22) : u2.drawElements(u2.LINES, v2, u2.UNSIGNED_SHORT, x2), s2.bind(), d2.program.set(this.program), d2.setDepthMode(i2), d2.setStencilMode(o2), d2.setColorMode(r2);
        }
        draw(e22, t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2) {
          const f2 = e22.context, g2 = f2.gl;
          if (this.failedToCreate)
            return;
          f2.program.set(this.program), f2.setDepthMode(i2), f2.setStencilMode(o2), f2.setColorMode(r2), f2.setCullFace(s2);
          for (const e3 of Object.keys(this.fixedUniforms))
            this.fixedUniforms[e3].set(this.program, e3, n2[e3]);
          u2 && u2.setUniforms(this.program, f2, this.binderUniforms, _2, { zoom: d2 });
          const v2 = { [g2.LINES]: 2, [g2.TRIANGLES]: 3, [g2.LINE_STRIP]: 1 }[t2], x2 = m2 && m2 > 0 ? 1 : void 0;
          for (const s3 of h22.get()) {
            const n3 = s3.vaos || (s3.vaos = {});
            (n3[a2] || (n3[a2] = new vi())).bind(f2, this, l2, u2 ? u2.getPaintVertexBuffers() : [], c2, s3.vertexOffset, p2 || [], x2), m2 && m2 > 1 ? g2.drawElementsInstanced(t2, s3.primitiveLength * v2, g2.UNSIGNED_SHORT, s3.primitiveOffset * v2 * 2, m2) : g2.drawElements(t2, s3.primitiveLength * v2, g2.UNSIGNED_SHORT, s3.primitiveOffset * v2 * 2), t2 === g2.TRIANGLES && this._drawDebugWireframe(e22, i2, o2, r2, c2, s3, _2, d2, u2, m2);
          }
        }
      }
      function ji(t2, i2) {
        const o2 = Math.pow(2, i2.tileID.overscaledZ), r2 = i2.tileSize * Math.pow(2, t2.transform.tileZoom) / o2, s2 = r2 * (i2.tileID.canonical.x + i2.tileID.wrap * o2), n2 = r2 * i2.tileID.canonical.y;
        return { u_image: 0, u_texsize: i2.imageAtlasTexture ? i2.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e.ay(i2, 1, t2.transform.tileZoom), u_pixel_coord_upper: [s2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & s2, 65535 & n2] };
      }
      const Vi = e.m.create(), Zi = (t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2) => {
        const g2 = i2.style.light, v2 = g2.properties.get("position"), x2 = [v2.x, v2.y, v2.z], y2 = e.bx.create();
        "viewport" === g2.properties.get("anchor") && (e.bx.fromRotation(y2, -i2.transform.angle), e.v.transformMat3(x2, x2, y2));
        const b2 = g2.properties.get("color"), w2 = i2.transform, T2 = { u_matrix: t2, u_lightpos: x2, u_lightintensity: g2.properties.get("intensity"), u_lightcolor: [b2.r, b2.g, b2.b], u_vertical_gradient: +o2, u_opacity: r2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Vi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: s2, u_edge_radius: n2, u_flood_light_color: d2, u_vertical_scale: u2, u_flood_light_intensity: p2, u_ground_shadow_factor: m2, u_emissive_strength: f2 };
        return "globe" === w2.projection.name && (T2.u_tile_id = [a2.canonical.x, a2.canonical.y, 1 << a2.canonical.z], T2.u_zoom_transition = c2, T2.u_inv_rot_matrix = _2, T2.u_merc_center = h22, T2.u_up_dir = w2.projection.upVector(new e.t(0, 0, 0), h22[0] * e.J, h22[1] * e.J), T2.u_height_lift = l2), T2;
      }, Wi = (e22, t2, i2) => ({ u_matrix: e22, u_edge_radius: t2, u_vertical_scale: i2 }), Hi = (t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2) => {
        const m2 = Zi(t2, i2, o2, r2, s2, n2, a2, c2, h22, _2, d2, u2, p2, 1, [0, 0, 0], 0), f2 = { u_height_factor: -Math.pow(2, a2.overscaledZ) / l2.tileSize / 8 };
        return e.ak(m2, ji(i2, l2), f2);
      }, qi = (e22, t2) => ({ u_matrix: e22, u_emissive_strength: t2 }), $i = (t2, i2, o2, r2) => e.ak(qi(t2, i2), ji(o2, r2)), Xi = (e22, t2, i2) => ({ u_matrix: e22, u_world: i2, u_emissive_strength: t2 }), Ji = (t2, i2, o2, r2, s2) => e.ak($i(t2, i2, o2, r2), { u_world: s2 }), Yi = (t2, i2, o2, r2) => {
        const s2 = e.J / o2.tileSize;
        return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(r2), u_extrude_scale: [i2.pixelsToGLUnits[0] / s2, i2.pixelsToGLUnits[1] / s2] };
      }, Ki = (e22, t2, i2 = 1) => ({ u_matrix: e22, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), Qi = e.m.create(), eo = (t2, i2, o2, r2, s2, n2, a2) => {
        const l2 = t2.transform, c2 = "globe" === l2.projection.name, h22 = c2 ? e.by(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : e.ay(o2, 1, n2), _2 = { u_matrix: i2.projMatrix, u_extrude_scale: h22, u_intensity: a2, u_inv_rot_matrix: Qi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (c2) {
          _2.u_inv_rot_matrix = r2, _2.u_merc_center = s2, _2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], _2.u_zoom_transition = e.ao(l2.zoom);
          const t3 = s2[0] * e.J, o3 = s2[1] * e.J;
          _2.u_up_dir = l2.projection.upVector(new e.t(0, 0, 0), t3, o3);
        }
        return _2;
      }, to2 = (e22, t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2, v2, x2, y2) => {
        return { u_matrix: e22, u_normalize_matrix: t2, u_globe_matrix: i2, u_merc_matrix: o2, u_grid_matrix: r2, u_tl_parent: s2, u_scale_parent: c2, u_fade_t: h22.mix, u_opacity: h22.opacity * _2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: _2.paint.get("raster-brightness-min"), u_brightness_high: _2.paint.get("raster-brightness-max"), u_saturation_factor: (w2 = _2.paint.get("raster-saturation"), w2 > 0 ? 1 - 1 / (1.001 - w2) : -w2), u_contrast_factor: (b2 = _2.paint.get("raster-contrast"), b2 > 0 ? 1 / (1 - b2) : 1 + b2), u_spin_weights: io(_2.paint.get("raster-hue-rotate")), u_perspective_transform: d2, u_raster_elevation: u2, u_zoom_transition: n2, u_merc_center: a2, u_cutoff_params: l2, u_colorization_mix: oo(m2, g2), u_colorization_offset: ro(f2, g2), u_color_ramp: p2, u_texture_offset: [x2 / (v2 + 2 * x2), v2 / (v2 + 2 * x2)], u_texture_res: [v2 + 2 * x2, v2 + 2 * x2], u_emissive_strength: y2 };
        var b2, w2;
      };
      function io(e22) {
        e22 *= Math.PI / 180;
        const t2 = Math.sin(e22), i2 = Math.cos(e22);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
      }
      function oo([t2, i2, o2, r2], [s2, n2]) {
        if (s2 === n2)
          return [0, 0, 0, 0];
        const a2 = (e.bz + 3) / (e.bz + 1) / (n2 - s2);
        return [t2 * a2, i2 * a2, o2 * a2, r2 * a2];
      }
      function ro(t2, [i2, o2]) {
        return i2 === o2 ? 0 : ((t2 - i2) / (o2 - i2) * (e.bz + 3) - 1) / (e.bz + 1);
      }
      const so = e.m.create(), no = (t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2, v2) => {
        const x2 = s2.transform, y2 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: x2.getCameraToCenterDistance(f2), u_rotate_symbol: +o2, u_aspect_ratio: x2.width / x2.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: a2, u_coord_matrix: l2, u_is_text: +c2, u_pitch_with_map: +r2, u_texsize: h22, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: so, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: so, u_up_vector: [0, -1, 0], u_icon_transition: v2 || 0, u_icon_saturation: g2 };
        return "globe" === f2.name && (y2.u_tile_id = [_2.canonical.x, _2.canonical.y, 1 << _2.canonical.z], y2.u_zoom_transition = d2, y2.u_inv_rot_matrix = p2, y2.u_merc_center = u2, y2.u_camera_forward = x2._camera.forward(), y2.u_ecef_origin = e.bA(x2.globeMatrix, _2.toUnwrapped()), y2.u_tile_matrix = Float32Array.from(x2.globeMatrix), y2.u_up_vector = m2), y2;
      }, ao = (t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2) => e.ak(no(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, d2, u2, p2, m2, f2, g2, 1), { u_gamma_scale: r2 ? s2.transform.getCameraToCenterDistance(g2) * Math.cos(s2.terrain ? 0 : s2.transform._pitch) : 1, u_device_pixel_ratio: e.a4.devicePixelRatio, u_is_halo: +_2, undefined: void 0 }), lo = (t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2) => e.ak(ao(t2, i2, o2, r2, s2, n2, a2, l2, true, c2, true, _2, d2, u2, p2, m2, f2), { u_texsize_icon: h22, u_texture_icon: 1 }), co = (e22, t2, i2, o2) => ({ u_matrix: e22, u_emissive_strength: t2, u_opacity: i2, u_color: o2 }), ho = (t2, i2, o2, r2, s2, n2, a2) => e.ak(function(t3, i3, o3, r3) {
        const s3 = o3.imageManager.getPattern(t3.toString(), i3), { width: n3, height: a3 } = o3.imageManager.getPixelSize(i3), l2 = Math.pow(2, r3.tileID.overscaledZ), c2 = r3.tileSize * Math.pow(2, o3.transform.tileZoom) / l2, h22 = c2 * (r3.tileID.canonical.x + r3.tileID.wrap * l2), _2 = c2 * r3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: s3.tl, u_pattern_br: s3.br, u_texsize: [n3, a3], u_pattern_size: s3.displaySize, u_tile_units_to_pixels: 1 / e.ay(r3, 1, o3.transform.tileZoom), u_pixel_coord_upper: [h22 >> 16, _2 >> 16], u_pixel_coord_lower: [65535 & h22, 65535 & _2] };
      }(s2, n2, r2, a2), { u_matrix: t2, u_emissive_strength: i2, u_opacity: o2 }), _o = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, ShadowMap0: 10 }, uo = (t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2 = [0, 0, 0]) => {
        const p2 = r2.style.light, m2 = p2.properties.get("position"), f2 = [-m2.x, -m2.y, m2.z], g2 = e.bx.create();
        "viewport" === p2.properties.get("anchor") && (e.bx.fromRotation(g2, -r2.transform.angle), e.v.transformMat3(f2, f2, g2));
        const v2 = "MASK" === h22.alphaMode, x2 = p2.properties.get("color"), y2 = d2.paint.get("model-ambient-occlusion-intensity"), b2 = d2.paint.get("model-color").constantOr(e.C.white), w2 = d2.paint.get("model-color-mix-intensity").constantOr(0);
        return { u_matrix: t2, u_lighting_matrix: i2, u_normal_matrix: o2, u_lightpos: f2, u_lightintensity: p2.properties.get("intensity"), u_lightcolor: [x2.r, x2.g, x2.b], u_camera_pos: u2, u_opacity: s2, u_baseTextureIsAlpha: 0, u_alphaMask: +v2, u_alphaCutoff: h22.alphaCutoff, u_baseColorFactor: [n2.r, n2.g, n2.b, n2.a], u_emissiveFactor: [a2[0], a2[1], a2[2], 1], u_metallicFactor: l2, u_roughnessFactor: c2, u_baseColorTexture: _o.BaseColor, u_metallicRoughnessTexture: _o.MetallicRoughness, u_normalTexture: _o.Normal, u_occlusionTexture: _o.Occlusion, u_emissionTexture: _o.Emission, u_color_mix: [b2.r, b2.g, b2.b, w2], u_aoIntensity: y2, u_emissive_strength: _2 };
      }, po = new Float32Array(16), mo = (e22, t2 = po, i2 = po) => ({ u_matrix: e22, u_instance: t2, u_node_matrix: i2 }), fo = { fillExtrusion: (t2) => ({ u_matrix: new e.a_(t2), u_lightpos: new e.b7(t2), u_lightintensity: new e.b2(t2), u_lightcolor: new e.b7(t2), u_vertical_gradient: new e.b2(t2), u_opacity: new e.b2(t2), u_edge_radius: new e.b2(t2), u_ao: new e.b0(t2), u_tile_id: new e.b7(t2), u_zoom_transition: new e.b2(t2), u_inv_rot_matrix: new e.a_(t2), u_merc_center: new e.b0(t2), u_up_dir: new e.b7(t2), u_height_lift: new e.b2(t2), u_flood_light_color: new e.b7(t2), u_vertical_scale: new e.b2(t2), u_flood_light_intensity: new e.b2(t2), u_ground_shadow_factor: new e.b7(t2), u_emissive_strength: new e.b2(t2) }), fillExtrusionDepth: (t2) => ({ u_matrix: new e.a_(t2), u_edge_radius: new e.b2(t2), u_vertical_scale: new e.b2(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.a_(t2), u_lightpos: new e.b7(t2), u_lightintensity: new e.b2(t2), u_lightcolor: new e.b7(t2), u_vertical_gradient: new e.b2(t2), u_height_factor: new e.b2(t2), u_edge_radius: new e.b2(t2), u_ao: new e.b0(t2), u_tile_id: new e.b7(t2), u_zoom_transition: new e.b2(t2), u_inv_rot_matrix: new e.a_(t2), u_merc_center: new e.b0(t2), u_up_dir: new e.b7(t2), u_height_lift: new e.b2(t2), u_image: new e.a$(t2), u_texsize: new e.b0(t2), u_pixel_coord_upper: new e.b0(t2), u_pixel_coord_lower: new e.b0(t2), u_tile_units_to_pixels: new e.b2(t2), u_opacity: new e.b2(t2) }), fillExtrusionGroundEffect: (t2) => ({ u_matrix: new e.a_(t2), u_opacity: new e.b2(t2), u_ao_pass: new e.b2(t2), u_meter_to_tile: new e.b2(t2), u_ao: new e.b0(t2), u_flood_light_intensity: new e.b2(t2), u_flood_light_color: new e.b7(t2), u_attenuation: new e.b2(t2), u_edge_radius: new e.b2(t2), u_fb: new e.a$(t2), u_fb_size: new e.b2(t2) }), fill: (t2) => ({ u_matrix: new e.a_(t2), u_emissive_strength: new e.b2(t2) }), fillPattern: (t2) => ({ u_matrix: new e.a_(t2), u_emissive_strength: new e.b2(t2), u_image: new e.a$(t2), u_texsize: new e.b0(t2), u_pixel_coord_upper: new e.b0(t2), u_pixel_coord_lower: new e.b0(t2), u_tile_units_to_pixels: new e.b2(t2) }), fillOutline: (t2) => ({ u_matrix: new e.a_(t2), u_emissive_strength: new e.b2(t2), u_world: new e.b0(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.a_(t2), u_emissive_strength: new e.b2(t2), u_world: new e.b0(t2), u_image: new e.a$(t2), u_texsize: new e.b0(t2), u_pixel_coord_upper: new e.b0(t2), u_pixel_coord_lower: new e.b0(t2), u_tile_units_to_pixels: new e.b2(t2) }), circle: e.bB, collisionBox: (t2) => ({ u_matrix: new e.a_(t2), u_camera_to_center_distance: new e.b2(t2), u_extrude_scale: new e.b0(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.a_(t2), u_inv_matrix: new e.a_(t2), u_camera_to_center_distance: new e.b2(t2), u_viewport_size: new e.b0(t2) }), debug: (t2) => ({ u_color: new e.b1(t2), u_matrix: new e.a_(t2), u_overlay: new e.a$(t2), u_overlay_scale: new e.b2(t2) }), clippingMask: (t2) => ({ u_matrix: new e.a_(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.b2(t2), u_intensity: new e.b2(t2), u_matrix: new e.a_(t2), u_inv_rot_matrix: new e.a_(t2), u_merc_center: new e.b0(t2), u_tile_id: new e.b7(t2), u_zoom_transition: new e.b2(t2), u_up_dir: new e.b7(t2) }), heatmapTexture: (t2) => ({ u_image: new e.a$(t2), u_color_ramp: new e.a$(t2), u_opacity: new e.b2(t2) }), hillshade: (t2) => ({ u_matrix: new e.a_(t2), u_image: new e.a$(t2), u_latrange: new e.b0(t2), u_light: new e.b0(t2), u_shadow: new e.b1(t2), u_highlight: new e.b1(t2), u_emissive_strength: new e.b2(t2), u_accent: new e.b1(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.a_(t2), u_image: new e.a$(t2), u_dimension: new e.b0(t2), u_zoom: new e.b2(t2) }), line: e.bC, linePattern: e.bD, raster: (t2) => ({ u_matrix: new e.a_(t2), u_normalize_matrix: new e.a_(t2), u_globe_matrix: new e.a_(t2), u_merc_matrix: new e.a_(t2), u_grid_matrix: new e.b8(t2), u_tl_parent: new e.b0(t2), u_scale_parent: new e.b2(t2), u_fade_t: new e.b2(t2), u_opacity: new e.b2(t2), u_image0: new e.a$(t2), u_image1: new e.a$(t2), u_brightness_low: new e.b2(t2), u_brightness_high: new e.b2(t2), u_saturation_factor: new e.b2(t2), u_contrast_factor: new e.b2(t2), u_spin_weights: new e.b7(t2), u_perspective_transform: new e.b0(t2), u_raster_elevation: new e.b2(t2), u_zoom_transition: new e.b2(t2), u_merc_center: new e.b0(t2), u_cutoff_params: new e.b9(t2), u_colorization_mix: new e.b9(t2), u_colorization_offset: new e.b2(t2), u_color_ramp: new e.a$(t2), u_texture_offset: new e.b0(t2), u_texture_res: new e.b0(t2), u_emissive_strength: new e.b2(t2) }), symbolIcon: (t2) => ({ u_is_size_zoom_constant: new e.a$(t2), u_is_size_feature_constant: new e.a$(t2), u_size_t: new e.b2(t2), u_size: new e.b2(t2), u_camera_to_center_distance: new e.b2(t2), u_rotate_symbol: new e.a$(t2), u_aspect_ratio: new e.b2(t2), u_fade_change: new e.b2(t2), u_matrix: new e.a_(t2), u_label_plane_matrix: new e.a_(t2), u_coord_matrix: new e.a_(t2), u_is_text: new e.a$(t2), u_pitch_with_map: new e.a$(t2), u_texsize: new e.b0(t2), u_tile_id: new e.b7(t2), u_zoom_transition: new e.b2(t2), u_inv_rot_matrix: new e.a_(t2), u_merc_center: new e.b0(t2), u_camera_forward: new e.b7(t2), u_tile_matrix: new e.a_(t2), u_up_vector: new e.b7(t2), u_ecef_origin: new e.b7(t2), u_texture: new e.a$(t2), u_icon_transition: new e.b2(t2), u_icon_saturation: new e.b2(t2) }), symbolSDF: (t2) => ({ u_is_size_zoom_constant: new e.a$(t2), u_is_size_feature_constant: new e.a$(t2), u_size_t: new e.b2(t2), u_size: new e.b2(t2), u_camera_to_center_distance: new e.b2(t2), u_rotate_symbol: new e.a$(t2), u_aspect_ratio: new e.b2(t2), u_fade_change: new e.b2(t2), u_matrix: new e.a_(t2), u_label_plane_matrix: new e.a_(t2), u_coord_matrix: new e.a_(t2), u_is_text: new e.a$(t2), u_pitch_with_map: new e.a$(t2), u_texsize: new e.b0(t2), u_texture: new e.a$(t2), u_gamma_scale: new e.b2(t2), u_device_pixel_ratio: new e.b2(t2), u_tile_id: new e.b7(t2), u_zoom_transition: new e.b2(t2), u_inv_rot_matrix: new e.a_(t2), u_merc_center: new e.b0(t2), u_camera_forward: new e.b7(t2), u_tile_matrix: new e.a_(t2), u_up_vector: new e.b7(t2), u_ecef_origin: new e.b7(t2), u_is_halo: new e.a$(t2) }), symbolTextAndIcon: (t2) => ({ u_is_size_zoom_constant: new e.a$(t2), u_is_size_feature_constant: new e.a$(t2), u_size_t: new e.b2(t2), u_size: new e.b2(t2), u_camera_to_center_distance: new e.b2(t2), u_rotate_symbol: new e.a$(t2), u_aspect_ratio: new e.b2(t2), u_fade_change: new e.b2(t2), u_matrix: new e.a_(t2), u_label_plane_matrix: new e.a_(t2), u_coord_matrix: new e.a_(t2), u_is_text: new e.a$(t2), u_pitch_with_map: new e.a$(t2), u_texsize: new e.b0(t2), u_texsize_icon: new e.b0(t2), u_texture: new e.a$(t2), u_texture_icon: new e.a$(t2), u_gamma_scale: new e.b2(t2), u_device_pixel_ratio: new e.b2(t2), u_is_halo: new e.a$(t2) }), background: (t2) => ({ u_matrix: new e.a_(t2), u_emissive_strength: new e.b2(t2), u_opacity: new e.b2(t2), u_color: new e.b1(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.a_(t2), u_emissive_strength: new e.b2(t2), u_opacity: new e.b2(t2), u_image: new e.a$(t2), u_pattern_tl: new e.b0(t2), u_pattern_br: new e.b0(t2), u_texsize: new e.b0(t2), u_pattern_size: new e.b0(t2), u_pixel_coord_upper: new e.b0(t2), u_pixel_coord_lower: new e.b0(t2), u_tile_units_to_pixels: new e.b2(t2) }), terrainRaster: Ti, terrainDepth: Ti, skybox: (t2) => ({ u_matrix: new e.a_(t2), u_sun_direction: new e.b7(t2), u_cubemap: new e.a$(t2), u_opacity: new e.b2(t2), u_temporal_offset: new e.b2(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.a_(t2), u_color_ramp: new e.a$(t2), u_center_direction: new e.b7(t2), u_radius: new e.b2(t2), u_opacity: new e.b2(t2), u_temporal_offset: new e.b2(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.b8(t2), u_sun_direction: new e.b7(t2), u_sun_intensity: new e.b2(t2), u_color_tint_r: new e.b9(t2), u_color_tint_m: new e.b9(t2), u_luminance: new e.b2(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.a_(t2), u_globe_matrix: new e.a_(t2), u_normalize_matrix: new e.a_(t2), u_merc_matrix: new e.a_(t2), u_zoom_transition: new e.b2(t2), u_merc_center: new e.b0(t2), u_image0: new e.a$(t2), u_grid_matrix: new e.b8(t2), u_skirt_height: new e.b2(t2), u_frustum_tl: new e.b7(t2), u_frustum_tr: new e.b7(t2), u_frustum_br: new e.b7(t2), u_frustum_bl: new e.b7(t2), u_globe_pos: new e.b7(t2), u_globe_radius: new e.b2(t2), u_viewport: new e.b0(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.b7(t2), u_frustum_tr: new e.b7(t2), u_frustum_br: new e.b7(t2), u_frustum_bl: new e.b7(t2), u_horizon: new e.b2(t2), u_transition: new e.b2(t2), u_fadeout_range: new e.b2(t2), u_color: new e.b9(t2), u_high_color: new e.b9(t2), u_space_color: new e.b9(t2), u_temporal_offset: new e.b2(t2), u_horizon_angle: new e.b2(t2) }), model: (t2) => ({ u_matrix: new e.a_(t2), u_lighting_matrix: new e.a_(t2), u_normal_matrix: new e.a_(t2), u_lightpos: new e.b7(t2), u_lightintensity: new e.b2(t2), u_lightcolor: new e.b7(t2), u_camera_pos: new e.b7(t2), u_opacity: new e.b2(t2), u_baseColorFactor: new e.b9(t2), u_emissiveFactor: new e.b9(t2), u_metallicFactor: new e.b2(t2), u_roughnessFactor: new e.b2(t2), u_baseTextureIsAlpha: new e.a$(t2), u_alphaMask: new e.a$(t2), u_alphaCutoff: new e.b2(t2), u_baseColorTexture: new e.a$(t2), u_metallicRoughnessTexture: new e.a$(t2), u_normalTexture: new e.a$(t2), u_occlusionTexture: new e.a$(t2), u_emissionTexture: new e.a$(t2), u_color_mix: new e.b9(t2), u_aoIntensity: new e.b2(t2), u_emissive_strength: new e.b2(t2) }), modelDepth: (t2) => ({ u_matrix: new e.a_(t2), u_instance: new e.a_(t2), u_node_matrix: new e.a_(t2) }), groundShadow: (t2) => ({ u_matrix: new e.a_(t2), u_ground_shadow_factor: new e.b7(t2) }), stars: (t2) => ({ u_matrix: new e.a_(t2), u_up: new e.b7(t2), u_right: new e.b7(t2), u_intensity_multiplier: new e.b2(t2) }) };
      let go;
      function vo(t2, i2, o2, r2, s2, n2, a2) {
        const l2 = t2.context, c2 = l2.gl, h22 = t2.transform, _2 = t2.getOrCreateProgram("collisionBox"), d2 = [];
        let u2 = 0, p2 = 0;
        for (let l3 = 0; l3 < r2.length; l3++) {
          const m3 = r2[l3], f3 = i2.getTile(m3), g3 = f3.getBucket(o2);
          if (!g3)
            continue;
          const v3 = It(m3, g3, h22);
          let x3 = v3;
          0 === s2[0] && 0 === s2[1] || (x3 = t2.translatePosMatrix(v3, f3, s2, n2));
          const y3 = a2 ? g3.textCollisionBox : g3.iconCollisionBox, b2 = g3.collisionCircleArray;
          if (b2.length > 0) {
            const t3 = e.m.create(), i3 = x3;
            e.m.mul(t3, g3.placementInvProjMatrix, h22.glCoordMatrix), e.m.mul(t3, t3, g3.placementViewportMatrix), d2.push({ circleArray: b2, circleOffset: p2, transform: i3, invTransform: t3, projection: g3.getProjection() }), u2 += b2.length / 4, p2 = u2;
          }
          y3 && (t2.terrain && t2.terrain.setupElevationDraw(f3, _2), _2.draw(t2, c2.LINES, e.b4.disabled, e.b6.disabled, t2.colorModeForRenderPass(), e.b5.disabled, Yi(x3, h22, f3, g3.getProjection()), o2.id, y3.layoutVertexBuffer, y3.indexBuffer, y3.segments, null, h22.zoom, null, [y3.collisionVertexBuffer, y3.collisionVertexBufferExt]));
        }
        if (!a2 || !d2.length)
          return;
        const m2 = t2.getOrCreateProgram("collisionCircle"), f2 = new e.bE();
        f2.resize(4 * u2), f2._trim();
        let g2 = 0;
        for (const e22 of d2)
          for (let t3 = 0; t3 < e22.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, o3 = e22.circleArray[i3 + 0], r3 = e22.circleArray[i3 + 1], s3 = e22.circleArray[i3 + 2], n3 = e22.circleArray[i3 + 3];
            f2.emplace(g2++, o3, r3, s3, n3, 0), f2.emplace(g2++, o3, r3, s3, n3, 1), f2.emplace(g2++, o3, r3, s3, n3, 2), f2.emplace(g2++, o3, r3, s3, n3, 3);
          }
        (!go || go.length < 2 * u2) && (go = function(t3) {
          const i3 = 2 * t3, o3 = new e.bp();
          o3.resize(i3), o3._trim();
          for (let e22 = 0; e22 < i3; e22++) {
            const t4 = 6 * e22;
            o3.uint16[t4 + 0] = 4 * e22 + 0, o3.uint16[t4 + 1] = 4 * e22 + 1, o3.uint16[t4 + 2] = 4 * e22 + 2, o3.uint16[t4 + 3] = 4 * e22 + 2, o3.uint16[t4 + 4] = 4 * e22 + 3, o3.uint16[t4 + 5] = 4 * e22 + 0;
          }
          return o3;
        }(u2));
        const v2 = l2.createIndexBuffer(go, true), x2 = l2.createVertexBuffer(f2, e.bF.members, true);
        for (const i3 of d2) {
          const r3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (y2 = h22).getCameraToCenterDistance(i3.projection), u_viewport_size: [y2.width, y2.height] };
          m2.draw(t2, c2.TRIANGLES, e.b4.disabled, e.b6.disabled, t2.colorModeForRenderPass(), e.b5.disabled, r3, o2.id, x2, v2, e.bm.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h22.zoom);
        }
        var y2;
        x2.destroy(), v2.destroy();
      }
      const xo = e.m.create();
      function yo({ width: t2, height: i2, anchor: o2, textOffset: r2, textScale: s2 }, n2) {
        const { horizontalAlign: a2, verticalAlign: l2 } = e.aY(o2), c2 = -(a2 - 0.5) * t2, h22 = -(l2 - 0.5) * i2, _2 = e.aW(o2, r2);
        return new e.P((c2 / s2 + _2[0]) * n2, (h22 / s2 + _2[1]) * n2);
      }
      function bo(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2) {
        const d2 = t2.text.placedSymbolArray, u2 = t2.text.dynamicLayoutVertexArray, p2 = t2.icon.dynamicLayoutVertexArray, m2 = {}, f2 = t2.getProjection(), g2 = St(l2, f2, n2), v2 = n2.elevation, x2 = f2.upVectorScale(l2.canonical, n2.center.lat, n2.worldSize).metersToTile;
        u2.clear();
        for (let p3 = 0; p3 < d2.length; p3++) {
          const y2 = d2.get(p3), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y2, E2 = y2.hidden || !y2.crossTileID || t2.allowVerticalPlacement && !y2.placedOrientation ? null : r2[y2.crossTileID];
          if (E2) {
            let r3 = 0, d3 = 0, p4 = 0;
            if (v2) {
              const e22 = v2 ? v2.getAtTileOffset(l2, b2, w2) : 0, [t3, i3, o3] = f2.upVector(l2.canonical, b2, w2);
              r3 = e22 * t3 * x2, d3 = e22 * i3 * x2, p4 = e22 * o3 * x2;
            }
            let [C2, I2, S2, M2] = ge(y2.projectedAnchorX + r3, y2.projectedAnchorY + d3, y2.projectedAnchorZ + p4, o2 ? g2 : a2);
            const L2 = ve(n2.getCameraToCenterDistance(f2), M2);
            let P2 = s2.evaluateSizeForFeature(t2.textSizeData, h22, y2) * L2 / e.aV;
            o2 && (P2 *= t2.tilePixelRatio / c2);
            const D2 = yo(E2, P2);
            o2 ? ({ x: C2, y: I2, z: S2 } = f2.projectTilePoint(b2 + D2.x, w2 + D2.y, l2.canonical), [C2, I2, S2] = ge(C2 + r3, I2 + d3, S2 + p4, a2)) : (i2 && D2._rotate(-n2.angle), C2 += D2.x, I2 += D2.y, S2 = 0);
            const A2 = t2.allowVerticalPlacement && y2.placedOrientation === e.W.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0; t3 < T2; t3++)
              e.k(u2, C2, I2, S2, A2);
            _2 && y2.associatedIconIndex >= 0 && (m2[y2.associatedIconIndex] = { x: C2, y: I2, z: S2, angle: A2 });
          } else
            Se(T2, u2);
        }
        if (_2) {
          p2.clear();
          const i3 = t2.icon.placedSymbolArray;
          for (let t3 = 0; t3 < i3.length; t3++) {
            const o3 = i3.get(t3), { numGlyphs: r3 } = o3, s3 = m2[t3];
            if (o3.hidden || !s3)
              Se(r3, p2);
            else {
              const { x: t4, y: i4, z: o4, angle: n3 } = s3;
              for (let s4 = 0; s4 < r3; s4++)
                e.k(p2, t4, i4, o4, n3);
            }
          }
          t2.icon.dynamicLayoutVertexBuffer.updateData(p2);
        }
        t2.text.dynamicLayoutVertexBuffer.updateData(u2);
      }
      function wo(e22, t2, i2) {
        return i2.iconsInText && t2 ? "symbolTextAndIcon" : e22 ? "symbolSDF" : "symbolIcon";
      }
      function To(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2) {
        const p2 = t2.context, m2 = p2.gl, f2 = t2.transform, g2 = "map" === l2, v2 = "map" === c2, x2 = g2 && "point" !== o2.layout.get("symbol-placement"), y2 = g2 && !v2 && !x2, b2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
        let w2 = false;
        const T2 = t2.depthModeForSublayer(0, e.b4.ReadOnly), E2 = [e.E(f2.center.lng), e.H(f2.center.lat)], C2 = o2.layout.get("text-variable-anchor"), I2 = "globe" === f2.projection.name, S2 = [], M2 = [0, -1, 0];
        let L2 = M2;
        !I2 && !f2.mercatorFromTransition || g2 || (L2 = function(t3) {
          const i3 = t3._camera.getWorldToCamera(t3.worldSize, 1), o3 = e.m.multiply([], i3, t3.globeMatrix);
          e.m.invert(o3, o3);
          const r3 = [0, 0, 0], s3 = [0, 1, 0, 0];
          return e.e.transformMat4(s3, s3, o3), r3[0] = s3[0], r3[1] = s3[1], r3[2] = s3[2], e.v.normalize(r3, r3), r3;
        }(f2));
        for (const l3 of r2) {
          const r3 = i2.getTile(l3), c3 = r3.getBucket(o2);
          if (!c3)
            continue;
          if ("mercator" === c3.projection.name && I2)
            continue;
          const d3 = s2 ? c3.text : c3.icon;
          if (!d3 || c3.fullyClipped || !d3.segments.get().length)
            continue;
          const u3 = d3.programConfigurations.get(o2.id), p3 = s2 || c3.sdfIcons, T3 = s2 ? c3.textSizeData : c3.iconSizeData, P2 = v2 || 0 !== f2.pitch, D2 = e.i(T3, f2.zoom);
          let A2, R2, z2, O2, F2 = [0, 0], B2 = null;
          if (s2)
            R2 = r3.glyphAtlasTexture ? r3.glyphAtlasTexture : null, z2 = m2.LINEAR, A2 = r3.glyphAtlasTexture ? r3.glyphAtlasTexture.size : [0, 0], c3.iconsInText && (F2 = r3.imageAtlasTexture ? r3.imageAtlasTexture.size : [0, 0], B2 = r3.imageAtlasTexture ? r3.imageAtlasTexture : null, O2 = P2 || t2.options.rotating || t2.options.zooming || "composite" === T3.kind || "camera" === T3.kind ? m2.LINEAR : m2.NEAREST);
          else {
            const e22 = 1 !== o2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
            R2 = r3.imageAtlasTexture ? r3.imageAtlasTexture : null, z2 = p3 || t2.options.rotating || t2.options.zooming || e22 || P2 ? m2.LINEAR : m2.NEAREST, A2 = r3.imageAtlasTexture ? r3.imageAtlasTexture.size : [0, 0];
          }
          const k2 = "globe" === c3.projection.name, N2 = k2 ? L2 : M2, U2 = k2 ? e.ao(f2.zoom) : 0, G2 = St(l3, c3.getProjection(), f2), j2 = f2.calculatePixelsToTileUnitsMatrix(r3), V2 = pe(G2, r3.tileID.canonical, v2, g2, f2, c3.getProjection(), j2), Z2 = t2.terrain && v2 && x2 ? e.m.invert(e.m.create(), V2) : xo, W2 = fe(G2, r3.tileID.canonical, v2, g2, f2, c3.getProjection(), j2), H2 = C2 && c3.hasTextData(), q2 = c3.hasIconTextFit() && H2 && c3.hasIconData();
          if (x2) {
            const e22 = f2.elevation, i3 = e22 ? e22.getAtTileOffsetFunc(l3, f2.center.lat, f2.worldSize, c3.getProjection()) : null, o3 = me(G2, r3.tileID.canonical, v2, g2, f2, c3.getProjection(), j2);
            ye(c3, G2, t2, s2, o3, W2, v2, h22, i3, l3);
          }
          const $2 = x2 || s2 && C2 || q2, X2 = t2.translatePosMatrix(G2, r3, n2, a2), J2 = $2 ? xo : V2, Y2 = t2.translatePosMatrix(W2, r3, n2, a2, true), K2 = c3.getProjection().createInversionMatrix(f2, l3.canonical), Q2 = o2.paint.get("icon-image-cross-fade").constantOr(0), ee2 = [];
          t2.terrainRenderModeElevated() && v2 && ee2.push("PITCH_WITH_MAP_TERRAIN"), k2 && (ee2.push("PROJECTION_GLOBE_VIEW"), $2 && ee2.push("PROJECTED_POS_ON_VIEWPORT")), Q2 > 0 && ee2.push("ICON_TRANSITION"), d3.zOffsetVertexBuffer && ee2.push("Z_OFFSET");
          const te2 = p3 && 0 !== o2.paint.get(s2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
          let ie2;
          p3 ? ie2 = c3.iconsInText ? lo(T3.kind, D2, y2, v2, t2, X2, J2, Y2, A2, F2, l3, U2, E2, K2, N2, c3.getProjection()) : ao(T3.kind, D2, y2, v2, t2, X2, J2, Y2, s2, A2, true, l3, U2, E2, K2, N2, c3.getProjection()) : (_2 < 1 && ee2.push("SATURATION"), ie2 = no(T3.kind, D2, y2, v2, t2, X2, J2, Y2, s2, A2, l3, U2, E2, K2, N2, c3.getProjection(), _2, Q2));
          const oe2 = { program: t2.getOrCreateProgram(wo(p3, s2, c3), { config: u3, defines: ee2 }), buffers: d3, uniformValues: ie2, atlasTexture: R2, atlasTextureIcon: B2, atlasInterpolation: z2, atlasInterpolationIcon: O2, isSDF: p3, hasHalo: te2, tile: r3, labelPlaneMatrixInv: Z2 };
          if (b2 && c3.canOverlap) {
            w2 = true;
            const t3 = d3.segments.get();
            for (const i3 of t3)
              S2.push({ segments: new e.bm([i3]), sortKey: i3.sortKey, state: oe2 });
          } else
            S2.push({ segments: d3.segments, sortKey: 0, state: oe2 });
        }
        w2 && S2.sort((e22, t3) => e22.sortKey - t3.sortKey);
        for (const e22 of S2) {
          const i3 = e22.state;
          if (t2.terrain && t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: f2.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), p2.activeTexture.set(m2.TEXTURE0), i3.atlasTexture && i3.atlasTexture.bind(i3.atlasInterpolation, m2.CLAMP_TO_EDGE, true), i3.atlasTextureIcon && (p2.activeTexture.set(m2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, m2.CLAMP_TO_EDGE, true)), t2.uploadCommonLightUniforms(t2.context, i3.program), i3.hasHalo) {
            const r3 = i3.uniformValues;
            r3.u_is_halo = 1, Eo(i3.buffers, e22.segments, o2, t2, i3.program, T2, d2, u2, r3, 2), r3.u_is_halo = 0;
          } else {
            if (i3.isSDF) {
              const r3 = i3.uniformValues;
              i3.hasHalo && (r3.u_is_halo = 1, Eo(i3.buffers, e22.segments, o2, t2, i3.program, T2, d2, u2, r3, 1)), r3.u_is_halo = 0;
            }
            Eo(i3.buffers, e22.segments, o2, t2, i3.program, T2, d2, u2, i3.uniformValues, 1);
          }
        }
      }
      function Eo(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22) {
        const _2 = [t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer, t2.iconTransitioningVertexBuffer, t2.globeExtVertexBuffer, t2.zOffsetVertexBuffer];
        s2.draw(r2, r2.context.gl.TRIANGLES, n2, a2, l2, e.b5.disabled, c2, o2.id, t2.layoutVertexBuffer, t2.indexBuffer, i2, o2.paint, r2.transform.zoom, t2.programConfigurations.get(o2.id), _2, h22);
      }
      function Co(t2, i2, o2, r2, s2, n2, a2) {
        const l2 = t2.context.gl, c2 = o2.paint.get("fill-pattern"), h22 = c2 && c2.constantOr(1);
        let _2, d2, u2, p2, m2;
        a2 ? (d2 = h22 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", _2 = l2.LINES) : (d2 = h22 ? "fillPattern" : "fill", _2 = l2.TRIANGLES);
        for (const f2 of r2) {
          const r3 = i2.getTile(f2);
          if (h22 && !r3.patternsLoaded())
            continue;
          const g2 = r3.getBucket(o2);
          if (!g2)
            continue;
          t2.prepareDrawTile();
          const v2 = g2.programConfigurations.get(o2.id), x2 = t2.isTileAffectedByFog(f2), y2 = t2.getOrCreateProgram(d2, { config: v2, overrideFog: x2 });
          h22 && (t2.context.activeTexture.set(l2.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v2.updatePaintBuffers());
          const b2 = c2.constantOr(null);
          if (b2 && r3.imageAtlas) {
            const e22 = r3.imageAtlas.patternPositions[b2.toString()];
            e22 && v2.setConstantPatternPositions(e22);
          }
          const w2 = t2.translatePosMatrix(f2.projMatrix, r3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor")), T2 = o2.paint.get("fill-emissive-strength");
          if (a2) {
            p2 = g2.indexBuffer2, m2 = g2.segments2;
            const e22 = t2.terrain && t2.terrain.renderingToTexture ? t2.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
            u2 = "fillOutlinePattern" === d2 && h22 ? Ji(w2, T2, t2, r3, e22) : Xi(w2, T2, e22);
          } else
            p2 = g2.indexBuffer, m2 = g2.segments, u2 = h22 ? $i(w2, T2, t2, r3) : qi(w2, T2);
          t2.uploadCommonUniforms(t2.context, y2, f2.toUnwrapped()), y2.draw(t2, _2, s2, t2.stencilModeForClipping(f2), n2, e.b5.disabled, u2, o2.id, g2.layoutVertexBuffer, p2, m2, o2.paint, t2.transform.zoom, v2, void 0);
        }
      }
      function Io(t2, i2, o2, r2, s2, n2, a2, l2) {
        o2.resetLayerRenderingStats();
        const c2 = t2.context, h22 = c2.gl, _2 = t2.transform, d2 = o2.paint.get("fill-extrusion-pattern"), u2 = d2.constantOr(1), p2 = o2.paint.get("fill-extrusion-opacity"), m2 = t2.style.enable3dLights(), f2 = o2.paint.get(m2 && !u2 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), f2], v2 = o2.layout.get("fill-extrusion-edge-radius"), x2 = v2 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), y2 = x2 ? 0 : v2, b2 = "globe" === _2.projection.name ? e.bO() : 0, w2 = "globe" === _2.projection.name, T2 = w2 ? e.ao(_2.zoom) : 0, E2 = [e.E(_2.center.lng), e.H(_2.center.lat)], C2 = o2.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), I2 = o2.paint.get("fill-extrusion-flood-light-intensity"), S2 = o2.paint.get("fill-extrusion-vertical-scale"), M2 = Ii(t2, o2.paint.get("fill-extrusion-cutoff-fade-range")), L2 = o2.paint.get("fill-extrusion-emissive-strength"), P2 = [];
        let D2;
        w2 && P2.push("PROJECTION_GLOBE_VIEW"), g2[0] > 0 && P2.push("FAUX_AO"), x2 && P2.push("ZERO_ROOF_RADIUS"), l2 && P2.push("HAS_CENTROID"), I2 > 0 && P2.push("FLOOD_LIGHT"), M2.shouldRenderCutoff && P2.push("RENDER_CUTOFF");
        const A2 = "shadow" === t2.renderPass, R2 = t2.shadowRenderer, z2 = A2 && !!R2;
        t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = true);
        let O2 = [0, 0, 0];
        if (R2) {
          const e22 = t2.style.directionalLight, i3 = t2.style.ambientLight;
          e22 && i3 && (O2 = wr(e22, i3)), D2 = P2.concat(["SHADOWS_SINGLE_CASCADE"]);
        }
        const F2 = z2 ? "fillExtrusionDepth" : u2 ? "fillExtrusionPattern" : "fillExtrusion", B2 = o2.getLayerRenderingStats();
        for (const m3 of r2) {
          const r3 = i2.getTile(m3), f3 = r3.getBucket(o2);
          if (!f3 || f3.projection.name !== _2.projection.name)
            continue;
          let v3 = false;
          R2 && (v3 = 0 === R2.getMaxCascadeForTile(m3.toUnwrapped()));
          const x3 = t2.isTileAffectedByFog(m3), z3 = f3.programConfigurations.get(o2.id), k2 = t2.getOrCreateProgram(F2, { config: z3, defines: v3 ? D2 : P2, overrideFog: x3 });
          if (t2.terrain && t2.terrain.setupElevationDraw(r3, k2, { useMeterToDem: true }), !f3.centroidVertexBuffer) {
            const e22 = k2.attributes.a_centroid_pos;
            void 0 !== e22 && h22.vertexAttrib2f(e22, 0, 0);
          }
          !A2 && R2 && R2.setupShadows(r3.tileID.toUnwrapped(), k2, "vector-tile", r3.tileID.overscaledZ), u2 && (t2.context.activeTexture.set(h22.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(h22.LINEAR, h22.CLAMP_TO_EDGE), z3.updatePaintBuffers());
          const N2 = d2.constantOr(null);
          if (N2 && r3.imageAtlas) {
            const e22 = r3.imageAtlas.patternPositions[N2.toString()];
            e22 && z3.setConstantPatternPositions(e22);
          }
          const U2 = o2.paint.get("fill-extrusion-vertical-gradient");
          let G2;
          if (A2 && R2) {
            if (Ao(r3.tileID, f3, t2))
              continue;
            const e22 = R2.calculateShadowPassMatrixFromTile(r3.tileID.toUnwrapped());
            G2 = Wi(e22, y2, S2);
          } else {
            const e22 = t2.translatePosMatrix(m3.expandedProjMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = _2.projection.createInversionMatrix(_2, m3.canonical);
            G2 = u2 ? Hi(e22, t2, U2, p2, g2, y2, m3, r3, b2, T2, E2, i3, C2, S2) : Zi(e22, t2, U2, p2, g2, y2, m3, b2, T2, E2, i3, C2, S2, I2, O2, L2);
          }
          t2.uploadCommonUniforms(c2, k2, m3.toUnwrapped(), null, M2);
          let j2 = f3.segments;
          if ("mercator" === _2.projection.name && !A2 && (j2 = f3.getVisibleSegments(r3.tileID, t2.terrain, t2.transform.getFrustum(0)), !j2.get().length))
            continue;
          if (B2)
            if (A2)
              for (const e22 of j2.get())
                B2.numRenderedVerticesInShadowPass += e22.primitiveLength;
            else
              for (const e22 of j2.get())
                B2.numRenderedVerticesInTransparentPass += e22.primitiveLength;
          const V2 = [];
          (t2.terrain || l2) && V2.push(f3.centroidVertexBuffer), w2 && V2.push(f3.layoutVertexExtBuffer), k2.draw(t2, c2.gl.TRIANGLES, s2, n2, a2, e.b5.backCCW, G2, o2.id, f3.layoutVertexBuffer, f3.indexBuffer, j2, o2.paint, t2.transform.zoom, z3, V2);
        }
        t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = false);
      }
      function So(t2, i2, o2, r2, s2, n2, a2, l2, c2, h22, _2, d2, u2, p2, m2, f2, g2, v2, x2) {
        const y2 = t2.context, b2 = y2.gl, w2 = t2.transform, T2 = t2.transform.zoom, E2 = [], C2 = Ii(t2, o2.paint.get("fill-extrusion-cutoff-fade-range"));
        "clear" === h22 ? (E2.push("CLEAR_SUBPASS"), x2 && (E2.push("CLEAR_FROM_TEXTURE"), y2.activeTexture.set(b2.TEXTURE0), x2.bind(b2.LINEAR, b2.CLAMP_TO_EDGE))) : "sdf" === h22 && E2.push("SDF_SUBPASS"), g2 && E2.push("HAS_CENTROID"), C2.shouldRenderCutoff && E2.push("RENDER_CUTOFF");
        const I2 = o2.layout.get("fill-extrusion-edge-radius"), S2 = (e22, i3, r3, h3, v3) => {
          const b3 = i3.programConfigurations.get(o2.id), w3 = t2.isTileAffectedByFog(e22), S3 = t2.getOrCreateProgram("fillExtrusionGroundEffect", { config: b3, defines: E2, overrideFog: w3 }), M2 = /* @__PURE__ */ ((e3, t3, i4, o3, r4, s3, n3, a3, l3, c3, h4) => ({ u_matrix: t3, u_opacity: i4, u_ao_pass: o3 ? 1 : 0, u_meter_to_tile: r4, u_ao: s3, u_flood_light_intensity: n3, u_flood_light_color: a3, u_attenuation: l3, u_edge_radius: c3, u_fb: 0, u_fb_size: h4 }))(0, h3, _2, c2, v3, [d2, u2 * v3], p2, m2, f2, T2 >= 17 ? 0 : I2 * v3, x2 ? x2.size[0] : 0), L2 = [];
          g2 && L2.push(i3.hiddenByLandmarkVertexBuffer), t2.uploadCommonUniforms(y2, S3, e22.toUnwrapped(), null, C2), S3.draw(t2, y2.gl.TRIANGLES, s2, n2, a2, l2, M2, o2.id, i3.vertexBuffer, i3.indexBuffer, r3, o2.paint, T2, b3, L2);
        };
        for (const s3 of r2) {
          const r3 = i2.getTile(s3), n3 = r3.getBucket(o2);
          if (!n3 || n3.projection.name !== w2.projection.name || !n3.groundEffect || n3.groundEffect && !n3.groundEffect.hasData())
            continue;
          const a3 = n3.groundEffect, l3 = 1 / n3.tileToMeter;
          {
            const e22 = t2.translatePosMatrix(s3.projMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = a3.getDefaultSegment();
            S2(s3, a3, i3, e22, l3);
          }
          if (v2)
            for (let n4 = 0; n4 < 4; n4++) {
              const a4 = e.bP[n4](s3), c3 = i2.getTile(a4);
              if (!c3)
                continue;
              const h3 = c3.getBucket(o2);
              if (!h3 || h3.projection.name !== w2.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData())
                continue;
              const _3 = h3.groundEffect;
              let d3, u3;
              0 === n4 ? (d3 = [-e.J, 0, 0], u3 = 1) : 1 === n4 ? (d3 = [e.J, 0, 0], u3 = 0) : 2 === n4 ? (d3 = [0, -e.J, 0], u3 = 3) : (d3 = [0, e.J, 0], u3 = 2);
              const p3 = _3.regionSegments[u3];
              if (!p3)
                continue;
              const m3 = new Float32Array(16);
              e.m.translate(m3, s3.projMatrix, d3), S2(s3, _3, p3, t2.translatePosMatrix(m3, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), l3);
            }
        }
      }
      function Mo(t2, i2, o2, r2, s2, n2, a2) {
        0 === r2.centroidVertexArray.length && r2.createCentroidsBuffer();
        const l2 = n2 ? n2.findDEMTileFor(o2) : null;
        if (!(l2 && l2.dem || a2))
          return;
        const c2 = (t3) => new e.P(Math.ceil((t3 + e.bS) * e.bT), 0), h22 = (e22) => {
          const t3 = i2.getSource().minzoom, o3 = (e3) => {
            const t4 = i2.getTileByID(e3);
            if (t4 && t4.hasData())
              return t4.getBucket(s2);
          }, r3 = [0, -1, 1];
          for (const i3 of r3) {
            if (e22.overscaledZ + i3 < t3)
              continue;
            const r4 = o3(e22.calculateScaledKey(e22.overscaledZ + i3));
            if (r4)
              return r4;
          }
        }, _2 = [0, 0, 0], d2 = (t3, i3) => (_2[0] = Math.min(t3.min.y, i3.min.y), _2[1] = Math.max(t3.max.y, i3.max.y), _2[2] = e.J - i3.min.x > t3.max.x ? i3.min.x - e.J : t3.max.x, _2), u2 = (t3, i3) => (_2[0] = Math.min(t3.min.x, i3.min.x), _2[1] = Math.max(t3.max.x, i3.max.x), _2[2] = e.J - i3.min.y > t3.max.y ? i3.min.y - e.J : t3.max.y, _2), p2 = [(e22, t3) => d2(e22, t3), (e22, t3) => d2(t3, e22), (e22, t3) => u2(e22, t3), (e22, t3) => u2(t3, e22)], m2 = (t3, i3, r3, s3, a3, c3, h3) => {
          if (!n2)
            return 0;
          const _3 = [[c3 ? r3 : t3, c3 ? t3 : r3, 0], [c3 ? r3 : i3, c3 ? i3 : r3, 0]], d3 = h3 < 0 ? e.J + h3 : h3, u3 = [c3 ? d3 : (t3 + i3) / 2, c3 ? (t3 + i3) / 2 : d3, 0];
          return 0 === r3 && h3 < 0 || 0 !== r3 && h3 > 0 ? n2.getForTilePoints(a3, [u3], true, s3) : _3.push(u3), n2.getForTilePoints(o2, _3, true, l2), Math.max(_3[0][2], _3[1][2], u3[2]) / n2.exaggeration();
        };
        for (let t3 = 0; t3 < 4; t3++) {
          const i3 = r2.borderFeatureIndices[t3];
          if (0 === i3.length)
            continue;
          const s3 = e.bP[t3](o2), l3 = h22(s3);
          if (!(l3 && l3 instanceof e.bQ))
            continue;
          if (r2.borderDoneWithNeighborZ[t3] === l3.canonical.z)
            continue;
          0 === l3.centroidVertexArray.length && l3.createCentroidsBuffer();
          const _3 = n2 ? n2.findDEMTileFor(s3) : null;
          if (!(_3 && _3.dem || a2))
            continue;
          const d3 = (t3 < 2 ? 1 : 5) - t3, u3 = l3.borderDoneWithNeighborZ[d3] !== r2.canonical.z, v2 = l3.borderFeatureIndices[d3];
          let x2 = 0;
          if (r2.canonical.z !== l3.canonical.z) {
            for (const e22 of i3)
              r2.showCentroid(r2.featuresOnBorder[e22]);
            if (u3)
              for (const e22 of v2)
                l3.showCentroid(l3.featuresOnBorder[e22]);
            r2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[d3] = r2.canonical.z;
          }
          for (const o3 of i3) {
            const i4 = r2.featuresOnBorder[o3], n3 = r2.centroidData[i4.centroidDataIndex], h3 = i4.borders[t3];
            let u4;
            for (; x2 < v2.length; ) {
              u4 = l3.featuresOnBorder[v2[x2]];
              const e22 = u4.borders[d3];
              if (e22[1] > h3[0] + 3 || e22[0] > h3[0] - 3)
                break;
              l3.showCentroid(u4), x2++;
            }
            if (u4 && x2 < v2.length) {
              const o4 = x2;
              let y2 = 0;
              for (; !(u4.borders[d3][0] > h3[1] - 3) && (y2++, ++x2 !== v2.length); )
                u4 = l3.featuresOnBorder[v2[x2]];
              if (u4 = l3.featuresOnBorder[v2[o4]], y2 > 1) {
                const e22 = u4.borders[d3];
                Math.abs(h3[0] - e22[0]) < 3 && Math.abs(h3[1] - e22[1]) < 3 && (y2 = 1, x2 = o4 + 1);
              } else if (0 === y2) {
                r2.showCentroid(i4);
                continue;
              }
              const b2 = l3.centroidData[u4.centroidDataIndex];
              a2 && 1 === y2 && (((f2 = n3).flags | (g2 = b2).flags) & e.bR ? (f2.flags |= e.bR, g2.flags |= e.bR) : (f2.flags &= ~e.bR, g2.flags &= ~e.bR));
              const w2 = i4.intersectsCount() > 1 || u4.intersectsCount() > 1;
              if (y2 > 1)
                x2 = o4, n3.centroidXY = b2.centroidXY = new e.P(0, 0);
              else if (_3 && _3.dem && !w2) {
                const i5 = p2[t3](n3, b2), o5 = t3 % 2 ? e.J - 1 : 0, r3 = m2(i5[0], Math.min(e.J - 1, i5[1]), o5, _3, s3, t3 < 2, i5[2]);
                n3.centroidXY = b2.centroidXY = c2(r3);
              } else
                w2 ? n3.centroidXY = b2.centroidXY = new e.P(0, 0) : (n3.centroidXY = r2.encodeBorderCentroid(i4), b2.centroidXY = l3.encodeBorderCentroid(u4));
              r2.writeCentroidToBuffer(n3), l3.writeCentroidToBuffer(b2);
            } else
              r2.showCentroid(i4);
          }
          r2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[d3] = r2.canonical.z;
        }
        var f2, g2;
        (r2.needsCentroidUpdate || !r2.centroidVertexBuffer && 0 !== r2.centroidVertexArray.length) && r2.uploadCentroid(t2);
      }
      const Lo = [1, 0, 0], Po = [0, 1, 0], Do = [0, 0, 1];
      function Ao(t2, i2, o2) {
        const r2 = o2.transform, s2 = o2.shadowRenderer;
        if (!s2)
          return true;
        const n2 = t2.toUnwrapped(), a2 = r2.tileSize * s2._cascades[o2.currentShadowCascade].scale;
        let l2 = i2.maxHeight;
        if (r2.elevation) {
          const e22 = r2.elevation.getMinMaxForTile(t2);
          e22 && (l2 += e22.max);
        }
        const c2 = [...s2.shadowDirection];
        c2[2] = -c2[2];
        const h22 = s2.computeSimplifiedTileShadowVolume(n2, l2, a2, c2);
        if (!h22)
          return false;
        const _2 = [Lo, Po, Do, c2, [c2[0], 0, c2[2]], [0, c2[1], c2[2]]], d2 = "globe" === r2.projection.name, u2 = r2.scaleZoom(a2), p2 = e.F.fromInvProjectionMatrix(r2.invProjMatrix, r2.worldSize, u2, !d2), m2 = s2.getCurrentCascadeFrustum();
        return 0 === p2.intersectsPrecise(h22.vertices, h22.planes, _2) || 0 === m2.intersectsPrecise(h22.vertices, h22.planes, _2);
      }
      function Ro(e22) {
        const t2 = e22._nearZ, i2 = e22.projection.farthestPixelDistance(e22), o2 = i2 - t2, r2 = 0.2 * e22.height, s2 = t2 + r2;
        return [t2, i2, (s2 - r2 - t2) / o2, (s2 - t2) / o2];
      }
      const zo = new e.C(1, 0, 0, 1), Oo = new e.C(0, 1, 0, 1), Fo = new e.C(0, 0, 1, 1), Bo = new e.C(1, 0, 1, 1), ko = new e.C(0, 1, 1, 1);
      function No(t2, i2, o2, r2, s2, n2) {
        const a2 = t2.context, l2 = t2.transform, c2 = a2.gl, h22 = "globe" === l2.projection.name, _2 = h22 ? ["PROJECTION_GLOBE_VIEW"] : [];
        let d2 = e.m.clone(o2.projMatrix);
        if (h22 && e.ao(l2.zoom) > 0) {
          const t3 = e.bU(o2.canonical, l2), i3 = e.bV(t3);
          d2 = e.m.multiply(new Float32Array(16), l2.globeMatrix, i3), e.m.multiply(d2, l2.projMatrix, d2);
        }
        const u2 = e.m.create();
        u2[12] += 2 * s2 / (e.a4.devicePixelRatio * l2.width), u2[13] += 2 * n2 / (e.a4.devicePixelRatio * l2.height), e.m.multiply(d2, u2, d2);
        const p2 = t2.getOrCreateProgram("debug", { defines: _2 }), m2 = i2.getTileByID(o2.key);
        t2.terrain && t2.terrain.setupElevationDraw(m2, p2);
        const f2 = e.b4.disabled, g2 = e.b6.disabled, v2 = t2.colorModeForRenderPass(), x2 = "$debug";
        a2.activeTexture.set(c2.TEXTURE0), t2.emptyTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), h22 ? m2._makeGlobeTileDebugBuffers(t2.context, l2) : m2._makeDebugTileBoundsBuffers(t2.context, l2.projection);
        const y2 = m2._tileDebugBuffer || t2.debugBuffer, b2 = m2._tileDebugIndexBuffer || t2.debugIndexBuffer, w2 = m2._tileDebugSegments || t2.debugSegments;
        p2.draw(t2, c2.LINE_STRIP, f2, g2, v2, e.b5.disabled, Ki(d2, r2), x2, y2, b2, w2, null, null, null, [m2._globeTileDebugBorderBuffer]);
        const T2 = m2.latestRawTileData, E2 = Math.floor((T2 && T2.byteLength || 0) / 1024), C2 = i2.getTile(o2).tileSize, I2 = 512 / Math.min(C2, 512) * (o2.overscaledZ / l2.zoom) * 0.5;
        let S2 = o2.canonical.toString();
        o2.overscaledZ !== o2.canonical.z && (S2 += ` => ${o2.overscaledZ}`), S2 += ` ${E2}kb`, function(e22, t3) {
          e22.initDebugOverlayCanvas();
          const i3 = e22.debugOverlayCanvas, o3 = e22.context.gl, r3 = e22.debugOverlayCanvas.getContext("2d");
          r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(t3, 5, 5), r3.strokeText(t3, 5, 5), e22.debugOverlayTexture.update(i3), e22.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
        }(t2, S2);
        const M2 = m2._tileDebugTextBuffer || t2.debugBuffer, L2 = m2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, P2 = m2._tileDebugTextSegments || t2.debugSegments;
        p2.draw(t2, c2.TRIANGLES, f2, g2, e.a.alphaBlended, e.b5.disabled, Ki(d2, e.C.transparent, I2), x2, M2, L2, P2, null, null, null, [m2._globeTileDebugTextBuffer]);
      }
      function Uo(e22, t2, i2, o2) {
        jo(e22, 0, t2 + i2 / 2, e22.transform.width, i2, o2);
      }
      function Go(e22, t2, i2, o2) {
        jo(e22, t2 - i2 / 2, 0, i2, e22.transform.height, o2);
      }
      function jo(t2, i2, o2, r2, s2, n2) {
        const a2 = t2.context, l2 = a2.gl;
        l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.a4.devicePixelRatio, o2 * e.a4.devicePixelRatio, r2 * e.a4.devicePixelRatio, s2 * e.a4.devicePixelRatio), a2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
      }
      const Vo = e.bW([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Zo } = Vo;
      function Wo(e22, t2, i2, o2) {
        e22.emplaceBack(t2, i2, o2);
      }
      class Ho {
        constructor(t2) {
          this.vertexArray = new e.bX(), this.indices = new e.bp(), Wo(this.vertexArray, -1, -1, 1), Wo(this.vertexArray, 1, -1, 1), Wo(this.vertexArray, -1, 1, 1), Wo(this.vertexArray, 1, 1, 1), Wo(this.vertexArray, -1, -1, -1), Wo(this.vertexArray, 1, -1, -1), Wo(this.vertexArray, -1, 1, -1), Wo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, Zo), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.bm.simpleSegment(0, 0, 36, 12);
        }
      }
      function qo(t2, i2, o2, r2, s2, n2) {
        const a2 = t2.context.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h22 = i2.paint.get("sky-atmosphere-sun-intensity"), _2 = ((e22, t3, i3, o3, r3) => ({ u_matrix_3f: e22, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r3.r, r3.g, r3.b, r3.a], u_luminance: 5e-5 }))(e.bx.fromMat4(e.bx.create(), r2), s2, h22, l2, c2);
        a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + n2, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, e.b4.disabled, e.b6.disabled, e.a.unblended, e.b5.frontCW, _2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
      }
      const $o = e.bW([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class Xo {
        constructor(t2) {
          const i2 = new e.bY();
          i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
          const o2 = new e.bp();
          o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, $o.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.bm.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const Jo = e.bW([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
      class Yo {
        constructor() {
          this.starsCount = 16e3, this.sizeMultiplier = 0.15;
        }
      }
      class Ko {
        constructor(t2) {
          this.colorModeAlphaBlendedWriteRGB = new e.a([e.bZ, e.b_, e.bZ, e.b_], e.C.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new e.a([e.bZ, e.b$, e.bZ, e.b$], e.C.transparent, [false, false, false, true]), this.params = new Yo(), this.allocatedStarsCount = 0, t2.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }), t2.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 });
        }
        update(t2) {
          const i2 = t2.context;
          if (!this.atmosphereBuffer || this.allocatedStarsCount !== this.params.starsCount) {
            this.atmosphereBuffer = new Xo(i2), this.allocatedStarsCount = this.params.starsCount;
            const t3 = 100, o2 = 200, r2 = function(t4) {
              const i3 = e.c2(30), o3 = [];
              for (let r3 = 0; r3 < t4; ++r3) {
                const t5 = 2 * Math.PI * i3(), r4 = Math.acos(1 - 2 * i3()) - 0.5 * Math.PI;
                o3.push(e.v.fromValues(Math.cos(r4) * Math.cos(t5), Math.cos(r4) * Math.sin(t5), Math.sin(r4)));
              }
              return o3;
            }(this.allocatedStarsCount), s2 = e.c2(300), n2 = new e.c0(), a2 = new e.bp();
            let l2 = 0;
            for (let i3 = 0; i3 < r2.length; ++i3) {
              const c2 = e.v.scale([], r2[i3], 200), h22 = Math.max(0, 1 + 0.01 * t3 * (1 * s2() - 0.5)), _2 = Math.max(0, 1 + 0.01 * o2 * (1 * s2() - 0.5));
              n2.emplaceBack(c2[0], c2[1], c2[2], -1, -1, h22, _2), n2.emplaceBack(c2[0], c2[1], c2[2], 1, -1, h22, _2), n2.emplaceBack(c2[0], c2[1], c2[2], 1, 1, h22, _2), n2.emplaceBack(c2[0], c2[1], c2[2], -1, 1, h22, _2), a2.emplaceBack(l2 + 0, l2 + 1, l2 + 2), a2.emplaceBack(l2 + 0, l2 + 2, l2 + 3), l2 += 4;
            }
            this.starsVx = i2.createVertexBuffer(n2, Jo.members), this.starsIdx = i2.createIndexBuffer(a2), this.starsSegments = e.bm.simpleSegment(0, 0, n2.length, a2.length);
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(t2, i2) {
          const o2 = t2.context, r2 = o2.gl, s2 = t2.transform, n2 = new e.b4(r2.LEQUAL, e.b4.ReadOnly, [0, 1]), a2 = e.ao(s2.zoom), l2 = i2.properties.get("color").toArray01(), c2 = i2.properties.get("high-color").toArray01(), h22 = i2.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = 5e-4, d2 = e.c1(i2.properties.get("horizon-blend"), 0, 1, _2, 0.25), u2 = e.bb(t2, o2, s2) && d2 === _2 ? s2.worldSize / (2 * Math.PI * 1.025) - 1 : s2.globeRadius, p2 = t2.frameCounter / 1e3 % 1, m2 = e.v.length(s2.globeCenterInViewSpace), f2 = Math.sqrt(Math.pow(m2, 2) - Math.pow(u2, 2)), g2 = Math.acos(f2 / m2), v2 = (i3) => {
            const _3 = "globe" === s2.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
            i3 && _3.push("ALPHA_PASS");
            const u3 = t2.getOrCreateProgram("globeAtmosphere", { defines: _3 }), m3 = /* @__PURE__ */ ((e22, t3, i4, o3, r3, s3, n3, a3, l3, c3, h3, _4) => ({ u_frustum_tl: e22, u_frustum_tr: t3, u_frustum_br: i4, u_frustum_bl: o3, u_horizon: r3, u_transition: s3, u_fadeout_range: n3, u_color: a3, u_high_color: l3, u_space_color: c3, u_temporal_offset: h3, u_horizon_angle: _4 }))(s2.frustumCorners.TL, s2.frustumCorners.TR, s2.frustumCorners.BR, s2.frustumCorners.BL, s2.frustumCorners.horizon, a2, d2, l2, c2, h22, p2, g2);
            t2.uploadCommonUniforms(o2, u3);
            const f3 = this.atmosphereBuffer;
            f3 && u3.draw(t2, r2.TRIANGLES, n2, e.b6.disabled, i3 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, e.b5.backCW, m3, i3 ? "atmosphere_glow_alpha" : "atmosphere_glow", f3.vertexBuffer, f3.indexBuffer, f3.segments);
          };
          v2(false), v2(true);
        }
        drawStars(t2, i2) {
          const o2 = e.c(i2.properties.get("star-intensity"), 0, 1);
          if (0 === o2)
            return;
          const r2 = t2.context, s2 = r2.gl, n2 = t2.transform, a2 = t2.getOrCreateProgram("stars"), l2 = e.q.identity([]);
          e.q.rotateX(l2, l2, -n2._pitch), e.q.rotateZ(l2, l2, -n2.angle), e.q.rotateX(l2, l2, e.d(n2._center.lat)), e.q.rotateY(l2, l2, -e.d(n2._center.lng));
          const c2 = e.m.fromQuat(new Float32Array(16), l2), h22 = e.m.multiply([], n2.starsProjMatrix, c2), _2 = e.bx.fromMat4([], c2), d2 = e.bx.invert([], _2), u2 = [0, 1, 0];
          e.v.transformMat3(u2, u2, d2), e.v.scale(u2, u2, this.params.sizeMultiplier);
          const p2 = [1, 0, 0];
          e.v.transformMat3(p2, p2, d2), e.v.scale(p2, p2, this.params.sizeMultiplier);
          const m2 = (f2 = u2, g2 = p2, v2 = o2, { u_matrix: Float32Array.from(h22), u_up: f2, u_right: g2, u_intensity_multiplier: v2 });
          var f2, g2, v2;
          t2.uploadCommonUniforms(r2, a2), this.starsVx && this.starsIdx && a2.draw(t2, s2.TRIANGLES, e.b4.disabled, e.b6.disabled, this.colorModeAlphaBlendedWriteRGB, e.b5.disabled, m2, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function Qo(t2, i2) {
        const o2 = [...t2], r2 = i2.cameraWorldSizeForFog / i2.worldSize, s2 = e.m.identity([]);
        return e.m.scale(s2, s2, [r2, r2, 1]), e.m.multiply(o2, s2, o2), e.m.multiply(o2, i2.worldToFogMatrix, o2), o2;
      }
      function er(e22, t2, i2, o2) {
        const r2 = i2.material, s2 = o2.context, { baseColorTexture: n2, metallicRoughnessTexture: a2 } = r2.pbrMetallicRoughness, { normalTexture: l2, occlusionTexture: c2, emissionTexture: h22 } = r2;
        function _2(t3, i3, o3) {
          if (t3 && (e22.push(i3), s2.activeTexture.set(s2.gl.TEXTURE0 + o3), t3.gfxTexture)) {
            const { minFilter: e3, magFilter: i4, wrapS: o4, wrapT: r3 } = t3.sampler;
            t3.gfxTexture.bindExtraParam(e3, i4, o4, r3);
          }
        }
        _2(n2, "HAS_TEXTURE_u_baseColorTexture", _o.BaseColor), _2(a2, "HAS_TEXTURE_u_metallicRoughnessTexture", _o.MetallicRoughness), _2(l2, "HAS_TEXTURE_u_normalTexture", _o.Normal), _2(c2, "HAS_TEXTURE_u_occlusionTexture", _o.Occlusion), _2(h22, "HAS_TEXTURE_u_emissionTexture", _o.Emission), i2.texcoordBuffer && (e22.push("HAS_ATTRIBUTE_a_uv_2f"), t2.push(i2.texcoordBuffer)), i2.colorBuffer && (e22.push(12 === i2.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t2.push(i2.colorBuffer)), i2.normalBuffer && (e22.push("HAS_ATTRIBUTE_a_normal_3f"), t2.push(i2.normalBuffer)), i2.pbrBuffer && (e22.push("HAS_ATTRIBUTE_a_pbr"), e22.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t2.push(i2.pbrBuffer)), "OPAQUE" !== r2.alphaMode && "MASK" !== r2.alphaMode || e22.push("UNPREMULT_TEXTURE_IN_SHADER"), r2.defined || e22.push("DIFFUSE_SHADED"), e22.push("USE_STANDARD_DERIVATIVES");
      }
      function tr(t2, i2, o2, r2, s2, n2) {
        const a2 = o2.paint.get("model-opacity"), l2 = i2.context, c2 = new e.b4(i2.context.gl.LEQUAL, e.b4.ReadWrite, i2.depthRangeFor3D), h22 = i2.transform, _2 = t2.mesh, d2 = _2.material, u2 = d2.pbrMetallicRoughness, p2 = i2.style.fog;
        let m2;
        m2 = "pixels" === i2.transform.projection.zAxisUnit ? [...t2.nodeModelMatrix] : e.m.multiply([], r2.zScaleMatrix, t2.nodeModelMatrix), e.m.multiply(m2, r2.negCameraPosMatrix, m2);
        const f2 = e.m.invert([], m2);
        e.m.transpose(f2, f2);
        const g2 = o2.paint.get("model-emissive-strength").constantOr(0), v2 = uo(new Float32Array(t2.worldViewProjection), new Float32Array(m2), new Float32Array(f2), i2, a2, u2.baseColorFactor, d2.emissiveFactor, u2.metallicFactor, u2.roughnessFactor, d2, g2, o2), x2 = { defines: [] }, y2 = [];
        er(x2.defines, y2, _2, i2);
        const b2 = i2.shadowRenderer;
        b2 && (b2.useNormalOffset = false);
        let w2 = null;
        if (p2) {
          const e22 = Qo(t2.nodeModelMatrix, i2.transform);
          if (w2 = new Float32Array(e22), "globe" !== h22.projection.name) {
            const t3 = _2.aabb.min, i3 = _2.aabb.max, [o3, r3] = p2.getOpacityForBounds(e22, t3[0], t3[1], i3[0], i3[1]);
            x2.overrideFog = o3 >= Ue || r3 >= Ue;
          }
        }
        const T2 = Ii(i2, o2.paint.get("model-cutoff-fade-range"));
        T2.shouldRenderCutoff && x2.defines.push("RENDER_CUTOFF");
        const E2 = i2.getOrCreateProgram("model", x2);
        i2.uploadCommonUniforms(l2, E2, null, w2, T2), "shadow" !== i2.renderPass && b2 && b2.setupShadowsFromMatrix(t2.nodeModelMatrix, E2), E2.draw(i2, l2.gl.TRIANGLES, c2, s2, n2, _2.material.doubleSided ? e.b5.disabled : e.b5.backCCW, v2, o2.id, _2.vertexBuffer, _2.indexBuffer, _2.segments, o2.paint, i2.transform.zoom, void 0, y2);
      }
      function ir(t2, i2, o2, r2, s2, n2, a2) {
        let l2;
        l2 = "globe" === t2.projection.name ? e.c5(o2, t2) : [...o2], e.m.multiply(l2, l2, i2.matrix);
        const c2 = e.m.multiply([], r2, l2);
        if (i2.meshes)
          for (const t3 of i2.meshes) {
            if ("BLEND" !== t3.material.alphaMode) {
              a2.push({ mesh: t3, depth: 0, modelIndex: s2, worldViewProjection: c2, nodeModelMatrix: l2 });
              continue;
            }
            const i3 = e.v.transformMat4([], t3.centroid, c2);
            i3[2] > 0 && n2.push({ mesh: t3, depth: i3[2], modelIndex: s2, worldViewProjection: c2, nodeModelMatrix: l2 });
          }
        if (i2.children)
          for (const e22 of i2.children)
            ir(t2, e22, o2, r2, s2, n2, a2);
      }
      function or(t2, i2, o2, r2) {
        const s2 = o2.shadowRenderer;
        if (!s2)
          return;
        const n2 = s2.getShadowPassDepthMode(), a2 = s2.getShadowPassColorMode(), l2 = s2.calculateShadowPassMatrixFromMatrix(i2), c2 = mo(l2);
        o2.getOrCreateProgram("modelDepth", { defines: ["DEPTH_TEXTURE"] }).draw(o2, o2.context.gl.TRIANGLES, n2, e.b6.disabled, a2, e.b5.backCCW, c2, r2.id, t2.vertexBuffer, t2.indexBuffer, t2.segments, r2.paint, o2.transform.zoom, void 0, void 0);
      }
      function rr(t2, i2, o2) {
        const r2 = i2.updateZoomBasedPaintProperties(), s2 = function(t3, i3, o3) {
          let r3, s3, n2, a2 = t3.terrain ? t3.terrain.exaggeration() : 0;
          if (t3.terrain && a2 > 0) {
            const i4 = t3.terrain, s4 = i4.findDEMTileFor(o3);
            s4 && s4.dem ? r3 = e.c7.create(i4, o3, s4) : a2 = 0;
          }
          if (0 === a2 && (i3.terrainElevationMin = 0, i3.terrainElevationMax = 0), a2 === i3.validForExaggeration && (0 === a2 || r3 && r3._demTile && r3._demTile.tileID === i3.validForDEMTile.id && r3._dem._timestamp === i3.validForDEMTile.timestamp))
            return false;
          for (const e22 in i3.instancesPerModel) {
            const t4 = i3.instancesPerModel[e22];
            for (let e3 = 0; e3 < t4.instancedDataArray.length; ++e3) {
              const o4 = (r3 ? a2 * r3.getElevationAt(0 | t4.instancedDataArray.float32[16 * e3], 0 | t4.instancedDataArray.float32[16 * e3 + 1], true, true) : 0) + t4.instancesEvaluatedElevation[e3];
              t4.instancedDataArray.float32[16 * e3 + 6] = o4, s3 = s3 ? Math.min(i3.terrainElevationMin, o4) : o4, n2 = n2 ? Math.max(i3.terrainElevationMax, o4) : o4;
            }
          }
          return i3.terrainElevationMin = s3 || 0, i3.terrainElevationMax = n2 || 0, i3.validForExaggeration = a2, i3.validForDEMTile = r3 && r3._demTile ? { id: r3._demTile.tileID, timestamp: r3._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
        }(t2, i2, o2);
        (r2 || s2) && (i2.uploaded = false, i2.upload(t2.context));
      }
      const sr = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e.c3([0, 0, 0], [e.J, e.J, 0]) };
      function nr(t2, i2) {
        const o2 = 1 << t2.canonical.z, r2 = i2.getFreeCameraOptions().position, s2 = i2.elevation, n2 = t2.canonical.x / o2, a2 = (t2.canonical.x + 1) / o2, l2 = t2.canonical.y / o2, c2 = (t2.canonical.y + 1) / o2;
        let h22 = i2._centerAltitude;
        if (s2) {
          const e22 = s2.getMinMaxForTile(t2);
          e22 && e22.max > h22 && (h22 = e22.max);
        }
        const _2 = e.c(r2.x, n2, a2) - r2.x, d2 = e.c(r2.y, l2, c2) - r2.y, u2 = e.b(h22, i2.center.lat) - r2.z;
        return i2._zoomFromMercatorZ(Math.sqrt(_2 * _2 + d2 * d2 + u2 * u2));
      }
      function ar(t2, i2, o2, r2, s2, n2, a2) {
        const l2 = t2.context, c2 = "shadow" === t2.renderPass, h22 = t2.shadowRenderer, _2 = c2 && h22 ? h22.getShadowPassDepthMode() : new e.b4(l2.gl.LEQUAL, e.b4.ReadWrite, t2.depthRangeFor3D), d2 = t2.isTileAffectedByFog(n2);
        if (o2.meshes)
          for (const u2 of o2.meshes) {
            const p2 = ["MODEL_POSITION_ON_GPU"], m2 = [];
            let f2, g2, v2;
            r2.instancedDataArray.length > 20 && p2.push("INSTANCED_ARRAYS");
            const x2 = Ii(t2, i2.paint.get("model-cutoff-fade-range"));
            if (x2.shouldRenderCutoff && p2.push("RENDER_CUTOFF"), c2 && h22)
              f2 = t2.getOrCreateProgram("modelDepth", { defines: p2 }), g2 = mo(a2.shadowTileMatrix, a2.shadowTileMatrix, Float32Array.from(o2.matrix)), v2 = h22.getShadowPassColorMode();
            else {
              er(p2, m2, u2, t2), f2 = t2.getOrCreateProgram("model", { defines: p2, overrideFog: d2 });
              const r3 = u2.material, c3 = r3.pbrMetallicRoughness, _3 = i2.paint.get("model-opacity"), y3 = i2.paint.get("model-emissive-strength").constantOr(0);
              g2 = uo(n2.expandedProjMatrix, Float32Array.from(o2.matrix), new Float32Array(16), t2, _3, c3.baseColorFactor, r3.emissiveFactor, c3.metallicFactor, c3.roughnessFactor, r3, y3, i2, s2), h22 && (a2.shadowUniformsInitialized ? f2.setShadowUniformValues(l2, h22.getShadowUniformValues()) : (h22.setupShadows(n2.toUnwrapped(), f2, "model-tile", n2.overscaledZ), a2.shadowUniformsInitialized = true)), v2 = x2.shouldRenderCutoff || _3 < 1 || "OPAQUE" !== r3.alphaMode ? e.a.alphaBlended : e.a.unblended;
            }
            t2.uploadCommonUniforms(l2, f2, n2.toUnwrapped(), null, x2);
            const y2 = u2.material.doubleSided ? e.b5.disabled : e.b5.backCCW;
            if (r2.instancedDataArray.length > 20)
              m2.push(r2.instancedDataBuffer), f2.draw(t2, l2.gl.TRIANGLES, _2, e.b6.disabled, v2, y2, g2, i2.id, u2.vertexBuffer, u2.indexBuffer, u2.segments, i2.paint, t2.transform.zoom, void 0, m2, r2.instancedDataArray.length);
            else {
              const o3 = c2 ? "u_instance" : "u_normal_matrix";
              for (let s3 = 0; s3 < r2.instancedDataArray.length; ++s3)
                g2[o3] = new Float32Array(r2.instancedDataArray.arrayBuffer, 64 * s3, 16), f2.draw(t2, l2.gl.TRIANGLES, _2, e.b6.disabled, v2, y2, g2, i2.id, u2.vertexBuffer, u2.indexBuffer, u2.segments, i2.paint, t2.transform.zoom, void 0, m2);
            }
          }
        if (o2.children)
          for (const e22 of o2.children)
            ar(t2, i2, e22, r2, s2, n2, a2);
      }
      const lr = [1, -1, 1];
      function cr(t2, i2, o2, r2) {
        if (!o2.modelManager)
          return true;
        const s2 = o2.modelManager;
        if (!o2.shadowRenderer)
          return true;
        const n2 = o2.shadowRenderer, a2 = i2.aabb;
        let l2 = true, c2 = t2.maxHeight;
        if (0 === c2) {
          let e22 = 0;
          for (const i3 in t2.instancesPerModel) {
            const t3 = s2.getModel(i3, r2);
            t3 ? e22 = Math.max(e22, Math.max(Math.max(t3.aabb.max[0], t3.aabb.max[1]), t3.aabb.max[2])) : l2 = false;
          }
          c2 = t2.maxScale * e22 * 1.41 + t2.maxVerticalOffset, l2 && (t2.maxHeight = c2);
        }
        a2.max[2] = c2, a2.min[2] += t2.terrainElevationMin, a2.max[2] += t2.terrainElevationMax, e.v.transformMat4(a2.min, a2.min, i2.tileMatrix), e.v.transformMat4(a2.max, a2.max, i2.tileMatrix);
        const h22 = a2.intersects(n2.getCurrentCascadeFrustum());
        return 0 === o2.currentShadowCascade && (t2.isInsideFirstShadowMapFrustum = 2 === h22), 0 === h22;
      }
      class hr {
      }
      class _r {
        constructor() {
          this._storage = /* @__PURE__ */ new Map();
        }
        getLinesFromTrianglesBuffer(t2, i2, o2) {
          {
            const e22 = this._storage.get(i2.id);
            if (e22)
              return e22.lastUsedFrameIdx = t2, e22.buf;
          }
          const r2 = o2.gl, s2 = r2.getBufferParameter(r2.ELEMENT_ARRAY_BUFFER, r2.BUFFER_SIZE), n2 = new ArrayBuffer(s2), a2 = new Int16Array(n2);
          r2.getBufferSubData(r2.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n2));
          const l2 = new e.c9();
          for (let e22 = 0; e22 < s2 / 2; e22 += 3) {
            const t3 = a2[e22], i3 = a2[e22 + 1], o3 = a2[e22 + 2];
            l2.emplaceBack(t3, i3), l2.emplaceBack(i3, o3), l2.emplaceBack(o3, t3);
          }
          const c2 = o2.bindVertexArrayOES.current, h22 = new hr();
          return h22.buf = new e.I(o2, l2), h22.lastUsedFrameIdx = t2, this._storage.set(i2.id, h22), o2.bindVertexArrayOES.set(c2), h22.buf;
        }
        update(e22) {
          for (const [t2, i2] of this._storage)
            e22 - i2.lastUsedFrameIdx > 30 && (i2.buf.destroy(), this._storage.delete(t2));
        }
        destroy() {
          for (const [e22, t2] of this._storage)
            t2.buf.destroy(), this._storage.delete(e22);
        }
      }
      class dr {
        registerParameter(e22, t2, i2, o2, r2) {
        }
        registerButton(e22, t2, i2) {
        }
      }
      const ur = { symbol: function(t2, i2, o2, r2, s2) {
        if ("translucent" !== t2.renderPass)
          return;
        const n2 = e.b6.disabled, a2 = t2.colorModeForRenderPass();
        o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r3, s3, n3, a3) {
          const l2 = i3.transform, c2 = "map" === s3, h22 = "map" === n3;
          for (const i4 of t3) {
            const t4 = r3.getTile(i4), s4 = t4.getBucket(o3);
            if (!s4 || !s4.text || !s4.text.segments.get().length)
              continue;
            const n4 = e.i(s4.textSizeData, l2.zoom), _2 = St(i4, s4.getProjection(), l2), d2 = l2.calculatePixelsToTileUnitsMatrix(t4), u2 = pe(_2, t4.tileID.canonical, h22, c2, l2, s4.getProjection(), d2), p2 = s4.hasIconTextFit() && s4.hasIconData();
            if (n4) {
              const o4 = Math.pow(2, l2.zoom - t4.tileID.overscaledZ);
              bo(s4, c2, h22, a3, e.bG, l2, u2, i4, o4, n4, p2);
            }
          }
        }(r2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), s2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && To(t2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), o2.paint.get("icon-color-saturation"), n2, a2), 0 !== o2.paint.get("text-opacity").constantOr(1) && To(t2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), o2.paint.get("icon-color-saturation"), n2, a2), i2.map.showCollisionBoxes && (vo(t2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), vo(t2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
      }, circle: function(t2, i2, o2, r2) {
        if ("translucent" !== t2.renderPass)
          return;
        const s2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1), c2 = o2.paint.get("circle-emissive-strength");
        if (0 === s2.constantOr(1) && (0 === n2.constantOr(1) || 0 === a2.constantOr(1)))
          return;
        const h22 = t2.context, _2 = h22.gl, d2 = t2.transform, u2 = t2.depthModeForSublayer(0, e.b4.ReadOnly), p2 = e.b6.disabled, m2 = t2.colorModeForDrapableLayerRenderPass(c2), f2 = "globe" === d2.projection.name, g2 = [e.E(d2.center.lng), e.H(d2.center.lat)], v2 = [];
        for (let s3 = 0; s3 < r2.length; s3++) {
          const n3 = r2[s3], a3 = i2.getTile(n3), c3 = a3.getBucket(o2);
          if (!c3 || c3.projection.name !== d2.projection.name)
            continue;
          const h3 = c3.programConfigurations.get(o2.id), _3 = e.bH(o2), u3 = t2.isTileAffectedByFog(n3);
          f2 && _3.push("PROJECTION_GLOBE_VIEW");
          const p3 = t2.getOrCreateProgram("circle", { config: h3, defines: _3, overrideFog: u3 }), m3 = c3.layoutVertexBuffer, x3 = c3.globeExtVertexBuffer, y2 = c3.indexBuffer, b2 = d2.projection.createInversionMatrix(d2, n3.canonical), w2 = { programConfiguration: h3, program: p3, layoutVertexBuffer: m3, globeExtVertexBuffer: x3, indexBuffer: y2, uniformValues: e.bI(t2, n3, a3, b2, g2, o2), tile: a3 };
          if (l2) {
            const t3 = c3.segments.get();
            for (const i3 of t3)
              v2.push({ segments: new e.bm([i3]), sortKey: i3.sortKey, state: w2 });
          } else
            v2.push({ segments: c3.segments, sortKey: 0, state: w2 });
        }
        l2 && v2.sort((e22, t3) => e22.sortKey - t3.sortKey);
        const x2 = { useDepthForOcclusion: d2.depthOcclusionForSymbolsAndCircles };
        for (const i3 of v2) {
          const { programConfiguration: r3, program: s3, layoutVertexBuffer: n3, globeExtVertexBuffer: a3, indexBuffer: l3, uniformValues: c3, tile: f3 } = i3.state, g3 = i3.segments;
          t2.terrain && t2.terrain.setupElevationDraw(f3, s3, x2), t2.uploadCommonUniforms(h22, s3, f3.tileID.toUnwrapped()), s3.draw(t2, _2.TRIANGLES, u2, p2, m2, e.b5.disabled, c3, o2.id, n3, l3, g3, o2.paint, d2.zoom, r3, [a3]);
        }
      }, heatmap: function(t2, i2, o2, r2) {
        if (0 !== o2.paint.get("heatmap-opacity"))
          if ("offscreen" === t2.renderPass) {
            const s2 = t2.context, n2 = s2.gl, a2 = e.b6.disabled, l2 = new e.a([n2.ONE, n2.ONE, n2.ONE, n2.ONE], e.C.transparent, [true, true, true, true]);
            !function(e22, t3, i3, o3) {
              const r3 = e22.gl, s3 = t3.width * o3, n3 = t3.height * o3;
              e22.activeTexture.set(r3.TEXTURE1), e22.viewport.set([0, 0, s3, n3]);
              let a3 = i3.heatmapFbo;
              if (!a3 || a3 && (a3.width !== s3 || a3.height !== n3)) {
                a3 && a3.destroy();
                const t4 = r3.createTexture();
                r3.bindTexture(r3.TEXTURE_2D, t4), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR), a3 = i3.heatmapFbo = e22.createFramebuffer(s3, n3, true, null), function(e3, t5, i4, o4, r4, s4) {
                  const n4 = e3.gl;
                  n4.texImage2D(n4.TEXTURE_2D, 0, e3.extRenderToTextureHalfFloat ? n4.RGBA16F : n4.RGBA, r4, s4, 0, n4.RGBA, e3.extRenderToTextureHalfFloat ? n4.HALF_FLOAT : n4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(e22, 0, t4, a3, s3, n3);
              } else
                r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), e22.bindFramebuffer.set(a3.framebuffer);
            }(s2, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), s2.clear({ color: e.C.transparent });
            const c2 = t2.transform, h22 = "globe" === c2.projection.name, _2 = h22 ? ["PROJECTION_GLOBE_VIEW"] : [], d2 = h22 ? e.b5.frontCCW : e.b5.disabled, u2 = [e.E(c2.center.lng), e.H(c2.center.lat)];
            for (let p2 = 0; p2 < r2.length; p2++) {
              const m2 = r2[p2];
              if (i2.hasRenderableParent(m2))
                continue;
              const f2 = i2.getTile(m2), g2 = f2.getBucket(o2);
              if (!g2 || g2.projection.name !== c2.projection.name)
                continue;
              const v2 = t2.isTileAffectedByFog(m2), x2 = g2.programConfigurations.get(o2.id), y2 = t2.getOrCreateProgram("heatmap", { config: x2, defines: _2, overrideFog: v2 }), { zoom: b2 } = t2.transform;
              t2.terrain && t2.terrain.setupElevationDraw(f2, y2), t2.uploadCommonUniforms(s2, y2, m2.toUnwrapped());
              const w2 = c2.projection.createInversionMatrix(c2, m2.canonical);
              y2.draw(t2, n2.TRIANGLES, e.b4.disabled, a2, l2, d2, eo(t2, m2, f2, w2, u2, b2, o2.paint.get("heatmap-intensity")), o2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, o2.paint, t2.transform.zoom, x2, h22 ? [g2.globeExtVertexBuffer] : null);
            }
            s2.viewport.set([0, 0, t2.width, t2.height]);
          } else
            "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
              const o3 = t3.context, r3 = o3.gl, s2 = i3.heatmapFbo;
              if (!s2)
                return;
              o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, s2.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
              let n2 = i3.colorRampTexture;
              n2 || (n2 = i3.colorRampTexture = new e.a9(o3, i3.colorRamp, r3.RGBA)), n2.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), t3.getOrCreateProgram("heatmapTexture").draw(t3, r3.TRIANGLES, e.b4.disabled, e.b6.disabled, t3.colorModeForRenderPass(), e.b5.disabled, ((e22, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
            }(t2, o2));
      }, line: function(t2, i2, o2, r2) {
        if ("translucent" !== t2.renderPass)
          return;
        const s2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
        if (0 === s2.constantOr(1) || 0 === n2.constantOr(1))
          return;
        const a2 = o2.paint.get("line-emissive-strength"), l2 = t2.depthModeForSublayer(0, e.b4.ReadOnly), c2 = t2.colorModeForDrapableLayerRenderPass(a2), h22 = t2.terrain && t2.terrain.renderingToTexture ? 1 : e.a4.devicePixelRatio, _2 = o2.paint.get("line-dasharray"), d2 = _2.constantOr(1), u2 = o2.layout.get("line-cap"), p2 = o2.paint.get("line-pattern"), m2 = p2.constantOr(1), f2 = o2.paint.get("line-pattern").constantOr(1), g2 = 1 !== o2.paint.get("line-opacity").constantOr(1);
        let v2 = !f2 && g2;
        const x2 = o2.paint.get("line-gradient"), y2 = m2 ? "linePattern" : "line", b2 = t2.context, w2 = b2.gl, T2 = e.bJ(o2);
        t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (v2 = false);
        for (const s3 of r2) {
          const r3 = i2.getTile(s3);
          if (m2 && !r3.patternsLoaded())
            continue;
          const n3 = r3.getBucket(o2);
          if (!n3)
            continue;
          t2.prepareDrawTile();
          const a3 = n3.programConfigurations.get(o2.id), f3 = t2.isTileAffectedByFog(s3), g3 = t2.getOrCreateProgram(y2, { config: a3, defines: T2, overrideFog: f3 }), E2 = p2.constantOr(null);
          if (E2 && r3.imageAtlas) {
            const e22 = r3.imageAtlas.patternPositions[E2.toString()];
            e22 && a3.setConstantPatternPositions(e22);
          }
          const C2 = _2.constantOr(null), I2 = u2.constantOr(null);
          if (!m2 && C2 && I2 && r3.lineAtlas) {
            const e22 = r3.lineAtlas.getDash(C2, I2);
            e22 && a3.setConstantPatternPositions(e22);
          }
          let [S2, M2] = o2.paint.get("line-trim-offset");
          if ("round" === I2 || "square" === I2) {
            const e22 = 1;
            S2 !== M2 && (0 === S2 && (S2 -= e22), 1 === M2 && (M2 += e22));
          }
          const L2 = t2.terrain ? s3.projMatrix : null, P2 = m2 ? e.bK(t2, r3, o2, L2, h22) : e.bL(t2, r3, o2, L2, n3.lineClipsArray.length, h22, [S2, M2]);
          if (x2) {
            const r4 = n3.gradients[o2.id];
            let a4 = r4.texture;
            if (o2.gradientVersion !== r4.version) {
              let l3 = 256;
              if (o2.stepInterpolant) {
                const o3 = i2.getSource().maxzoom, r5 = s3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - s3.canonical.z) : 1;
                l3 = e.c(e.bM(n3.maxLineLength / e.J * 1024 * r5), 256, b2.maxTextureSize);
              }
              r4.gradient = e.bN({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r4.gradient || void 0, clips: n3.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new e.a9(b2, r4.gradient, w2.RGBA), r4.version = o2.gradientVersion, a4 = r4.texture;
            }
            b2.activeTexture.set(w2.TEXTURE1), a4.bind(o2.stepInterpolant ? w2.NEAREST : w2.LINEAR, w2.CLAMP_TO_EDGE);
          }
          d2 && (b2.activeTexture.set(w2.TEXTURE0), r3.lineAtlasTexture && r3.lineAtlasTexture.bind(w2.LINEAR, w2.REPEAT), a3.updatePaintBuffers()), m2 && (b2.activeTexture.set(w2.TEXTURE0), r3.imageAtlasTexture && r3.imageAtlasTexture.bind(w2.LINEAR, w2.CLAMP_TO_EDGE), a3.updatePaintBuffers()), t2.uploadCommonUniforms(b2, g3, s3.toUnwrapped());
          const D2 = (i3) => {
            g3.draw(t2, w2.TRIANGLES, l2, i3, c2, e.b5.disabled, P2, o2.id, n3.layoutVertexBuffer, n3.indexBuffer, n3.segments, o2.paint, t2.transform.zoom, a3, [n3.layoutVertexBuffer2]);
          };
          if (v2) {
            const i3 = t2.stencilModeForClipping(s3).ref;
            0 === i3 && t2.terrain && b2.clear({ stencil: 0 });
            const o3 = { func: w2.EQUAL, mask: 255 };
            P2.u_alpha_discard_threshold = 0.8, D2(new e.b6(o3, i3, 255, w2.KEEP, w2.KEEP, w2.INVERT)), P2.u_alpha_discard_threshold = 0, D2(new e.b6(o3, i3, 255, w2.KEEP, w2.KEEP, w2.KEEP));
          } else
            D2(t2.stencilModeForClipping(s3));
        }
        v2 && (t2.resetStencilClippingMasks(), t2.terrain && b2.clear({ stencil: 0 }));
      }, fill: function(t2, i2, o2, r2) {
        const s2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
        if (0 === n2.constantOr(1))
          return;
        const a2 = o2.paint.get("fill-emissive-strength"), l2 = t2.colorModeForDrapableLayerRenderPass(a2), c2 = o2.paint.get("fill-pattern"), h22 = t2.opaquePassEnabledForLayer() && !c2.constantOr(1) && 1 === s2.constantOr(e.C.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
        if (t2.renderPass === h22) {
          const s3 = t2.depthModeForSublayer(1, "opaque" === t2.renderPass ? e.b4.ReadWrite : e.b4.ReadOnly);
          Co(t2, i2, o2, r2, s3, l2, false);
        }
        if ("translucent" === t2.renderPass && o2.paint.get("fill-antialias")) {
          const s3 = t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.b4.ReadOnly);
          Co(t2, i2, o2, r2, s3, l2, true);
        }
      }, "fill-extrusion": function(t2, i2, o2, r2) {
        const s2 = o2.paint.get("fill-extrusion-opacity"), n2 = t2.context, a2 = n2.gl, l2 = t2.terrain, c2 = l2 && l2.renderingToTexture;
        if (0 === s2)
          return;
        const h22 = t2.conflationActive && t2.layerUsedInConflation(o2, i2.getSource());
        if (h22 && function(e22, t3, i3, o3) {
          for (const r3 of o3) {
            const o4 = t3.getTile(r3).getBucket(i3);
            o4 && (o4.updateReplacement(r3, e22.replacementSource), o4.uploadCentroid(e22.context));
          }
        }(t2, i2, o2, r2), l2 || h22)
          for (const e22 of r2) {
            const r3 = i2.getTile(e22).getBucket(o2);
            r3 && Mo(t2.context, i2, e22, r3, o2, l2, h22);
          }
        if ("shadow" === t2.renderPass && t2.shadowRenderer) {
          const n3 = t2.shadowRenderer;
          if (l2 && s2 < 0.65 && o2._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.am)
            return;
          const a3 = n3.getShadowPassDepthMode(), c3 = n3.getShadowPassColorMode();
          Io(t2, i2, o2, r2, a3, e.b6.disabled, c3, h22);
        } else if ("translucent" === t2.renderPass) {
          const _2 = !o2.paint.get("fill-extrusion-pattern").constantOr(1), d2 = o2.paint.get("fill-extrusion-color").constantOr(e.C.white);
          if (!c2 && 0 !== d2.a) {
            const n3 = new e.b4(t2.context.gl.LEQUAL, e.b4.ReadWrite, t2.depthRangeFor3D);
            1 === s2 && _2 ? Io(t2, i2, o2, r2, n3, e.b6.disabled, e.a.unblended, h22) : (Io(t2, i2, o2, r2, n3, e.b6.disabled, e.a.disabled, h22), Io(t2, i2, o2, r2, n3, t2.stencilModeFor3D(), t2.colorModeForRenderPass(), h22), t2.resetStencilClippingMasks());
          }
          if (t2.style.enable3dLights() && _2 && (!l2 && "globe" !== t2.transform.projection.name || c2)) {
            const s3 = o2.paint.get("fill-extrusion-opacity"), _3 = o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), d3 = o2.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), u2 = o2.paint.get("fill-extrusion-flood-light-intensity"), p2 = o2.paint.get("fill-extrusion-flood-light-color").toArray01().slice(0, 3), m2 = _3 > 0 && d3 > 0, f2 = u2 > 0, g2 = (e22, t3, i3) => (1 - i3) * e22 + i3 * t3, v2 = (n3) => {
              const l3 = t2.depthModeForSublayer(1, e.b4.ReadOnly, a2.LEQUAL, true), c3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), m3 = g2(0.1, 3, c3), f3 = t2._showOverdrawInspector;
              if (!f3) {
                const c4 = new e.b6({ func: a2.ALWAYS, mask: 255 }, 255, 255, a2.KEEP, a2.KEEP, a2.REPLACE), f4 = new e.a([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.C.transparent, [false, false, false, true], a2.MIN);
                So(t2, i2, o2, r2, l3, c4, f4, e.b5.disabled, n3, "sdf", s3, _3, d3, u2, p2, m3, h22, false);
              }
              {
                const c4 = f3 ? e.b6.disabled : new e.b6({ func: a2.EQUAL, mask: 255 }, 255, 255, a2.KEEP, a2.DECR, a2.DECR), g3 = f3 ? t2.colorModeForRenderPass() : new e.a([a2.ONE_MINUS_DST_ALPHA, a2.DST_ALPHA, a2.ONE, a2.ONE], e.C.transparent, [true, true, true, true]);
                So(t2, i2, o2, r2, l3, c4, g3, e.b5.disabled, n3, "color", s3, _3, d3, u2, p2, m3, h22, false);
              }
            };
            if (c2) {
              const c3 = (n3, l3, c4) => {
                const m3 = t2.depthModeForSublayer(1, e.b4.ReadOnly, a2.LEQUAL, false), f3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), v3 = g2(0.1, 3, f3);
                {
                  const c5 = new e.a([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.C.transparent, [false, false, false, true]);
                  So(t2, i2, o2, r2, m3, e.b6.disabled, c5, e.b5.disabled, n3, "clear", s3, _3, d3, u2, p2, v3, h22, l3);
                }
                {
                  const c5 = new e.b6({ func: a2.ALWAYS, mask: 255 }, 255, 255, a2.KEEP, a2.KEEP, a2.REPLACE), f4 = new e.a([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.C.transparent, [false, false, false, true], a2.MIN);
                  So(t2, i2, o2, r2, m3, c5, f4, e.b5.disabled, n3, "sdf", s3, _3, d3, u2, p2, v3, h22, l3);
                }
                {
                  const c5 = n3 ? a2.ZERO : a2.ONE_MINUS_DST_ALPHA, f4 = new e.b6({ func: a2.EQUAL, mask: 255 }, 255, 255, a2.KEEP, a2.DECR, a2.DECR), g3 = new e.a([c5, a2.DST_ALPHA, a2.ONE_MINUS_DST_ALPHA, a2.ZERO], e.C.transparent, [true, true, true, true]);
                  So(t2, i2, o2, r2, m3, f4, g3, e.b5.disabled, n3, "color", s3, _3, d3, u2, p2, v3, h22, l3);
                }
                {
                  const f4 = new e.a([a2.ONE, a2.ONE, a2.ONE, n3 ? a2.ZERO : a2.ONE], e.C.transparent, [false, false, false, true], n3 ? a2.FUNC_ADD : a2.MAX);
                  So(t2, i2, o2, r2, m3, e.b6.disabled, f4, e.b5.disabled, n3, "clear", s3, _3, d3, u2, p2, v3, h22, l3, c4);
                }
              };
              if (m2 || f2) {
                let i3;
                if (t2.prepareDrawTile(), l2) {
                  const t3 = l2.drapeBufferSize[0], o3 = l2.drapeBufferSize[1];
                  i3 = l2.framebufferCopyTexture, i3 && (!i3 || i3.size[0] === t3 && i3.size[1] === o3) || (i3 && i3.destroy(), i3 = l2.framebufferCopyTexture = new e.a9(n2, new e.a5({ width: t3, height: o3 }), a2.RGBA)), i3.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), a2.copyTexImage2D(a2.TEXTURE_2D, 0, a2.RGBA, 0, 0, t3, o3, 0);
                }
                m2 && c3(true, false, i3), f2 && c3(false, true, i3);
              }
            } else
              m2 && v2(true), f2 && v2(false);
          }
        }
      }, hillshade: function(t2, i2, o2, r2) {
        if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass)
          return;
        if (t2.style.disableElevatedTerrain)
          return;
        const s2 = t2.context, n2 = t2.terrain && t2.terrain.renderingToTexture, [a2, l2] = "translucent" !== t2.renderPass || n2 ? [{}, r2] : t2.stencilConfigForOverlap(r2);
        for (const r3 of l2) {
          const s3 = i2.getTile(r3);
          if (s3.needsHillshadePrepare && "offscreen" === t2.renderPass)
            wi(t2, s3, o2);
          else if ("translucent" === t2.renderPass) {
            const i3 = t2.depthModeForSublayer(0, e.b4.ReadOnly), l3 = o2.paint.get("hillshade-emissive-strength"), c2 = t2.colorModeForDrapableLayerRenderPass(l3), h22 = n2 && t2.terrain ? t2.terrain.stencilModeForRTTOverlap(r3) : a2[r3.overscaledZ];
            yi(t2, r3, s3, o2, i3, h22, c2);
          }
        }
        s2.viewport.set([0, 0, t2.width, t2.height]), t2.resetStencilClippingMasks();
      }, raster: function(t2, i2, o2, r2, s2, n2) {
        if ("translucent" !== t2.renderPass)
          return;
        if (0 === o2.paint.get("raster-opacity"))
          return;
        const a2 = t2.context, l2 = a2.gl, c2 = i2.getSource(), h22 = function(t3, i3, o3) {
          const r3 = t3.paint.get("raster-color"), s3 = [], n3 = t3.paint.get("raster-resampling"), a3 = t3.paint.get("raster-color-mix"), l3 = t3.paint.get("raster-color-range"), c3 = [a3[0], a3[1], a3[2], 0], h3 = a3[3], _3 = "nearest" === n3 ? o3.NEAREST : o3.LINEAR;
          if (r3 && s3.push("RASTER_COLOR"), r3) {
            i3.activeTexture.set(o3.TEXTURE2);
            let r4 = t3.colorRampTexture;
            r4 || (r4 = t3.colorRampTexture = new e.a9(i3, t3.colorRamp, o3.RGBA)), r4.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
          }
          return { mix: c3, range: l3, offset: h3, defines: s3, resampling: _3 };
        }(o2, a2, l2), _2 = h22.defines, d2 = "globe" === t2.transform.projection.name;
        let u2 = false;
        if (c2 instanceof e.aK && !r2.length) {
          if (!d2)
            return;
          if (c2.onNorthPole)
            u2 = true, _2.push("GLOBE_POLES");
          else {
            if (!c2.onSouthPole)
              return;
            u2 = true, _2.push("GLOBE_POLES");
          }
        }
        const p2 = o2.paint.get("raster-emissive-strength"), m2 = t2.colorModeForDrapableLayerRenderPass(p2), f2 = t2.terrain && t2.terrain.renderingToTexture, g2 = c2 instanceof e.aK && 0 !== o2.paint.get("raster-elevation"), v2 = !t2.options.moving, x2 = "nearest" === o2.paint.get("raster-resampling") ? l2.NEAREST : l2.LINEAR;
        if (u2) {
          const r3 = i2.getSource();
          if (!(r3 instanceof e.aK))
            return;
          const s3 = r3.texture;
          if (!s3)
            return;
          const n3 = t2.globeSharedBuffers;
          if (!n3)
            return;
          const c3 = new e.b4(l2.LEQUAL, e.b4.ReadWrite, t2.depthRangeFor3D), _3 = Float32Array.from(t2.transform.expandedFarZProjMatrix);
          let d3 = e.bj(0, 0, t2.transform);
          const u3 = Float32Array.from(e.bh(e.bi(new e.t(0, 0, 0)))), f3 = { opacity: 1, mix: 0 };
          t2.terrain && t2.terrain.prepareDrawTile(), a2.activeTexture.set(l2.TEXTURE0), s3.bind(x2, l2.CLAMP_TO_EDGE), a2.activeTexture.set(l2.TEXTURE1), s3.bind(x2, l2.CLAMP_TO_EDGE), s3.useMipmap && a2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && l2.texParameterf(l2.TEXTURE_2D, a2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a2.extTextureFilterAnisotropicMax);
          const [g3, v3, y3, b3] = n3.getPoleBuffers(0, true);
          let w3;
          r3.onNorthPole ? (w3 = g3, t2.renderDefaultNorthPole = false) : (d3 = e.m.scale(e.m.create(), d3, [1, -1, 1]), w3 = v3, t2.renderDefaultSouthPole = false);
          const T3 = ((e22, t3, i3, o3, r4, s4, n4, a3, l3, c4, h3, _4) => to2(e22, t3, i3, new Float32Array(16), new Float32Array(9), [0, 0], 0, [0, 0], [0, 0, 0, 0], 1, o3, r4, [0, 0], n4, 2, l3, c4, h3, 1, 0, _4))(_3, u3, d3, f3, o2, 0, o2.paint.get("raster-elevation"), 0, h22.mix, h22.offset, h22.range, p2), E2 = t2.getOrCreateProgram("raster", { defines: h22.defines });
          return t2.uploadCommonUniforms(a2, E2, null), void E2.draw(t2, l2.TRIANGLES, c3, e.b6.disabled, m2, e.b5.disabled, T3, o2.id, w3, y3, b3);
        }
        if (!r2.length)
          return;
        const [y2, b2] = c2 instanceof e.aK || f2 ? [{}, r2] : t2.stencilConfigForOverlap(r2), w2 = b2[b2.length - 1].overscaledZ, T2 = g2 && d2;
        T2 && h22.defines.push("PROJECTION_GLOBE_VIEW"), g2 && h22.defines.push("RENDER_CUTOFF");
        for (const r3 of b2) {
          const s3 = r3.toUnwrapped(), _3 = i2.getTile(r3);
          if (f2 && (!_3 || !_3.hasData()))
            continue;
          if (!_3.texture)
            continue;
          let u3, b3;
          f2 ? (u3 = e.b4.disabled, b3 = r3.projMatrix) : g2 ? (u3 = new e.b4(l2.LEQUAL, e.b4.ReadWrite, t2.depthRangeFor3D), b3 = d2 ? Float32Array.from(t2.transform.expandedFarZProjMatrix) : t2.transform.calculateProjMatrix(s3, v2)) : (u3 = t2.depthModeForSublayer(r3.overscaledZ - w2, 1 === o2.paint.get("raster-opacity") ? e.b4.ReadWrite : e.b4.ReadOnly, l2.LESS), b3 = t2.transform.calculateProjMatrix(s3, v2));
          const E2 = t2.terrain && f2 ? t2.terrain.stencilModeForRTTOverlap(r3) : y2[r3.overscaledZ], C2 = n2 ? 0 : o2.paint.get("raster-fade-duration");
          _3.registerFadeDuration(C2);
          const I2 = i2.findLoadedParent(r3, 0), S2 = Ri(_3, I2, i2, t2.transform, C2);
          let M2, L2;
          t2.terrain && t2.terrain.prepareDrawTile(), a2.activeTexture.set(l2.TEXTURE0), _3.texture && _3.texture.bind(x2, l2.CLAMP_TO_EDGE), a2.activeTexture.set(l2.TEXTURE1), I2 ? (I2.texture && I2.texture.bind(x2, l2.CLAMP_TO_EDGE), M2 = Math.pow(2, I2.tileID.overscaledZ - _3.tileID.overscaledZ), L2 = [_3.tileID.canonical.x * M2 % 1, _3.tileID.canonical.y * M2 % 1]) : _3.texture && _3.texture.bind(x2, l2.CLAMP_TO_EDGE), _3.texture && _3.texture.useMipmap && a2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && l2.texParameterf(l2.TEXTURE_2D, a2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a2.extTextureFilterAnisotropicMax);
          const P2 = t2.transform;
          let D2;
          const A2 = g2 ? Ro(P2) : [0, 0, 0, 0];
          let R2, z2, O2, F2, B2;
          T2 && c2 instanceof e.aK && c2.coordinates.length > 3 ? (R2 = Float32Array.from(e.bh(e.bi(new e.t(0, 0, 0)))), z2 = Float32Array.from(P2.globeMatrix), O2 = Float32Array.from(e.bc(P2)), F2 = [e.E(P2.center.lng), e.H(P2.center.lat)], D2 = c2.elevatedGlobePerspectiveTransform, B2 = c2.elevatedGlobeGridMatrix || new Float32Array(9)) : (D2 = c2 instanceof e.aK ? c2.perspectiveTransform : [0, 0], R2 = new Float32Array(16), z2 = new Float32Array(9), O2 = new Float32Array(16), F2 = [0, 0], B2 = new Float32Array(9));
          const k2 = to2(b3, R2, z2, O2, B2, L2 || [0, 0], e.ao(t2.transform.zoom), F2, A2, M2 || 1, S2, o2, D2, g2 ? o2.paint.get("raster-elevation") : 0, 2, h22.mix, h22.offset, h22.range, 1, 0, p2), N2 = t2.isTileAffectedByFog(r3), U2 = t2.getOrCreateProgram("raster", { defines: h22.defines, overrideFog: N2 });
          if (t2.uploadCommonUniforms(a2, U2, s3), c2 instanceof e.aK) {
            const i3 = c2.elevatedGlobeVertexBuffer, r4 = c2.elevatedGlobeIndexBuffer;
            if (f2 || !d2)
              c2.boundsBuffer && c2.boundsSegments && U2.draw(t2, l2.TRIANGLES, u3, e.b6.disabled, m2, e.b5.disabled, k2, o2.id, c2.boundsBuffer, t2.quadTriangleIndexBuffer, c2.boundsSegments);
            else if (i3 && r4) {
              const s4 = P2.zoom <= e.Z ? c2.elevatedGlobeSegments : c2.getSegmentsForLongitude(P2.center.lng);
              s4 && (U2.draw(t2, l2.TRIANGLES, u3, e.b6.disabled, m2, e.b5.backCW, k2, o2.id, i3, r4, s4), U2.draw(t2, l2.TRIANGLES, u3, e.b6.disabled, m2, e.b5.frontCW, k2, o2.id, i3, r4, s4));
            }
          } else {
            const { tileBoundsBuffer: i3, tileBoundsIndexBuffer: r4, tileBoundsSegments: s4 } = t2.getTileBoundsBuffers(_3);
            U2.draw(t2, l2.TRIANGLES, u3, E2, m2, e.b5.disabled, k2, o2.id, i3, r4, s4);
          }
        }
        t2.resetStencilClippingMasks();
      }, background: function(t2, i2, o2, r2) {
        const s2 = o2.paint.get("background-color"), n2 = o2.paint.get("background-opacity"), a2 = o2.paint.get("background-emissive-strength");
        if (0 === n2)
          return;
        const l2 = t2.context, c2 = l2.gl, h22 = t2.transform, _2 = h22.tileSize, d2 = o2.paint.get("background-pattern");
        if (t2.isPatternMissing(d2, o2.scope))
          return;
        const u2 = !d2 && 1 === s2.a && 1 === n2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t2.renderPass !== u2)
          return;
        const p2 = e.b6.disabled, m2 = t2.depthModeForSublayer(0, "opaque" === u2 ? e.b4.ReadWrite : e.b4.ReadOnly), f2 = t2.colorModeForDrapableLayerRenderPass(a2), g2 = d2 ? "backgroundPattern" : "background";
        let v2, x2 = r2;
        x2 || (v2 = t2.getBackgroundTiles(), x2 = Object.values(v2).map((e22) => e22.tileID)), d2 && (l2.activeTexture.set(c2.TEXTURE0), t2.imageManager.bind(t2.context, o2.scope));
        for (const u3 of x2) {
          const x3 = t2.isTileAffectedByFog(u3), y2 = t2.getOrCreateProgram(g2, { overrideFog: x3 }), b2 = u3.toUnwrapped(), w2 = r2 ? u3.projMatrix : t2.transform.calculateProjMatrix(b2);
          t2.prepareDrawTile();
          const T2 = i2 ? i2.getTile(u3) : v2 ? v2[u3.key] : new e.bt(u3, _2, h22.zoom, t2), E2 = d2 ? ho(w2, a2, n2, t2, d2, o2.scope, { tileID: u3, tileSize: _2 }) : co(w2, a2, n2, s2);
          t2.uploadCommonUniforms(l2, y2, b2);
          const { tileBoundsBuffer: C2, tileBoundsIndexBuffer: I2, tileBoundsSegments: S2 } = t2.getTileBoundsBuffers(T2);
          y2.draw(t2, c2.TRIANGLES, m2, p2, f2, e.b5.disabled, E2, o2.id, C2, I2, S2);
        }
      }, sky: function(t2, i2, o2) {
        const r2 = t2._atmosphere ? e.ao(t2.transform.zoom) : 1, s2 = o2.paint.get("sky-opacity") * r2;
        if (0 === s2)
          return;
        const n2 = t2.context, a2 = o2.paint.get("sky-type"), l2 = new e.b4(n2.gl.LEQUAL, e.b4.ReadOnly, [0, 1]), c2 = t2.frameCounter / 1e3 % 1;
        "atmosphere" === a2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r3) {
          const s3 = t3.context, n3 = s3.gl;
          let a3 = i3.skyboxFbo;
          if (!a3) {
            a3 = i3.skyboxFbo = s3.createFramebuffer(32, 32, true, null), i3.skyboxGeometry = new Ho(s3), i3.skyboxTexture = s3.gl.createTexture(), n3.bindTexture(n3.TEXTURE_CUBE_MAP, i3.skyboxTexture), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_S, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_T, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MIN_FILTER, n3.LINEAR), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MAG_FILTER, n3.LINEAR);
            for (let e22 = 0; e22 < 6; ++e22)
              n3.texImage2D(n3.TEXTURE_CUBE_MAP_POSITIVE_X + e22, 0, n3.RGBA, 32, 32, 0, n3.RGBA, n3.UNSIGNED_BYTE, null);
          }
          s3.bindFramebuffer.set(a3.framebuffer), s3.viewport.set([0, 0, 32, 32]);
          const l3 = i3.getCenter(t3, true), c3 = t3.getOrCreateProgram("skyboxCapture"), h22 = new Float64Array(16);
          e.m.identity(h22), e.m.rotateY(h22, h22, 0.5 * -Math.PI), qo(t3, i3, c3, h22, l3, 0), e.m.identity(h22), e.m.rotateY(h22, h22, 0.5 * Math.PI), qo(t3, i3, c3, h22, l3, 1), e.m.identity(h22), e.m.rotateX(h22, h22, 0.5 * -Math.PI), qo(t3, i3, c3, h22, l3, 2), e.m.identity(h22), e.m.rotateX(h22, h22, 0.5 * Math.PI), qo(t3, i3, c3, h22, l3, 3), e.m.identity(h22), qo(t3, i3, c3, h22, l3, 4), e.m.identity(h22), e.m.rotateY(h22, h22, Math.PI), qo(t3, i3, c3, h22, l3, 5), s3.viewport.set([0, 0, t3.width, t3.height]);
        }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(t3, i3, o3, r3, s3) {
          const n3 = t3.context, a3 = n3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skybox");
          n3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
          const h22 = /* @__PURE__ */ ((e22, t4, i4, o4, r4) => ({ u_matrix: e22, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), 0, r3, s3);
          t3.uploadCommonUniforms(n3, c3), c3.draw(t3, a3.TRIANGLES, o3, e.b6.disabled, t3.colorModeForRenderPass(), e.b5.backCW, h22, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t2, o2, l2, s2, c2) : "gradient" === a2 && "sky" === t2.renderPass && function(t3, i3, o3, r3, s3) {
          const n3 = t3.context, a3 = n3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skyboxGradient");
          i3.skyboxGeometry || (i3.skyboxGeometry = new Ho(n3)), n3.activeTexture.set(a3.TEXTURE0);
          let h22 = i3.colorRampTexture;
          h22 || (h22 = i3.colorRampTexture = new e.a9(n3, i3.colorRamp, a3.RGBA)), h22.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
          const _2 = ((t4, i4, o4, r4, s4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.d(o4), u_opacity: r4, u_temporal_offset: s4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r3, s3);
          t3.uploadCommonUniforms(n3, c3), c3.draw(t3, a3.TRIANGLES, o3, e.b6.disabled, t3.colorModeForRenderPass(), e.b5.backCW, _2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t2, o2, l2, s2, c2);
      }, debug: function(t2, i2, o2, r2, s2) {
        for (let n2 = 0; n2 < o2.length; n2++)
          if (s2) {
            const s3 = 1, a2 = 0.8, l2 = new e.C(r2.r * a2, r2.g * a2, r2.b * a2, 1);
            No(t2, i2, o2[n2], r2, -s3, -s3), No(t2, i2, o2[n2], r2, -s3, s3), No(t2, i2, o2[n2], r2, s3, s3), No(t2, i2, o2[n2], r2, s3, -s3), No(t2, i2, o2[n2], l2, 0, 0);
          } else
            No(t2, i2, o2[n2], r2, 0, 0);
      }, custom: function(t2, i2, o2, r2) {
        const s2 = t2.context, n2 = o2.implementation;
        if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isLayerDraped(i2)) {
          if ("offscreen" === t2.renderPass) {
            const i3 = n2.prerender;
            if (i3) {
              if (t2.setCustomLayerDefaults(), s2.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                const o3 = t2.transform.pointMerc;
                i3.call(n2, s2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.ao(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
              } else
                i3.call(n2, s2.gl, t2.transform.customLayerMatrix());
              s2.setDirty(), t2.setBaseState();
            }
          } else if ("translucent" === t2.renderPass) {
            if (t2.terrain && t2.terrain.renderingToTexture) {
              const i4 = n2.renderToTile;
              if (i4) {
                const o3 = r2[0].canonical, a2 = new e.M(o3.x + r2[0].wrap * (1 << o3.z), o3.y, o3.z);
                s2.setDepthMode(e.b4.disabled), s2.setStencilMode(e.b6.disabled), s2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), i4.call(n2, s2.gl, a2), s2.setDirty(), t2.setBaseState();
              }
              return;
            }
            t2.setCustomLayerDefaults(), s2.setColorMode(t2.colorModeForRenderPass()), s2.setStencilMode(e.b6.disabled);
            const i3 = "3d" === n2.renderingMode ? new e.b4(t2.context.gl.LEQUAL, e.b4.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, e.b4.ReadOnly);
            if (s2.setDepthMode(i3), "globe" === t2.transform.projection.name) {
              const i4 = t2.transform.pointMerc;
              n2.render(s2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.ao(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
            } else
              n2.render(s2.gl, t2.transform.customLayerMatrix());
            s2.setDirty(), t2.setBaseState(), s2.bindFramebuffer.set(null);
          }
        } else
          e.X("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }, model: function(t2, i2, o2, r2) {
        if ("opaque" === t2.renderPass)
          return;
        const s2 = o2.paint.get("model-opacity");
        if (0 === s2)
          return;
        const n2 = o2.paint.get("model-cast-shadows");
        if ("shadow" === t2.renderPass) {
          if (!n2)
            return;
          if (t2.terrain && s2 < 0.65 && o2._transitionablePaint._values["model-opacity"].value.expression instanceof e.am)
            return;
        }
        const a2 = t2.shadowRenderer, l2 = o2.paint.get("model-receive-shadows");
        a2 && (a2.useNormalOffset = true, l2 || (a2.enabled = false));
        const c2 = () => {
          a2 && (a2.useNormalOffset = true, l2 || (a2.enabled = true));
        }, h22 = i2.getSource();
        if ("light-beam" === t2.renderPass && "batched-model" !== h22.type)
          return;
        if ("vector" === h22.type || "geojson" === h22.type)
          return function(t3, i3, o3, r3) {
            const s3 = t3.transform;
            if ("mercator" !== s3.projection.name)
              return void e.X(`Drawing 3D models for ${s3.projection.name} projection is not yet implemented`);
            const n3 = s3.getFreeCameraOptions().position;
            if (!t3.modelManager)
              return;
            const a3 = t3.modelManager, l3 = t3.shadowRenderer;
            if (!o3._unevaluatedLayout._values.hasOwnProperty("model-id"))
              return;
            const c3 = o3._unevaluatedLayout._values["model-id"], h3 = { ...o3.layout.get("model-id").parameters };
            for (const _3 of r3) {
              const r4 = i3.getTile(_3).getBucket(o3);
              if (!r4 || r4.projection.name !== s3.projection.name)
                continue;
              const d3 = nr(_3, s3);
              h3.zoom = d3;
              const u3 = c3.possiblyEvaluate(h3);
              if (rr(t3, r4, _3), sr.shadowUniformsInitialized = false, sr.useSingleShadowCascade = !!l3 && 0 === l3.getMaxCascadeForTile(_3.toUnwrapped()), "shadow" === t3.renderPass && l3) {
                if (1 === t3.currentShadowCascade && r4.isInsideFirstShadowMapFrustum)
                  continue;
                const i4 = s3.calculatePosMatrix(_3.toUnwrapped(), s3.worldSize);
                if (sr.tileMatrix.set(i4), sr.shadowTileMatrix = Float32Array.from(l3.calculateShadowPassMatrixFromMatrix(i4)), sr.aabb.min.fill(0), sr.aabb.max[0] = sr.aabb.max[1] = e.J, sr.aabb.max[2] = 0, cr(r4, sr, t3, o3.scope))
                  continue;
              }
              const p3 = 1 << _3.canonical.z, m3 = [((n3.x - _3.wrap) * p3 - _3.canonical.x) * e.J, (n3.y * p3 - _3.canonical.y) * e.J, n3.z * p3 * e.J];
              for (let e22 in r4.instancesPerModel) {
                const i4 = r4.instancesPerModel[e22];
                i4.features.length > 0 && (e22 = u3.evaluate(i4.features[0].feature, {}));
                const s4 = a3.getModel(e22, o3.scope);
                if (s4 && s4.uploaded)
                  for (const e3 of s4.nodes)
                    ar(t3, o3, e3, i4, m3, _3, sr);
              }
            }
          }(t2, i2, o2, r2), void c2();
        if (!h22.loaded())
          return;
        if ("batched-model" === h22.type)
          return function(t3, i3, o3, r3) {
            const s3 = t3.context, n3 = t3.transform, a3 = t3.style.fog, l3 = t3.shadowRenderer;
            if ("mercator" !== n3.projection.name)
              return void e.X(`Drawing 3D landmark models for ${n3.projection.name} projection is not yet implemented`);
            const c3 = t3.transform.getFreeCameraOptions().position, h3 = e.v.scale([], [c3.x, c3.y, c3.z], t3.transform.worldSize);
            e.v.negate(h3, h3);
            const _3 = e.m.identity([]), d3 = e.c4(n3.center.lat, n3.zoom), u3 = e.m.fromScaling([], [1, 1, 1 / d3]);
            e.m.translate(_3, _3, h3);
            const p3 = o3.paint.get("model-opacity"), m3 = new e.b4(s3.gl.LEQUAL, e.b4.ReadWrite, t3.depthRangeFor3D), f3 = new e.b4(s3.gl.LEQUAL, e.b4.ReadOnly, t3.depthRangeFor3D), g3 = function(c4, h4) {
              for (const d4 of r3) {
                const r4 = i3.getTile(d4).getBucket(o3);
                if (!r4 || !r4.uploaded)
                  continue;
                let g4 = false;
                l3 && (g4 = 0 === l3.getMaxCascadeForTile(d4.toUnwrapped()));
                const v2 = n3.calculatePosMatrix(d4.toUnwrapped(), n3.worldSize), x2 = r4.modelTraits;
                for (const i4 of r4.getNodesInfo()) {
                  if (i4.hiddenByReplacement)
                    continue;
                  if (!i4.node.meshes)
                    continue;
                  const r5 = i4.node, y2 = "light-beam" === t3.renderPass, b2 = [...v2], w2 = i4.evaluatedScale;
                  let T2 = 0;
                  t3.terrain && r5.elevation && (T2 = r5.elevation * t3.terrain.exaggeration()), e.m.translate(b2, b2, [(r5.anchor ? r5.anchor[0] : 0) * (w2[0] - 1), (r5.anchor ? r5.anchor[1] : 0) * (w2[1] - 1), T2]), w2 !== e.c6 && e.m.scale(b2, b2, w2), e.m.multiply(b2, b2, r5.matrix);
                  const E2 = e.m.multiply([], u3, b2);
                  e.m.multiply(E2, _3, E2);
                  const C2 = e.m.invert([], E2);
                  e.m.transpose(C2, C2), e.m.scale(C2, C2, lr);
                  const I2 = e.m.multiply([], n3.expandedFarZProjMatrix, b2), S2 = x2 & e.c8.HasMapboxMeshFeatures, M2 = S2 ? 0 : i4.evaluatedRMEA[0][2];
                  for (let _4 = 0; _4 < r5.meshes.length; ++_4) {
                    const u4 = r5.meshes[_4], v3 = _4 === r5.lightMeshIndex;
                    if (v3) {
                      if (!y2 && !t3.terrain && t3.shadowRenderer) {
                        t3.currentLayer < t3.firstLightBeamLayer && (t3.firstLightBeamLayer = t3.currentLayer);
                        continue;
                      }
                    } else if (y2)
                      continue;
                    const x3 = { defines: [] }, w3 = [];
                    er(x3.defines, w3, u4, t3), S2 || x3.defines.push("DIFFUSE_SHADED"), g4 && x3.defines.push("SHADOWS_SINGLE_CASCADE");
                    const T3 = "shadow" === t3.renderPass;
                    if (T3) {
                      or(u4, b2, t3, o3);
                      continue;
                    }
                    let L2 = null;
                    if (a3) {
                      const e22 = Qo(b2, t3.transform);
                      if (L2 = new Float32Array(e22), "globe" !== n3.projection.name) {
                        const t4 = u4.aabb.min, i5 = u4.aabb.max, [o4, r6] = a3.getOpacityForBounds(e22, t4[0], t4[1], i5[0], i5[1]);
                        x3.overrideFog = o4 >= Ue || r6 >= Ue;
                      }
                    }
                    const P2 = t3.getOrCreateProgram("model", x3);
                    !T3 && l3 && (l3.useNormalOffset = !!u4.normalBuffer, l3.setupShadowsFromMatrix(b2, P2, l3.useNormalOffset)), t3.uploadCommonUniforms(s3, P2, d4.toUnwrapped(), L2);
                    const D2 = u4.material, A2 = D2.pbrMetallicRoughness;
                    A2.metallicFactor = 0.9, A2.roughnessFactor = 0.5;
                    const R2 = uo(new Float32Array(I2), new Float32Array(E2), new Float32Array(C2), t3, p3, A2.baseColorFactor, D2.emissiveFactor, A2.metallicFactor, A2.roughnessFactor, D2, M2, o3);
                    P2.draw(t3, s3.gl.TRIANGLES, h4 && !v3 ? m3 : f3, e.b6.disabled, c4 ? v3 || p3 < 1 || i4.hasTranslucentParts ? e.a.alphaBlended : e.a.unblended : e.a.disabled, e.b5.backCCW, R2, o3.id, u4.vertexBuffer, u4.indexBuffer, u4.segments, o3.paint, t3.transform.zoom, void 0, w3);
                  }
                }
              }
            };
            (function(e22, t4, i4, o4) {
              const r4 = e22.terrain ? e22.terrain.exaggeration() : 0, s4 = e22.transform.zoom;
              for (const n4 of o4) {
                const o5 = t4.getTile(n4).getBucket(i4);
                o5 && (e22.conflationActive && o5.updateReplacement(n4, e22.replacementSource), o5.evaluateScale(e22, i4), e22.terrain && r4 > 0 && o5.elevationUpdate(e22.terrain, r4, n4, i4.source), o5.needsReEvaluation(e22, s4, i4) && o5.evaluate(i4));
              }
            })(t3, i3, o3, r3), 1 === p3 ? g3(true, true) : (g3(false, true), g3(true, false));
          }(t2, i2, o2, r2), void c2();
        const _2 = h22.getModels(), d2 = [], u2 = t2.transform.getFreeCameraOptions().position, p2 = e.v.scale([], [u2.x, u2.y, u2.z], t2.transform.worldSize);
        e.v.negate(p2, p2);
        const m2 = [], f2 = [];
        let g2 = 0;
        for (const i3 of _2) {
          const r3 = o2.paint.get("model-rotation").constantOr(null), s3 = o2.paint.get("model-scale").constantOr(null), n3 = o2.paint.get("model-translation").constantOr(null);
          i3.computeModelMatrix(t2, r3, s3, n3, true, true, false);
          const a3 = e.m.identity([]), l3 = e.c4(i3.position.lat, t2.transform.zoom), c3 = e.m.fromScaling([], [1, 1, 1 / l3]);
          e.m.translate(a3, a3, p2), d2.push({ zScaleMatrix: c3, negCameraPosMatrix: a3 });
          for (const e22 of i3.nodes)
            ir(t2.transform, e22, i3.matrix, t2.transform.expandedFarZProjMatrix, g2, m2, f2);
          g2++;
        }
        if (m2.sort((e22, t3) => t3.depth - e22.depth), "shadow" !== t2.renderPass) {
          if (1 === s2)
            for (const i3 of f2)
              tr(i3, t2, o2, d2[i3.modelIndex], e.b6.disabled, t2.colorModeForRenderPass());
          else {
            for (const i3 of f2)
              tr(i3, t2, o2, d2[i3.modelIndex], e.b6.disabled, e.a.disabled);
            for (const e22 of f2)
              tr(e22, t2, o2, d2[e22.modelIndex], t2.stencilModeFor3D(), t2.colorModeForRenderPass());
            t2.resetStencilClippingMasks();
          }
          for (const i3 of m2)
            tr(i3, t2, o2, d2[i3.modelIndex], e.b6.disabled, t2.colorModeForRenderPass());
          c2();
        } else {
          for (const e22 of f2)
            or(e22.mesh, e22.nodeModelMatrix, t2, o2);
          for (const e22 of m2)
            or(e22.mesh, e22.nodeModelMatrix, t2, o2);
          c2();
        }
      } }, pr = { modelUpload: function(e22, t2, i2) {
        const o2 = t2.getSource();
        if (!o2.loaded())
          return;
        if ("vector" === o2.type || "geojson" === o2.type)
          return void (e22.modelManager && e22.modelManager.upload(e22, i2));
        if ("batched-model" === o2.type)
          return;
        const r2 = o2.getModels();
        for (const t3 of r2)
          t3.upload(e22.context);
      } };
      class mr {
        constructor(t2, i2, o2, r2) {
          this.context = new se(t2, i2), this.transform = o2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r2, this._debugParams = { showTerrainProxyTiles: false }, r2.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
            this.style.map.triggerRepaint();
          }), this.setup(), this.numSublayers = e.bq.maxUnderzooming + e.bq.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e.ca(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new xr(this), this._wireframeDebugCache = new _r(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true;
        }
        updateTerrain(e22, t2) {
          const i2 = !!e22 && !!e22.terrain && this.transform.projection.supportsTerrain;
          if (!(i2 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new Bi(this, e22));
          const o2 = this._terrain;
          this.transform.elevation = i2 ? o2 : null, o2.update(e22, this.transform, t2), this.transform.elevation && !o2.enabled && (this.transform.elevation = null);
        }
        _updateFog(e22) {
          const t2 = e22.fog;
          if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
          if (i2 > o2)
            return void (this.transform.fogCullDistSq = null);
          const r2 = i2 + 0.78 * (o2 - i2);
          this.transform.fogCullDistSq = r2 * r2;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(t2, i2) {
          if (this.width = t2 * e.a4.devicePixelRatio, this.height = i2 * e.a4.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e22 of this.style.order)
              this.style._mergedLayers[e22].resize();
        }
        setup() {
          const t2 = this.context, i2 = new e.bo();
          i2.emplaceBack(0, 0), i2.emplaceBack(e.J, 0), i2.emplaceBack(0, e.J), i2.emplaceBack(e.J, e.J), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.bl.members), this.tileExtentSegments = e.bm.simpleSegment(0, 0, 4, 2);
          const o2 = new e.bo();
          o2.emplaceBack(0, 0), o2.emplaceBack(e.J, 0), o2.emplaceBack(0, e.J), o2.emplaceBack(e.J, e.J), this.debugBuffer = t2.createVertexBuffer(o2, e.bl.members), this.debugSegments = e.bm.simpleSegment(0, 0, 4, 5);
          const r2 = new e.bo();
          r2.emplaceBack(-1, -1), r2.emplaceBack(1, -1), r2.emplaceBack(-1, 1), r2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(r2, e.bl.members), this.viewportSegments = e.bm.simpleSegment(0, 0, 4, 2);
          const s2 = new e.cb();
          s2.emplaceBack(0, 0, 0, 0), s2.emplaceBack(e.J, 0, e.J, 0), s2.emplaceBack(0, e.J, 0, e.J), s2.emplaceBack(e.J, e.J, e.J, e.J), this.mercatorBoundsBuffer = t2.createVertexBuffer(s2, e.cc.members), this.mercatorBoundsSegments = e.bm.simpleSegment(0, 0, 4, 2);
          const n2 = new e.bp();
          n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
          const a2 = new e.cd();
          for (const e22 of [0, 1, 3, 2, 0])
            a2.emplaceBack(e22);
          this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.a9(t2, new e.a5({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA), this.identityMat = e.m.create();
          const l2 = this.context.gl;
          this.stencilClearMode = new e.b6({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(e22) {
          return e22._makeTileBoundsBuffers(this.context, this.transform.projection), e22._tileBoundsBuffer ? { tileBoundsBuffer: e22._tileBoundsBuffer, tileBoundsIndexBuffer: e22._tileBoundsIndexBuffer, tileBoundsSegments: e22._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const t2 = this.context.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t2.TRIANGLES, e.b4.disabled, this.stencilClearMode, e.a.disabled, e.b5.disabled, Ai(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(t2, i2, o2) {
          if (!i2 || this.currentStencilSource === i2.id || !t2.isTileClipped() || !o2 || 0 === o2.length)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let e22 = false;
            for (const t3 of o2)
              if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                e22 = true;
                break;
              }
            if (!e22)
              return;
          }
          this.currentStencilSource = i2.id;
          const r2 = this.context, s2 = r2.gl;
          this.nextStencilID + o2.length > 256 && this.clearStencil(), r2.setColorMode(e.a.disabled), r2.setDepthMode(e.b4.disabled);
          const n2 = this.getOrCreateProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t3 of o2) {
            const o3 = i2.getTile(t3), r3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, { tileBoundsBuffer: a2, tileBoundsIndexBuffer: l2, tileBoundsSegments: c2 } = this.getTileBoundsBuffers(o3);
            n2.draw(this, s2.TRIANGLES, e.b4.disabled, new e.b6({ func: s2.ALWAYS, mask: 0 }, r3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), e.a.disabled, e.b5.disabled, Ai(t3.projMatrix), "$clipping", a2, l2, c2);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t2 = this.nextStencilID++, i2 = this.context.gl;
          return new e.b6({ func: i2.NOTEQUAL, mask: 255 }, t2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilModeForClipping(t2) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(t2);
          const i2 = this.context.gl;
          return new e.b6({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilConfigForOverlap(t2) {
          const i2 = this.context.gl, o2 = t2.sort((e22, t3) => t3.overscaledZ - e22.overscaledZ), r2 = o2[o2.length - 1].overscaledZ, s2 = o2[0].overscaledZ - r2 + 1;
          if (s2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + s2 > 256 && this.clearStencil();
            const t3 = {};
            for (let o3 = 0; o3 < s2; o3++)
              t3[o3 + r2] = new e.b6({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            return this.nextStencilID += s2, [t3, o2];
          }
          return [{ [r2]: e.b6.disabled }, o2];
        }
        colorModeForRenderPass() {
          const t2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new e.a([t2.CONSTANT_COLOR, t2.ONE, t2.CONSTANT_COLOR, t2.ONE], new e.C(i2, i2, i2, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? e.a.unblended : e.a.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(t2) {
          const i2 = this.context.gl;
          return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new e.a([i2.ONE, i2.ONE_MINUS_SRC_ALPHA, i2.CONSTANT_ALPHA, i2.ONE_MINUS_SRC_ALPHA], new e.C(0, 0, 0, void 0 === t2 ? 0 : t2), [true, true, true, true]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(t2, i2, o2, r2 = false) {
          if (!this.opaquePassEnabledForLayer() && !r2)
            return e.b4.disabled;
          const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
          return new e.b4(o2 || this.context.gl.LEQUAL, i2, [s2, s2]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t2, i2) {
          this._wireframeDebugCache.update(this.frameCounter), this.style = t2, this.options = i2;
          const o2 = this.style._mergedLayers, r2 = this.style.order, s2 = r2.map((e22) => o2[e22]), n2 = this.style._mergedSourceCaches;
          this.imageManager = t2.imageManager, this.modelManager = t2.modelManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.a4.now()), this.imageManager.beginFrame();
          let a2 = 0, l2 = false;
          for (const e22 in n2) {
            const t3 = n2[e22];
            t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++a2);
          }
          const c2 = {}, h22 = {}, _2 = {}, d2 = {}, u2 = {};
          for (const e22 in n2) {
            const t3 = n2[e22];
            c2[e22] = t3.getVisibleCoordinates(), h22[e22] = c2[e22].slice().reverse(), _2[e22] = t3.getVisibleCoordinates(true).reverse(), d2[e22] = t3.getShadowCasterCoordinates(), u2[e22] = t3.sortCoordinatesByDistance(c2[e22]);
          }
          const p2 = (e22) => {
            const t3 = this.style.getLayerSourceCache(e22);
            return t3 && t3.used ? t3.getSource() : null;
          };
          if (a2) {
            const e22 = [];
            for (const t3 of s2)
              this.layerUsedInConflation(t3, p2(t3)) && e22.push(t3);
            if (e22 && e22.length > 1) {
              const t3 = [];
              for (const i3 of e22) {
                const e3 = this.style.getLayerSourceCache(i3);
                e3 && e3.used && e3.getSource().usedInConflation && t3.push({ layer: i3.fqid, cache: e3 });
              }
              this.replacementSource.setSources(t3), l2 = true;
            }
          }
          l2 || this.replacementSource.clear(), this.conflationActive = l2, this.minCutoffZoom = 0, this.longestCutoffRange = 0;
          for (const e22 of s2) {
            const t3 = e22.cutoffRange();
            if (this.longestCutoffRange = Math.max(t3, this.longestCutoffRange), t3 > 0) {
              const t4 = p2(e22);
              t4 && (this.minCutoffZoom = Math.max(t4.minzoom, this.minCutoffZoom)), e22.minzoom && (this.minCutoffZoom = Math.max(e22.minzoom, this.minCutoffZoom));
            }
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e22 = 0; e22 < s2.length; e22++)
            if (s2[e22].is3D()) {
              this.opaquePassCutoff = e22;
              break;
            }
          const m2 = this.style && this.style.fog;
          m2 ? (this._fogVisible = 0 !== m2.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = m2.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(_2), this.opaquePassCutoff = 0);
          const f2 = this._shadowRenderer;
          if (f2) {
            f2.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const e22 in n2)
              for (const t3 of c2[e22]) {
                let e3 = { min: 0, max: 0 };
                this.terrain && (e3 = this.terrain.getMinMaxForTile(t3) || e3), f2.addShadowReceiver(t3.toUnwrapped(), e3.min, e3.max);
              }
          }
          "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.ce(this.context));
          for (const e22 of s2) {
            if (e22.isHidden(this.transform.zoom))
              continue;
            const i3 = t2.getLayerSourceCache(e22);
            this.uploadLayer(this, e22, i3);
          }
          if (this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Ko(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), !e.cf(this.context.gl))
            return;
          this.renderPass = "offscreen";
          for (const e22 of s2) {
            const i3 = t2.getLayerSourceCache(e22);
            if (!e22.hasOffscreenPass() || e22.isHidden(this.transform.zoom))
              continue;
            const o3 = i3 ? h22[i3.id] : void 0;
            ("custom" === e22.type || "raster" === e22.type || e22.isSky() || o3 && o3.length) && this.renderLayer(this, i3, e22, o3);
          }
          this.depthRangeFor3D = [0, 1 - (s2.length + 2) * this.numSublayers * this.depthEpsilon];
          const g2 = this.terrain;
          g2 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && !this.transform.isOrthographic && g2.drawDepth(), this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, d2)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const v2 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), x2 = (() => {
            if (i2.showOverdrawInspector)
              return e.C.black;
            if (this.style.fog && this.transform.projection.supportsFog && !v2) {
              const t3 = this.style.fog.properties.get("color").toArray01();
              return new e.C(...t3);
            }
            if (this.style.fog && this.transform.projection.supportsFog && v2) {
              const t3 = this.style.fog.properties.get("space-color").toArray01();
              return new e.C(...t3);
            }
            return e.C.transparent;
          })();
          if (this.context.clear({ color: x2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v2 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
            for (this.currentLayer = r2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e22 = s2[this.currentLayer], i3 = t2.getLayerSourceCache(e22);
              if (e22.isSky())
                continue;
              const o3 = i3 ? (e22.is3D() ? u2 : h22)[i3.id] : void 0;
              this._renderTileClippingMasks(e22, i3, o3), this.renderLayer(this, i3, e22, o3);
            }
          if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v2 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.ao(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible()))
            for (this.currentLayer = 0; this.currentLayer < r2.length; this.currentLayer++) {
              const e22 = s2[this.currentLayer], i3 = t2.getLayerSourceCache(e22);
              e22.isSky() && this.renderLayer(this, i3, e22, i3 ? h22[i3.id] : void 0);
            }
          this.renderPass = "translucent", this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
          let y2 = 0;
          for (f2 && (y2 = f2.getShadowCastingLayerCount()); this.currentLayer < r2.length; ) {
            const e22 = s2[this.currentLayer], i3 = t2.getLayerSourceCache(e22);
            if (e22.isSky()) {
              ++this.currentLayer;
              continue;
            }
            if (g2 && this.style.isLayerDraped(e22)) {
              if (e22.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = g2.renderBatch(this.currentLayer);
              continue;
            }
            let o3;
            if (i3 && (o3 = ("symbol" === e22.type ? _2 : e22.is3D() ? u2 : h22)[i3.id]), this._renderTileClippingMasks(e22, i3, i3 ? c2[i3.id] : void 0), this.renderLayer(this, i3, e22, o3), !g2 && f2 && y2 > 0 && e22.hasShadowPass() && 0 == --y2 && (f2.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
              const e3 = this.currentLayer;
              for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e3; this.currentLayer++) {
                const e4 = s2[this.currentLayer];
                if (!e4.hasLightBeamPass())
                  continue;
                const i4 = t2.getLayerSourceCache(e4);
                this.renderLayer(this, i4, e4, i4 ? h22[i4.id] : void 0);
              }
              this.currentLayer = e3, this.renderPass = "translucent";
            }
            ++this.currentLayer;
          }
          if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let i3 = null;
            s2.forEach((e22) => {
              const o3 = t2.getLayerSourceCache(e22);
              o3 && !e22.isHidden(this.transform.zoom) && o3.getVisibleCoordinates().length && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
            }), i3 && this.options.showTileBoundaries && ur.debug(this, i3, i3.getVisibleCoordinates(), e.C.red, false);
          }
          this.terrain && this._debugParams.showTerrainProxyTiles && ur.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.C(1, 0.8, 0.1, 1), true), this.options.showPadding && function(e22) {
            const t3 = e22.transform.padding;
            Uo(e22, e22.transform.height - (t3.top || 0), 3, zo), Uo(e22, t3.bottom || 0, 3, Oo), Go(e22, t3.left || 0, 3, Fo), Go(e22, e22.transform.width - (t3.right || 0), 3, Bo);
            const i3 = e22.transform.centerPoint;
            !function(e3, t4, i4, o3) {
              jo(e3, t4 - 1, i4 - 10, 2, 20, o3), jo(e3, t4 - 10, i4 - 1, 20, 2, o3);
            }(e22, i3.x, e22.transform.height - i3.y, ko);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), l2 || (this.conflationActive = false);
        }
        uploadLayer(e22, t2, i2) {
          this.gpuTimingStart(t2), (!e22.transform.projection.unsupportedLayers || !e22.transform.projection.unsupportedLayers.includes(t2.type) || e22.terrain && "custom" === t2.type) && pr[`${t2.type}Upload`] && pr[`${t2.type}Upload`](e22, i2, t2.scope), this.gpuTimingEnd();
        }
        renderLayer(e22, t2, i2, o2) {
          i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || "model" === i2.type || "raster" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), (!e22.transform.projection.unsupportedLayers || !e22.transform.projection.unsupportedLayers.includes(i2.type) || e22.terrain && "custom" === i2.type) && ur[i2.type](e22, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e22) {
          if (!this.options.gpuTiming)
            return;
          const t2 = this.context.extTimerQuery, i2 = this.context.gl;
          let o2 = this.gpuTimers[e22.id];
          o2 || (o2 = this.gpuTimers[e22.id] = { calls: 0, cpuTime: 0, query: i2.createQuery() }), o2.calls++, i2.beginQuery(t2.TIME_ELAPSED_EXT, o2.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const e22 = this.context.extTimerQuery, t2 = this.context.gl, i2 = t2.createQuery();
            this.deferredRenderGpuTimeQueries.push(i2), t2.beginQuery(e22.TIME_ELAPSED_EXT, i2);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e22 = this.gpuTimers;
          return this.gpuTimers = {}, e22;
        }
        collectDeferredRenderGpuQueries() {
          const e22 = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], e22;
        }
        queryGpuTimers(e22) {
          const t2 = {};
          for (const i2 in e22) {
            const o2 = e22[i2], r2 = this.context.extTimerQuery, s2 = r2.getQueryParameter(o2.query, this.context.gl.QUERY_RESULT) / 1e6;
            r2.deleteQueryEXT(o2.query), t2[i2] = s2;
          }
          return t2;
        }
        queryGpuTimeDeferredRender(e22) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const t2 = this.context.extTimerQuery, i2 = this.context.gl;
          let o2 = 0;
          for (const r2 of e22)
            o2 += t2.getQueryParameter(r2, i2.QUERY_RESULT) / 1e6, t2.deleteQueryEXT(r2);
          return o2;
        }
        translatePosMatrix(t2, i2, o2, r2, s2) {
          if (!o2[0] && !o2[1])
            return t2;
          const n2 = s2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
          if (n2) {
            const e22 = Math.sin(n2), t3 = Math.cos(n2);
            o2 = [o2[0] * t3 - o2[1] * e22, o2[0] * e22 + o2[1] * t3];
          }
          const a2 = [s2 ? o2[0] : e.ay(i2, o2[0], this.transform.zoom), s2 ? o2[1] : e.ay(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
          return e.m.translate(l2, t2, a2), l2;
        }
        saveTileTexture(e22) {
          const t2 = e22.size[0], i2 = this._tileTextures[t2];
          i2 ? i2.push(e22) : this._tileTextures[t2] = [e22];
        }
        getTileTexture(e22) {
          const t2 = this._tileTextures[e22];
          return t2 && t2.length > 0 ? t2.pop() : null;
        }
        isPatternMissing(e22, t2) {
          return null === e22 || void 0 !== e22 && !this.imageManager.getPattern(e22.toString(), t2);
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
        }
        linearFloatFilteringSupported() {
          return null != this.context.extTextureFloatLinear;
        }
        currentGlobalDefines(e22, t2, i2) {
          const o2 = void 0 === i2 ? this.terrain && this.terrain.renderingToTexture : i2, r2 = this.terrain && 0 === this.terrain.exaggeration(), s2 = [];
          return this.style && this.style.enable3dLights() && ("globeRaster" === e22 || "terrainRaster" === e22 ? (s2.push("LIGHTING_3D_MODE"), s2.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o2 || s2.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass ? this._shadowMapDebug || s2.push("DEPTH_TEXTURE") : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? s2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET") : s2.push("RENDER_SHADOWS", "DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s2.push("TERRAIN"), this.linearFloatFilteringSupported() && s2.push("TERRAIN_DEM_FLOAT_FORMAT"), r2 && s2.push("ZERO_EXAGGERATION")), "globe" === this.transform.projection.name && s2.push("GLOBE"), !this._fogVisible || o2 || void 0 !== t2 && !t2 || s2.push("FOG", "FOG_DITHERING"), o2 && s2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s2.push("OVERDRAW_INSPECTOR"), s2;
        }
        getOrCreateProgram(e22, t2) {
          this.cache = this.cache || {};
          const i2 = t2 && t2.defines || [], o2 = t2 && t2.config, r2 = this.currentGlobalDefines(e22, t2 && t2.overrideFog, t2 && t2.overrideRtt).concat(i2), s2 = Gi.cacheKey(mi[e22], e22, r2, o2);
          return this.cache[s2] || (this.cache[s2] = new Gi(this.context, e22, mi[e22], o2, fo[e22], r2)), this.cache[s2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e22 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e22.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.a9(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(t2, i2) {
          if (this.style.enable3dLights()) {
            const o2 = this.style.directionalLight, r2 = this.style.ambientLight;
            if (o2 && r2) {
              const s2 = ((t3, i3) => {
                const o3 = t3.properties.get("direction"), r3 = t3.properties.get("color").toArray01(), s3 = t3.properties.get("intensity"), n2 = i3.properties.get("color").toArray01(), a2 = i3.properties.get("intensity"), l2 = [o3.x, o3.y, o3.z], c2 = e.bv(n2, a2), h22 = e.bv(r3, s3);
                return { u_lighting_ambient_color: c2, u_lighting_directional_dir: l2, u_lighting_directional_color: h22, u_ground_radiance: ki(l2, h22, c2) };
              })(o2, r2);
              i2.setLightsUniformValues(t2, s2);
            }
          }
        }
        uploadCommonUniforms(t2, i2, o2, r2, s2) {
          if (this.uploadCommonLightUniforms(t2, i2), this.terrain && this.terrain.renderingToTexture)
            return;
          const n2 = this.style.fog;
          if (n2) {
            const s3 = n2.getOpacity(this.transform.pitch), a2 = ((t3, i3, o3, r3, s4, n3, a3, l2, c2, h22, _2, d2) => {
              const u2 = t3.transform, p2 = i3.properties.get("color").toArray01();
              p2[3] = r3;
              const m2 = t3.frameCounter / 1e3 % 1, [f2, g2] = i3.properties.get("vertical-range");
              return { u_fog_matrix: o3 ? u2.calculateFogTileMatrix(o3) : d2 || t3.identityMat, u_fog_range: i3.getFovAdjustedRange(u2._fov), u_fog_color: p2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(f2, g2), g2], u_fog_temporal_offset: m2, u_frustum_tl: s4, u_frustum_tr: n3, u_frustum_br: a3, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h22, u_viewport: _2, u_globe_transition: e.ao(u2.zoom), u_is_globe: +("globe" === u2.projection.name) };
            })(this, n2, o2, s3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.a4.devicePixelRatio, this.transform.height * e.a4.devicePixelRatio], r2);
            i2.setFogUniformValues(t2, a2);
          }
          s2 && i2.setCutoffUniformValues(t2, s2.uniformValues);
        }
        setTileLoadedFlag(e22) {
          this.tileLoaded = e22;
        }
        saveCanvasCopy() {
          const e22 = this.canvasCopy();
          e22 && (this.frameCopies.push(e22), this.tileLoaded = false);
        }
        canvasCopy() {
          const e22 = this.context.gl, t2 = e22.createTexture();
          return e22.bindTexture(e22.TEXTURE_2D, t2), e22.copyTexImage2D(e22.TEXTURE_2D, 0, e22.RGBA, 0, 0, e22.drawingBufferWidth, e22.drawingBufferHeight, 0), t2;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e22 = this.style && this.style.fog;
          return !!e22 && 0 !== e22.getOpacity(this.transform.pitch);
        }
        getBackgroundTiles() {
          const t2 = this._backgroundTiles, i2 = this._backgroundTiles = {}, o2 = this.transform.coveringTiles({ tileSize: 512 });
          for (const r2 of o2)
            i2[r2.key] = t2[r2.key] || new e.bt(r2, 512, this.transform.tileZoom, this);
          return i2;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        layerUsedInConflation(e22, t2) {
          return !(!e22.is3D() || e22.minzoom && e22.minzoom > this.transform.zoom || "building" !== e22.sourceLayer && (!t2 || "batched-model" !== t2.type));
        }
        isTileAffectedByFog(e22) {
          if (!this.style || !this.style.fog)
            return false;
          if ("globe" === this.transform.projection.name)
            return true;
          let t2 = this._cachedTileFogOpacities[e22.key];
          return t2 || (this._cachedTileFogOpacities[e22.key] = t2 = this.style.fog.getOpacityForTile(e22)), t2[0] >= Ue || t2[1] >= Ue;
        }
      }
      const fr = { cascadeCount: 2, shadowMapResolution: 2048 };
      class gr {
        constructor(e22, t2) {
          this.aabb = e22, this.lastCascade = t2;
        }
      }
      class vr {
        add(e22, t2) {
          const i2 = this.receivers[e22.key];
          void 0 !== i2 ? (i2.aabb.min[0] = Math.min(i2.aabb.min[0], t2.min[0]), i2.aabb.min[1] = Math.min(i2.aabb.min[1], t2.min[1]), i2.aabb.min[2] = Math.min(i2.aabb.min[2], t2.min[2]), i2.aabb.max[0] = Math.max(i2.aabb.max[0], t2.max[0]), i2.aabb.max[1] = Math.max(i2.aabb.max[1], t2.max[1]), i2.aabb.max[2] = Math.max(i2.aabb.max[2], t2.max[2])) : this.receivers[e22.key] = new gr(t2, null);
        }
        clear() {
          this.receivers = {};
        }
        get(e22) {
          return this.receivers[e22.key];
        }
        computeRequiredCascades(t2, i2, o2) {
          const r2 = e.c3.fromPoints(t2.points);
          let s2 = 0;
          for (const t3 in this.receivers) {
            const n2 = this.receivers[t3];
            if (!n2)
              continue;
            if (!r2.intersectsAabb(n2.aabb))
              continue;
            n2.aabb.min = r2.closestPoint(n2.aabb.min), n2.aabb.max = r2.closestPoint(n2.aabb.max);
            const a2 = n2.aabb.getCorners();
            for (let t4 = 0; t4 < o2.length; t4++) {
              let r3 = true;
              for (const s3 of a2) {
                const n3 = [s3[0] * i2, s3[1] * i2, s3[2]];
                if (e.v.transformMat4(n3, n3, o2[t4].matrix), n3[0] < -1 || n3[0] > 1 || n3[1] < -1 || n3[1] > 1) {
                  r3 = false;
                  break;
                }
              }
              if (n2.lastCascade = t4, s2 = Math.max(s2, t4), r3)
                break;
            }
          }
          return s2 + 1;
        }
      }
      class xr {
        constructor(t2) {
          this.painter = t2, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new vr(), this._depthMode = new e.b4(t2.context.gl.LEQUAL, e.b4.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this.useNormalOffset = false, t2.tp.registerParameter(fr, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), t2.tp.registerParameter(fr, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 });
        }
        destroy() {
          for (const e22 of this._cascades)
            e22.texture.destroy(), e22.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(t2, i2) {
          const o2 = this.painter;
          if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i2 || !i2.properties)
            return;
          const r2 = i2.properties.get("shadow-intensity");
          if (!i2.shadowsEnabled() || r2 <= 0)
            return;
          if (this._shadowLayerCount = o2.style.order.reduce((e22, i3) => {
            const r3 = o2.style._mergedLayers[i3];
            return e22 + (r3.hasShadowPass() && !r3.isHidden(t2.zoom) ? 1 : 0);
          }, 0), this._enabled = this._shadowLayerCount > 0, !this._enabled)
            return;
          const s2 = o2.context, n2 = fr.shadowMapResolution, a2 = fr.shadowMapResolution;
          if (0 === this._cascades.length || fr.shadowMapResolution !== this._cascades[0].texture.size[0]) {
            this._cascades = [];
            for (let t3 = 0; t3 < fr.cascadeCount; ++t3) {
              const t4 = o2._shadowMapDebug, i3 = s2.gl, r3 = s2.createFramebuffer(n2, a2, t4, "texture"), l3 = new e.a9(s2, { width: n2, height: a2, data: null }, i3.DEPTH_COMPONENT);
              if (r3.depthAttachment.set(l3.texture), t4) {
                const t5 = new e.a9(s2, { width: n2, height: a2, data: null }, i3.RGBA);
                r3.colorAttachment.set(t5.texture);
              }
              this._cascades.push({ framebuffer: r3, texture: l3, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e.F(), scale: 0 });
            }
          }
          this.shadowDirection = br(i2);
          let l2 = 0;
          if (t2.elevation) {
            const e22 = t2.elevation, i3 = [1e4, -1e4];
            e22.visibleDemTiles.filter((e3) => e3.dem).forEach((e3) => {
              const t3 = e3.dem.tree;
              i3[0] = Math.min(i3[0], t3.minimums[0]), i3[1] = Math.max(i3[1], t3.maximums[0]);
            }), 1e4 !== i3[0] && (l2 = (i3[1] - i3[0]) * e22.exaggeration());
          }
          const c2 = 1.5 * t2.cameraToCenterDistance, h22 = 3 * c2, _2 = new Float64Array(16);
          for (let i3 = 0; i3 < this._cascades.length; ++i3) {
            const o3 = this._cascades[i3];
            let r3 = t2.height / 50, s3 = 1;
            1 === fr.cascadeCount ? s3 = h22 : 0 === i3 ? s3 = c2 : (r3 = c2, s3 = h22);
            const [n3, a3] = Tr(t2, this.shadowDirection, r3, s3, fr.shadowMapResolution, l2);
            o3.scale = t2.scale, o3.matrix = n3, o3.boundingSphereRadius = a3, e.m.invert(_2, o3.matrix), o3.frustum = e.F.fromInvProjectionMatrix(_2, 1, 0, true), o3.far = s3;
          }
          const d2 = this._cascades.length - 1;
          this._uniformValues.u_fade_range = [0.75 * this._cascades[d2].far, this._cascades[d2].far], this._uniformValues.u_shadow_intensity = r2, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / fr.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = fr.shadowMapResolution, this._uniformValues.u_shadowmap_0 = _o.ShadowMap0, this._uniformValues.u_shadowmap_1 = _o.ShadowMap0 + 1, this._groundShadowTiles = o2.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
          const u2 = o2.transform.elevation;
          for (const e22 of this._groundShadowTiles) {
            let t3 = { min: 0, max: 0 };
            if (u2) {
              const i3 = u2.getMinMaxForTile(e22);
              i3 && (t3 = i3);
            }
            this.addShadowReceiver(e22.toUnwrapped(), t3.min, t3.max);
          }
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e22) {
          this._enabled = e22;
        }
        drawShadowPass(t2, i2) {
          if (!this._enabled)
            return;
          const o2 = this.painter, r2 = o2.context;
          this._numCascadesToRender = this._receivers.computeRequiredCascades(o2.transform.getFrustum(0), o2.transform.worldSize, this._cascades), r2.viewport.set([0, 0, fr.shadowMapResolution, fr.shadowMapResolution]);
          for (let s2 = 0; s2 < this._numCascadesToRender; ++s2) {
            o2.currentShadowCascade = s2, r2.bindFramebuffer.set(this._cascades[s2].framebuffer.framebuffer), r2.clear({ color: e.C.white, depth: 1 });
            for (const e22 of t2.order) {
              const r3 = t2._mergedLayers[e22];
              if (!r3.hasShadowPass() || r3.isHidden(o2.transform.zoom))
                continue;
              const s3 = t2.getLayerSourceCache(r3), n2 = s3 ? i2[s3.id] : void 0;
              ("model" === r3.type || n2 && n2.length) && o2.renderLayer(o2, s3, r3, n2);
            }
          }
          o2.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this._enabled)
            return;
          const t2 = this.painter, i2 = t2.style, o2 = t2.context, r2 = i2.directionalLight, s2 = i2.ambientLight;
          if (!r2 || !s2)
            return;
          const n2 = [], a2 = Ii(t2, t2.longestCutoffRange);
          a2.shouldRenderCutoff && n2.push("RENDER_CUTOFF");
          const l2 = wr(r2, s2), c2 = new e.b4(o2.gl.LEQUAL, e.b4.ReadOnly, t2.depthRangeFor3D);
          for (const i3 of this._groundShadowTiles) {
            const r3 = i3.toUnwrapped(), s3 = t2.isTileAffectedByFog(i3), h22 = t2.getOrCreateProgram("groundShadow", { defines: n2, overrideFog: s3 });
            this.setupShadows(r3, h22), t2.uploadCommonUniforms(o2, h22, r3, null, a2);
            const _2 = { u_matrix: t2.transform.calculateProjMatrix(r3), u_ground_shadow_factor: l2 };
            h22.draw(t2, o2.gl.TRIANGLES, c2, e.b6.disabled, e.a.multiply, e.b5.disabled, _2, "ground_shadow", t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments, {}, t2.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? e.a.unblended : e.a.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(t2) {
          const i2 = this.painter.transform, o2 = i2.calculatePosMatrix(t2, i2.worldSize);
          return e.m.multiply(o2, this._cascades[this.painter.currentShadowCascade].matrix, o2), Float32Array.from(o2);
        }
        calculateShadowPassMatrixFromMatrix(t2) {
          return e.m.multiply(t2, this._cascades[this.painter.currentShadowCascade].matrix, t2), Float32Array.from(t2);
        }
        setupShadows(t2, i2, o2, r2 = 0) {
          if (!this._enabled)
            return;
          const s2 = this.painter.transform, n2 = this.painter.context, a2 = n2.gl, l2 = this._uniformValues, c2 = new Float64Array(16), h22 = s2.calculatePosMatrix(t2, s2.worldSize);
          for (let t3 = 0; t3 < this._cascades.length; t3++)
            e.m.multiply(c2, this._cascades[t3].matrix, h22), l2[0 === t3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c2), n2.activeTexture.set(a2.TEXTURE0 + _o.ShadowMap0 + t3), this._cascades[t3].texture.bind(a2.NEAREST, a2.CLAMP_TO_EDGE);
          if (this.useNormalOffset = !!o2, this.useNormalOffset) {
            const i3 = e.cg(t2.canonical), n3 = 2 / s2.tileSize * e.J / fr.shadowMapResolution, a3 = n3 * this._cascades[0].boundingSphereRadius, c3 = n3 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h3 = ("vector-tile" === o2 ? 1 : 3) / Math.pow(2, r2 - t2.canonical.z - (1 - s2.zoom + Math.floor(s2.zoom)));
            l2.u_shadow_normal_offset = [i3, a3 * h3, c3 * h3], l2.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            l2.u_shadow_bias = [36e-5, 12e-4, 0.012];
          i2.setShadowUniformValues(n2, l2);
        }
        setupShadowsFromMatrix(t2, i2, o2 = false) {
          if (!this._enabled)
            return;
          const r2 = this.painter.context, s2 = r2.gl, n2 = this._uniformValues, a2 = new Float64Array(16);
          for (let i3 = 0; i3 < fr.cascadeCount; i3++)
            e.m.multiply(a2, this._cascades[i3].matrix, t2), n2[0 === i3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a2), r2.activeTexture.set(s2.TEXTURE0 + _o.ShadowMap0 + i3), this._cascades[i3].texture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE);
          if (this.useNormalOffset = o2, o2) {
            const e22 = 5;
            n2.u_shadow_normal_offset = [1, e22, e22], n2.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            n2.u_shadow_bias = [36e-5, 12e-4, 0.012];
          i2.setShadowUniformValues(r2, n2);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(t2, i2, o2, r2) {
          if (r2[2] >= 0)
            return {};
          const s2 = function(t3, i3, o3) {
            const r3 = o3 / (1 << t3.canonical.z);
            return new e.c3([t3.canonical.x * r3 + t3.wrap * o3, t3.canonical.y * r3 + t3.wrap * o3, 0], [(t3.canonical.x + 1) * r3 + t3.wrap * o3, (t3.canonical.y + 1) * r3 + t3.wrap * o3, i3]);
          }(t2, i2, o2).getCorners(), n2 = i2 / -r2[2];
          r2[0] < 0 ? (e.v.add(s2[0], s2[0], [r2[0] * n2, 0, 0]), e.v.add(s2[3], s2[3], [r2[0] * n2, 0, 0])) : r2[0] > 0 && (e.v.add(s2[1], s2[1], [r2[0] * n2, 0, 0]), e.v.add(s2[2], s2[2], [r2[0] * n2, 0, 0])), r2[1] < 0 ? (e.v.add(s2[0], s2[0], [0, r2[1] * n2, 0]), e.v.add(s2[1], s2[1], [0, r2[1] * n2, 0])) : r2[1] > 0 && (e.v.add(s2[2], s2[2], [0, r2[1] * n2, 0]), e.v.add(s2[3], s2[3], [0, r2[1] * n2, 0]));
          const a2 = {};
          return a2.vertices = s2, a2.planes = [yr(s2[1], s2[0], s2[4]), yr(s2[2], s2[1], s2[5]), yr(s2[3], s2[2], s2[6]), yr(s2[0], s2[3], s2[7])], a2;
        }
        addShadowReceiver(t2, i2, o2) {
          this._receivers.add(t2, e.c3.fromTileIdAndHeight(t2, i2, o2));
        }
        getMaxCascadeForTile(e22) {
          const t2 = this._receivers.get(e22);
          return t2 && t2.lastCascade ? t2.lastCascade : 0;
        }
      }
      function yr(t2, i2, o2) {
        const r2 = e.v.sub([], o2, i2), s2 = e.v.sub([], t2, i2), n2 = e.v.cross([], r2, s2), a2 = e.v.length(n2);
        return 0 === a2 ? [0, 0, 1, 0] : (e.v.scale(n2, n2, 1 / a2), [n2[0], n2[1], n2[2], -e.v.dot(n2, i2)]);
      }
      function br(t2) {
        const i2 = t2.properties.get("direction"), o2 = e.b3(i2.x, i2.y, i2.z);
        o2[2] = e.c(o2[2], 0, 75);
        const r2 = e.ch([o2[0], o2[1], o2[2]]);
        return e.v.fromValues(r2.x, r2.y, r2.z);
      }
      function wr(t2, i2) {
        const o2 = t2.properties.get("color"), r2 = t2.properties.get("intensity"), s2 = t2.properties.get("direction"), n2 = [s2.x, s2.y, s2.z], a2 = i2.properties.get("color"), l2 = i2.properties.get("intensity"), c2 = Math.max(e.v.dot([0, 0, 1], n2), 0), h22 = [0, 0, 0];
        e.v.scale(h22, a2.toArray01Linear().slice(0, 3), l2);
        const _2 = [0, 0, 0];
        return e.v.scale(_2, o2.toArray01Linear().slice(0, 3), c2 * r2), e.bw([h22[0] > 0 ? h22[0] / (h22[0] + _2[0]) : 0, h22[1] > 0 ? h22[1] / (h22[1] + _2[1]) : 0, h22[2] > 0 ? h22[2] / (h22[2] + _2[2]) : 0]);
      }
      function Tr(t2, i2, o2, r2, s2, n2) {
        const a2 = t2.zoom, l2 = t2.scale, c2 = t2.worldSize, h22 = 1 / c2, _2 = t2.aspect, d2 = Math.sqrt(1 + _2 * _2) * Math.tan(0.5 * t2.fovX), u2 = d2 * d2, p2 = r2 - o2, m2 = r2 + o2;
        let f2, g2;
        u2 > p2 / m2 ? (f2 = r2, g2 = r2 * d2) : (f2 = 0.5 * m2 * (1 + u2), g2 = 0.5 * Math.sqrt(p2 * p2 + 2 * (r2 * r2 + o2 * o2) * u2 + m2 * m2 * u2 * u2));
        const v2 = t2.projection.pixelsPerMeter(t2.center.lat, c2), x2 = t2._camera.getCameraToWorldMercator(), y2 = [0, 0, -f2 * h22];
        e.v.transformMat4(y2, y2, x2);
        let b2 = g2 * h22;
        const w2 = t2._edgeInsets;
        if (!(0 === w2.left && 0 === w2.top && 0 === w2.right && 0 === w2.bottom || w2.left === w2.right && w2.top === w2.bottom)) {
          const i3 = t2._camera.getWorldToCamera(t2.worldSize, "meters" === t2.projection.zAxisUnit ? v2 : 1), s3 = t2._camera.getCameraToClipPerspective(t2._fov, t2.width / t2.height, o2, r2);
          s3[8] = 2 * -t2.centerOffset.x / t2.width, s3[9] = 2 * t2.centerOffset.y / t2.height;
          const n3 = new Float64Array(16);
          e.m.mul(n3, s3, i3);
          const h3 = new Float64Array(16);
          e.m.invert(h3, n3);
          const _3 = e.F.fromInvProjectionMatrix(h3, c2, a2, true);
          for (const i4 of _3.points) {
            const o3 = ((T2 = i4)[0] /= l2, T2[1] /= l2, T2[2] = e.b(T2[2], t2._center.lat), T2);
            b2 = Math.max(b2, e.v.len(e.v.subtract([], y2, o3)));
          }
        }
        var T2;
        b2 *= s2 / (s2 - 1);
        const E2 = Math.acos(i2[2]), C2 = Math.atan2(-i2[0], -i2[1]), I2 = new _e();
        I2.position = y2, I2.setPitchBearing(E2, C2);
        const S2 = I2.getWorldToCamera(c2, v2), M2 = b2 * c2, L2 = Math.min(t2._mercatorZfromZoom(17) * c2 * -2, -2 * M2), P2 = I2.getCameraToClipOrthographic(-M2, M2, -M2, M2, L2, (M2 + n2 * v2) / i2[2]), D2 = new Float64Array(16);
        e.m.multiply(D2, P2, S2);
        const A2 = e.v.fromValues(Math.floor(1e6 * y2[0]) / 1e6 * c2, Math.floor(1e6 * y2[1]) / 1e6 * c2, 0), R2 = 0.5 * s2, z2 = [0, 0, 0];
        e.v.transformMat4(z2, A2, D2), e.v.scale(z2, z2, R2);
        const O2 = [Math.floor(z2[0]), Math.floor(z2[1]), Math.floor(z2[2])], F2 = [0, 0, 0];
        e.v.sub(F2, z2, O2), e.v.scale(F2, F2, -1 / R2);
        const B2 = new Float64Array(16);
        return e.m.identity(B2), e.m.translate(B2, B2, F2), e.m.multiply(D2, B2, D2), [D2, M2];
      }
      class Er extends e.a6 {
        constructor(e22) {
          super(), this.requestManager = e22, this.models = { "": {} }, this.numModelsLoading = {};
        }
        loadModel(t2, i2) {
          return e.aO(this.requestManager.transformRequest(i2, e.a2.Model).url).then((i3) => {
            if (!i3)
              return;
            const o2 = e.aP(i3), r2 = new e.aQ(t2, void 0, void 0, o2);
            return r2.computeBoundsAndApplyParent(), r2;
          }).catch((o2) => {
            this.fire(new e.a7(new Error(`Could not load model ${t2} from ${i2}: ${o2.message}`)));
          });
        }
        load(t2, i2) {
          this.models[i2] || (this.models[i2] = {});
          const o2 = Object.keys(t2);
          this.numModelsLoading[i2] = (this.numModelsLoading[i2] || 0) + o2.length;
          const r2 = [];
          for (const e22 of o2)
            r2.push(this.loadModel(e22, t2[e22]));
          Promise.allSettled(r2).then((t3) => {
            for (let e22 = 0; e22 < t3.length; e22++) {
              const { status: r3, value: s2 } = t3[e22];
              "fulfilled" === r3 && s2 && (this.models[i2][o2[e22]] = s2);
            }
            this.numModelsLoading[i2] -= o2.length, this.fire(new e.a8("data", { dataType: "style" }));
          }).catch((t3) => {
            this.fire(new e.a7(new Error(`Could not load models: ${t3.message}`)));
          });
        }
        isLoaded() {
          for (const e22 in this.numModelsLoading)
            if (this.numModelsLoading[e22] > 0)
              return false;
          return true;
        }
        hasModel(e22, t2) {
          return !!this.getModel(e22, t2);
        }
        getModel(e22, t2) {
          return this.models[t2] || (this.models[t2] = {}), this.models[t2][e22];
        }
        addModel(e22, t2, i2) {
          this.models[i2] || (this.models[i2] = {}), this.hasModel(e22, i2) && this.removeModel(e22, i2), this.load({ [e22]: this.requestManager.normalizeModelURL(t2) }, i2);
        }
        addModels(e22, t2) {
          const i2 = {};
          for (const t3 in e22)
            i2[t3] = this.requestManager.normalizeModelURL(e22[t3]);
          this.load(i2, t2);
        }
        removeModel(e22, t2) {
          this.models[t2] || (this.models[t2] = {});
          const i2 = this.models[t2][e22];
          delete this.models[t2][e22], i2.destroy();
        }
        listModels(e22) {
          return this.models[e22] || (this.models[e22] = {}), Object.keys(this.models[e22]);
        }
        upload(e22, t2) {
          this.models[t2] || (this.models[t2] = {});
          for (const i2 in this.models[t2])
            this.models[t2][i2].upload(e22.context);
        }
      }
      const Cr = (t2, i2) => e.ai(t2, i2 && i2.filter((e22) => "source.canvas" !== e22.identifier)), Ir = e.p(ut, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection", "setCamera", "addImport", "removeImport", "setImportUrl", "setImportData", "setImportConfig"]), Sr = e.p(ut, ["setCenter", "setZoom", "setBearing", "setPitch"]), Mr = { version: 8, layers: [], sources: {} }, Lr = { duration: 300, delay: 0 }, Pr = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
      class Dr extends e.a6 {
        constructor(t2, i2 = {}) {
          super(), this.map = t2, this.scope = i2.scope || "", this.fragments = [], this.importDepth = i2.importDepth || 0, this.importsCache = i2.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i2.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e.ak({}, Lr), this._buildingIndex = new ht(this), this.crossTileSymbolIndex = new Qt(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i2.styleChanges || new v(), this.dispatcher = i2.dispatcher ? i2.dispatcher : new e.br(e.bs(), this), i2.imageManager ? this.imageManager = i2.imageManager : (this.imageManager = new Re(), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i2.glyphManager ? i2.glyphManager : new e.cj(t2._requestManager, i2.localFontFamily ? e.ck.all : i2.localIdeographFontFamily ? e.ck.ideographs : e.ck.none, i2.localFontFamily || i2.localIdeographFontFamily), i2.modelManager ? this.modelManager = i2.modelManager : (this.modelManager = new Er(t2._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._order = [], this._markersNeedUpdate = false, this.options = i2.configOptions ? i2.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i2.configDependentLayers ? i2.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i2.config, this.dispatcher.broadcast("setReferrer", e.cl());
          const o2 = this;
          this._rtlTextPluginCallback = Dr.registerForPluginStateChange((t3) => {
            o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
              if (e.cm(t4), i3 && i3.every((e22) => e22))
                for (const e22 in o2._sourceCaches) {
                  const t5 = o2._sourceCaches[e22], i4 = t5.getSource().type;
                  "vector" !== i4 && "geojson" !== i4 || t5.reload();
                }
            });
          }), this.on("data", (e22) => {
            if ("source" !== e22.dataType || "metadata" !== e22.sourceDataType)
              return;
            const t3 = this.getOwnSource(e22.sourceId);
            if (t3 && t3.vectorLayerIds)
              for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t3.id && this._validateLayer(i3);
              }
          });
        }
        loadURL(t2, i2 = {}) {
          this.fire(new e.a8("dataloading", { dataType: "style" }));
          const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.cn(t2);
          t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken), this.resolvedImports.add(t2);
          const r2 = this.importsCache.get(t2);
          if (r2)
            return this._load(r2, o2);
          const s2 = this.map._requestManager.transformRequest(t2, e.a2.Style);
          this._request = e.a1(s2, (i3, r3) => {
            if (this._request = null, i3)
              this.fire(new e.a7(i3));
            else if (r3)
              return this.importsCache.set(t2, r3), this._load(r3, o2);
          });
        }
        loadJSON(t2, i2 = {}) {
          this.fire(new e.a8("dataloading", { dataType: "style" })), this._request = e.a4.frame(() => {
            this._request = null, this._load(t2, false !== i2.validate);
          });
        }
        loadEmpty() {
          this.fire(new e.a8("dataloading", { dataType: "style" })), this._load(Mr, false);
        }
        _loadImports(t2, i2) {
          if (this.importDepth >= 4)
            return e.X("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const o2 = [];
          for (const e22 of t2) {
            const t3 = this._createFragmentStyle(e22), r2 = new Promise((e3) => {
              t3.once("style.import.load", e3), t3.once("error", e3);
            }).then(() => this.mergeAll());
            if (o2.push(r2), this.resolvedImports.has(e22.url)) {
              t3.loadEmpty();
              continue;
            }
            const s2 = e22.data || this.importsCache.get(e22.url);
            s2 ? t3.loadJSON(s2, { validate: i2 }) : e22.url ? t3.loadURL(e22.url, { validate: i2 }) : t3.loadEmpty(), this.fragments.push({ style: t3, id: e22.id, config: e22.config });
          }
          return Promise.allSettled(o2);
        }
        _createFragmentStyle(t2) {
          const i2 = this.scope ? e.aE(t2.id, this.scope) : t2.id, o2 = new Dr(this.map, { scope: i2, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: t2.config, configOptions: this.options, configDependentLayers: this._configDependentLayers });
          return o2.setEventedParent(this.map, { style: o2 }), o2;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options });
          const t2 = this.isRootStyle();
          this._shouldPrecompile = t2, this.fire(new e.a8(t2 ? "style.load" : "style.import.load"));
        }
        _load(t2, i2) {
          const o2 = t2.schema;
          if (this.isRootStyle() && (t2.fragment || o2 && false !== t2.fragment)) {
            const o3 = e.ak({}, Mr, { imports: [{ id: "basemap", data: t2, url: "" }] });
            return void this._load(o3, i2);
          }
          if (this.setConfig(this._config, o2), i2 && Cr(this, e.aj(t2)))
            return;
          this._loaded = true, this.stylesheet = e.co(t2);
          for (const e22 in t2.sources)
            this.addSource(e22, t2.sources[e22], { validate: false, isInitialLoad: true });
          t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.glyphManager.setURL(t2.glyphs, this.scope);
          const r2 = dt(this.stylesheet.layers);
          if (this._order = r2.map((e22) => e22.id), this.stylesheet.light && e.X("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
            if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
              const e22 = this.stylesheet.lights[0];
              this.light = new Oe(e22.properties, e22.id);
            } else
              this.setLights(this.stylesheet.lights);
          this.light || (this.light = new Oe(this.stylesheet.light)), this._layers = {}, this._serializedLayers = {};
          for (const t3 of r2) {
            const i3 = e.cp(t3, this.scope, this.options);
            i3.isConfigDependent && this._configDependentLayers.add(i3.fqid), i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3, this._serializedLayers[i3.id] = i3.serialize();
            const o3 = this.getOwnLayerSourceCache(i3), r3 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            o3 && i3.canCastShadows() && r3 && (o3.castsShadows = true);
          }
          this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
          const s2 = this.stylesheet.terrain;
          s2 && (void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.a4.hasCanvasFingerprintNoise()), this.disableElevatedTerrain ? e.X("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).") : this.terrainSetForDrapingOnly() || this._createTerrain(s2, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.a8("data", { dataType: "style" })), t2.imports ? this._loadImports(t2.imports, i2).then(() => this._reloadImports()) : this._reloadImports();
        }
        isRootStyle() {
          return 0 === this.importDepth;
        }
        mergeAll() {
          let t2, i2, o2, r2, s2, n2, a2, l2;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e22) => {
            if (e22.stylesheet) {
              if (null != e22.light && (t2 = e22.light), e22.stylesheet.lights)
                for (const t3 of e22.stylesheet.lights)
                  "ambient" === t3.type && null != e22.ambientLight && (i2 = e22.ambientLight), "directional" === t3.type && null != e22.directionalLight && (o2 = e22.directionalLight);
              r2 = this._prioritizeTerrain(r2, e22.terrain, e22.stylesheet.terrain), e22.stylesheet.fog && null != e22.fog && (s2 = e22.fog), null != e22.stylesheet.camera && (l2 = e22.stylesheet.camera), null != e22.stylesheet.projection && (n2 = e22.stylesheet.projection), null != e22.stylesheet.transition && (a2 = e22.stylesheet.transition);
            }
          }), this.light = t2, this.ambientLight = i2, this.directionalLight = o2, this.fog = s2, null === r2 ? delete this.terrain : this.terrain = r2, this.camera = l2 || { "camera-projection": "perspective" }, this.projection = n2 || { name: "mercator" }, this.transition = e.ak({}, Lr, a2), this.mergeSources(), this.mergeLayers();
        }
        forEachFragmentStyle(e22) {
          const t2 = (i2) => {
            for (const e3 of i2.fragments)
              t2(e3.style);
            e22(i2);
          };
          t2(this);
        }
        _prioritizeTerrain(e22, t2, i2) {
          const o2 = e22 && 0 === e22.drapeRenderMode;
          return null === i2 ? t2 && 0 === t2.drapeRenderMode ? t2 : o2 ? e22 : null : null != t2 && (!e22 || o2 || t2 && 1 === t2.drapeRenderMode) ? t2 : e22;
        }
        mergeTerrain() {
          let e22;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t2) => {
            e22 = this._prioritizeTerrain(e22, t2.terrain, t2.stylesheet.terrain);
          }), null === e22 ? delete this.terrain : this.terrain = e22;
        }
        mergeProjection() {
          let e22;
          this.forEachFragmentStyle((t2) => {
            null != t2.stylesheet.projection && (e22 = t2.stylesheet.projection);
          }), this.projection = e22 || { name: "mercator" };
        }
        mergeSources() {
          const t2 = {}, i2 = {}, o2 = {};
          this.forEachFragmentStyle((r2) => {
            for (const i3 in r2._sourceCaches) {
              const o3 = e.aE(i3, r2.scope);
              t2[o3] = r2._sourceCaches[i3];
            }
            for (const t3 in r2._otherSourceCaches) {
              const o3 = e.aE(t3, r2.scope);
              i2[o3] = r2._otherSourceCaches[t3];
            }
            for (const t3 in r2._symbolSourceCaches) {
              const i3 = e.aE(t3, r2.scope);
              o2[i3] = r2._symbolSourceCaches[t3];
            }
          }), this._mergedSourceCaches = t2, this._mergedOtherSourceCaches = i2, this._mergedSymbolSourceCaches = o2;
        }
        mergeLayers() {
          const t2 = {}, i2 = [], o2 = {};
          this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o3) => {
            for (const r3 of o3._order) {
              const s2 = o3._layers[r3];
              if ("slot" === s2.type) {
                const i3 = e.cq(r3);
                if (t2[i3])
                  continue;
                t2[i3] = [];
              }
              s2.slot && t2[s2.slot] ? t2[s2.slot].push(s2) : i2.push(s2);
            }
          }), this._mergedOrder = [];
          const r2 = (i3 = []) => {
            for (const s2 of i3)
              if ("slot" === s2.type) {
                const i4 = e.cq(s2.id);
                t2[i4] && r2(t2[i4]);
              } else {
                const t3 = e.aE(s2.id, s2.scope);
                this._mergedOrder.push(t3), o2[t3] = s2, s2.is3D() && (this._has3DLayers = true), "circle" === s2.type && (this._hasCircleLayers = true), "symbol" === s2.type && (this._hasSymbolLayers = true);
              }
          };
          r2(i2), this._mergedLayers = o2, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && 0 === this.terrain.drapeRenderMode;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(t2) {
          return this.stylesheet.camera = e.ak({}, this.stylesheet.camera, t2), this.camera = this.stylesheet.camera, this;
        }
        setProjection(e22) {
          e22 ? this.stylesheet.projection = e22 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(t2) {
          this._spriteRequest = function(t3, i2, o2) {
            let r2, s2, n2;
            const a2 = e.a4.devicePixelRatio > 1 ? "@2x" : "";
            let l2 = e.a1(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.a2.SpriteJSON), (e22, t4) => {
              l2 = null, n2 || (n2 = e22, r2 = t4, h22());
            }), c2 = e.a3(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.a2.SpriteImage), (e22, t4) => {
              c2 = null, n2 || (n2 = e22, s2 = t4, h22());
            });
            function h22() {
              if (n2)
                o2(n2);
              else if (r2 && s2) {
                const t4 = e.a4.getImageData(s2), i3 = {};
                for (const o3 in r2) {
                  const { width: s3, height: n3, x: a3, y: l3, sdf: c3, pixelRatio: h3, stretchX: _2, stretchY: d2, content: u2 } = r2[o3], p2 = new e.a5({ width: s3, height: n3 });
                  e.a5.copy(t4, p2, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: s3, height: n3 }), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: _2, stretchY: d2, content: u2 };
                }
                o2(null, i3);
              }
            }
            return { cancel() {
              l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
            } };
          }(t2, this.map._requestManager, (t3, i2) => {
            if (this._spriteRequest = null, t3)
              this.fire(new e.a7(t3));
            else if (i2)
              for (const e22 in i2)
                this.imageManager.addImage(e22, this.scope, i2[e22]);
            this.imageManager.setLoaded(true, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e.a8("data", { dataType: "style" }));
          });
        }
        _validateLayer(t2) {
          const i2 = this.getOwnSource(t2.source);
          if (!i2)
            return;
          const o2 = t2.sourceLayer;
          o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.a7(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._changes.getUpdatedSourceCaches()).length)
            return false;
          for (const e22 in this._sourceCaches)
            if (!this._sourceCaches[e22].loaded())
              return false;
          if (!this.imageManager.isLoaded())
            return false;
          if (!this.modelManager.isLoaded())
            return false;
          for (const { style: e22 } of this.fragments)
            if (!e22.loaded())
              return false;
          return true;
        }
        _serializeImports() {
          if (this.stylesheet.imports)
            return this.stylesheet.imports.map((e22, t2) => {
              const i2 = this.fragments[t2];
              return i2 && i2.style && (e22.data = i2.style.serialize()), e22;
            });
        }
        _serializeSources() {
          const e22 = {};
          for (const t2 in this._sourceCaches) {
            const i2 = this._sourceCaches[t2].getSource();
            e22[i2.id] || (e22[i2.id] = i2.serialize());
          }
          return e22;
        }
        _serializeLayers(e22) {
          const t2 = [];
          for (const i2 of e22) {
            const e3 = this._layers[i2];
            e3 && "custom" !== e3.type && t2.push(e3.serialize());
          }
          return t2;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions())
            return true;
          if (this.hasFogTransition())
            return true;
          for (const e22 in this._sourceCaches)
            if (this._sourceCaches[e22].hasTransition())
              return true;
          for (const e22 in this._layers)
            if (this._layers[e22].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        isLayerDraped(e22) {
          return !!this.terrain && ("function" == typeof e22.isLayerDraped ? e22.isLayerDraped(this.getLayerSourceCache(e22)) : Pr.has(e22.type));
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        _checkLayer(t2) {
          const i2 = this.getOwnLayer(t2);
          if (i2)
            return i2;
          this.fire(new e.a7(new Error(`The layer '${t2}' does not exist in the map's style.`)));
        }
        _checkSource(t2) {
          const i2 = this.getOwnSource(t2);
          if (i2)
            return i2;
          this.fire(new e.a7(new Error(`The source '${t2}' does not exist in the map's style.`)));
        }
        update(t2) {
          if (!this._loaded)
            return;
          this.ambientLight && this.ambientLight.recalculate(t2), this.directionalLight && this.directionalLight.recalculate(t2);
          const i2 = this.calculateLightsBrightness();
          t2.brightness = i2 || 0, i2 !== this._brightness && (this._brightness = i2, this.dispatcher.broadcast("setBrightness", i2));
          const o2 = this._changes.isDirty();
          if (this._changes.isDirty()) {
            const e22 = this._changes.getLayerUpdatesByScope();
            for (const t3 in e22) {
              const { updatedIds: i3, removedIds: o3 } = e22[t3];
              (i3 || o3) && this._updateWorkerLayers(t3, i3, o3);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t2), this.light && this.light.updateTransitions(t2), this.ambientLight && this.ambientLight.updateTransitions(t2), this.directionalLight && this.directionalLight.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._changes.reset();
          }
          const r2 = {};
          for (const e22 in this._mergedSourceCaches) {
            const t3 = this._mergedSourceCaches[e22];
            r2[e22] = t3.used, t3.used = false;
          }
          for (const e22 of this._mergedOrder) {
            const i3 = this._mergedLayers[e22];
            if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
              const e3 = this.getLayerSourceCache(i3);
              e3 && (e3.used = true);
            }
            if (!this._precompileDone && this._shouldPrecompile)
              for (let e3 = i3.minzoom || 0; e3 < (i3.maxzoom || 25.5); e3++) {
                const e4 = this.map.painter;
                if (e4) {
                  const o3 = i3.getProgramIds();
                  if (!o3)
                    continue;
                  for (const r3 of o3) {
                    const o4 = i3.getDefaultProgramParams(r3, t2.zoom);
                    o4 && (e4.style = this, this.fog && (e4._fogVisible = true, o4.overrideFog = true, e4.getOrCreateProgram(r3, o4)), e4._fogVisible = false, o4.overrideFog = false, e4.getOrCreateProgram(r3, o4), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o4.overrideRtt = true, e4.getOrCreateProgram(r3, o4)));
                  }
                }
              }
          }
          this._shouldPrecompile && (this._precompileDone = true);
          for (const t3 in r2) {
            const i3 = this._mergedSourceCaches[t3];
            r2[t3] !== i3.used && i3.getSource().fire(new e.a8("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
          }
          this.light && this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), o2 && this.fire(new e.a8("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e22 = this._changes.getUpdatedImages();
          if (e22.length) {
            for (const t2 in this._sourceCaches)
              this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e22);
            this._changes.resetUpdatedImages();
          }
        }
        _updateWorkerLayers(e22, t2, i2) {
          const o2 = this.getFragmentStyle(e22);
          o2 && this.dispatcher.broadcast("updateLayers", { layers: t2 ? o2._serializeLayers(t2) : [], scope: e22, removedIds: i2 || [], options: o2.options });
        }
        setState(i2) {
          if (this._checkLoaded(), Cr(this, e.aj(i2)))
            return false;
          (i2 = e.co(i2)).layers = dt(i2.layers);
          const o2 = function(e22, i3) {
            if (!e22)
              return [{ command: ut.setStyle, args: [i3] }];
            let o3 = [];
            try {
              if (!t(e22.version, i3.version))
                return [{ command: ut.setStyle, args: [i3] }];
              t(e22.center, i3.center) || o3.push({ command: ut.setCenter, args: [i3.center] }), t(e22.zoom, i3.zoom) || o3.push({ command: ut.setZoom, args: [i3.zoom] }), t(e22.bearing, i3.bearing) || o3.push({ command: ut.setBearing, args: [i3.bearing] }), t(e22.pitch, i3.pitch) || o3.push({ command: ut.setPitch, args: [i3.pitch] }), t(e22.sprite, i3.sprite) || o3.push({ command: ut.setSprite, args: [i3.sprite] }), t(e22.glyphs, i3.glyphs) || o3.push({ command: ut.setGlyphs, args: [i3.glyphs] }), t(e22.imports, i3.imports) || function(e3 = [], i4 = [], o4) {
                i4 = i4 || [];
                const r4 = (e3 = e3 || []).map(xt), s3 = i4.map(xt), n3 = e3.reduce(yt, {}), a3 = i4.reduce(yt, {}), l2 = r4.slice();
                let c2, h22, _2, d2;
                for (c2 = 0, h22 = 0; c2 < r4.length; c2++)
                  _2 = r4[c2], a3.hasOwnProperty(_2) ? h22++ : (o4.push({ command: ut.removeImport, args: [_2] }), l2.splice(l2.indexOf(_2, h22), 1));
                for (c2 = 0, h22 = 0; c2 < s3.length; c2++)
                  _2 = s3[s3.length - 1 - c2], l2[l2.length - 1 - c2] !== _2 && (n3.hasOwnProperty(_2) ? (o4.push({ command: ut.removeImport, args: [_2] }), l2.splice(l2.lastIndexOf(_2, l2.length - h22), 1)) : h22++, d2 = l2[l2.length - c2], o4.push({ command: ut.addImport, args: [a3[_2], d2] }), l2.splice(l2.length - c2, 0, _2));
                for (const e4 of i4) {
                  const i5 = n3[e4.id];
                  if (!i5 || t(i5, e4))
                    continue;
                  t(i5.config, e4.config) || o4.push({ command: ut.setImportConfig, args: [e4.id, e4.config] }), t(i5.url, e4.url) || o4.push({ command: ut.setImportUrl, args: [e4.id, e4.url] });
                  const r5 = e4.data;
                  t(i5 && i5.data, r5) || o4.push({ command: ut.setImportData, args: [e4.id, r5] });
                }
              }(e22.imports, i3.imports, o3), t(e22.transition, i3.transition) || o3.push({ command: ut.setTransition, args: [i3.transition] }), t(e22.light, i3.light) || o3.push({ command: ut.setLight, args: [i3.light] }), t(e22.fog, i3.fog) || o3.push({ command: ut.setFog, args: [i3.fog] }), t(e22.projection, i3.projection) || o3.push({ command: ut.setProjection, args: [i3.projection] }), t(e22.lights, i3.lights) || o3.push({ command: ut.setLights, args: [i3.lights] }), t(e22.camera, i3.camera) || o3.push({ command: ut.setCamera, args: [i3.camera] });
              const r3 = {}, s2 = [];
              !function(e3, i4, o4, r4) {
                let s3;
                for (s3 in i4 = i4 || {}, e3 = e3 || {})
                  e3.hasOwnProperty(s3) && (i4.hasOwnProperty(s3) || mt(s3, o4, r4));
                for (s3 in i4) {
                  if (!i4.hasOwnProperty(s3))
                    continue;
                  const n3 = i4[s3];
                  e3.hasOwnProperty(s3) ? t(e3[s3], n3) || ("geojson" === e3[s3].type && "geojson" === n3.type && gt(e3, i4, s3) ? o4.push({ command: ut.setGeoJSONSourceData, args: [s3, n3.data] }) : ft(s3, i4, o4, r4)) : pt(s3, i4, o4);
                }
              }(e22.sources, i3.sources, s2, r3);
              const n2 = [];
              e22.layers && e22.layers.forEach((e3) => {
                e3.source && r3[e3.source] ? o3.push({ command: ut.removeLayer, args: [e3.id] }) : n2.push(e3);
              });
              let a2 = e22.terrain;
              a2 && r3[a2.source] && (o3.push({ command: ut.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(s2), t(a2, i3.terrain) || o3.push({ command: ut.setTerrain, args: [i3.terrain] }), function(e3, i4, o4) {
                i4 = i4 || [];
                const r4 = (e3 = e3 || []).map(xt), s3 = i4.map(xt), n3 = e3.reduce(yt, {}), a3 = i4.reduce(yt, {}), l2 = r4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                let h22, _2, d2, u2, p2, m2, f2;
                for (h22 = 0, _2 = 0; h22 < r4.length; h22++)
                  d2 = r4[h22], a3.hasOwnProperty(d2) ? _2++ : (o4.push({ command: ut.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, _2), 1));
                for (h22 = 0, _2 = 0; h22 < s3.length; h22++)
                  d2 = s3[s3.length - 1 - h22], l2[l2.length - 1 - h22] !== d2 && (n3.hasOwnProperty(d2) ? (o4.push({ command: ut.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - _2), 1)) : _2++, m2 = l2[l2.length - h22], o4.push({ command: ut.addLayer, args: [a3[d2], m2] }), l2.splice(l2.length - h22, 0, d2), c2[d2] = true);
                for (h22 = 0; h22 < s3.length; h22++)
                  if (d2 = s3[h22], u2 = n3[d2], p2 = a3[d2], !c2[d2] && !t(u2, p2))
                    if (t(u2.source, p2.source) && t(u2["source-layer"], p2["source-layer"]) && t(u2.type, p2.type)) {
                      for (f2 in vt(u2.layout, p2.layout, o4, d2, null, ut.setLayoutProperty), vt(u2.paint, p2.paint, o4, d2, null, ut.setPaintProperty), t(u2.slot, p2.slot) || o4.push({ command: ut.setSlot, args: [d2, p2.slot] }), t(u2.filter, p2.filter) || o4.push({ command: ut.setFilter, args: [d2, p2.filter] }), t(u2.minzoom, p2.minzoom) && t(u2.maxzoom, p2.maxzoom) || o4.push({ command: ut.setLayerZoomRange, args: [d2, p2.minzoom, p2.maxzoom] }), u2)
                        u2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && "slot" !== f2 && (0 === f2.indexOf("paint.") ? vt(u2[f2], p2[f2], o4, d2, f2.slice(6), ut.setPaintProperty) : t(u2[f2], p2[f2]) || o4.push({ command: ut.setLayerProperty, args: [d2, f2, p2[f2]] }));
                      for (f2 in p2)
                        p2.hasOwnProperty(f2) && !u2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && "slot" !== f2 && (0 === f2.indexOf("paint.") ? vt(u2[f2], p2[f2], o4, d2, f2.slice(6), ut.setPaintProperty) : t(u2[f2], p2[f2]) || o4.push({ command: ut.setLayerProperty, args: [d2, f2, p2[f2]] }));
                    } else
                      o4.push({ command: ut.removeLayer, args: [d2] }), m2 = l2[l2.lastIndexOf(d2) + 1], o4.push({ command: ut.addLayer, args: [p2, m2] });
              }(n2, i3.layers, o3);
            } catch (e3) {
              console.warn("Unable to compute style diff:", e3), o3 = [{ command: ut.setStyle, args: [i3] }];
            }
            return o3;
          }(this.serialize(), i2).filter((e22) => !(e22.command in Sr));
          if (0 === o2.length)
            return false;
          const r2 = o2.filter((e22) => !(e22.command in Ir));
          if (r2.length > 0)
            throw new Error(`Unimplemented: ${r2.map((e22) => e22.command).join(", ")}.`);
          return o2.forEach((e22) => {
            this[e22.command].apply(this, e22.args);
          }), this.stylesheet = i2, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
        }
        addImage(t2, i2) {
          return this.getImage(t2) ? this.fire(new e.a7(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t2, this.scope, i2), this._afterImageUpdated(t2), this);
        }
        updateImage(e22, t2) {
          this.imageManager.updateImage(e22, this.scope, t2);
        }
        getImage(e22) {
          return this.imageManager.getImage(e22, this.scope);
        }
        removeImage(t2) {
          return this.getImage(t2) ? (this.imageManager.removeImage(t2, this.scope), this._afterImageUpdated(t2), this) : this.fire(new e.a7(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(t2) {
          this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t2), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new e.a8("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModel(t2, i2, o2 = {}) {
          return this._checkLoaded(), this._validate(e.cr, `models.${t2}`, i2, null, o2) || (this.modelManager.addModel(t2, i2, this.scope), this._changes.setDirty()), this;
        }
        hasModel(e22) {
          return this.modelManager.hasModel(e22, this.scope);
        }
        removeModel(t2) {
          return this.hasModel(t2) ? (this.modelManager.removeModel(t2, this.scope), this) : this.fire(new e.a7(new Error("No model with this ID exists.")));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(t2, i2, o2 = {}) {
          if (this._checkLoaded(), void 0 !== this.getOwnSource(t2))
            throw new Error(`There is already a source with ID "${t2}".`);
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.cs, `sources.${t2}`, i2, null, o2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const r2 = st(t2, i2, this.dispatcher, this);
          r2.scope = this.scope, r2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(r2.id), source: r2.serialize(), sourceId: r2.id }));
          const s2 = (t3) => {
            const i3 = (t3 ? "symbol:" : "other:") + r2.id, o3 = e.aE(i3, this.scope), s3 = this._sourceCaches[i3] = new e.bq(o3, r2, t3);
            (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[r2.id] = s3, s3.onAdd(this.map);
          };
          s2(false), "vector" !== i2.type && "geojson" !== i2.type || s2(true), r2.onAdd && r2.onAdd(this.map), o2.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(t2) {
          this._checkLoaded();
          const i2 = this.getOwnSource(t2);
          if (!i2)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t2)
              return this.fire(new e.a7(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t2)
            return this.fire(new e.a7(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
          const o2 = this.getOwnSourceCaches(t2);
          for (const t3 of o2) {
            const i3 = e.cq(t3.id);
            delete this._sourceCaches[i3], this._changes.discardSourceCacheUpdate(t3.id), t3.fire(new e.a8("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
          }
          return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], this.mergeSources(), i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(e22, t2) {
          this._checkLoaded(), this.getOwnSource(e22).setData(t2), this._changes.setDirty();
        }
        getOwnSource(e22) {
          const t2 = this.getOwnSourceCache(e22);
          return t2 && t2.getSource();
        }
        getOwnSources() {
          const e22 = [];
          for (const t2 in this._otherSourceCaches) {
            const i2 = this.getOwnSourceCache(t2);
            i2 && e22.push(i2.getSource());
          }
          return e22;
        }
        areTilesLoaded() {
          const e22 = this._mergedSourceCaches;
          for (const t2 in e22) {
            const i2 = e22[t2]._tiles;
            for (const e3 in i2) {
              const t3 = i2[e3];
              if ("loaded" !== t3.state && "errored" !== t3.state)
                return false;
            }
          }
          return true;
        }
        setLights(t2) {
          if (this._checkLoaded(), !t2)
            return delete this.ambientLight, void delete this.directionalLight;
          const i2 = this._getTransitionParameters();
          for (const o3 of t2) {
            if (this._validate(e.ct, "lights", o3))
              return;
            switch (o3.type) {
              case "ambient":
                if (this.ambientLight) {
                  const e22 = this.ambientLight;
                  e22.set(o3), e22.updateTransitions(i2);
                } else
                  this.ambientLight = new qe(o3, $e, this.scope, this.options);
                break;
              case "directional":
                if (this.directionalLight) {
                  const e22 = this.directionalLight;
                  e22.set(o3), e22.updateTransitions(i2);
                } else
                  this.directionalLight = new qe(o3, Xe, this.scope, this.options);
            }
          }
          const o2 = new e.al(this.z || 0, i2);
          this.ambientLight && this.ambientLight.recalculate(o2), this.directionalLight && this.directionalLight.recalculate(o2), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
        }
        calculateLightsBrightness() {
          const t2 = this.directionalLight, i2 = this.ambientLight;
          if (!t2 || !i2)
            return;
          const o2 = (e22) => 0.2126 * (e22[0] <= 0.03928 ? e22[0] / 12.92 : Math.pow((e22[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e22[1] <= 0.03928 ? e22[1] / 12.92 : Math.pow((e22[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e22[2] <= 0.03928 ? e22[2] / 12.92 : Math.pow((e22[2] + 0.055) / 1.055, 2.4)), r2 = t2.properties.get("color").toArray01(), s2 = t2.properties.get("intensity"), n2 = t2.properties.get("direction"), a2 = 1 - e.b3(n2.x, n2.y, n2.z)[2] / 90, l2 = o2(r2) * s2 * a2, c2 = i2.properties.get("color").toArray01(), h22 = i2.properties.get("intensity");
          return (l2 + o2(c2) * h22) / 2;
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights())
            return null;
          const e22 = [];
          return this.directionalLight && e22.push(this.directionalLight.get()), this.ambientLight && e22.push(this.ambientLight.get()), e22;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(t2) {
          if (!t2)
            return this;
          if (e.cu(t2)) {
            const i2 = e.cv(t2), o2 = this.fragments.find(({ id: e22 }) => e22 === i2);
            if (!o2)
              throw new Error(`Style import not found: ${t2}`);
            const r2 = e.cq(t2);
            return o2.style.getFragmentStyle(r2);
          }
          {
            const e22 = this.fragments.find(({ id: e3 }) => e3 === t2);
            if (!e22)
              throw new Error(`Style import not found: ${t2}`);
            return e22.style;
          }
        }
        getConfigProperty(t2, i2) {
          const o2 = this.getFragmentStyle(t2);
          if (!o2)
            return null;
          const r2 = e.aE(i2, o2.scope), s2 = o2.options.get(r2), n2 = s2 ? s2.value || s2.default : null;
          return n2 ? n2.serialize() : null;
        }
        setConfigProperty(t2, i2, o2) {
          const r2 = e.cw(o2);
          if ("success" !== r2.result)
            return void Cr(this, r2.value);
          const s2 = r2.value.expression, n2 = this.getFragmentStyle(t2);
          if (!n2)
            return;
          const a2 = e.aE(i2, n2.scope), l2 = n2.options.get(a2);
          l2 && (this.options.set(a2, { ...l2, value: s2 }), this.updateConfigDependencies());
        }
        setConfig(t2, i2) {
          if (this._config = t2, t2 || i2)
            if (i2)
              for (const o2 in i2) {
                let r2, s2;
                const n2 = e.cw(i2[o2].default);
                if ("success" === n2.result && (r2 = n2.value.expression), t2 && void 0 !== t2[o2]) {
                  const i3 = e.cw(t2[o2]);
                  "success" === i3.result && (s2 = i3.value.expression);
                }
                const { minValue: a2, maxValue: l2, stepValue: c2, type: h22, values: _2 } = i2[o2];
                if (r2) {
                  const t3 = e.aE(o2, this.scope);
                  this.options.set(t3, { default: r2, value: s2, minValue: a2, maxValue: l2, stepValue: c2, type: h22, values: _2 });
                } else
                  this.fire(new e.a7(new Error(`No schema defined for config option "${o2}".`)));
              }
            else
              this.fire(new e.a7(new Error("Attempting to set config for a style without schema.")));
        }
        updateConfigDependencies() {
          for (const e22 of this._configDependentLayers) {
            const t2 = this.getLayer(e22);
            t2 && (t2.possiblyEvaluateVisibility(), this._updateLayer(t2));
          }
          this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this._changes.setDirty();
        }
        addLayer(t2, i2, o2 = {}) {
          this._checkLoaded();
          const r2 = t2.id;
          if (this._layers[r2])
            return void this.fire(new e.a7(new Error(`Layer with id "${r2}" already exists on this map`)));
          let s2;
          if ("custom" === t2.type) {
            if (Cr(this, e.cx(t2)))
              return;
            s2 = e.cp(t2, this.scope, this.options);
          } else {
            if ("object" == typeof t2.source && (this.addSource(r2, t2.source), t2 = e.co(t2), t2 = e.ak(t2, { source: r2 })), this._validate(e.cy, `layers.${r2}`, t2, { arrayIndex: -1 }, o2))
              return;
            s2 = e.cp(t2, this.scope, this.options), this._validateLayer(s2), s2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[s2.id] = s2.serialize();
          }
          s2.isConfigDependent && this._configDependentLayers.add(s2.fqid);
          let n2 = this._order.length;
          if (i2) {
            const t3 = this._order.indexOf(i2);
            if (-1 === t3)
              return void this.fire(new e.a7(new Error(`Layer with id "${i2}" does not exist on this map.`)));
            s2.slot === this._layers[i2].slot ? n2 = t3 : e.X(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(n2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = s2;
          const a2 = this.getOwnLayerSourceCache(s2), l2 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          a2 && s2.canCastShadows() && l2 && (a2.castsShadows = true);
          const c2 = this._changes.getRemovedLayer(s2);
          if (c2 && s2.source && a2 && "custom" !== s2.type) {
            this._changes.discardLayerRemoval(s2);
            const t3 = e.aE(s2.source, s2.scope);
            c2.type !== s2.type ? this._changes.updateSourceCache(t3, "clear") : (this._changes.updateSourceCache(t3, "reload"), a2.pause());
          }
          this._updateLayer(s2), s2.onAdd && s2.onAdd(this.map), s2.scope = this.scope, this.mergeLayers();
        }
        moveLayer(t2, i2) {
          this._checkLoaded();
          const o2 = this._checkLayer(t2);
          if (!o2)
            return;
          if (t2 === i2)
            return;
          const r2 = this._order.indexOf(t2);
          this._order.splice(r2, 1);
          let s2 = this._order.length;
          if (i2) {
            const t3 = this._order.indexOf(i2);
            if (-1 === t3)
              return void this.fire(new e.a7(new Error(`Layer with id "${i2}" does not exist on this map.`)));
            o2.slot === this._layers[i2].slot ? s2 = t3 : e.X(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(s2, 0, t2), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
        }
        removeLayer(e22) {
          this._checkLoaded();
          const t2 = this._checkLayer(e22);
          if (!t2)
            return;
          t2.setEventedParent(null);
          const i2 = this._order.indexOf(e22);
          this._order.splice(i2, 1), delete this._layers[e22], delete this._serializedLayers[e22], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t2.fqid), this._changes.removeLayer(t2);
          const o2 = this.getOwnLayerSourceCache(t2);
          if (o2 && o2.castsShadows) {
            let e3 = false;
            for (const i3 in this._layers)
              if (this._layers[i3].source === t2.source && this._layers[i3].canCastShadows()) {
                e3 = true;
                break;
              }
            o2.castsShadows = e3;
          }
          t2.onRemove && t2.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(e22) {
          return this._layers[e22];
        }
        hasLayer(e22) {
          return e22 in this._mergedLayers;
        }
        hasLayerType(e22) {
          for (const t2 in this._layers)
            if (this._layers[t2].type === e22)
              return true;
          return false;
        }
        setLayerZoomRange(e22, t2, i2) {
          this._checkLoaded();
          const o2 = this._checkLayer(e22);
          o2 && (o2.minzoom === t2 && o2.maxzoom === i2 || (null != t2 && (o2.minzoom = t2), null != i2 && (o2.maxzoom = i2), this._updateLayer(o2)));
        }
        setSlot(e22, t2) {
          this._checkLoaded();
          const i2 = this._checkLayer(e22);
          i2 && i2.slot !== t2 && (i2.slot = t2, this._updateLayer(i2));
        }
        setFilter(i2, o2, r2 = {}) {
          this._checkLoaded();
          const s2 = this._checkLayer(i2);
          if (s2 && !t(s2.filter, o2))
            return null == o2 ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(e.cz, `layers.${s2.id}.filter`, o2, { layerType: s2.type }, r2) || (s2.filter = e.co(o2), this._updateLayer(s2)));
        }
        getFilter(t2) {
          const i2 = this._checkLayer(t2);
          if (i2)
            return e.co(i2.filter);
        }
        setLayoutProperty(e22, i2, o2, r2 = {}) {
          this._checkLoaded();
          const s2 = this._checkLayer(e22);
          s2 && (t(s2.getLayoutProperty(i2), o2) || (s2.setLayoutProperty(i2, o2, r2), s2.isConfigDependent && this._configDependentLayers.add(s2.fqid), this._updateLayer(s2)));
        }
        getLayoutProperty(e22, t2) {
          const i2 = this._checkLayer(e22);
          if (i2)
            return i2.getLayoutProperty(t2);
        }
        setPaintProperty(e22, i2, o2, r2 = {}) {
          this._checkLoaded();
          const s2 = this._checkLayer(e22);
          if (!s2)
            return;
          if (t(s2.getPaintProperty(i2), o2))
            return;
          const n2 = s2.setPaintProperty(i2, o2, r2);
          s2.isConfigDependent && this._configDependentLayers.add(s2.fqid), n2 && this._updateLayer(s2), this._changes.updatePaintProperties(s2);
        }
        getPaintProperty(e22, t2) {
          const i2 = this._checkLayer(e22);
          if (i2)
            return i2.getPaintProperty(t2);
        }
        setFeatureState(t2, i2) {
          this._checkLoaded();
          const o2 = t2.source, r2 = t2.sourceLayer, s2 = this._checkSource(o2);
          if (!s2)
            return;
          const n2 = s2.type;
          if ("geojson" === n2 && r2)
            return void this.fire(new e.a7(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if ("vector" === n2 && !r2)
            return void this.fire(new e.a7(new Error("The sourceLayer parameter must be provided for vector source types.")));
          void 0 === t2.id && this.fire(new e.a7(new Error("The feature id parameter must be provided.")));
          const a2 = this.getOwnSourceCaches(o2);
          for (const e22 of a2)
            e22.setFeatureState(r2, t2.id, i2);
        }
        removeFeatureState(t2, i2) {
          this._checkLoaded();
          const o2 = t2.source, r2 = this._checkSource(o2);
          if (!r2)
            return;
          const s2 = r2.type, n2 = "vector" === s2 ? t2.sourceLayer : void 0;
          if ("vector" === s2 && !n2)
            return void this.fire(new e.a7(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (i2 && "string" != typeof t2.id && "number" != typeof t2.id)
            return void this.fire(new e.a7(new Error("A feature id is required to remove its specific state property.")));
          const a2 = this.getOwnSourceCaches(o2);
          for (const e22 of a2)
            e22.removeFeatureState(n2, t2.id, i2);
        }
        getFeatureState(t2) {
          this._checkLoaded();
          const i2 = t2.source, o2 = t2.sourceLayer, r2 = this._checkSource(i2);
          if (r2) {
            if ("vector" !== r2.type || o2)
              return void 0 === t2.id && this.fire(new e.a7(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i2)[0].getFeatureState(o2, t2.id);
            this.fire(new e.a7(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
        }
        setTransition(t2) {
          return this.stylesheet.transition = e.ak({}, this.stylesheet.transition, t2), this.transition = this.stylesheet.transition, this;
        }
        getTransition() {
          return e.ak({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const t2 = this.getTerrain(), i2 = t2 && this.terrain && this.terrain.scope === this.scope ? t2 : this.stylesheet.terrain;
          return e.cA({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i2, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e22) => void 0 !== e22);
        }
        _updateLayer(t2) {
          this._changes.updateLayer(t2);
          const i2 = this.getLayerSourceCache(t2), o2 = e.aE(t2.source, t2.scope), r2 = this._changes.getUpdatedSourceCaches();
          t2.source && !r2[o2] && i2 && "raster" !== i2.getSource().type && (this._changes.updateSourceCache(o2, "reload"), i2.pause()), t2.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(e22) {
          const t2 = (e3) => "fill-extrusion" === this._mergedLayers[e3].type, i2 = this.order, o2 = {}, r2 = [];
          for (let s3 = i2.length - 1; s3 >= 0; s3--) {
            const n2 = i2[s3];
            if (t2(n2)) {
              o2[n2] = s3;
              for (const t3 of e22) {
                const e3 = t3[n2];
                if (e3)
                  for (const t4 of e3)
                    r2.push(t4);
              }
            }
          }
          r2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const s2 = [];
          for (let n2 = i2.length - 1; n2 >= 0; n2--) {
            const a2 = i2[n2];
            if (t2(a2))
              for (let e3 = r2.length - 1; e3 >= 0; e3--) {
                const t3 = r2[e3].feature;
                if (o2[t3.layer.id] < n2)
                  break;
                s2.push(t3), r2.pop();
              }
            else
              for (const t3 of e22) {
                const e3 = t3[a2];
                if (e3)
                  for (const t4 of e3)
                    s2.push(t4.feature);
              }
          }
          return s2;
        }
        queryRenderedFeatures(t2, i2, o2) {
          i2 && i2.filter && this._validate(e.cz, "queryRenderedFeatures.filter", i2.filter, null, i2), i2.scope = this.scope, i2.availableImages = this._availableImages, i2.serializedLayers = this._serializedLayers;
          const r2 = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e.a7(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i2.layers) {
              const i3 = this._mergedLayers[t3];
              if (!i3)
                return this.fire(new e.a7(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
              r2[i3.source] = true;
            }
          }
          const s2 = [], n2 = i2.serializedLayers || {}, a2 = i2 && i2.layers ? i2.layers.some((e22) => {
            const t3 = this.getLayer(e22);
            return t3 && t3.is3D();
          }) : this.has3DLayers(), l2 = Je.createFromScreenPoints(t2, o2);
          for (const e22 in this._mergedSourceCaches) {
            const t3 = this._mergedSourceCaches[e22].getSource();
            if (!t3 || t3.scope !== i2.scope)
              continue;
            const c2 = this._mergedSourceCaches[e22].getSource().id;
            i2.layers && !r2[c2] || s2.push(at(this._mergedSourceCaches[e22], this._mergedLayers, n2, l2, i2, o2, a2, !!this.map._showQueryGeometry));
          }
          return this.placement && s2.push(function(e22, t3, i3, o3, r3, s3, n3) {
            const a3 = {}, l3 = s3.queryRenderedSymbols(o3), c2 = [];
            for (const e3 of Object.keys(l3).map(Number))
              c2.push(n3[e3]);
            c2.sort(ct);
            for (const i4 of c2) {
              const o4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, e22);
              for (const e3 in o4) {
                const t4 = a3[e3] = a3[e3] || [], r4 = o4[e3];
                r4.sort((e4, t5) => {
                  const o5 = i4.featureSortOrder;
                  if (o5) {
                    const i5 = o5.indexOf(e4.featureIndex);
                    return o5.indexOf(t5.featureIndex) - i5;
                  }
                  return t5.featureIndex - e4.featureIndex;
                });
                for (const e4 of r4)
                  t4.push(e4);
              }
            }
            for (const t4 in a3)
              a3[t4].forEach((o4) => {
                const r4 = o4.feature, s4 = i3(e22[t4]);
                if (!s4)
                  return;
                const n4 = s4.getFeatureState(r4.layer["source-layer"], r4.id);
                r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = n4;
              });
            return a3;
          }(this._mergedLayers, n2, this.getLayerSourceCache.bind(this), l2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s2);
        }
        querySourceFeatures(t2, i2) {
          i2 && i2.filter && this._validate(e.cz, "querySourceFeatures.filter", i2.filter, null, i2);
          const o2 = this.getOwnSourceCaches(t2);
          let r2 = [];
          for (const e22 of o2)
            r2 = r2.concat(lt(e22, i2));
          return r2;
        }
        addSourceType(e22, t2, i2) {
          return Dr.getSourceType(e22) ? i2(new Error(`A source type called "${e22}" already exists.`)) : (Dr.setSourceType(e22, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e22, url: t2.workerSourceURL }, i2) : i2(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(e22, i2, o2 = {}) {
          this._checkLoaded();
          const r2 = this.light.getLight();
          let s2 = false;
          for (const i3 in e22)
            if (!t(e22[i3], r2[i3])) {
              s2 = true;
              break;
            }
          if (!s2)
            return;
          const n2 = this._getTransitionParameters();
          this.light.setLight(e22, i2, o2), this.light.updateTransitions(n2);
        }
        getTerrain() {
          return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        setTerrain(i2, o2 = 1) {
          if (this._checkLoaded(), !i2)
            return delete this.terrain, null === i2 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          let r2 = i2;
          const s2 = null == i2.source;
          if (1 === o2) {
            if ("object" == typeof r2.source) {
              const t3 = "terrain-dem-src";
              this.addSource(t3, r2.source), r2 = e.co(r2), r2 = e.ak(r2, { source: t3 });
            }
            const t2 = e.ak({}, r2), i3 = {};
            if (this.terrain && s2) {
              t2.source = this.terrain.get().source;
              const e22 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              e22 && (i3.style = e22.serialize());
            }
            if (this._validate(e.cB, "terrain", t2, i3))
              return;
          }
          if (!this.terrain || this.terrain.scope !== this.scope && !s2 || this.terrain && o2 !== this.terrain.drapeRenderMode) {
            if (!r2)
              return;
            this._createTerrain(r2, o2), this.fire(new e.a8("data", { dataType: "style" }));
          } else {
            const o3 = this.terrain, s3 = o3.get();
            for (const t2 of Object.keys(e.ae.terrain))
              !r2.hasOwnProperty(t2) && e.ae.terrain[t2].default && (r2[t2] = e.ae.terrain[t2].default);
            for (const r3 in i2)
              if (!t(i2[r3], s3[r3])) {
                o3.set(i2, this.options), this.stylesheet.terrain = i2;
                const t2 = this._getTransitionParameters({ duration: 0 });
                o3.updateTransitions(t2), this.fire(new e.a8("data", { dataType: "style" }));
                break;
              }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
        }
        _createFog(e22) {
          const t2 = this.fog = new He(e22, this.map.transform);
          this.stylesheet.fog = t2.get();
          const i2 = this._getTransitionParameters({ duration: 0 });
          t2.updateTransitions(i2);
        }
        _updateMarkersOpacity() {
          0 !== this.map._markers.length && this.map._requestDomTask(() => {
            for (const e22 of this.map._markers)
              e22._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(e22) {
          if (this._checkLoaded(), !e22)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const i2 = this.fog;
            if (!t(i2.get(), e22)) {
              i2.set(e22), this.stylesheet.fog = i2.get();
              const t2 = this._getTransitionParameters({ duration: 0 });
              i2.updateTransitions(t2);
            }
          } else
            this._createFog(e22);
          this._markersNeedUpdate = true;
        }
        _getTransitionParameters(t2) {
          return { now: e.a4.now(), transition: e.ak(this.transition, t2) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain)
            return;
          const e22 = [], t2 = [];
          for (const i2 in this._mergedLayers)
            this.isLayerDraped(this._mergedLayers[i2]) ? e22.push(i2) : t2.push(i2);
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e22), this._drapedFirstOrder.push(...t2);
        }
        _createTerrain(e22, t2) {
          const i2 = this.terrain = new Be(e22, t2, this.scope, this.options);
          1 === t2 && (this.stylesheet.terrain = e22), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const o2 = this._getTransitionParameters({ duration: 0 });
          i2.updateTransitions(o2);
        }
        _force3DLayerUpdate() {
          for (const e22 in this._layers) {
            const t2 = this._layers[e22];
            "fill-extrusion" === t2.type && this._updateLayer(t2);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const e22 in this._layers) {
            const t2 = this._layers[e22];
            "symbol" === t2.type && this._updateLayer(t2);
          }
        }
        _validate(t2, i2, o2, r2, s2 = {}) {
          if (s2 && false === s2.validate)
            return false;
          const n2 = e.ak({}, this.serialize());
          return Cr(this, t2.call(e.aj, e.ak({ key: i2, style: n2, value: o2, styleSpec: e.ae }, r2)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.cC.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e22 in this._mergedLayers)
            this._mergedLayers[e22].setEventedParent(null);
          for (const e22 in this._mergedSourceCaches)
            this._mergedSourceCaches[e22].clearTiles(), this._mergedSourceCaches[e22].setEventedParent(null);
          this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
        }
        clearSource(e22) {
          const t2 = this.getSourceCaches(e22);
          for (const e3 of t2)
            e3.clearTiles();
        }
        clearSources() {
          for (const e22 in this._mergedSourceCaches)
            this._mergedSourceCaches[e22].clearTiles();
        }
        reloadSource(e22) {
          const t2 = this.getSourceCaches(e22);
          for (const e3 of t2)
            e3.resume(), e3.reload();
        }
        reloadSources() {
          for (const e22 of this.getSources())
            e22.reload && e22.reload();
        }
        updateSources(e22) {
          let t2;
          this.directionalLight && (t2 = br(this.directionalLight));
          for (const i2 in this._mergedSourceCaches)
            this._mergedSourceCaches[i2].update(e22, void 0, void 0, t2);
        }
        _generateCollisionBoxes() {
          for (const e22 in this._sourceCaches) {
            const t2 = this._sourceCaches[e22];
            t2.resume(), t2.reload();
          }
        }
        _updatePlacement(t2, i2, o2, r2, s2 = false) {
          let n2 = false, a2 = false;
          const l2 = {}, c2 = {};
          for (const i3 of this._mergedOrder) {
            const o3 = this._mergedLayers[i3];
            if ("symbol" !== o3.type)
              continue;
            const r3 = e.aE(o3.source, o3.scope);
            let s3 = l2[r3];
            if (!s3) {
              const e22 = this.getLayerSourceCache(o3);
              if (!e22)
                continue;
              const t3 = e22.getRenderableIds(true).map((t4) => e22.getTileByID(t4));
              c2[r3] = t3.slice(), s3 = l2[r3] = t3.sort((e3, t4) => t4.tileID.overscaledZ - e3.tileID.overscaledZ || (e3.tileID.isLessThan(t4.tileID) ? -1 : 1));
            }
            const a3 = this.crossTileSymbolIndex.addLayer(o3, s3, t2.center.lng, t2.projection);
            n2 = n2 || a3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), s2 = s2 || this._layerOrderChanged || 0 === o2, this._layerOrderChanged && this.fire(new e.a8("neworder")), (s2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.a4.now(), t2.zoom)) && (this.pauseablePlacement = new $t(t2, this._mergedOrder, s2, i2, o2, r2, this.placement, this.fog && t2.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l2, c2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.a4.now()), a2 = true), n2 && this.pauseablePlacement.placement.setStale()), a2 || n2)
            for (const t3 of this._mergedOrder) {
              const i3 = this._mergedLayers[t3];
              "symbol" === i3.type && this.placement.updateLayerOpacities(i3, l2[e.aE(i3.source, i3.scope)]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.a4.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e22 in this._sourceCaches)
            this._sourceCaches[e22].releaseSymbolFadeTiles();
        }
        addImport(t2) {
          this._checkLoaded();
          const i2 = this.stylesheet.imports = this.stylesheet.imports || [];
          return -1 !== i2.findIndex(({ id: e22 }) => e22 === t2.id) ? this.fire(new e.a7(new Error(`Import with id '${t2.id}' already exists in the map's style.`))) : (i2.push(t2), this._loadImports([t2], true), this);
        }
        setImportUrl(e22, t2) {
          this._checkLoaded();
          const i2 = this.stylesheet.imports || [], o2 = this.getImportIndex(e22);
          if (-1 === o2)
            return this;
          i2[o2].url = t2;
          const r2 = this.fragments[o2];
          return r2.style = this._createFragmentStyle(i2[o2]), r2.style.on("style.import.load", () => this.mergeAll()), r2.style.loadURL(t2), this;
        }
        setImportData(e22, t2) {
          this._checkLoaded();
          const i2 = this.getImportIndex(e22), o2 = this.stylesheet.imports || [];
          return -1 === i2 ? this : t2 ? (this.fragments[i2].style.setState(t2), this._reloadImports(), this) : (delete o2[i2].data, this.setImportUrl(e22, o2[i2].url));
        }
        setImportConfig(e22, t2) {
          this._checkLoaded();
          const i2 = this.getImportIndex(e22), o2 = this.stylesheet.imports || [];
          if (-1 === i2)
            return this;
          t2 ? o2[i2].config = t2 : delete o2[i2].config;
          const r2 = this.fragments[i2], s2 = r2.style.stylesheet && r2.style.stylesheet.schema;
          return r2.config = t2, r2.style.setConfig(t2, s2), this.updateConfigDependencies(), this;
        }
        removeImport(e22) {
          this._checkLoaded();
          const t2 = this.stylesheet.imports || [], i2 = this.getImportIndex(e22);
          return -1 === i2 || (t2.splice(i2, 1), this.fragments[i2].style._remove(), this.fragments.splice(i2, 1), this._reloadImports()), this;
        }
        getImportIndex(t2) {
          const i2 = (this.stylesheet.imports || []).findIndex((e22) => e22.id === t2);
          return -1 === i2 && this.fire(new e.a7(new Error(`Import '${t2}' does not exist in the map's style and cannot be updated.`))), i2;
        }
        getLayer(e22) {
          return this._mergedLayers[e22];
        }
        getSources() {
          const e22 = [];
          for (const t2 in this._mergedOtherSourceCaches) {
            const i2 = this._mergedOtherSourceCaches[t2];
            i2 && e22.push(i2.getSource());
          }
          return e22;
        }
        getSource(e22, t2) {
          const i2 = this.getSourceCache(e22, t2);
          return i2 && i2.getSource();
        }
        getLayerSource(e22) {
          const t2 = this.getLayerSourceCache(e22);
          return t2 && t2.getSource();
        }
        getSourceCache(t2, i2) {
          const o2 = e.aE(t2, i2);
          return this._mergedOtherSourceCaches[o2];
        }
        getLayerSourceCache(t2) {
          const i2 = e.aE(t2.source, t2.scope);
          return "symbol" === t2.type ? this._mergedSymbolSourceCaches[i2] : this._mergedOtherSourceCaches[i2];
        }
        getSourceCaches(e22) {
          const t2 = [];
          return this._mergedOtherSourceCaches[e22] && t2.push(this._mergedOtherSourceCaches[e22]), this._mergedSymbolSourceCaches[e22] && t2.push(this._mergedSymbolSourceCaches[e22]), t2;
        }
        updateSourceCaches() {
          const e22 = this._changes.getUpdatedSourceCaches();
          for (const t2 in e22) {
            const i2 = e22[t2];
            "reload" === i2 ? this.reloadSource(t2) : "clear" === i2 && this.clearSource(t2);
          }
        }
        updateLayers(e22) {
          const t2 = this._changes.getUpdatedPaintProperties();
          for (const i2 of t2) {
            const t3 = this.getLayer(i2);
            t3 && t3.updateTransitions(e22);
          }
        }
        getImages(e22, t2, i2) {
          this.imageManager.getImages(t2.icons, t2.scope, i2), this._updateTilesForChangedImages();
          const o2 = (e3) => {
            e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
          };
          o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
        }
        getGlyphs(e22, t2, i2) {
          this.glyphManager.getGlyphs(t2.stacks, t2.scope, i2);
        }
        getResource(t2, i2, o2) {
          return e.cD(i2, o2);
        }
        getOwnSourceCache(e22) {
          return this._otherSourceCaches[e22];
        }
        getOwnLayerSourceCache(e22) {
          return "symbol" === e22.type ? this._symbolSourceCaches[e22.source] : this._otherSourceCaches[e22.source];
        }
        getOwnSourceCaches(e22) {
          const t2 = [];
          return this._otherSourceCaches[e22] && t2.push(this._otherSourceCaches[e22]), this._symbolSourceCaches[e22] && t2.push(this._symbolSourceCaches[e22]), t2;
        }
        _isSourceCacheLoaded(t2) {
          const i2 = this.getOwnSourceCaches(t2);
          return 0 === i2.length ? (this.fire(new e.a7(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e22) => e22.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      function Ar(e22, t2) {
        let i2 = false, o2 = null;
        const r2 = () => {
          o2 = null, i2 && (e22(), o2 = setTimeout(r2, t2), i2 = false);
        };
        return () => (i2 = true, o2 || r2(), o2);
      }
      Dr.getSourceType = function(e22) {
        return rt[e22];
      }, Dr.setSourceType = function(e22, t2) {
        rt[e22] = t2;
      }, Dr.registerForPluginStateChange = e.ci;
      class Rr {
        constructor(t2) {
          this._hashName = t2 && encodeURIComponent(t2), e.aR(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Ar(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(e22) {
          return this._map = e22, window.addEventListener("hashchange", this._onHashChange, false), e22.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const e22 = this._map;
          if (!e22)
            return "";
          const t2 = zr(e22);
          if (this._hashName) {
            const e3 = this._hashName;
            let i2 = false;
            const o2 = location.hash.slice(1).split("&").map((o3) => {
              const r2 = o3.split("=")[0];
              return r2 === e3 ? (i2 = true, `${r2}=${t2}`) : o3;
            }).filter((e4) => e4);
            return i2 || o2.push(`${e3}=${t2}`), `#${o2.join("&")}`;
          }
          return `#${t2}`;
        }
        _getCurrentHash() {
          const e22 = location.hash.replace("#", "");
          if (this._hashName) {
            let t2;
            return e22.split("&").map((e3) => e3.split("=")).forEach((e3) => {
              e3[0] === this._hashName && (t2 = e3);
            }), (t2 && t2[1] || "").split("/");
          }
          return e22.split("/");
        }
        _onHashChange() {
          const e22 = this._map;
          if (!e22)
            return false;
          const t2 = this._getCurrentHash();
          if (t2.length >= 3 && !t2.some((e3) => isNaN(e3))) {
            const i2 = e22.dragRotate.isEnabled() && e22.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e22.getBearing();
            return e22.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
        }
      }
      function zr(e22, t2) {
        const i2 = e22.getCenter(), o2 = Math.round(100 * e22.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s2 = Math.pow(10, r2), n2 = Math.round(i2.lng * s2) / s2, a2 = Math.round(i2.lat * s2) / s2, l2 = e22.getBearing(), c2 = e22.getPitch();
        let h22 = t2 ? `/${n2}/${a2}/${o2}` : `${o2}/${a2}/${n2}`;
        return (l2 || c2) && (h22 += "/" + Math.round(10 * l2) / 10), c2 && (h22 += `/${Math.round(c2)}`), h22;
      }
      const Or = { linearity: 0.3, easing: e.cE(0, 0, 0.3, 1) }, Fr = e.ak({ deceleration: 2500, maxSpeed: 1400 }, Or), Br = e.ak({ deceleration: 20, maxSpeed: 1400 }, Or), kr = e.ak({ deceleration: 1e3, maxSpeed: 360 }, Or), Nr = e.ak({ deceleration: 1e3, maxSpeed: 90 }, Or);
      class Ur {
        constructor(e22) {
          this._map = e22, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.a4.now(), settings: t2 });
        }
        _drainInertiaBuffer() {
          const t2 = this._inertiaBuffer, i2 = e.a4.now();
          for (; t2.length > 0 && i2 - t2[0].time > 160; )
            t2.shift();
        }
        _onMoveEnd(t2) {
          if (this._map._prefersReducedMotion())
            return;
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e22 } of this._inertiaBuffer)
            i2.zoom += e22.zoomDelta || 0, i2.bearing += e22.bearingDelta || 0, i2.pitch += e22.pitchDelta || 0, e22.panDelta && i2.pan._add(e22.panDelta), e22.around && (i2.around = e22.around), e22.pinchAround && (i2.pinchAround = e22.pinchAround);
          const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
          if (i2.pan.mag()) {
            const s2 = jr(i2.pan.mag(), o2, e.ak({}, Fr, t2 || {}));
            r2.offset = i2.pan.mult(s2.amount / i2.pan.mag()), r2.center = this._map.transform.center, Gr(r2, s2);
          }
          if (i2.zoom) {
            const e22 = jr(i2.zoom, o2, Br);
            r2.zoom = this._map.transform.zoom + e22.amount, Gr(r2, e22);
          }
          if (i2.bearing) {
            const t3 = jr(i2.bearing, o2, kr);
            r2.bearing = this._map.transform.bearing + e.c(t3.amount, -179, 179), Gr(r2, t3);
          }
          if (i2.pitch) {
            const e22 = jr(i2.pitch, o2, Nr);
            r2.pitch = this._map.transform.pitch + e22.amount, Gr(r2, e22);
          }
          if (r2.zoom || r2.bearing) {
            const e22 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
            r2.around = e22 ? this._map.unproject(e22) : this._map.getCenter();
          }
          return this.clear(), r2.noMoveStart = true, r2;
        }
      }
      function Gr(e22, t2) {
        (!e22.duration || e22.duration < t2.duration) && (e22.duration = t2.duration, e22.easing = t2.easing);
      }
      function jr(t2, i2, o2) {
        const { maxSpeed: r2, linearity: s2, deceleration: n2 } = o2, a2 = e.c(t2 * s2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(a2) / (n2 * s2);
        return { easing: o2.easing, duration: 1e3 * l2, amount: a2 * (l2 / 2) };
      }
      class Vr extends e.a8 {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, o2, r2 = {}) {
          const s2 = p(i2.getCanvasContainer(), o2), n2 = i2.unproject(s2);
          super(t2, e.ak({ point: s2, lngLat: n2, originalEvent: o2 }, r2)), this._defaultPrevented = false, this.target = i2;
        }
      }
      class Zr extends e.a8 {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, o2) {
          const r2 = "touchend" === t2 ? o2.changedTouches : o2.touches, s2 = m(i2.getCanvasContainer(), r2), n2 = s2.map((e22) => i2.unproject(e22)), a2 = s2.reduce((e22, t3, i3, o3) => e22.add(t3.div(o3.length)), new e.P(0, 0));
          super(t2, { points: s2, point: a2, lngLats: n2, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
        }
      }
      class Wr extends e.a8 {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e22, t2, i2) {
          super(e22, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }
      class Hr {
        constructor(e22, t2) {
          this._map = e22, this._clickTolerance = t2.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(e22) {
          return this._firePreventable(new Wr(e22.type, this._map, e22));
        }
        mousedown(e22, t2) {
          return this._mousedownPos = t2, this._firePreventable(new Vr(e22.type, this._map, e22));
        }
        mouseup(e22) {
          this._map.fire(new Vr(e22.type, this._map, e22));
        }
        preclick(t2) {
          const i2 = e.ak({}, t2);
          i2.type = "preclick", this._map.fire(new Vr(i2.type, this._map, i2));
        }
        click(e22, t2) {
          this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e22), this._map.fire(new Vr(e22.type, this._map, e22)));
        }
        dblclick(e22) {
          return this._firePreventable(new Vr(e22.type, this._map, e22));
        }
        mouseover(e22) {
          this._map.fire(new Vr(e22.type, this._map, e22));
        }
        mouseout(e22) {
          this._map.fire(new Vr(e22.type, this._map, e22));
        }
        touchstart(e22) {
          return this._firePreventable(new Zr(e22.type, this._map, e22));
        }
        touchmove(e22) {
          this._map.fire(new Zr(e22.type, this._map, e22));
        }
        touchend(e22) {
          this._map.fire(new Zr(e22.type, this._map, e22));
        }
        touchcancel(e22) {
          this._map.fire(new Zr(e22.type, this._map, e22));
        }
        _firePreventable(e22) {
          if (this._map.fire(e22), e22.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class qr {
        constructor(e22) {
          this._map = e22;
        }
        reset() {
          this._delayContextMenu = false, this._contextMenuEvent = void 0;
        }
        mousemove(e22) {
          this._map.fire(new Vr(e22.type, this._map, e22));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Vr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e22) {
          this._delayContextMenu ? this._contextMenuEvent = e22 : this._map.fire(new Vr(e22.type, this._map, e22)), this._map.listens("contextmenu") && e22.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class $r {
        constructor(e22, t2) {
          this._map = e22, this._el = e22.getCanvasContainer(), this._container = e22.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e22, t2) {
          this.isEnabled() && e22.shiftKey && 0 === e22.button && (h(), this._startPos = this._lastPos = t2, this._active = true);
        }
        mousemoveWindow(e22, t2) {
          if (!this._active)
            return;
          const i2 = t2, o2 = this._startPos, r2 = this._lastPos;
          if (!o2 || !r2 || r2.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance)
            return;
          this._lastPos = i2, this._box || (this._box = s("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e22));
          const n2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), l2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${n2}px,${l2}px)`, this._box.style.width = a2 - n2 + "px", this._box.style.height = c2 - l2 + "px");
          });
        }
        mouseupWindow(t2, i2) {
          if (!this._active)
            return;
          const o2 = this._startPos, r2 = i2;
          if (o2 && 0 === t2.button) {
            if (this.reset(), u(), o2.x !== r2.x || o2.y !== r2.y)
              return this._map.fire(new e.a8("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e22) => e22.fitScreenCoordinates(o2, r2, this._map.getBearing(), { linear: false }) };
            this._fireEvent("boxzoomcancel", t2);
          }
        }
        keydown(e22) {
          this._active && 27 === e22.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e22));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), _(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t2, i2) {
          return this._map.fire(new e.a8(t2, { originalEvent: i2 }));
        }
      }
      function Xr(e22, t2) {
        const i2 = {};
        for (let o2 = 0; o2 < e22.length; o2++)
          i2[e22[o2].identifier] = t2[o2];
        return i2;
      }
      class Jr {
        constructor(e22) {
          this.reset(), this.numTouches = e22.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
        }
        touchstart(t2, i2, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e.P(0, 0);
            for (const e22 of t3)
              i3._add(e22);
            return i3.div(t3.length);
          }(i2), this.touches = Xr(o2, i2)));
        }
        touchmove(e22, t2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const o2 = Xr(i2, t2);
          for (const e3 in this.touches) {
            const t3 = o2[e3];
            (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
          }
        }
        touchend(e22, t2, i2) {
          if ((!this.centroid || e22.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }
      class Yr {
        constructor(e22) {
          this.singleTap = new Jr(e22), this.numTaps = e22.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(e22, t2, i2) {
          this.singleTap.touchstart(e22, t2, i2);
        }
        touchmove(e22, t2, i2) {
          this.singleTap.touchmove(e22, t2, i2);
        }
        touchend(e22, t2, i2) {
          const o2 = this.singleTap.touchend(e22, t2, i2);
          if (o2) {
            const t3 = e22.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e22.timeStamp, this.lastTap = o2, this.count === this.numTaps)
              return this.reset(), o2;
          }
        }
      }
      class Kr {
        constructor() {
          this._zoomIn = new Yr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Yr({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e22, t2, i2) {
          this._zoomIn.touchstart(e22, t2, i2), this._zoomOut.touchstart(e22, t2, i2);
        }
        touchmove(e22, t2, i2) {
          this._zoomIn.touchmove(e22, t2, i2), this._zoomOut.touchmove(e22, t2, i2);
        }
        touchend(e22, t2, i2) {
          const o2 = this._zoomIn.touchend(e22, t2, i2), r2 = this._zoomOut.touchend(e22, t2, i2);
          return o2 ? (this._active = true, e22.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e22 }) }) : r2 ? (this._active = true, e22.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r2) }, { originalEvent: e22 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const Qr = { 0: 1, 2: 2 };
      class es {
        constructor(e22) {
          this.reset(), this._clickTolerance = e22.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(e22, t2) {
          return false;
        }
        _move(e22, t2) {
          return {};
        }
        mousedown(e22, t2) {
          if (this._lastPoint)
            return;
          const i2 = f(e22);
          this._correctButton(e22, i2) && (this._lastPoint = t2, this._eventButton = i2);
        }
        mousemoveWindow(e22, t2) {
          const i2 = this._lastPoint;
          if (i2) {
            if (e22.preventDefault(), null != this._eventButton && function(e3, t3) {
              const i3 = Qr[t3];
              return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
            }(e22, this._eventButton))
              this.reset();
            else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
          }
        }
        mouseupWindow(e22) {
          this._lastPoint && f(e22) === this._eventButton && (this._moved && u(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ts extends es {
        mousedown(e22, t2) {
          super.mousedown(e22, t2), this._lastPoint && (this._active = true);
        }
        _correctButton(e22, t2) {
          return 0 === t2 && !e22.ctrlKey;
        }
        _move(e22, t2) {
          return { around: t2, panDelta: t2.sub(e22) };
        }
      }
      class is extends es {
        _correctButton(e22, t2) {
          return 0 === t2 && e22.ctrlKey || 2 === t2;
        }
        _move(e22, t2) {
          const i2 = 0.8 * (t2.x - e22.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }
        contextmenu(e22) {
          e22.preventDefault();
        }
      }
      class os extends es {
        _correctButton(e22, t2) {
          return 0 === t2 && e22.ctrlKey || 2 === t2;
        }
        _move(e22, t2) {
          const i2 = -0.5 * (t2.y - e22.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }
        contextmenu(e22) {
          e22.preventDefault();
        }
      }
      class rs {
        constructor(t2, i2) {
          this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.aR(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
        }
        touchstart(e22, t2, i2) {
          return this._calculateTransform(e22, t2, i2);
        }
        touchmove(t2, i2, o2) {
          if (this._active && !(o2.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (1 === o2.length && !e.cF())
                return void this._showTouchPanBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
          }
        }
        touchend(e22, t2, i2) {
          this._calculateTransform(e22, t2, i2), this._active && i2.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t2, i2, o2) {
          o2.length > 0 && (this._active = true);
          const r2 = Xr(o2, i2), s2 = new e.P(0, 0), n2 = new e.P(0, 0);
          let a2 = 0;
          for (const e22 in r2) {
            const t3 = r2[e22], i3 = this._touches[e22];
            i3 && (s2._add(t3), n2._add(t3.sub(i3)), a2++, r2[e22] = t3);
          }
          if (this._touches = r2, a2 < this._minTouches || !n2.mag())
            return;
          const l2 = n2.div(a2);
          return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: s2.div(a2), panDelta: l2 };
        }
        enable() {
          this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = s("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 500);
        }
      }
      class ss {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, this._firstTwoTouches = void 0;
        }
        _start(e22) {
        }
        _move(e22, t2, i2) {
          return {};
        }
        touchstart(e22, t2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
        }
        touchmove(e22, t2, i2) {
          const o2 = this._firstTwoTouches;
          if (!o2)
            return;
          e22.preventDefault();
          const [r2, s2] = o2, n2 = ns(i2, t2, r2), a2 = ns(i2, t2, s2);
          if (!n2 || !a2)
            return;
          const l2 = this._aroundCenter ? null : n2.add(a2).div(2);
          return this._move([n2, a2], l2, e22);
        }
        touchend(e22, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [o2, r2] = this._firstTwoTouches, s2 = ns(i2, t2, o2), n2 = ns(i2, t2, r2);
          s2 && n2 || (this._active && u(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e22) {
          this._enabled = true, this._aroundCenter = !!e22 && "center" === e22.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function ns(e22, t2, i2) {
        for (let o2 = 0; o2 < e22.length; o2++)
          if (e22[o2].identifier === i2)
            return t2[o2];
      }
      function as(e22, t2) {
        return Math.log(e22 / t2) / Math.LN2;
      }
      class ls extends ss {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(e22) {
          this._startDistance = this._distance = e22[0].dist(e22[1]);
        }
        _move(e22, t2) {
          const i2 = this._distance;
          if (this._distance = e22[0].dist(e22[1]), this._active || !(Math.abs(as(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: as(this._distance, i2), pinchAround: t2 };
        }
      }
      function cs(e22, t2) {
        return 180 * e22.angleWith(t2) / Math.PI;
      }
      class hs extends ss {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(e22) {
          this._startVector = this._vector = e22[0].sub(e22[1]), this._minDiameter = e22[0].dist(e22[1]);
        }
        _move(e22, t2) {
          const i2 = this._vector;
          if (this._vector = e22[0].sub(e22[1]), i2 && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = true, { bearingDelta: cs(this._vector, i2), pinchAround: t2 };
        }
        _isBelowThreshold(e22) {
          this._minDiameter = Math.min(this._minDiameter, e22.mag());
          const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
          if (!i2)
            return false;
          const o2 = cs(e22, i2);
          return Math.abs(o2) < t2;
        }
      }
      function _s(e22) {
        return Math.abs(e22.y) > Math.abs(e22.x);
      }
      class ds extends ss {
        constructor(e22) {
          super(), this._map = e22;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(e22) {
          this._lastPoints = e22, _s(e22[0].sub(e22[1])) && (this._valid = false);
        }
        _move(t2, i2, o2) {
          const r2 = this._lastPoints;
          if (!r2)
            return;
          const s2 = t2[0].sub(r2[0]), n2 = t2[1].sub(r2[1]);
          return this._map._cooperativeGestures && !e.cF() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(s2, n2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (s2.y + n2.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(e22, t2, i2) {
          if (void 0 !== this._valid)
            return this._valid;
          const o2 = e22.mag() >= 2, r2 = t2.mag() >= 2;
          if (!o2 && !r2)
            return;
          if (!o2 || !r2)
            return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
          const s2 = e22.y > 0 == t2.y > 0;
          return _s(e22) && _s(t2) && s2;
        }
      }
      const us = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class ps {
        constructor() {
          const e22 = us;
          this._panStep = e22.panStep, this._bearingStep = e22.bearingStep, this._pitchStep = e22.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e22) {
          if (e22.altKey || e22.ctrlKey || e22.metaKey)
            return;
          let t2 = 0, i2 = 0, o2 = 0, r2 = 0, s2 = 0;
          switch (e22.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t2 = -1;
              break;
            case 37:
              e22.shiftKey ? i2 = -1 : (e22.preventDefault(), r2 = -1);
              break;
            case 39:
              e22.shiftKey ? i2 = 1 : (e22.preventDefault(), r2 = 1);
              break;
            case 38:
              e22.shiftKey ? o2 = 1 : (e22.preventDefault(), s2 = -1);
              break;
            case 40:
              e22.shiftKey ? o2 = -1 : (e22.preventDefault(), s2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (n2) => {
            const a2 = n2.getZoom();
            n2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ms, zoom: t2 ? Math.round(a2) + t2 * (e22.shiftKey ? 2 : 1) : a2, bearing: n2.getBearing() + i2 * this._bearingStep, pitch: n2.getPitch() + o2 * this._pitchStep, offset: [-r2 * this._panStep, -s2 * this._panStep], center: n2.getCenter() }, { originalEvent: e22 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function ms(e22) {
        return e22 * (2 - e22);
      }
      const fs = 4.000244140625;
      class gs {
        constructor(t2, i2) {
          this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.aR(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(e22) {
          this._defaultZoomRate = e22;
        }
        setWheelZoomRate(e22) {
          this._wheelZoomRate = e22;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e22) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e22 && "center" === e22.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t2) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.cF()))
              return void this._showBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let i2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
          const o2 = e.a4.now(), r2 = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, 0 !== i2 && i2 % fs == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
        }
        _onTimeout(e22) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e22);
        }
        _start(e22) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t2 = p(this._el, e22);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t2 = this._map.transform;
          "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
          if (0 !== this._delta) {
            const e22 = "wheel" === this._type && Math.abs(this._delta) > fs ? this._wheelZoomRate : this._defaultZoomRate;
            let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e22)));
            this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
            const r3 = i2(), s3 = Math.pow(2, r3), n3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : s3;
            this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(n3 * o3))), "wheel" === this._type && (this._startZoom = r3, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
          }
          const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r2 = this._startZoom, s2 = this._easing;
          let n2, a2 = false;
          if ("wheel" === this._type && r2 && s2) {
            const t3 = Math.min((e.a4.now() - this._lastWheelEventTime) / 200, 1), i3 = s2(t3);
            n2 = e.n(r2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
          } else
            n2 = o2, a2 = true;
          this._active = true, a2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200));
          let l2 = n2 - i2();
          return l2 * this._lastDelta < 0 && (l2 = 0), { noInertia: true, needsRenderFrame: !a2, zoomDelta: l2, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t2) {
          let i2 = e.cG;
          if (this._prevEase) {
            const t3 = this._prevEase, o2 = (e.a4.now() - t3.start) / t3.duration, r2 = t3.easing(o2 + 0.01) - t3.easing(o2), s2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - s2 * s2);
            i2 = e.cE(s2, n2, 0.25, 1);
          }
          return this._prevEase = { start: e.a4.now(), duration: t2, easing: i2 }, i2;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = s("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 200);
        }
      }
      class vs {
        constructor(e22, t2) {
          this._clickZoom = e22, this._tapZoom = t2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class xs {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e22, t2) {
          return e22.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e22.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e22 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ys {
        constructor() {
          this._tap = new Yr({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(e22, t2, i2) {
          this._swipePoint || (this._tapTime && e22.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e22, t2, i2));
        }
        touchmove(e22, t2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const o2 = t2[0], r2 = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, e22.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
            }
          } else
            this._tap.touchmove(e22, t2, i2);
        }
        touchend(e22, t2, i2) {
          this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e22, t2, i2) && (this._tapTime = e22.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class bs {
        constructor(e22, t2, i2) {
          this._el = e22, this._mousePan = t2, this._touchPan = i2;
        }
        enable(e22) {
          this._inertiaOptions = e22 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class ws {
        constructor(e22, t2, i2) {
          this._pitchWithRotate = e22.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Ts {
        constructor(e22, t2, i2, o2) {
          this._el = e22, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e22) {
          this._touchZoom.enable(e22), this._rotationDisabled || this._touchRotate.enable(e22), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const Es = (e22) => e22.zoom || e22.drag || e22.pitch || e22.rotate;
      class Cs extends e.a8 {
      }
      class Is {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t2, i2) {
          const o2 = e.v.sub([], i2, t2);
          this.radius = e.v.length(o2[2] < 0 ? e.v.div([], o2, this.constants) : [o2[0], o2[1], 0]);
        }
        projectRay(t2) {
          e.v.div(t2, t2, this.constants), e.v.normalize(t2, t2), e.v.mul(t2, t2, this.constants);
          const i2 = e.v.scale([], t2, this.radius);
          if (i2[2] > 0) {
            const t3 = e.v.scale([], [0, 0, 1], e.v.dot(i2, [0, 0, 1])), o2 = e.v.scale([], e.v.normalize([], [i2[0], i2[1], 0]), this.radius), r2 = e.v.add([], i2, e.v.scale([], e.v.sub([], e.v.add([], o2, t3), i2), 2));
            i2[0] = r2[0], i2[1] = r2[1];
          }
          return i2;
        }
      }
      function Ss(e22) {
        return e22.panDelta && e22.panDelta.mag() || e22.zoomDelta || e22.bearingDelta || e22.pitchDelta;
      }
      class Ms {
        constructor(t2, i2) {
          this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ur(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Is(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.aR(["handleEvent", "handleWindowEvent"], this);
          const o2 = this._el;
          this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [e22, t3, i3] of this._listeners) {
            const o3 = e22 === document ? this.handleWindowEvent : this.handleEvent;
            e22.addEventListener(t3, o3, i3);
          }
        }
        destroy() {
          for (const [e22, t2, i2] of this._listeners) {
            const o2 = e22 === document ? this.handleWindowEvent : this.handleEvent;
            e22.removeEventListener(t2, o2, i2);
          }
        }
        _addDefaultHandlers(e22) {
          const t2 = this._map, i2 = t2.getCanvasContainer();
          this._add("mapEvent", new Hr(t2, e22));
          const o2 = t2.boxZoom = new $r(t2, e22);
          this._add("boxZoom", o2);
          const r2 = new Kr(), s2 = new xs();
          t2.doubleClickZoom = new vs(s2, r2), this._add("tapZoom", r2), this._add("clickZoom", s2);
          const n2 = new ys();
          this._add("tapDragZoom", n2);
          const a2 = t2.touchPitch = new ds(t2);
          this._add("touchPitch", a2);
          const l2 = new is(e22), c2 = new os(e22);
          t2.dragRotate = new ws(e22, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
          const h22 = new ts(e22), _2 = new rs(t2, e22);
          t2.dragPan = new bs(i2, h22, _2), this._add("mousePan", h22), this._add("touchPan", _2, ["touchZoom", "touchRotate"]);
          const d2 = new hs(), u2 = new ls();
          t2.touchZoomRotate = new Ts(i2, u2, d2, n2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", u2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new qr(t2));
          const p2 = t2.scrollZoom = new gs(t2, this);
          this._add("scrollZoom", p2, ["mousePan"]);
          const m2 = t2.keyboard = new ps();
          this._add("keyboard", m2);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e22.interactive && e22[i3] && t2[i3].enable(e22[i3]);
        }
        _add(e22, t2, i2) {
          this._handlers.push({ handlerName: e22, handler: t2, allowed: i2 }), this._handlersById[e22] = t2;
        }
        stop(e22) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e22), this._changes = [], this._originalZoom = void 0;
          }
        }
        isActive() {
          for (const { handler: e22 } of this._handlers)
            if (e22.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Es(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(e22, t2, i2) {
          for (const o2 in e22)
            if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e22) {
          this.handleEvent(e22, `${e22.type}Window`);
        }
        _getMapTouches(e22) {
          const t2 = [];
          for (const i2 of e22)
            this._el.contains(i2.target) && t2.push(i2);
          return t2;
        }
        handleEvent(e22, t2) {
          this._updatingCamera = true;
          const i2 = "renderFrame" === e22.type, o2 = i2 ? void 0 : e22, r2 = { needsRenderFrame: false }, s2 = {}, n2 = {}, a2 = e22.touches ? this._getMapTouches(e22.touches) : void 0, l2 = a2 ? m(this._el, a2) : i2 ? void 0 : p(this._el, e22);
          for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
            if (!c3.isEnabled())
              continue;
            let _2;
            this._blockedByActive(n2, h3, i3) ? c3.reset() : c3[t2 || e22.type] && (_2 = c3[t2 || e22.type](e22, l2, a2), this.mergeHandlerResult(r2, s2, _2, i3, o2), _2 && _2.needsRenderFrame && this._triggerRenderFrame()), (_2 || c3.isActive()) && (n2[i3] = c3);
          }
          const c2 = {};
          for (const e3 in this._previousActiveHandlers)
            n2[e3] || (c2[e3] = o2);
          this._previousActiveHandlers = n2, (Object.keys(c2).length || Ss(r2)) && (this._changes.push([r2, s2, c2]), this._triggerRenderFrame()), (Object.keys(n2).length || Ss(r2)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: h22 } = r2;
          h22 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h22(this._map));
        }
        mergeHandlerResult(t2, i2, o2, r2, s2) {
          if (!o2)
            return;
          e.ak(t2, o2);
          const n2 = { handlerName: r2, originalEvent: o2.originalEvent || s2 };
          void 0 !== o2.zoomDelta && (i2.zoom = n2), void 0 !== o2.panDelta && (i2.drag = n2), void 0 !== o2.pitchDelta && (i2.pitch = n2), void 0 !== o2.bearingDelta && (i2.rotate = n2);
        }
        _applyChanges() {
          const t2 = {}, i2 = {}, o2 = {};
          for (const [r2, s2, n2] of this._changes)
            r2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(r2.panDelta)), r2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r2.pitchDelta), void 0 !== r2.around && (t2.around = r2.around), void 0 !== r2.aroundCoord && (t2.aroundCoord = r2.aroundCoord), void 0 !== r2.pinchAround && (t2.pinchAround = r2.pinchAround), r2.noInertia && (t2.noInertia = r2.noInertia), e.ak(i2, s2), e.ak(o2, n2);
          this._updateMapTransform(t2, i2, o2), this._changes = [];
        }
        _updateMapTransform(t2, i2, o2) {
          const r2 = this._map, s2 = r2.transform, n2 = (e22) => [e22.x, e22.y, e22.z];
          if (((e22) => {
            const t3 = this._eventsInProgress.drag;
            return t3 && !this._handlersById[t3.handlerName].isActive();
          })() && !Ss(t2)) {
            const e22 = s2.zoom;
            s2.cameraElevationReference = "sea", null != this._originalZoom && s2._orthographicProjectionAtLowPitch && "globe" !== s2.projection.name && 0 === s2.pitch ? (s2.cameraElevationReference = "ground", s2.zoom = this._originalZoom) : (s2.recenterOnTerrain(), s2.cameraElevationReference = "ground"), e22 !== s2.zoom && this._map._update(true);
          }
          if (s2._isCameraConstrained && r2._stop(true), !Ss(t2))
            return void this._fireEvents(i2, o2, true);
          let { panDelta: a2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h22, around: _2, aroundCoord: d2, pinchAround: u2 } = t2;
          s2._isCameraConstrained && (l2 > 0 && (l2 = 0), s2._isCameraConstrained = false), void 0 !== u2 && (_2 = u2), (l2 || ((e22) => i2[e22] && !this._eventsInProgress[e22])("drag")) && _2 && (this._dragOrigin = n2(s2.pointCoordinate3D(_2)), this._originalZoom = s2.zoom, this._trackingEllipsoid.setup(s2._camera.position, this._dragOrigin)), s2.cameraElevationReference = "sea", r2._stop(true), _2 = _2 || r2.transform.centerPoint, c2 && (s2.bearing += c2), h22 && (s2.pitch += h22), s2._updateCameraState();
          const p2 = [0, 0, 0];
          if (a2)
            if ("mercator" === s2.projection.name) {
              const e22 = this._trackingEllipsoid.projectRay(s2.screenPointToMercatorRay(_2).dir), t3 = this._trackingEllipsoid.projectRay(s2.screenPointToMercatorRay(_2.sub(a2)).dir);
              p2[0] = t3[0] - e22[0], p2[1] = t3[1] - e22[1];
            } else {
              const t3 = s2.pointCoordinate(_2);
              if ("globe" === s2.projection.name) {
                a2 = a2.rotate(-s2.angle);
                const i3 = s2._pixelsPerMercatorPixel / s2.worldSize;
                p2[0] = -a2.x * e.cH(e.l(t3.y)) * i3, p2[1] = -a2.y * e.cH(s2.center.lat) * i3;
              } else {
                const e22 = s2.pointCoordinate(_2.sub(a2));
                t3 && e22 && (p2[0] = e22.x - t3.x, p2[1] = e22.y - t3.y);
              }
            }
          const m2 = s2.zoom, f2 = [0, 0, 0];
          if (l2) {
            const t3 = n2(d2 || s2.pointCoordinate3D(_2)), i3 = { dir: e.v.normalize([], e.v.sub([], t3, s2._camera.position)) };
            if (i3.dir[2] < 0) {
              const o3 = s2.zoomDeltaToMovement(t3, l2);
              e.v.scale(f2, i3.dir, o3);
            }
          }
          const g2 = e.v.add(p2, p2, f2);
          s2._translateCameraConstrained(g2), l2 && Math.abs(s2.zoom - m2) > 1e-4 && s2.recenterOnTerrain(), s2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
        }
        _fireEvents(t2, i2, o2) {
          const r2 = Es(this._eventsInProgress), s2 = Es(t2), n2 = {};
          for (const e22 in t2) {
            const { originalEvent: i3 } = t2[e22];
            this._eventsInProgress[e22] || (n2[`${e22}start`] = i3), this._eventsInProgress[e22] = t2[e22];
          }
          !r2 && s2 && this._fireEvent("movestart", s2.originalEvent);
          for (const e22 in n2)
            this._fireEvent(e22, n2[e22]);
          s2 && this._fireEvent("move", s2.originalEvent);
          for (const e22 in t2) {
            const { originalEvent: i3 } = t2[e22];
            this._fireEvent(e22, i3);
          }
          const a2 = {};
          let l2;
          for (const e22 in this._eventsInProgress) {
            const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e22];
            this._handlersById[t3].isActive() || (delete this._eventsInProgress[e22], l2 = i2[t3] || o3, a2[`${e22}end`] = l2);
          }
          for (const e22 in a2)
            this._fireEvent(e22, a2[e22]);
          const c2 = Es(this._eventsInProgress);
          if (o2 && (r2 || s2) && !c2) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e22) => 0 !== e22 && -this._bearingSnap < e22 && e22 < this._bearingSnap;
            t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.a8("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(t2, i2) {
          this._map.fire(new e.a8(t2, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e22) => {
            this._frameId = void 0, this.handleEvent(new Cs("renderFrame", { timeStamp: e22 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      const Ls = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class Ps extends e.a6 {
        constructor(t2, i2) {
          super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, this._respectPrefersReducedMotion = false !== i2.respectPrefersReducedMotion, e.aR(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new e.L(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e22, t2) {
          return this.jumpTo({ center: e22 }, t2);
        }
        panBy(t2, i2, o2) {
          return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.ak({ offset: t2 }, i2), o2);
        }
        panTo(t2, i2, o2) {
          return this.easeTo(e.ak({ center: t2 }, i2), o2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e22, t2) {
          return this.jumpTo({ zoom: e22 }, t2), this;
        }
        zoomTo(t2, i2, o2) {
          return this.easeTo(e.ak({ zoom: t2 }, i2), o2);
        }
        zoomIn(e22, t2) {
          return this.zoomTo(this.getZoom() + 1, e22, t2), this;
        }
        zoomOut(e22, t2) {
          return this.zoomTo(this.getZoom() - 1, e22, t2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e22, t2) {
          return this.jumpTo({ bearing: e22 }, t2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e22, t2) {
          return this.jumpTo({ padding: e22 }, t2), this;
        }
        rotateTo(t2, i2, o2) {
          return this.easeTo(e.ak({ bearing: t2 }, i2), o2);
        }
        resetNorth(t2, i2) {
          return this.rotateTo(0, e.ak({ duration: 1e3 }, t2), i2), this;
        }
        resetNorthPitch(t2, i2) {
          return this.easeTo(e.ak({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
        }
        snapToNorth(e22, t2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e22, t2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e22, t2) {
          return this.jumpTo({ pitch: e22 }, t2), this;
        }
        cameraForBounds(t2, i2) {
          t2 = e.D.convert(t2);
          const o2 = i2 && i2.bearing || 0, r2 = i2 && i2.pitch || 0, s2 = t2.getNorthWest(), n2 = t2.getSouthEast();
          return this._cameraForBounds(this.transform, s2, n2, o2, r2, i2);
        }
        _extendCameraOptions(t2) {
          const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if ("number" == typeof (t2 = e.ak({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding) {
            const e22 = t2.padding;
            t2.padding = { top: e22, bottom: e22, right: e22, left: e22 };
          }
          return t2.padding = e.ak(i2, t2.padding), t2;
        }
        _minimumAABBFrustumDistance(e22, t2) {
          const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
          return i2 / o2 > e22.aspect ? i2 / (2 * Math.tan(0.5 * e22.fovX) * e22.aspect) : o2 / (2 * Math.tan(0.5 * e22.fovY) * e22.aspect);
        }
        _cameraForBoundsOnGlobe(t2, i2, o2, r2, s2, n2) {
          const a2 = t2.clone(), l2 = this._extendCameraOptions(n2);
          a2.bearing = r2, a2.pitch = s2;
          const c2 = e.L.convert(i2), h22 = e.L.convert(o2), _2 = 0.5 * (c2.lat + h22.lat), d2 = 0.5 * (c2.lng + h22.lng), u2 = e.cI(_2, d2), p2 = e.v.normalize([], u2), m2 = e.v.normalize([], e.v.cross([], p2, [0, 1, 0])), f2 = e.v.cross([], m2, p2), g2 = [m2[0], m2[1], m2[2], 0, f2[0], f2[1], f2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v2 = [u2, e.cI(c2.lat, c2.lng), e.cI(h22.lat, c2.lng), e.cI(h22.lat, h22.lng), e.cI(c2.lat, h22.lng), e.cI(_2, c2.lng), e.cI(_2, h22.lng), e.cI(c2.lat, d2), e.cI(h22.lat, d2)];
          let x2 = e.c3.fromPoints(v2.map((t3) => [e.v.dot(m2, t3), e.v.dot(f2, t3), e.v.dot(p2, t3)]));
          const y2 = e.v.transformMat4([], x2.center, g2);
          0 === e.v.squaredLength(y2) && e.v.set(y2, 0, 0, 1), e.v.normalize(y2, y2), e.v.scale(y2, y2, e.aC), a2.center = e.cJ(y2);
          const b2 = a2.getWorldToCameraMatrix(), w2 = e.m.invert(new Float64Array(16), b2);
          x2 = e.c3.applyTransform(x2, e.m.multiply([], b2, g2)), e.v.transformMat4(y2, y2, b2);
          const T2 = 0.5 * (x2.max[2] - x2.min[2]), E2 = this._minimumAABBFrustumDistance(a2, x2), C2 = e.v.scale([], [0, 0, 1], T2), I2 = e.v.add(C2, y2, C2), S2 = E2 + (0 === a2.pitch ? 0 : e.v.distance(y2, I2)), M2 = a2.globeCenterInViewSpace, L2 = e.v.sub([], y2, [M2[0], M2[1], M2[2]]);
          e.v.normalize(L2, L2), e.v.scale(L2, L2, S2);
          const P2 = e.v.add([], y2, L2);
          e.v.transformMat4(P2, P2, w2);
          const D2 = e.cL / e.aC, A2 = e.v.length(P2), R2 = e.b(Math.max(A2 * D2 - e.cL, Number.EPSILON), 0), z2 = Math.min(a2.zoomFromMercatorZAdjusted(R2), l2.maxZoom);
          return z2 > 0.5 * (e.Z + e.G) ? (a2.setProjection({ name: "mercator" }), a2.zoom = z2, this._cameraForBounds(a2, i2, o2, r2, s2, n2)) : { center: a2.center, zoom: z2, bearing: r2, pitch: s2 };
        }
        queryTerrainElevation(t2, i2) {
          const o2 = this.transform.elevation;
          return o2 ? (i2 = e.ak({}, { exaggerated: true }, i2), o2.getAtPoint(e.M.fromLngLat(t2), null, i2.exaggerated)) : null;
        }
        _cameraForBounds(t2, i2, o2, r2, s2, n2) {
          if ("globe" === t2.projection.name)
            return this._cameraForBoundsOnGlobe(t2, i2, o2, r2, s2, n2);
          const a2 = t2.clone(), l2 = this._extendCameraOptions(n2), c2 = a2.padding;
          a2.bearing = r2, a2.pitch = s2;
          const h22 = e.L.convert(i2), _2 = e.L.convert(o2), d2 = new e.L(h22.lng, _2.lat), u2 = new e.L(_2.lng, h22.lat), p2 = a2.project(h22), m2 = a2.project(_2), f2 = this.queryTerrainElevation(h22), g2 = this.queryTerrainElevation(_2), v2 = this.queryTerrainElevation(d2), x2 = this.queryTerrainElevation(u2), y2 = [[p2.x, p2.y, Math.min(f2 || 0, g2 || 0, v2 || 0, x2 || 0)], [m2.x, m2.y, Math.max(f2 || 0, g2 || 0, v2 || 0, x2 || 0)]];
          let b2 = e.c3.fromPoints(y2);
          const w2 = a2.getWorldToCameraMatrix(), T2 = e.m.invert(new Float64Array(16), w2);
          b2 = e.c3.applyTransform(b2, w2);
          const E2 = e.v.sub([], b2.max, b2.min), C2 = c2.left || 0, I2 = c2.right || 0, S2 = c2.bottom || 0, M2 = c2.top || 0, { left: L2, right: P2, top: D2, bottom: A2 } = l2.padding, R2 = 0.5 * (C2 + I2), z2 = 0.5 * (M2 + S2), O2 = Math.min(a2.scaleZoom(a2.scale * Math.min((a2.width - (C2 + I2 + L2 + P2)) / E2[0], (a2.height - (S2 + M2 + A2 + D2)) / E2[1])), l2.maxZoom), F2 = a2.scale / a2.zoomScale(O2);
          b2 = new e.c3([b2.min[0] - (L2 + R2) * F2, b2.min[1] - (A2 + z2) * F2, b2.min[2]], [b2.max[0] + (P2 + R2) * F2, b2.max[1] + (D2 + z2) * F2, b2.max[2]]);
          const B2 = 0.5 * E2[2], k2 = this._minimumAABBFrustumDistance(a2, b2), N2 = [0, 0, 1, 0];
          e.e.transformMat4(N2, N2, w2), e.e.normalize(N2, N2);
          const U2 = e.v.scale([], N2, k2 + B2), G2 = e.v.add([], b2.center, U2), j2 = ("number" == typeof l2.offset.x && "number" == typeof l2.offset.y ? new e.P(l2.offset.x, l2.offset.y) : e.P.convert(l2.offset)).rotate(-e.d(r2));
          b2.center[0] -= j2.x * F2, b2.center[1] += j2.y * F2, e.v.transformMat4(b2.center, b2.center, T2), e.v.transformMat4(G2, G2, T2);
          const V2 = [b2.center[0], b2.center[1], G2[2] * a2.pixelsPerMeter];
          e.v.scale(V2, V2, 1 / a2.worldSize);
          const Z2 = e.cK(V2[0]), W2 = e.l(V2[1]), H2 = Math.min(a2._zoomFromMercatorZ(V2[2]), l2.maxZoom), q2 = new e.L(Z2, W2);
          return a2.mercatorFromTransition && H2 < 0.5 * (e.Z + e.G) ? (a2.setProjection({ name: "globe" }), a2.zoom = H2, this._cameraForBounds(a2, i2, o2, r2, s2, n2)) : { center: q2, zoom: H2, bearing: r2, pitch: s2 };
        }
        fitBounds(e22, t2, i2) {
          const o2 = this.cameraForBounds(e22, t2);
          return this._fitInternal(o2, t2, i2);
        }
        fitScreenCoordinates(t2, i2, o2, r2, s2) {
          const n2 = e.P.convert(t2), a2 = e.P.convert(i2), l2 = new e.P(Math.min(n2.x, a2.x), Math.min(n2.y, a2.y)), c2 = new e.P(Math.max(n2.x, a2.x), Math.max(n2.y, a2.y));
          if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n2, a2))
            return this;
          const h22 = this.transform.pointLocation3D(l2), _2 = this.transform.pointLocation3D(c2), d2 = this.transform.pointLocation3D(new e.P(l2.x, c2.y)), u2 = this.transform.pointLocation3D(new e.P(c2.x, l2.y)), p2 = [Math.min(h22.lng, _2.lng, d2.lng, u2.lng), Math.min(h22.lat, _2.lat, d2.lat, u2.lat)], m2 = [Math.max(h22.lng, _2.lng, d2.lng, u2.lng), Math.max(h22.lat, _2.lat, d2.lat, u2.lat)], f2 = r2 && r2.pitch ? r2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, m2, o2, f2, r2);
          return this._fitInternal(g2, r2, s2);
        }
        _fitInternal(t2, i2, o2) {
          return t2 ? (delete (i2 = e.ak(t2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
        }
        jumpTo(t2, i2) {
          this.stop();
          const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
          let r2 = false, s2 = false, n2 = false;
          return "zoom" in t2 && o2.zoom !== +t2.zoom && (r2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.L.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (s2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (n2 = true, o2.pitch = +t2.pitch), null == t2.padding || o2.isPaddingEqual(t2.padding) || (o2.padding = t2.padding), t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.a8("movestart", i2)).fire(new e.a8("move", i2)), r2 && this.fire(new e.a8("zoomstart", i2)).fire(new e.a8("zoom", i2)).fire(new e.a8("zoomend", i2)), s2 && this.fire(new e.a8("rotatestart", i2)).fire(new e.a8("rotate", i2)).fire(new e.a8("rotateend", i2)), n2 && this.fire(new e.a8("pitchstart", i2)).fire(new e.a8("pitch", i2)).fire(new e.a8("pitchend", i2)), this.fire(new e.a8("moveend", i2)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || e.X(Ls), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t2, i2) {
          const o2 = this.transform;
          if (!o2.projection.supportsFreeCamera)
            return e.X(Ls), this;
          this.stop();
          const r2 = o2.zoom, s2 = o2.pitch, n2 = o2.bearing;
          o2.setFreeCameraOptions(t2);
          const a2 = r2 !== o2.zoom, l2 = s2 !== o2.pitch, c2 = n2 !== o2.bearing;
          return this.fire(new e.a8("movestart", i2)).fire(new e.a8("move", i2)), a2 && this.fire(new e.a8("zoomstart", i2)).fire(new e.a8("zoom", i2)).fire(new e.a8("zoomend", i2)), c2 && this.fire(new e.a8("rotatestart", i2)).fire(new e.a8("rotate", i2)).fire(new e.a8("rotateend", i2)), l2 && this.fire(new e.a8("pitchstart", i2)).fire(new e.a8("pitch", i2)).fire(new e.a8("pitchend", i2)), this.fire(new e.a8("moveend", i2)), this;
        }
        easeTo(t2, i2) {
          this._stop(false, t2.easeId), (false === (t2 = e.ak({ offset: [0, 0], duration: 500, easing: e.cG }, t2)).animate || this._prefersReducedMotion(t2)) && (t2.duration = 0);
          const o2 = this.transform, r2 = this.getZoom(), s2 = this.getBearing(), n2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, s2) : s2, h22 = "pitch" in t2 ? +t2.pitch : n2, _2 = "padding" in t2 ? t2.padding : o2.padding, d2 = e.P.convert(t2.offset);
          let u2, p2, m2;
          if ("globe" === o2.projection.name) {
            const i3 = e.M.fromLngLat(o2.center), r3 = d2.rotate(-o2.angle);
            i3.x += r3.x / o2.worldSize, i3.y += r3.y / o2.worldSize;
            const s3 = i3.toLngLat(), n3 = e.L.convert(t2.center || s3);
            this._normalizeCenter(n3), u2 = o2.centerPoint.add(r3), p2 = new e.P(i3.x, i3.y).mult(o2.worldSize), m2 = new e.P(e.E(n3.lng), e.H(n3.lat)).mult(o2.worldSize).sub(p2);
          } else {
            u2 = o2.centerPoint.add(d2);
            const i3 = o2.pointLocation(u2), r3 = e.L.convert(t2.center || i3);
            this._normalizeCenter(r3), p2 = o2.project(i3), m2 = o2.project(r3).sub(p2);
          }
          const f2 = o2.zoomScale(l2 - r2);
          let g2, v2;
          t2.around && (g2 = e.L.convert(t2.around), v2 = o2.locationPoint(g2));
          const x2 = this._zooming || l2 !== r2, y2 = this._rotating || s2 !== c2, b2 = this._pitching || h22 !== n2, w2 = !o2.isPaddingEqual(_2), T2 = (o3) => (T3) => {
            if (x2 && (o3.zoom = e.n(r2, l2, T3)), y2 && (o3.bearing = e.n(s2, c2, T3)), b2 && (o3.pitch = e.n(n2, h22, T3)), w2 && (o3.interpolatePadding(a2, _2, T3), u2 = o3.centerPoint.add(d2)), g2)
              o3.setLocationAtPoint(g2, v2);
            else {
              const e22 = o3.zoomScale(o3.zoom - r2), t3 = l2 > r2 ? Math.min(2, f2) : Math.max(0.5, f2), i3 = Math.pow(t3, 1 - T3), s3 = o3.unproject(p2.add(m2.mult(T3 * i3)).mult(e22));
              o3.setLocationAtPoint(o3.renderWorldCopies ? s3.wrap() : s3, u2);
            }
            return t2.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t2.preloadOnly) {
            const e22 = this._emulate(T2, t2.duration, o2);
            return this._preloadTiles(e22), this;
          }
          const E2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = x2, this._rotating = y2, this._pitching = b2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, E2), this._ease(T2(o2), (e22) => {
            "sea" === o2.cameraElevationReference && o2.recenterOnTerrain(), this._afterEase(i2, e22);
          }, t2), this;
        }
        _prepareEase(t2, i2, o2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i2 || o2.moving || this.fire(new e.a8("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.a8("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.a8("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.a8("pitchstart", t2));
        }
        _fireMoveEvents(t2) {
          this.fire(new e.a8("move", t2)), this._zooming && this.fire(new e.a8("zoom", t2)), this._rotating && this.fire(new e.a8("rotate", t2)), this._pitching && this.fire(new e.a8("pitch", t2));
        }
        _afterEase(t2, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const o2 = this._zooming, r2 = this._rotating, s2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, o2 && this.fire(new e.a8("zoomend", t2)), r2 && this.fire(new e.a8("rotateend", t2)), s2 && this.fire(new e.a8("pitchend", t2)), this.fire(new e.a8("moveend", t2));
        }
        flyTo(t2, i2) {
          if (this._prefersReducedMotion(t2)) {
            const o3 = e.p(t2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(o3, i2);
          }
          this.stop(), t2 = e.ak({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.cG }, t2);
          const o2 = this.transform, r2 = this.getZoom(), s2 = this.getBearing(), n2 = this.getPitch(), a2 = "zoom" in t2 ? e.c(+t2.zoom, o2.minZoom, o2.maxZoom) : r2, l2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, s2) : s2, c2 = "pitch" in t2 ? +t2.pitch : n2, h22 = o2.zoomScale(a2 - r2), _2 = e.P.convert(t2.offset), d2 = o2.centerPoint.add(_2), u2 = o2.pointLocation(d2);
          let p2 = t2.center;
          if (p2 && t2.padding) {
            const e22 = this._cameraForBounds(this.transform, p2, p2, l2, c2, t2);
            e22 && (p2 = e22.center);
          }
          p2 = e.L.convert(p2 || u2), this._normalizeCenter(p2);
          const m2 = o2.project(u2), f2 = o2.project(p2).sub(m2);
          let g2 = t2.curve;
          const v2 = Math.max(o2.width, o2.height), x2 = v2 / h22, y2 = f2.mag();
          if ("minZoom" in t2) {
            const i3 = e.c(Math.min(t2.minZoom, r2, a2), o2.minZoom, o2.maxZoom), s3 = v2 / o2.zoomScale(i3 - r2);
            g2 = Math.sqrt(s3 / y2 * 2);
          }
          const b2 = g2 * g2;
          function w2(e22) {
            const t3 = (x2 * x2 - v2 * v2 + (e22 ? -1 : 1) * b2 * b2 * y2 * y2) / (2 * (e22 ? x2 : v2) * b2 * y2);
            return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
          }
          function T2(e22) {
            return (Math.exp(e22) - Math.exp(-e22)) / 2;
          }
          function E2(e22) {
            return (Math.exp(e22) + Math.exp(-e22)) / 2;
          }
          const C2 = w2(0);
          let I2 = function(e22) {
            return E2(C2) / E2(C2 + g2 * e22);
          }, S2 = function(e22) {
            return v2 * ((E2(C2) * (T2(t3 = C2 + g2 * e22) / E2(t3)) - T2(C2)) / b2) / y2;
            var t3;
          }, M2 = (w2(1) - C2) / g2;
          if (Math.abs(y2) < 1e-6 || !isFinite(M2)) {
            if (Math.abs(v2 - x2) < 1e-6)
              return this.easeTo(t2, i2);
            const e22 = x2 < v2 ? -1 : 1;
            M2 = Math.abs(Math.log(x2 / v2)) / g2, S2 = function() {
              return 0;
            }, I2 = function(t3) {
              return Math.exp(e22 * g2 * t3);
            };
          }
          t2.duration = "duration" in t2 ? +t2.duration : 1e3 * M2 / ("screenSpeed" in t2 ? +t2.screenSpeed / g2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
          const L2 = s2 !== l2, P2 = c2 !== n2, D2 = (o3) => (h3) => {
            const _3 = h3 * M2, u3 = 1 / I2(_3);
            o3.zoom = 1 === h3 ? a2 : r2 + o3.scaleZoom(u3), L2 && (o3.bearing = e.n(s2, l2, h3)), P2 && (o3.pitch = e.n(n2, c2, h3));
            const g3 = 1 === h3 ? p2 : o3.unproject(m2.add(f2.mult(S2(_3))).mult(u3));
            return o3.setLocationAtPoint(o3.renderWorldCopies ? g3.wrap() : g3, d2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
          };
          if (t2.preloadOnly) {
            const e22 = this._emulate(D2, t2.duration, o2);
            return this._preloadTiles(e22), this;
          }
          return this._zooming = true, this._rotating = L2, this._pitching = P2, this._prepareEase(i2, false), this._ease(D2(o2), () => this._afterEase(i2), t2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e22, t2) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            this._onEaseEnd = void 0, e3.call(this, t2);
          }
          if (!e22) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(t2, i2, o2) {
          false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.a4.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t2 = Math.min((e.a4.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
          i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t2, i2) {
          t2 = e.w(t2, -180, 180);
          const o2 = Math.abs(t2 - i2);
          return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
        }
        _normalizeCenter(e22) {
          const t2 = this.transform;
          if (t2.maxBounds)
            return;
          if ("globe" !== t2.projection.name && !t2.renderWorldCopies)
            return;
          const i2 = e22.lng - t2.center.lng;
          e22.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        _prefersReducedMotion(t2) {
          return this._respectPrefersReducedMotion && e.a4.prefersReducedMotion && !(t2 && t2.essential);
        }
        _emulate(e22, t2, i2) {
          const o2 = Math.ceil(15 * t2 / 1e3), r2 = [], s2 = e22(i2.clone());
          for (let e3 = 0; e3 <= o2; e3++) {
            const t3 = s2(e3 / o2);
            r2.push(t3.clone());
          }
          return r2;
        }
      }
      class Ds {
        constructor(t2 = {}) {
          this.options = t2, e.aR(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e22) {
          const t2 = this.options && this.options.compact;
          return this._map = e22, this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = s("button", "mapboxgl-ctrl-attrib-button", this._container), s("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = s("div", "mapboxgl-ctrl-attrib-inner", this._container), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e22, t2) {
          const i2 = this._map._getUIString(`AttributionControl.${t2}`);
          e22.removeAttribute("title"), e22.firstElementChild && e22.firstElementChild.setAttribute("title", i2);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t2 = this._editLink;
          t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.cM.ACCESS_TOKEN }];
          if (t2) {
            const o2 = i2.reduce((e22, t3, o3) => (t3.value && (e22 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e22), "?");
            t2.href = `${e.cM.FEEDBACK_URL}/${o2}#${zr(this._map, true)}`, t2.rel = "noopener nofollow", this._setElementTitle(t2, "MapFeedback");
          }
        }
        _updateData(e22) {
          !e22 || "metadata" !== e22.sourceDataType && "visibility" !== e22.sourceDataType && "style" !== e22.dataType || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e22 = [];
          if (this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t2 = this._map.style._mergedSourceCaches;
          for (const i3 in t2) {
            const o2 = t2[i3];
            if (o2.used) {
              const t3 = o2.getSource();
              t3.attribution && e22.indexOf(t3.attribution) < 0 && e22.push(t3.attribution);
            }
          }
          e22.sort((e3, t3) => e3.length - t3.length), e22 = e22.filter((t3, i3) => {
            for (let o2 = i3 + 1; o2 < e22.length; o2++)
              if (e22[o2].indexOf(t3) >= 0)
                return false;
            return true;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e22 = [...this.options.customAttribution, ...e22] : e22.unshift(this.options.customAttribution));
          const i2 = e22.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e22.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class As {
        constructor() {
          e.aR(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(e22) {
          this._map = e22, this._container = s("div", "mapboxgl-ctrl");
          const t2 = s("a", "mapboxgl-ctrl-logo");
          return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e22) {
          e22 && "metadata" !== e22.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e22 = this._map.style._sourceCaches;
          if (0 === Object.entries(e22).length)
            return true;
          for (const t2 in e22) {
            const i2 = e22[t2].getSource();
            if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e22 = this._container.children;
          if (e22.length) {
            const t2 = e22[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Rs {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e22) {
          const t2 = ++this._id;
          return this._queue.push({ callback: e22, id: t2, cancelled: false }), t2;
        }
        remove(e22) {
          const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
          for (const t3 of i2)
            if (t3.id === e22)
              return void (t3.cancelled = true);
        }
        run(e22 = 0) {
          const t2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t2)
            if (!i2.cancelled && (i2.callback(e22), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      function zs(t2, i2, o2) {
        if (t2 = new e.L(t2.lng, t2.lat), i2) {
          const r2 = new e.L(t2.lng - 360, t2.lat), s2 = new e.L(t2.lng + 360, t2.lat), n2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
          o2.locationPoint(r2).distSqr(i2) < a2 && (l2 || Math.abs(r2.lng - o2.center.lng) < n2) ? t2 = r2 : o2.locationPoint(s2).distSqr(i2) < a2 && (l2 || Math.abs(s2.lng - o2.center.lng) < n2) && (t2 = s2);
        }
        for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
          const e22 = o2.locationPoint(t2);
          if (e22.x >= 0 && e22.y >= 0 && e22.x <= o2.width && e22.y <= o2.height)
            break;
          t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
        }
        return t2;
      }
      const Os = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class Fs extends e.a6 {
        constructor(t2, i2) {
          if (super(), (t2 instanceof HTMLElement || i2) && (t2 = e.ak({ element: t2 }, i2)), e.aR(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t2 && t2.occludedOpacity || 0.2, t2 && t2.element)
            this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = s("div");
            const i3 = 41, o3 = 27, r3 = n("svg", { display: "block", height: i3 * this._scale + "px", width: o3 * this._scale + "px", viewBox: `0 0 ${o3} ${i3}` }, this._element), a2 = n("radialGradient", { id: "shadowGradient" }, n("defs", {}, r3));
            n("stop", { offset: "10%", "stop-opacity": 0.4 }, a2), n("stop", { offset: "100%", "stop-opacity": 0.05 }, a2), n("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), n("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), n("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), n("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e.P.convert(t2 && t2.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e22) => {
            e22.preventDefault();
          }), this._element.addEventListener("mousedown", (e22) => {
            e22.preventDefault();
          });
          const o2 = this._element.classList;
          for (const e22 in Os)
            o2.remove(`mapboxgl-marker-anchor-${e22}`);
          o2.add(`mapboxgl-marker-anchor-${this._anchor}`);
          const r2 = t2 && t2.className ? t2.className.trim().split(/\s+/) : [];
          o2.add(...r2), this._popup = null;
        }
        addTo(e22) {
          return e22 === this._map || (this.remove(), this._map = e22, e22.getCanvasContainer().appendChild(this._element), e22.on("move", this._updateMoving), e22.on("moveend", this._update), e22.on("remove", this._clearFadeTimer), e22._addMarker(this), this.setDraggable(this._draggable), this._update(), e22.on("click", this._onMapClick)), this;
        }
        remove() {
          const e22 = this._map;
          return e22 && (e22.off("click", this._onMapClick), e22.off("move", this._updateMoving), e22.off("moveend", this._update), e22.off("mousedown", this._addDragHandler), e22.off("touchstart", this._addDragHandler), e22.off("mouseup", this._onUp), e22.off("touchend", this._onUp), e22.off("mousemove", this._onMove), e22.off("touchmove", this._onMove), e22.off("remove", this._clearFadeTimer), e22._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.L.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e22) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e22) {
            if (!("offset" in e22.options)) {
              const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
              e22.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
            }
            this._popup = e22, e22._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(e22) {
          const t2 = e22.code, i2 = e22.charCode || e22.keyCode;
          "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
        }
        _onMapClick(e22) {
          const t2 = e22.originalEvent.target, i2 = this._element;
          this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e22 = this._popup;
          return e22 ? (e22.isOpen() ? (e22.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e22.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const e22 = this._map, t2 = this._pos;
          if (!e22 || !t2)
            return false;
          const i2 = e22.unproject(t2), o2 = e22.getFreeCameraOptions();
          if (!o2.position)
            return false;
          const r2 = o2.position.toLngLat();
          return r2.distanceTo(i2) < 0.9 * r2.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t2 = this._map;
          if (!t2)
            return;
          const i2 = this._pos;
          if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height)
            return void this._clearFadeTimer();
          const o2 = t2.unproject(i2);
          let r2;
          t2._showingGlobe() && e.cN(t2.transform, this._lngLat) ? r2 = 0 : (r2 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (r2 *= this._occludedOpacity)), this._element.style.opacity = `${r2}`, this._element.style.pointerEvents = r2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r2), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const e22 = this._pos;
          if (!e22 || !this._map)
            return;
          const t2 = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${e22.x}px,${e22.y}px)
            ${Os[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
        }
        _calculateXYTransform() {
          const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
          if (!i2 || !t2 || "map" !== o2)
            return "";
          if (!i2._showingGlobe()) {
            const e22 = i2.getPitch();
            return e22 ? `rotateX(${e22}deg)` : "";
          }
          const r2 = e.Y(e.cO(i2.transform, this._lngLat)), s2 = t2.sub(e.cP(i2.transform)), n2 = Math.abs(s2.x) + Math.abs(s2.y);
          if (0 === n2)
            return "";
          const a2 = r2 / n2;
          return `rotateX(${-s2.y * a2}deg) rotateY(${s2.x * a2}deg)`;
        }
        _calculateZTransform() {
          const t2 = this._pos, i2 = this._map;
          if (!i2 || !t2)
            return "";
          let o2 = 0;
          const r2 = this.getRotationAlignment();
          if ("map" === r2)
            if (i2._showingGlobe()) {
              const t3 = i2.project(new e.L(this._lngLat.lng, this._lngLat.lat + 1e-3)), r3 = i2.project(new e.L(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t3);
              o2 = e.Y(Math.atan2(r3.y, r3.x)) - 90;
            } else
              o2 = -i2.getBearing();
          else if ("horizon" === r2) {
            const r3 = e.an(4, 6, i2.getZoom()), s2 = e.cP(i2.transform);
            s2.y += r3 * i2.transform.height;
            const n2 = t2.sub(s2), a2 = e.Y(Math.atan2(n2.y, n2.x));
            o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - r3);
          }
          return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
        }
        _update(e22) {
          cancelAnimationFrame(this._updateFrameId);
          const t2 = this._map;
          t2 && (t2.transform.renderWorldCopies && (this._lngLat = zs(this._lngLat, this._pos, t2.transform)), this._pos = t2.project(this._lngLat), true === e22 ? this._updateFrameId = requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), t2._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t2._showingGlobe() || t2.getTerrain() || t2.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t2) {
          return this._offset = e.P.convert(t2), this._update(), this;
        }
        addClassName(e22) {
          return this._element.classList.add(e22), this;
        }
        removeClassName(e22) {
          return this._element.classList.remove(e22), this;
        }
        toggleClassName(e22) {
          return this._element.classList.toggle(e22);
        }
        _onMove(t2) {
          const i2 = this._map;
          if (!i2)
            return;
          const o2 = this._pointerdownPos, r2 = this._positionDelta;
          if (o2 && r2) {
            if (!this._isDragging) {
              const e22 = this._clickTolerance || i2._clickTolerance;
              if (t2.point.dist(o2) < e22)
                return;
              this._isDragging = true;
            }
            this._pos = t2.point.sub(r2), this._lngLat = i2.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.a8("dragstart"))), this.fire(new e.a8("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
          const t2 = this._map;
          t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.a8("dragend")), this._state = "inactive";
        }
        _addDragHandler(e22) {
          const t2 = this._map, i2 = this._pos;
          t2 && i2 && this._element.contains(e22.originalEvent.target) && (e22.preventDefault(), this._positionDelta = e22.point.sub(i2), this._pointerdownPos = e22.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
        }
        setDraggable(e22) {
          this._draggable = !!e22;
          const t2 = this._map;
          return t2 && (e22 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e22) {
          return this._rotation = e22 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e22) {
          return this._rotationAlignment = e22 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(e22) {
          return this._pitchAlignment = e22 || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(e22) {
          return this._occludedOpacity = e22 || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const Bs = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, ks = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Ns(t2 = new e.P(0, 0), i2 = "bottom") {
        if ("number" == typeof t2) {
          const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
          switch (i2) {
            case "top":
              return new e.P(0, t2);
            case "top-left":
              return new e.P(o2, o2);
            case "top-right":
              return new e.P(-o2, o2);
            case "bottom":
              return new e.P(0, -t2);
            case "bottom-left":
              return new e.P(o2, -o2);
            case "bottom-right":
              return new e.P(-o2, -o2);
            case "left":
              return new e.P(t2, 0);
            case "right":
              return new e.P(-t2, 0);
          }
          return new e.P(0, 0);
        }
        return t2 instanceof e.P || Array.isArray(t2) ? e.P.convert(t2) : e.P.convert(t2[i2] || [0, 0]);
      }
      class Us {
        constructor(e22) {
          this.jumpTo(e22);
        }
        getValue(t2) {
          if (t2 <= this._startTime)
            return this._start;
          if (t2 >= this._endTime)
            return this._end;
          const i2 = e.ba((t2 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i2) + this._end * i2;
        }
        isEasing(e22) {
          return e22 >= this._startTime && e22 <= this._endTime;
        }
        jumpTo(e22) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e22, this._end = e22;
        }
        easeTo(e22, t2, i2) {
          this._start = this.getValue(t2), this._end = e22, this._startTime = t2, this._endTime = t2 + i2;
        }
      }
      const Gs = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, js = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false };
      class Vs {
        constructor() {
          this.showOverdrawInspector = false, this.showTileBoundaries = false, this.continuousRedraw = false, this.showTerrainWireframe = false, this.showLayers2DWireframe = false, this.showLayers3DWireframe = false;
        }
      }
      const Zs = { showCompass: true, showZoom: true, visualizePitch: false };
      class Ws {
        constructor(t2, i2, o2 = false) {
          this._clickTolerance = 10, this.element = i2, this.mouseRotate = new is({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new os({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.aR(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
        }
        down(e22, t2) {
          this.mouseRotate.mousedown(e22, t2), this.mousePitch && this.mousePitch.mousedown(e22, t2), h();
        }
        move(e22, t2) {
          const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e22, t2), r2 = o2 && o2.bearingDelta;
          if (r2 && i2.setBearing(i2.getBearing() + r2), this.mousePitch) {
            const o3 = this.mousePitch.mousemoveWindow(e22, t2), r3 = o3 && o3.pitchDelta;
            r3 && i2.setPitch(i2.getPitch() + r3);
          }
        }
        off() {
          const e22 = this.element;
          e22.removeEventListener("mousedown", this.mousedown), e22.removeEventListener("touchstart", this.touchstart, { passive: false }), e22.removeEventListener("touchmove", this.touchmove), e22.removeEventListener("touchend", this.touchend), e22.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          _(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t2) {
          this.down(e.ak({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), p(this.element, t2)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(e22) {
          this.move(e22, p(this.element, e22));
        }
        mouseup(e22) {
          this.mouseRotate.mouseupWindow(e22), this.mousePitch && this.mousePitch.mouseupWindow(e22), this.offTemp();
        }
        touchstart(e22) {
          1 !== e22.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e22.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e22.preventDefault() }, this._startPos));
        }
        touchmove(e22) {
          1 !== e22.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e22.targetTouches)[0], this.move({ preventDefault: () => e22.preventDefault() }, this._lastPos));
        }
        touchend(e22) {
          0 === e22.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const Hs = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, qs2 = { maxWidth: 100, unit: "metric" }, $s = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, Xs = { version: e.c$, supported: i, setRTLTextPlugin: e.d1, getRTLTextPluginStatus: e.d2, Map: class extends Ps {
        constructor(t2) {
          const i2 = t2;
          if (null != (t2 = e.ak({}, js, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t2.minPitch && t2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (null != t2.maxPitch && t2.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2.antialias && e.cQ(window) && (t2.antialias = false, e.X("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new De(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._repaint = false, this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new Rs(), this._domRenderTaskQueue = new Rs(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.cR(), this._locale = e.ak({}, Gs, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Us(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e.cS(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, this._contextCreateOptions = t2.contextCreateOptions ? { ...t2.contextCreateOptions } : {}, "string" == typeof t2.container) {
            const e22 = document.getElementById(t2.container);
            if (!e22)
              throw new Error(`Container '${t2.container.toString()}' not found.`);
            this._container = e22;
          } else {
            if (!(t2.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t2.container;
          }
          if (this._container.childNodes.length > 0 && e.X("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.aR(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._debugParams = new Vs(), this._tp = t2.devtools ? new dr(this) : new dr(), this._tp.registerParameter(this._debugParams, ["Debug"], "showOverdrawInspector", void 0, () => {
            this._update();
          }), this._tp.registerParameter(this._debugParams, ["Debug"], "showTileBoundaries", void 0, () => {
            this._update();
          }), this._tp.registerParameter(this._debugParams, ["Debug"], "continuousRedraw", void 0, (e22) => {
            this.repaint = e22;
          }), this._tp.registerParameter(this._debugParams, ["Debug", "Wireframe"], "showTerrainWireframe", void 0, () => {
            this._update();
          }), this._tp.registerParameter(this._debugParams, ["Debug", "Wireframe"], "showLayers2DWireframe", void 0, () => {
            this._update();
          }), this._tp.registerParameter(this._debugParams, ["Debug", "Wireframe"], "showLayers3DWireframe", void 0, () => {
            this._update();
          }), this._setupPainter(), void 0 === this.painter)
            throw new Error("Failed to initialize WebGL.");
          if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new Ms(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, (t2.style || !t2.testMode) && this.setStyle(t2.style || e.cM.DEFAULT_STYLE, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), t2.hash && (this._hash = new Rr("string" == typeof t2.hash && t2.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
            null == i2.center && null == i2.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch });
            const o2 = t2.bounds;
            o2 && (this.resize(), this.fitBounds(o2, e.ak({}, t2.fitBoundsOptions, { duration: 0 })));
          }
          this.resize(), t2.attributionControl && this.addControl(new Ds({ customAttribution: t2.customAttribution })), this._logoControl = new As(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (t3) => {
            this._update("style" === t3.dataType), this.fire(new e.a8(`${t3.dataType}data`, t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e.a8(`${t3.dataType}dataloading`, t3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t2, i2) {
          if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
            return this.fire(new e.a7(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o2 = t2.onAdd(this);
          this._controls.push(t2);
          const r2 = this._controlPositions[i2];
          return -1 !== i2.indexOf("bottom") ? r2.insertBefore(o2, r2.firstChild) : r2.appendChild(o2), this;
        }
        removeControl(t2) {
          if (!t2 || !t2.onRemove)
            return this.fire(new e.a7(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t2);
          return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
        }
        hasControl(e22) {
          return this._controls.indexOf(e22) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t2) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i2 = !this._moving;
          return i2 && this.fire(new e.a8("movestart", t2)).fire(new e.a8("move", t2)), this.fire(new e.a8("resize", t2)), i2 && this.fire(new e.a8("moveend", t2)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(t2) {
          return this.transform.setMaxBounds(e.D.convert(t2)), this._update();
        }
        setMinZoom(t2) {
          if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
            return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.a8("zoomstart")).fire(new e.a8("zoom")).fire(new e.a8("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t2) {
          if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
            return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.a8("zoomstart")).fire(new e.a8("zoom")).fire(new e.a8("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t2) {
          if ((t2 = null == t2 ? 0 : t2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t2 >= 0 && t2 <= this.transform.maxPitch)
            return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.a8("pitchstart")).fire(new e.a8("pitch")).fire(new e.a8("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t2) {
          if ((t2 = null == t2 ? 85 : t2) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2 >= this.transform.minPitch)
            return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.a8("pitchstart")).fire(new e.a8("pitch")).fire(new e.a8("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e22) {
          return this.transform.renderWorldCopies = e22, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(e22) {
          return "auto" === e22 ? navigator.language : Array.isArray(e22) ? 0 === e22.length ? void 0 : e22.map((e3) => "auto" === e3 ? navigator.language : e3) : e22;
        }
        setLanguage(e22) {
          const t2 = this._parseLanguage(e22);
          if (!this.style || t2 === this._language)
            return this;
          this._language = t2, this.style.reloadSources();
          for (const e3 of this._controls)
            e3._setLanguage && e3._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(e22) {
          return this.style && e22 !== this._worldview ? (this._worldview = e22, this.style.reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return "globe" === this.transform.projection.name;
        }
        setProjection(e22) {
          return this._lazyInitEmptyStyle(), e22 ? "string" == typeof e22 && (e22 = { name: e22 }) : e22 = null, this._useExplicitProjection = !!e22, this._prioritizeAndUpdateProjection(e22, this.style.projection);
        }
        _updateProjectionTransition() {
          if ("globe" !== this.getProjection().name)
            return;
          const t2 = this.transform, i2 = t2.projection.name;
          let o2;
          "globe" === i2 && t2.zoom >= e.G ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.G && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(e22, t2) {
          return this._updateProjection(e22 || t2 || { name: "mercator" });
        }
        _updateProjection(t2) {
          let i2;
          return i2 = "globe" === t2.name && this.transform.zoom >= e.G ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
        }
        project(t2) {
          return this.transform.locationPoint3D(e.L.convert(t2));
        }
        unproject(t2) {
          return this.transform.pointLocation3D(e.P.convert(t2));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || false;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || false;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || false;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || false;
        }
        _createDelegatedListener(e22, t2, i2) {
          if ("mouseenter" === e22 || "mouseover" === e22) {
            let o2 = false;
            const r2 = (r3) => {
              const s3 = t2.filter((e3) => this.getLayer(e3)), n2 = s3.length ? this.queryRenderedFeatures(r3.point, { layers: s3 }) : [];
              n2.length ? o2 || (o2 = true, i2.call(this, new Vr(e22, this, r3.originalEvent, { features: n2 }))) : o2 = false;
            }, s2 = () => {
              o2 = false;
            };
            return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: s2 } };
          }
          if ("mouseleave" === e22 || "mouseout" === e22) {
            let o2 = false;
            const r2 = (r3) => {
              const s3 = t2.filter((e3) => this.getLayer(e3));
              (s3.length ? this.queryRenderedFeatures(r3.point, { layers: s3 }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new Vr(e22, this, r3.originalEvent)));
            }, s2 = (t3) => {
              o2 && (o2 = false, i2.call(this, new Vr(e22, this, t3.originalEvent)));
            };
            return { layers: new Set(t2), listener: i2, delegates: { mousemove: r2, mouseout: s2 } };
          }
          {
            const o2 = (e3) => {
              const o3 = t2.filter((e4) => this.getLayer(e4)), r2 = o3.length ? this.queryRenderedFeatures(e3.point, { layers: o3 }) : [];
              r2.length && (e3.features = r2, i2.call(this, e3), delete e3.features);
            };
            return { layers: new Set(t2), listener: i2, delegates: { [e22]: o2 } };
          }
        }
        on(e22, t2, i2) {
          if (void 0 === i2)
            return super.on(e22, t2);
          if (Array.isArray(t2) || (t2 = [t2]), t2) {
            for (const e3 of t2)
              if (!this._isValidId(e3))
                return this;
          }
          const o2 = this._createDelegatedListener(e22, t2, i2);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e22] = this._delegatedListeners[e22] || [], this._delegatedListeners[e22].push(o2);
          for (const e3 in o2.delegates)
            this.on(e3, o2.delegates[e3]);
          return this;
        }
        once(e22, t2, i2) {
          if (void 0 === i2)
            return super.once(e22, t2);
          if (Array.isArray(t2) || (t2 = [t2]), t2) {
            for (const e3 of t2)
              if (!this._isValidId(e3))
                return this;
          }
          const o2 = this._createDelegatedListener(e22, t2, i2);
          for (const e3 in o2.delegates)
            this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e22, t2, i2) {
          if (void 0 === i2)
            return super.off(e22, t2);
          t2 = new Set(Array.isArray(t2) ? t2 : [t2]);
          for (const e3 of t2)
            if (!this._isValidId(e3))
              return this;
          const o2 = (e3, t3) => {
            if (e3.size !== t3.size)
              return false;
            for (const i3 of e3)
              if (!t3.has(i3))
                return false;
            return true;
          }, r2 = this._delegatedListeners ? this._delegatedListeners[e22] : void 0;
          return r2 && ((e3) => {
            for (let r3 = 0; r3 < e3.length; r3++) {
              const s2 = e3[r3];
              if (s2.listener === i2 && o2(s2.layers, t2)) {
                for (const e4 in s2.delegates)
                  this.off(e4, s2.delegates[e4]);
                return e3.splice(r3, 1), this;
              }
            }
          })(r2), this;
        }
        queryRenderedFeatures(t2, i2) {
          if (!this.style)
            return [];
          if (void 0 !== i2 || void 0 === t2 || t2 instanceof e.P || Array.isArray(t2) || (i2 = t2, t2 = void 0), t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], (i2 = i2 || {}).layers && Array.isArray(i2.layers)) {
            for (const e22 of i2.layers)
              if (!this._isValidId(e22))
                return [];
          }
          return this.style.queryRenderedFeatures(t2, i2, this.transform);
        }
        querySourceFeatures(e22, t2) {
          return this._isValidId(e22) ? this.style.querySourceFeatures(e22, t2) : [];
        }
        isPointOnSurface(t2) {
          const { name: i2 } = this.transform.projection;
          return "globe" !== i2 && "mercator" !== i2 && e.X(`${i2} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t2));
        }
        setStyle(t2, i2) {
          return false !== (i2 = e.ak({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
        }
        _getUIString(e22) {
          const t2 = this._locale[e22];
          if (null == t2)
            throw new Error(`Missing UI string '${e22}'`);
          return t2;
        }
        _updateStyle(e22, t2) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e22 && (this.style = new Dr(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e22 ? this.style.loadURL(e22) : this.style.loadJSON(e22)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Dr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(t2, i2) {
          if ("string" == typeof t2) {
            const o2 = this._requestManager.normalizeStyleURL(t2), r2 = this._requestManager.transformRequest(o2, e.a2.Style);
            e.a1(r2, (t3, o3) => {
              t3 ? this.fire(new e.a7(t3)) : o3 && this._updateDiff(o3, i2);
            });
          } else
            "object" == typeof t2 && this._updateDiff(t2, i2);
        }
        _updateDiff(t2, i2) {
          try {
            this.style.setState(t2) && this._update(true);
          } catch (o2) {
            e.X(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e.X("There is no style added to the map."), false);
        }
        _isValidId(t2) {
          return null == t2 ? (this.fire(new e.a7(new Error("IDs can't be empty."))), false) : !e.cu(t2) || (this.fire(new e.a7(new Error(`IDs can't contain special symbols: "${t2}".`))), false);
        }
        addSource(e22, t2) {
          return this._isValidId(e22) ? (this._lazyInitEmptyStyle(), this.style.addSource(e22, t2), this._update(true)) : this;
        }
        isSourceLoaded(e22) {
          return !!this._isValidId(e22) && !!this.style && this.style._isSourceCacheLoaded(e22);
        }
        areTilesLoaded() {
          return this.style.areTilesLoaded();
        }
        addSourceType(e22, t2, i2) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e22, t2, i2);
        }
        removeSource(e22) {
          return this._isValidId(e22) ? (this.style.removeSource(e22), this._updateTerrain(), this._update(true)) : this;
        }
        getSource(e22) {
          return this._isValidId(e22) ? this.style.getOwnSource(e22) : null;
        }
        addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r2 = false, stretchX: s2, stretchY: n2, content: a2 } = {}) {
          if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap) {
            const { width: l2, height: c2, data: h22 } = e.a4.getImageData(i2);
            this.style.addImage(t2, { data: new e.a5({ width: l2, height: c2 }, h22), pixelRatio: o2, stretchX: s2, stretchY: n2, content: a2, sdf: r2, version: 0 });
          } else if (void 0 === i2.width || void 0 === i2.height)
            this.fire(new e.a7(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: l2, height: c2 } = i2, h22 = i2;
            this.style.addImage(t2, { data: new e.a5({ width: l2, height: c2 }, new Uint8Array(h22.data)), pixelRatio: o2, stretchX: s2, stretchY: n2, content: a2, sdf: r2, version: 0, userImage: h22 }), h22.onAdd && h22.onAdd(this, t2);
          }
        }
        updateImage(t2, i2) {
          this._lazyInitEmptyStyle();
          const o2 = this.style.getImage(t2);
          if (!o2)
            return void this.fire(new e.a7(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r2 = i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap ? e.a4.getImageData(i2) : i2, { width: s2, height: n2 } = r2, a2 = r2.data;
          if (void 0 === s2 || void 0 === n2)
            return void this.fire(new e.a7(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (s2 !== o2.data.width || n2 !== o2.data.height)
            return void this.fire(new e.a7(new Error(`The width and height of the updated image (${s2}, ${n2})
                must be that same as the previous version of the image
                (${o2.data.width}, ${o2.data.height})`)));
          const l2 = !(i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap);
          o2.data.replace(a2, l2), this.style.updateImage(t2, o2);
        }
        hasImage(t2) {
          return t2 ? !!this.style && !!this.style.getImage(t2) : (this.fire(new e.a7(new Error("Missing required image id"))), false);
        }
        removeImage(e22) {
          this.style.removeImage(e22);
        }
        loadImage(t2, i2) {
          e.a3(this._requestManager.transformRequest(t2, e.a2.Image), (t3, o2) => {
            i2(t3, o2 instanceof HTMLImageElement ? e.a4.getImageData(o2) : o2);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addModel(e22, t2) {
          this._lazyInitEmptyStyle(), this.style.addModel(e22, t2);
        }
        hasModel(t2) {
          return t2 ? this.style.hasModel(t2) : (this.fire(new e.a7(new Error("Missing required model id"))), false);
        }
        removeModel(e22) {
          this.style.removeModel(e22);
        }
        listModels() {
          return this.style.listModels();
        }
        addLayer(e22, t2) {
          return this._isValidId(e22.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e22, t2), this._update(true)) : this;
        }
        moveLayer(e22, t2) {
          return this._isValidId(e22) ? (this.style.moveLayer(e22, t2), this._update(true)) : this;
        }
        removeLayer(e22) {
          return this._isValidId(e22) ? (this.style.removeLayer(e22), this._update(true)) : this;
        }
        getLayer(e22) {
          return this._isValidId(e22) ? this.style.getOwnLayer(e22) : null;
        }
        setLayerZoomRange(e22, t2, i2) {
          return this._isValidId(e22) ? (this.style.setLayerZoomRange(e22, t2, i2), this._update(true)) : this;
        }
        setFilter(e22, t2, i2 = {}) {
          return this._isValidId(e22) ? (this.style.setFilter(e22, t2, i2), this._update(true)) : this;
        }
        getFilter(e22) {
          return this._isValidId(e22) ? this.style.getFilter(e22) : null;
        }
        setPaintProperty(e22, t2, i2, o2 = {}) {
          return this._isValidId(e22) ? (this.style.setPaintProperty(e22, t2, i2, o2), this._update(true)) : this;
        }
        getPaintProperty(e22, t2) {
          return this._isValidId(e22) ? this.style.getPaintProperty(e22, t2) : null;
        }
        setLayoutProperty(e22, t2, i2, o2 = {}) {
          return this._isValidId(e22) ? (this.style.setLayoutProperty(e22, t2, i2, o2), this._update(true)) : this;
        }
        getLayoutProperty(e22, t2) {
          return this._isValidId(e22) ? this.style.getLayoutProperty(e22, t2) : null;
        }
        getConfigProperty(e22, t2) {
          return this.style.getConfigProperty(e22, t2);
        }
        setConfigProperty(e22, t2, i2) {
          return this.style.setConfigProperty(e22, t2, i2), this._update(true);
        }
        setLights(e22) {
          if (this._lazyInitEmptyStyle(), e22 && 1 === e22.length && "flat" === e22[0].type) {
            const t2 = e22[0];
            t2.properties ? this.style.setFlatLight(t2.properties, t2.id, {}) : this.style.setFlatLight({}, "flat");
          } else
            this.style.setLights(e22), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
          return this._update(true);
        }
        getLights() {
          const e22 = this.style.getLights() || [];
          return 0 === e22.length && e22.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e22;
        }
        setLight(e22, t2 = {}) {
          return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e22 }]);
        }
        getLight() {
          return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
        }
        setTerrain(e22) {
          return this._lazyInitEmptyStyle(), !e22 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e22), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e22) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e22), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        setCamera(e22) {
          return this.style.setCamera(e22), this._triggerCameraUpdate(e22);
        }
        _triggerCameraUpdate(e22) {
          return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e22["camera-projection"]));
        }
        getCamera() {
          return this.style.camera;
        }
        _queryFogOpacity(t2) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.L.convert(t2), this.transform) : 0;
        }
        setFeatureState(e22, t2) {
          return this._isValidId(e22.source) ? (this.style.setFeatureState(e22, t2), this._update()) : this;
        }
        removeFeatureState(e22, t2) {
          return this._isValidId(e22.source) ? (this.style.removeFeatureState(e22, t2), this._update()) : this;
        }
        getFeatureState(e22) {
          return this._isValidId(e22.source) ? this.style.getFeatureState(e22) : null;
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const e22 = this._container.getBoundingClientRect().width || 400, t2 = this._container.getBoundingClientRect().height || 300;
          let i2, o2, r2, s2 = this._container;
          for (; s2 && (!o2 || !r2); ) {
            const e3 = window.getComputedStyle(s2).transform;
            e3 && "none" !== e3 && (i2 = e3.match(/matrix.*\((.+)\)/)[1].split(", "), i2[0] && "0" !== i2[0] && "1" !== i2[0] && (o2 = i2[0]), i2[3] && "0" !== i2[3] && "1" !== i2[3] && (r2 = i2[3])), s2 = s2.parentElement;
          }
          this._containerWidth = o2 ? Math.abs(e22 / o2) : e22, this._containerHeight = r2 ? Math.abs(t2 / r2) : t2;
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.X("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e22 = this._container;
          e22.classList.add("mapboxgl-map"), (this._missingCSSCanary = s("div", "mapboxgl-canary", e22)).style.visibility = "hidden", this._detectMissingCSS();
          const t2 = this._canvasContainer = s("div", "mapboxgl-canvas-container", e22);
          this._canvas = s("canvas", "mapboxgl-canvas", t2), this._interactive && (t2.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i2 = this._controlContainer = s("div", "mapboxgl-control-container", e22), o2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
            o2[e3] = s("div", `mapboxgl-ctrl-${e3}`, i2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t2, i2) {
          const o2 = e.a4.devicePixelRatio || 1;
          this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
        }
        _addMarker(e22) {
          this._markers.push(e22);
        }
        _removeMarker(e22) {
          const t2 = this._markers.indexOf(e22);
          -1 !== t2 && this._markers.splice(t2, 1);
        }
        _addPopup(e22) {
          this._popups.push(e22);
        }
        _removePopup(e22) {
          const t2 = this._popups.indexOf(e22);
          -1 !== t2 && this._popups.splice(t2, 1);
        }
        _setupPainter() {
          const t2 = e.ak({}, i.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl2", t2);
          o2 ? (e.cT(o2, true), this.painter = new mr(o2, this._contextCreateOptions, this.transform, this._tp), this.on("data", (e22) => {
            "source" === e22.dataType && this.painter.setTileLoadedFlag(true);
          }), e.cU.testSupport(o2)) : this.fire(new e.a7(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t2) {
          t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.a8("webglcontextlost", { originalEvent: t2 }));
        }
        _contextRestored(t2) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e.a8("webglcontextrestored", { originalEvent: t2 }));
        }
        _onMapScroll(e22) {
          if (e22.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e22) {
          return this.style ? (this._styleDirty = this._styleDirty || e22, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e22) {
          return this._update(), this._renderTaskQueue.add(e22);
        }
        _cancelRenderFrame(e22) {
          this._renderTaskQueue.remove(e22);
        }
        _requestDomTask(e22) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e22() : this._domRenderTaskQueue.add(e22);
        }
        _render(t2) {
          let i2;
          this.fire(new e.a8("renderstart"));
          const o2 = this.painter.context.extTimerQuery, r2 = e.a4.now(), s2 = this.painter.context.gl;
          if (this.listens("gpu-timing-frame") && (i2 = s2.createQuery(), s2.beginQuery(o2.TIME_ELAPSED_EXT, i2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
            return;
          this._updateProjectionTransition();
          const n2 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, i3 = this.transform.pitch, o3 = e.a4.now(), r3 = new e.al(t3, { now: o3, fadeDuration: n2, pitch: i3, transition: this.style.transition });
            this.style.update(r3);
          }
          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
          let a2 = false;
          if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), a2 = this._updateAverageElevation(r2), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : a2 = this._updateAverageElevation(r2), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n2, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries || this._debugParams.showTileBoundaries, wireframe: { terrain: this.showTerrainWireframe || this._debugParams.showTerrainWireframe, layers2D: this.showLayers2DWireframe || this._debugParams.showLayers2DWireframe, layers3D: this.showLayers3DWireframe || this._debugParams.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector || this._debugParams.showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.a8("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.a8("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i2) {
            const t3 = e.a4.now() - r2;
            s2.endQuery(o2.TIME_ELAPSED_EXT), setTimeout(() => {
              const o3 = s2.getQueryParameter(i2, s2.QUERY_RESULT) / 1e6;
              s2.deleteQuery(i2), this.fire(new e.a8("gpu-timing-frame", { cpuTime: t3, gpuTime: o3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t3 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimers(t3);
              this.fire(new e.a8("gpu-timing-layer", { layerTimes: i3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const t3 = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimeDeferredRender(t3);
              this.fire(new e.a8("gpu-timing-deferred-render", { gpuTime: i3 }));
            }, 50);
          }
          const l2 = this._sourcesDirty || this._styleDirty || this._placementDirty || a2;
          if (l2 || this._repaint)
            this.triggerRepaint();
          else {
            const t3 = !this.isMoving() && this.loaded();
            if (t3 && (a2 = this._updateAverageElevation(r2, true)), a2)
              this.triggerRepaint();
            else if (this._triggerFrame(false), t3 && (this.fire(new e.a8("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const t4 = this._calculateSpeedIndex();
              this.fire(new e.a8("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
            }
          }
          !this._loaded || this._fullyLoaded || l2 || (this._fullyLoaded = true, this._performanceMetricsCollection && e.cV(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(e22) {
          for (const t2 of this._markers)
            e22 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
          for (const t2 of this._popups)
            !e22 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
        }
        _updateAverageElevation(e22, t2 = false) {
          const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return 0 !== this.transform.averageElevation && i2(0);
          const o2 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
          if (o2 || (t2 || e22 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e22)) {
            const t3 = this.transform.averageElevation;
            let r2 = this.transform.sampleAverageElevation();
            this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(r2) ? r2 = 0 : this._averageElevationLastSampledAt = e22;
            const s2 = Math.abs(t3 - r2);
            if (s2 > 1) {
              if (this._isInitialLoad || o2)
                return this._averageElevation.jumpTo(r2), i2(r2);
              this._averageElevation.easeTo(r2, e22, 300);
            } else if (s2 > 1e-4)
              return this._averageElevation.jumpTo(r2), i2(r2);
          }
          return !!this._averageElevation.isEasing(e22) && i2(this._averageElevation.getValue(e22));
        }
        _authenticate() {
          e.cW(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
            if (t2 && (t2.message === e.cX || 401 === t2.status)) {
              const t3 = this.painter.context.gl;
              e.cT(t3, false), this._logoControl instanceof As && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.a7(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), e.cY(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          const e22 = this._isDragging();
          this.painter.updateTerrain(this.style, e22);
        }
        _calculateSpeedIndex() {
          const e22 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
          t2.timeStamps.push(performance.now());
          const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
          function r2(e3) {
            i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
            const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
            return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
          }
          return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r2(e22), t2.canvasCopies.map(r2), t2.timeStamps);
        }
        _canvasPixelComparison(e22, t2, i2) {
          let o2 = i2[1] - i2[0];
          const r2 = e22.length / 4;
          for (let s2 = 0; s2 < t2.length; s2++) {
            const n2 = t2[s2];
            let a2 = 0;
            for (let t3 = 0; t3 < n2.length; t3 += 4)
              n2[t3] === e22[t3] && n2[t3 + 1] === e22[t3 + 1] && n2[t3 + 2] === e22[t3 + 2] && n2[t3 + 3] === e22[t3 + 3] && (a2 += 1);
            o2 += (i2[s2 + 2] - i2[s2 + 1]) * (1 - a2 / r2);
          }
          return o2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e22 of this._controls)
            e22.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
          const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e.cZ(this.painter.context.gl), this._removed = true, this.fire(new e.a8("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(t2) {
          this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.a4.frame((e22) => {
            const t3 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t3 && this._render(e22);
          }));
        }
        _preloadTiles(t2) {
          const i2 = this.style ? Object.values(this.style._sourceCaches) : [];
          return e.c_(i2, (e22, i3) => e22._preloadTiles(t2, i3), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e22) {
          this._trackResize && this.resize({ originalEvent: e22 })._update();
        }
        _onVisibilityChange() {
          "hidden" === document.visibilityState && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e22) {
          this._showTileBoundaries !== e22 && (this._showTileBoundaries = e22, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e22) {
          this._showTerrainWireframe !== e22 && (this._showTerrainWireframe = e22, this._update());
        }
        get showLayers2DWireframe() {
          return !!this._showLayers2DWireframe;
        }
        set showLayers2DWireframe(e22) {
          this._showLayers2DWireframe !== e22 && (this._showLayers2DWireframe = e22, this._update());
        }
        get showLayers3DWireframe() {
          return !!this._showLayers3DWireframe;
        }
        set showLayers3DWireframe(e22) {
          this._showLayers3DWireframe !== e22 && (this._showLayers3DWireframe = e22, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e22) {
          this._speedIndexTiming !== e22 && (this._speedIndexTiming = e22, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e22) {
          this._showPadding !== e22 && (this._showPadding = e22, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e22) {
          this._showCollisionBoxes !== e22 && (this._showCollisionBoxes = e22, e22 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e22) {
          this._showOverdrawInspector !== e22 && (this._showOverdrawInspector = e22, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e22) {
          this._repaint !== e22 && (this._repaint = e22, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e22) {
          this._vertices = e22, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(e22) {
          this._showTileAABBs !== e22 && (this._showTileAABBs = e22, e22 && this._update());
        }
        _setCacheLimits(t2, i2) {
          e.d0(t2, i2);
        }
        get version() {
          return e.c$;
        }
      }, NavigationControl: class {
        constructor(t2) {
          this.options = e.ak({}, Zs, t2), this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e22) => e22.preventDefault()), this.options.showZoom && (e.aR(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e22) => {
            this._map && this._map.zoomIn({}, { originalEvent: e22 });
          }), s("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e22) => {
            this._map && this._map.zoomOut({}, { originalEvent: e22 });
          }), s("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aR(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e22) => {
            const t3 = this._map;
            t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e22 }) : t3.resetNorth({}, { originalEvent: e22 }));
          }), this._compassIcon = s("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const e22 = this._map;
          if (!e22)
            return;
          const t2 = e22.getZoom(), i2 = t2 === e22.getMaxZoom(), o2 = t2 === e22.getMinZoom();
          this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
        }
        _rotateCompassArrow() {
          const e22 = this._map;
          if (!e22)
            return;
          const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e22.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e22.transform.pitch}deg) rotateZ(${e22.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e22.transform.angle * (180 / Math.PI)}deg)`;
          e22._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t2);
          });
        }
        onAdd(e22) {
          return this._map = e22, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e22.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e22.on("pitch", this._rotateCompassArrow), e22.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ws(e22, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const e22 = this._map;
          e22 && (this._container.remove(), this.options.showZoom && e22.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e22.off("pitch", this._rotateCompassArrow), e22.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(e22, t2) {
          const i2 = s("button", e22, this._container);
          return i2.type = "button", i2.addEventListener("click", t2), i2;
        }
        _setButtonTitle(e22, t2) {
          if (!this._map)
            return;
          const i2 = this._map._getUIString(`NavigationControl.${t2}`);
          e22.setAttribute("aria-label", i2), e22.firstElementChild && e22.firstElementChild.setAttribute("title", i2);
        }
      }, GeolocateControl: class extends e.a6 {
        constructor(t2) {
          super();
          const i2 = navigator.geolocation;
          this.options = e.ak({ geolocation: i2 }, Hs, t2), e.aR(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Ar(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(e22) {
          return this._map = e22, this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
        }
        _checkGeolocationSupport(e22) {
          const t2 = (t3 = !!this.options.geolocation) => {
            this._supportsGeolocation = t3, e22(t3);
          };
          void 0 !== this._supportsGeolocation ? e22(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e3) => t2("denied" !== e3.state)).catch(() => t2()) : t2();
        }
        _isOutOfMapMaxBounds(e22) {
          const t2 = this._map.getMaxBounds(), i2 = e22.coords;
          return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t2) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t2))
              return this._setErrorState(), this.fire(new e.a8("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = t2, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.a8("geolocate", t2)), this._finish();
          }
        }
        _updateCamera(t2) {
          const i2 = new e.L(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r2 = this._map.getBearing(), s2 = e.ak({ bearing: r2 }, this.options.fitBoundsOptions);
          this._map.fitBounds(i2.toBounds(o2), s2, { geolocateSource: true });
        }
        _updateMarker(t2) {
          if (t2) {
            const i2 = new e.L(t2.coords.longitude, t2.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const t2 = this._map.transform, i2 = e.b(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
          this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t2) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (1 === t2.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e22 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", e22), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e22), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === t2.code && this._noTimeout)
                  return;
                this._setErrorState();
              }
            "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.a8("error", t2)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t2) {
          if (void 0 !== this._map) {
            if (this._container.addEventListener("contextmenu", (e22) => e22.preventDefault()), this._geolocateButton = s("button", "mapboxgl-ctrl-geolocate", this._container), s("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
              e.X("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
            } else {
              const e22 = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", e22), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e22);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = s("div", "mapboxgl-user-location"), this._dotElement.appendChild(s("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(s("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Fs({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = s("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Fs({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
              t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.a8("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(e22) {
          this._userLocationDotMarker && (e22.webkitCompassHeading ? this._heading = e22.webkitCompassHeading : true === e22.absolute && (this._heading = -1 * e22.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return e.X("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.a8("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.a8("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.a8("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
              this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let e22;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e22 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e22 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e22), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const e22 = () => {
            "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
          };
          "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t2) => {
            "granted" === t2 && e22();
          }).catch(console.error) : e22();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: Ds, ScaleControl: class {
        constructor(t2) {
          this.options = e.ak({}, qs2, t2), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
            } catch (e22) {
              return false;
            }
          }(), e.aR(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const e22 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e22 / 2, r2 = t2.unproject([o2, i2]), s2 = t2.unproject([o2 + e22, i2]), n2 = r2.distanceTo(s2);
          if ("imperial" === this.options.unit) {
            const t3 = 3.2808 * n2;
            t3 > 5280 ? this._setScale(e22, t3 / 5280, "mile") : this._setScale(e22, t3, "foot");
          } else
            "nautical" === this.options.unit ? this._setScale(e22, n2 / 1852, "nautical-mile") : n2 >= 1e3 ? this._setScale(e22, n2 / 1e3, "kilometer") : this._setScale(e22, n2, "meter");
        }
        _setScale(e22, t2, i2) {
          this._map._requestDomTask(() => {
            const o2 = function(e3) {
              const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
              let i3 = e3 / t3;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                return Math.round(e4 * t4) / t4;
              }(i3), t3 * i3;
            }(t2), r2 = o2 / t2;
            this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i2 }).format(o2) : `${o2}&nbsp;${$s[i2]}`, this._container.style.width = e22 * r2 + "px";
          });
        }
        onAdd(e22) {
          return this._map = e22, this._language = e22.getLanguage(), this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e22.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(e22) {
          this._language = e22, this._update();
        }
        setUnit(e22) {
          this.options.unit = e22, this._update();
        }
      }, FullscreenControl: class {
        constructor(t2) {
          this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.X("Full screen control 'container' must be a DOM element.")), e.aR(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t2) {
          return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = s("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.X("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const e22 = this._fullscreenButton = s("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          s("span", "mapboxgl-ctrl-icon", e22).setAttribute("aria-hidden", "true"), e22.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e22 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e22), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e22);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends e.a6 {
        constructor(t2) {
          super(), this.options = e.ak(Object.create(Bs), t2), e.aR(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
        }
        addTo(t2) {
          return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.a8("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t2 = this._map;
          return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.a8("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          this._lngLat = e.L.convert(t2), this._pos = null, this._trackPointer = false, this._update();
          const i2 = this._map;
          return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = true, this._pos = null, this._update();
          const e22 = this._map;
          return e22 && (e22.off("move", this._update), e22.on("mousemove", this._onMouseEvent), e22.on("drag", this._onMouseEvent), e22._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(e22) {
          return this.setDOMContent(document.createTextNode(e22));
        }
        setHTML(e22) {
          const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
          let o2;
          for (i2.innerHTML = e22; o2 = i2.firstChild, o2; )
            t2.appendChild(o2);
          return this.setDOMContent(t2);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e22) {
          return this.options.maxWidth = e22, this._update(), this;
        }
        setDOMContent(e22) {
          let t2 = this._content;
          if (t2)
            for (; t2.hasChildNodes(); )
              t2.firstChild && t2.removeChild(t2.firstChild);
          else
            t2 = this._content = s("div", "mapboxgl-popup-content", this._container || void 0);
          if (t2.appendChild(e22), this.options.closeButton) {
            const e3 = this._closeButton = s("button", "mapboxgl-popup-close-button", t2);
            e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.setAttribute("aria-hidden", "true"), e3.innerHTML = "&#215;", e3.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(e22) {
          return this._classList.add(e22), this._updateClassList(), this;
        }
        removeClassName(e22) {
          return this._classList.delete(e22), this._updateClassList(), this;
        }
        setOffset(e22) {
          return this.options.offset = e22, this._update(), this;
        }
        toggleClassName(e22) {
          let t2;
          return this._classList.delete(e22) ? t2 = false : (this._classList.add(e22), t2 = true), this._updateClassList(), t2;
        }
        _onMouseEvent(e22) {
          this._update(e22.point);
        }
        _getAnchor(e22) {
          if (this.options.anchor)
            return this.options.anchor;
          const t2 = this._map, i2 = this._container, o2 = this._pos;
          if (!t2 || !i2 || !o2)
            return "bottom";
          const r2 = i2.offsetWidth, s2 = i2.offsetHeight, n2 = o2.x < r2 / 2, a2 = o2.x > t2.transform.width - r2 / 2;
          if (o2.y + e22 < s2)
            return n2 ? "top-left" : a2 ? "top-right" : "top";
          if (o2.y > t2.transform.height - s2) {
            if (n2)
              return "bottom-left";
            if (a2)
              return "bottom-right";
          }
          return n2 ? "left" : a2 ? "right" : "bottom";
        }
        _updateClassList() {
          const e22 = this._container;
          if (!e22)
            return;
          const t2 = [...this._classList];
          t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e22.className = t2.join(" ");
        }
        _update(t2) {
          const i2 = this._map, o2 = this._content;
          if (!i2 || !this._lngLat && !this._trackPointer || !o2)
            return;
          let r2 = this._container;
          if (r2 || (r2 = this._container = s("div", "mapboxgl-popup", i2.getContainer()), this._tip = s("div", "mapboxgl-popup-tip", r2), r2.appendChild(o2)), this.options.maxWidth && r2.style.maxWidth !== this.options.maxWidth && (r2.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = zs(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
            const e22 = this._pos = this._trackPointer && t2 ? t2 : i2.project(this._lngLat), o3 = Ns(this.options.offset), r3 = this._anchor = this._getAnchor(o3.y), s2 = Ns(this.options.offset, r3), n2 = e22.add(s2).round();
            i2._requestDomTask(() => {
              this._container && r3 && (this._container.style.transform = `${Os[r3]} translate(${n2.x}px,${n2.y}px)`);
            });
          }
          if (!this._marker && i2._showingGlobe()) {
            const t3 = e.cN(i2.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(t3);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e22 = this._container.querySelector(ks);
          e22 && e22.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e22) {
          this._container && (this._container.style.opacity = `${e22}`), this._content && (this._content.style.pointerEvents = e22 ? "auto" : "none");
        }
      }, Marker: Fs, Style: Dr, LngLat: e.L, LngLatBounds: e.D, Point: e.P, MercatorCoordinate: e.M, FreeCameraOptions: he, Evented: e.a6, config: e.cM, prewarm: e.d3, clearPrewarmedResources: e.d4, get accessToken() {
        return e.cM.ACCESS_TOKEN;
      }, set accessToken(t2) {
        e.cM.ACCESS_TOKEN = t2;
      }, get baseApiUrl() {
        return e.cM.API_URL;
      }, set baseApiUrl(t2) {
        e.cM.API_URL = t2;
      }, get workerCount() {
        return e.d5.workerCount;
      }, set workerCount(t2) {
        e.d5.workerCount = t2;
      }, get maxParallelImageRequests() {
        return e.cM.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(t2) {
        e.cM.MAX_PARALLEL_IMAGE_REQUESTS = t2;
      }, clearStorage(t2) {
        e.d6(t2);
      }, get workerUrl() {
        return e.d7.workerUrl;
      }, set workerUrl(t2) {
        e.d7.workerUrl = t2;
      }, get workerClass() {
        return e.d7.workerClass;
      }, set workerClass(t2) {
        e.d7.workerClass = t2;
      }, get workerParams() {
        return e.d7.workerParams;
      }, set workerParams(t2) {
        e.d7.workerParams = t2;
      }, get dracoUrl() {
        return e.d8();
      }, set dracoUrl(t2) {
        e.d9(t2);
      }, setNow: e.a4.setNow, restoreNow: e.a4.restoreNow };
      return Xs;
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl);
var mapboxGlExports = mapboxGl.exports;
const mapboxgl = /* @__PURE__ */ getDefaultExportFromCjs(mapboxGlExports);
function bind$2(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray$5 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber$3 = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean$1 = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate$1 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$5(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$2() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$2(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$2({}, val);
    } else if (isArray$5(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a[key] = bind$2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray$5(thing))
    return thing;
  let i = thing.length;
  if (!isNumber$3(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray2) => {
  return (thing) => {
    return TypedArray2 && thing instanceof TypedArray2;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp$2 = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$5(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target2 = isArray$5(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target2[key] = reducedValue);
        });
        stack[i] = void 0;
        return target2;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const utils$4 = {
  isArray: isArray$5,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$3,
  isBoolean: isBoolean$1,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp: isRegExp$2,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$2,
  extend: extend$1,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$4.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$4.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors$1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors$1[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors$1);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$4.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$4.isPlainObject(thing) || utils$4.isArray(thing);
}
function removeBrackets(key) {
  return utils$4.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each2(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$4.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$4.toFlatObject(utils$4, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$4.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$4.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined2(option, source) {
    return !utils$4.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$4.isSpecCompliantForm(formData);
  if (!utils$4.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$4.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$4.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$4.isArrayBuffer(value) || utils$4.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$4.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$4.isArray(value) && isFlatArray(value) || (utils$4.isFileList(value) || utils$4.endsWith(key, "[]")) && (arr = utils$4.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index2) {
          !(utils$4.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$4.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$4.forEach(value, function each2(el, key) {
      const result = !(utils$4.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$4.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$4.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$2);
  } : encode$2;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode$1;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$4.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$4.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const utils$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$3,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$4.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$4.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject$1(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target2, index2) {
    let name = path[index2++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$4.isArray(target2) ? target2.length : name;
    if (isLast) {
      if (utils$4.hasOwnProp(target2, name)) {
        target2[name] = [target2[name], value];
      } else {
        target2[name] = value;
      }
      return !isNumericKey;
    }
    if (!target2[name] || !utils$4.isObject(target2[name])) {
      target2[name] = [];
    }
    const result = buildPath(path, value, target2[name], index2);
    if (result && utils$4.isArray(target2[name])) {
      target2[name] = arrayToObject$1(target2[name]);
    }
    return !isNumericKey;
  }
  if (utils$4.isFormData(formData) && utils$4.isFunction(formData.entries)) {
    const obj = {};
    utils$4.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$4.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$4.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$3 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$4.isObject(data);
    if (isObjectPayload && utils$4.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$4.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$4.isArrayBuffer(data) || utils$4.isBuffer(data) || utils$4.isStream(data) || utils$4.isFile(data) || utils$4.isBlob(data)) {
      return data;
    }
    if (utils$4.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$4.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$4.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$3.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils$4.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$4.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$3.headers[method] = {};
});
const defaults$4 = defaults$3;
const ignoreDuplicateOf = utils$4.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$4.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils$4.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$4.isString(value))
    return;
  if (utils$4.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$4.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$4.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$4.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$4.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$4.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$4.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$4.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$4.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$4.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$4.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher2 || matchHeaderValue(this, this[key], key, matcher2)));
    }
    return false;
  }
  delete(header, matcher2) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$4.findKey(self2, _header);
        if (key && (!matcher2 || matchHeaderValue(self2, self2[key], key, matcher2))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$4.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher2) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher2 || matchHeaderValue(this, this[key], key, matcher2, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$4.forEach(this, (value, header) => {
      const key = utils$4.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$4.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$4.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target2) => computed.set(target2));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$4.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$4.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$4.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$4;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$4.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$4.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$4.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$4.isString(path) && cookie.push("path=" + path);
      utils$4.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$4.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils$4.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type2, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve2(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$4.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$4.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$4.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$4.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$4.isFunction(adapter) || adapter === null || adapter === false;
const adapters$1 = {
  getAdapter: (adapters2) => {
    adapters2 = utils$4.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters$1.getAdapter(config.adapter || defaults$4.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target2, source, caseless) {
    if (utils$4.isPlainObject(target2) && utils$4.isPlainObject(source)) {
      return utils$4.merge.call({ caseless }, target2, source);
    } else if (utils$4.isPlainObject(source)) {
      return utils$4.merge({}, source);
    } else if (utils$4.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$4.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$4.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils$4.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils$4.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.6.7";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$4.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$4.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$4.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i < len) {
        promise2 = promise2.then(chain[i++], chain[i++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve2;
      const promise2 = new Promise((resolve2) => {
        token2.subscribe(resolve2);
        _resolve2 = resolve2;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token2.unsubscribe(_resolve2);
      };
      return promise2;
    };
    executor(function cancel(message, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback2) {
  return function wrap(arr) {
    return callback2.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$4.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance2 = bind$2(Axios$1.prototype.request, context);
  utils$4.extend(instance2, Axios$1.prototype, context, { allOwnKeys: true });
  utils$4.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
const axios = createInstance(defaults$4);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$4.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters$1.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
var esErrors = Error;
var _eval = EvalError;
var range = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type = TypeError;
var uri = URIError;
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  __proto__: null,
  foo: {}
};
var $Object = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr$1 = Object.prototype.toString;
var max = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str = "";
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
var implementation$1 = function bind(that) {
  var target2 = this;
  if (typeof target2 !== "function" || toStr$1.apply(target2) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target2);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target2.apply(
        this,
        concatty(args, arguments)
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target2.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max(0, target2.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target2.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target2.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call, $hasOwn);
var undefined$1;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range;
var $ReferenceError = ref;
var $SyntaxError$1 = syntax;
var $TypeError$3 = type;
var $URIError = uri;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var hasProto2 = hasProto$1();
var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
  return x.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = hasown;
var $concat$1 = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var $exec = bind2.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true) || false;
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty2 = false;
    }
  }
  esDefineProperty = $defineProperty2;
  return esDefineProperty;
}
var GetIntrinsic$3 = getIntrinsic;
var $gOPD = GetIntrinsic$3("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e) {
    $gOPD = null;
  }
}
var gopd$1 = $gOPD;
var $defineProperty$1 = requireEsDefineProperty();
var $SyntaxError = syntax;
var $TypeError$2 = type;
var gopd = gopd$1;
var defineDataProperty = function defineDataProperty2(obj, property, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$2("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$2("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty$1) {
    $defineProperty$1(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var $defineProperty = requireEsDefineProperty();
var hasPropertyDescriptors = function hasPropertyDescriptors2() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch (e) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors;
var GetIntrinsic$2 = getIntrinsic;
var define$1 = defineDataProperty;
var hasDescriptors = hasPropertyDescriptors_1();
var gOPD = gopd$1;
var $TypeError$1 = type;
var $floor$1 = GetIntrinsic$2("%Math.floor%");
var setFunctionLength = function setFunctionLength2(fn, length) {
  if (typeof fn !== "function") {
    throw new $TypeError$1("`fn` is not a function");
  }
  if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor$1(length) !== length) {
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ("length" in fn && gOPD) {
    var desc = gOPD(fn, "length");
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define$1(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length,
        true,
        true
      );
    } else {
      define$1(
        /** @type {Parameters<define>[0]} */
        fn,
        "length",
        length
      );
    }
  }
  return fn;
};
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var setFunctionLength$1 = setFunctionLength;
  var $TypeError2 = type;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty2 = requireEsDefineProperty();
  var $max = GetIntrinsic3("%Math.max%");
  module.exports = function callBind2(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError2("a function is required");
    }
    var func = $reflectApply(bind3, $call, arguments);
    return setFunctionLength$1(
      func,
      1 + $max(0, originalFunction.length - (arguments.length - 1)),
      true
    );
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module.exports, "apply", { value: applyBind });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var callBindExports = callBind$1.exports;
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBindExports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
  return O.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen2) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$4(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen2 === "undefined") {
    seen2 = [];
  } else if (indexOf(seen2, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from2, noIndent) {
    if (from2) {
      seen2 = $arrSlice.call(seen2);
      seen2.push(from2);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen2);
    }
    return inspect_(value, opts, depth + 1, seen2);
  }
  if (typeof obj === "function" && !isRegExp$1(obj)) {
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s;
  }
  if (isArray$4(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
      return utilInspect(obj, { depth: maxDepth - depth });
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
    }
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
    }
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber$2(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (typeof window !== "undefined" && obj === window) {
    return "{ [object Window] }";
  }
  if (obj === commonjsGlobal) {
    return "{ [object globalThis] }";
  }
  if (!isDate(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace.call(String(s), /"/g, "&quot;");
}
function isArray$4(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber$2(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type2) {
  return type2 + " { ? }";
}
function collectionOf(type2, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type2 + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$4(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$3(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = type;
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  var prev = list;
  var curr;
  for (; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = /** @type {NonNullable<typeof list.next>} */
      list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = /** @type {import('.').ListNode<typeof value>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;
var hexTable = function() {
  var array2 = [];
  for (var i = 0; i < 256; ++i) {
    array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array2;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$3(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== "undefined") {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge$1 = function merge(target2, source, options) {
  if (!source) {
    return target2;
  }
  if (typeof source !== "object") {
    if (isArray$3(target2)) {
      target2.push(source);
    } else if (target2 && typeof target2 === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target2[source] = true;
      }
    } else {
      return [target2, source];
    }
    return target2;
  }
  if (!target2 || typeof target2 !== "object") {
    return [target2].concat(source);
  }
  var mergeTarget = target2;
  if (isArray$3(target2) && !isArray$3(source)) {
    mergeTarget = arrayToObject(target2, options);
  }
  if (isArray$3(target2) && isArray$3(source)) {
    source.forEach(function(item, i) {
      if (has$2.call(target2, i)) {
        var targetItem = target2[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target2[i] = merge(targetItem, item, options);
        } else {
          target2.push(item);
        }
      } else {
        target2[i] = item;
      }
    });
    return target2;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target2, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target2);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{ obj: { o: value }, prop: "o" }];
  var refs = [];
  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$3(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer,
  isRegExp,
  maybeMap,
  merge: merge$1
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$2 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$2 = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var sentinel = {};
var stringify$1 = function stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter3, sort, allowDots, serializeDate2, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object2;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter3 === "function") {
    obj = filter3(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset, "key", format2) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset, "key", format2);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$2.encoder, charset, "value", format2))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = utils$1.maybeMap(obj, encoder);
    }
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$2(filter3)) {
    objKeys = filter3;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
  var adjustedPrefix = commaRoundTrip && isArray$2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
  if (allowEmptyArrays && isArray$2(obj) && obj.length === 0) {
    return adjustedPrefix + "[]";
  }
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    var keyPrefix = isArray$2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
    sideChannel2.set(object2, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray$2(obj) ? null : encoder,
      filter3,
      sort,
      allowDots,
      serializeDate2,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$2;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$2.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format2 = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  var formatter = formats$1.formatters[format2];
  var filter3 = defaults$2.filter;
  if (typeof opts.filter === "function" || isArray$2(opts.filter)) {
    filter3 = opts.filter;
  }
  var arrayFormat;
  if (opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults$2.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults$2.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$2.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$2.charsetSentinel,
    commaRoundTrip: opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$2.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$2.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$2.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$2.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
    filter: filter3,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$2.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$2.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$2.strictNullHandling
  };
};
var stringify_1 = function(object2, opts) {
  var obj = object2;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter3;
  if (typeof options.filter === "function") {
    filter3 = options.filter;
    obj = filter3("", obj);
  } else if (isArray$2(options.filter)) {
    filter3 = options.filter;
    objKeys = filter3;
  }
  var keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
  var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys, stringify$1(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$1 = Array.isArray;
var defaults$1 = {
  allowDots: false,
  allowEmptyArrays: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decodeDotInKeys: true,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = { __proto__: null };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults$1.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults$1.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$1(val) ? [val] : val;
    }
    var existing = has.call(obj, key);
    if (existing && options.duplicates === "combine") {
      obj[key] = utils.combine(obj[key], val);
    } else if (!existing || options.duplicates === "last") {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root2 = chain[i];
    if (root2 === "[]" && options.parseArrays) {
      obj = options.allowEmptyArrays && leaf === "" ? [] : [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
      var index2 = parseInt(decodedRoot, 10);
      if (!options.parseArrays && decodedRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (decodedRoot !== "__proto__") {
        obj[decodedRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys = [];
  if (parent2) {
    if (!options.plainObjects && has.call(Object.prototype, parent2)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent2);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }
  if (segment) {
    keys.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
  var duplicates = typeof opts.duplicates === "undefined" ? defaults$1.duplicates : opts.duplicates;
  if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
    throw new TypeError("The duplicates option must be either combine, first, or last");
  }
  var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
  return {
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$1.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
    decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults$1.decodeDotInKeys,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
    duplicates,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var parse$4 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys = Object.keys(tempObj);
  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify2 = stringify_1;
var parse$3 = parse$4;
var formats = formats$3;
var lib = {
  formats,
  parse: parse$3,
  stringify: stringify2
};
const qs = /* @__PURE__ */ getDefaultExportFromCjs(lib);
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
const map$1$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex$1 = [..."0123456789ABCDEF"];
const h1 = (b) => hex$1[b & 15];
const h2 = (b) => hex$1[(b & 240) >> 4] + hex$1[b & 15];
const eq = (b) => (b & 240) >> 4 === (b & 15);
const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1$1[str[1]] * 17,
        g: 255 & map$1$1[str[2]] * 17,
        b: 255 & map$1$1[str[3]] * 17,
        a: len === 5 ? map$1$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1$1[str[1]] << 4 | map$1$1[str[2]],
        g: map$1$1[str[3]] << 4 | map$1$1[str[4]],
        b: map$1$1[str[5]] << 4 | map$1$1[str[6]],
        a: len === 9 ? map$1$1[str[7]] << 4 | map$1$1[str[8]] : 255
      };
    }
  }
  return ret;
}
const alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb2 = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb2[i] *= 1 - w - b;
    rgb2[i] += w;
  }
  return rgb2;
}
function hueValue(r, g, b, d, max2) {
  if (r === max2) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max2) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range2 = 255;
  const r = v.r / range2;
  const g = v.g / range2;
  const b = v.b / range2;
  const max2 = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max2 + min) / 2;
  let h, s, d;
  if (max2 !== min) {
    d = max2 - min;
    s = l > 0.5 ? d / (2 - max2 - min) : d / (max2 + min);
    h = hueValue(r, g, b, d, max2);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb$1(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb$1(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb$1(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
const map$2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map$2[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate$3(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb$1(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone$1(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
let Color$1 = class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type2 = typeof input;
    let v;
    if (type2 === "object") {
      v = fromObject(input);
    } else if (type2 === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone$1(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate$3(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb2 = this._rgb;
    rgb2.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb2 = this._rgb;
    const val = round(rgb2.r * 0.3 + rgb2.g * 0.59 + rgb2.b * 0.11);
    rgb2.r = rgb2.g = rgb2.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb2 = this._rgb;
    rgb2.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};
/*!
 * Chart.js v4.4.2
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function noop$1() {
}
const uid = /* @__PURE__ */ (() => {
  let id2 = 0;
  return () => id2++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type2 = Object.prototype.toString.call(value);
  if (type2.slice(0, 7) === "[object" && type2.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject(source)) {
    const target2 = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target2[keys[k]] = clone(source[keys[k]]);
    }
    return target2;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target2, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target2[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge2(tval, sval, options);
  } else {
    target2[key] = clone(sval);
  }
}
function merge2(target2, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target2)) {
    return target2;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current2;
  for (let i = 0; i < ilen; ++i) {
    current2 = sources[i];
    if (!isObject(current2)) {
      continue;
    }
    const keys = Object.keys(current2);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target2, current2, options);
    }
  }
  return target2;
}
function mergeIf(target2, source) {
  return merge2(target2, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target2, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target2[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target2, key)) {
    target2[key] = clone(sval);
  }
}
const keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== "undefined";
const isFunction = (value) => typeof value === "function";
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon2) {
  return Math.abs(x - y) < epsilon2;
}
function niceNum(range2) {
  const roundedRange = Math.round(range2);
  range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
  const niceRange = Math.pow(10, Math.floor(log10(range2)));
  const fraction = range2 / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber$1(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon2) {
  const rounded = Math.round(x);
  return rounded - epsilon2 <= x && rounded + epsilon2 >= x;
}
function _setMinAndMaxByKey(array2, target2, property) {
  let i, ilen, value;
  for (i = 0, ilen = array2.length; i < ilen; i++) {
    value = array2[i][property];
    if (!isNaN(value)) {
      target2.min = Math.min(target2.min, value);
      target2.max = Math.max(target2.max, value);
    }
  }
}
function toRadians(degrees2) {
  return degrees2 * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start2, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start2);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max2) {
  return Math.max(min, Math.min(max2, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start2, end, epsilon2 = 1e-6) {
  return value >= Math.min(start2, end) - epsilon2 && value <= Math.max(start2, end) + epsilon2;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max2) {
  let start2 = 0;
  let end = values.length;
  while (start2 < end && values[start2] < min) {
    start2++;
  }
  while (end > start2 && values[end - 1] > max2) {
    end--;
  }
  return start2 > 0 || end < values.length ? values.slice(start2, end) : values;
}
const arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array2, listener) {
  if (array2._chartjs) {
    array2._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array2, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base2 = array2[key];
    Object.defineProperty(array2, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base2.apply(this, args);
        array2._chartjs.listeners.forEach((object2) => {
          if (typeof object2[method] === "function") {
            object2[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array2, listener) {
  const stub = array2._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array2[key];
  });
  delete array2._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
const requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout2;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout2);
      timeout2 = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
const _alignStartEnd = (align, start2, end) => align === "start" ? start2 : align === "end" ? end : (start2 + end) / 2;
const _textX = (align, left2, right2, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start2 = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis2 = iScale.axis;
    const { min, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start2 = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis2, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis2, iScale.getPixelForValue(min)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis2, iScale.getPixelForValue(max2), true).hi + 1
      ), start2, pointCount) - start2;
    } else {
      count = pointCount - start2;
    }
  }
  return {
    start: start2,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type2 = value.toString();
    return type2 === "[object CanvasPattern]" || type2 === "[object CanvasGradient]";
  }
  return false;
}
function color$1(value) {
  return isPatternOrGradient(value) ? value : new Color$1(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color$1(value).saturate(0.5).darken(0.1).hexString();
}
const numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
const colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
const formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks2) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks2.length > 1) {
      const maxTick = Math.max(Math.abs(ticks2[0].value), Math.abs(ticks2[ticks2.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks2);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index2, ticks2) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks2[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks2.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks2);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks2) {
  let delta = ticks2.length > 3 ? ticks2[2].value - ticks2[1].value : ticks2[1].value - ticks2[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
const overrides = /* @__PURE__ */ Object.create(null);
const descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set$2(root2, scope, values) {
  if (typeof scope === "string") {
    return merge2(getScope$1(root2, scope), values);
  }
  return merge2(getScope$1(root2, ""), scope);
}
class Defaults {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set$2(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set$2(descriptors, scope, values);
  }
  override(scope, values) {
    return set$2(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target2 = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target2, local);
          }
          return valueOrDefault(local, target2);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
}
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache2) {
  cache2 = cache2 || {};
  let data = cache2.data = cache2.data || {};
  let gc = cache2.garbageCollect = cache2.garbageCollect || [];
  if (cache2.font !== font) {
    data = cache2.data = {};
    gc = cache2.garbageCollect = [];
    cache2.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  drawPointLegend(ctx, options, x, y, null);
}
function drawPointLegend(ctx, options, x, y, w) {
  let type2, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type2 = style.toString();
    if (type2 === "[object HTMLImageElement]" || type2 === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target2, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target2.x, target2.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target2.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target2.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target2.y);
  } else {
    ctx.lineTo(target2.x, previous.y);
  }
  ctx.lineTo(target2.x, target2.y);
}
function _bezierCurveTo(ctx, previous, target2, flip) {
  if (!previous) {
    return ctx.lineTo(target2.x, target2.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target2.cp2x : target2.cp1x, flip ? target2.cp2y : target2.cp1y, target2.x, target2.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left2 = x - metrics.actualBoundingBoxLeft;
    const right2 = x + metrics.actualBoundingBoxRight;
    const top2 = y - metrics.actualBoundingBoxAscent;
    const bottom2 = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left2, yDecoration);
    ctx.lineTo(right2, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text2, x, y, font, opts = {}) {
  const lines = isArray(text2) ? text2 : [
    text2
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
const numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max: max2 } = minmax;
  const change = toDimension(grace, (max2 - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max2, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes2 = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache2 = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes2, finalRootScopes, fallback)
  };
  return new Proxy(cache2, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target2, prop) {
      delete target2[prop];
      delete target2._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target2, prop) {
      return _cached(target2, prop, () => _resolveWithPrefixes(prop, prefixes2, scopes, target2));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target2, prop) {
      return Reflect.getOwnPropertyDescriptor(target2._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target2, prop) {
      return getKeysFromAllScopes(target2).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target2) {
      return getKeysFromAllScopes(target2);
    },
    /**
    * A trap for setting property values.
    */
    set(target2, prop, value) {
      const storage = target2._storage || (target2._storage = getTarget());
      target2[prop] = storage[prop] = value;
      delete target2._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache2 = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache2, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target2, prop) {
      delete target2[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target2, prop, receiver) {
      return _cached(target2, prop, () => _resolveWithContext(target2, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target2, prop) {
      return target2._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target2, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target2, prop, value) {
      proxy[prop] = value;
      delete target2[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target2, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target2, prop)) {
    return target2[prop];
  }
  const value = resolve2();
  target2[prop] = value;
  return value;
}
function _resolveWithContext(target2, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target2;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target2, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target2, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target2, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target2;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target2, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target2;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent2) => key === true ? parent2 : typeof key === "string" ? resolveObjectKey(parent2, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent2 of parentScopes) {
    const scope = getScope(key, parent2);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent2 = resolver._getTarget();
  if (!(prop in parent2)) {
    parent2[prop] = {};
  }
  const target2 = parent2[prop];
  if (isArray(target2) && isObject(value)) {
    return value;
  }
  return target2 || {};
}
function _resolveWithPrefixes(prop, prefixes2, scopes, proxy) {
  let value;
  for (const prefix of prefixes2) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target2) {
  let keys = target2._keys;
  if (!keys) {
    keys = target2._keys = resolveKeysFromAllScopes(target2._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start2, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start2;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current2 = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current2, previous);
  const d12 = distanceBetweenPoints(next, current2);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current2.x - fa * (next.x - previous.x),
      y: current2.y - fa * (next.y - previous.y)
    },
    next: {
      x: current2.x + fb * (next.x - previous.x),
      y: current2.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max2) {
  return Math.max(Math.min(pt, max2), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop2, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop2 ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop2 ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent2 = domNode.parentNode;
  if (parent2 && parent2.toString() === "[object ShadowRoot]") {
    parent2 = parent2.host;
  }
  return parent2;
}
function parseMaxStyle(styleValue2, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue2 === "string") {
    valueInPixels = parseInt(styleValue2, 10);
    if (styleValue2.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue2;
  }
  return valueInPixels;
}
const getComputedStyle$1 = (element2) => element2.ownerDocument.defaultView.getComputedStyle(element2, null);
function getStyle(el, property) {
  return getComputedStyle$1(el).getPropertyValue(property);
}
const positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target2) => (x > 0 || y > 0) && (!target2 || !target2.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle$1(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container2 = _getParentNode(canvas);
    if (!container2) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container2.getBoundingClientRect();
      const containerStyle = getComputedStyle$1(container2);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container2, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container2, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle$1(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element2, property) {
  const value = getStyle(element2, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start: start2, end, count, loop: loop2, style }) {
  return {
    start: start2 % count,
    end: end % count,
    loop: loop2 && (end - start2 + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize: normalize2 } = propertyFn(property);
  const count = points.length;
  let { start: start2, end, loop: loop2 } = segment;
  let i, ilen;
  if (loop2) {
    start2 += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize2(points[start2 % count][property]), startBound, endBound)) {
        break;
      }
      start2--;
      end--;
    }
    start2 %= count;
    end %= count;
  }
  if (end < start2) {
    end += count;
  }
  return {
    start: start2,
    end,
    loop: loop2,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize: normalize2 } = propertyFn(property);
  const { start: start2, end, loop: loop2, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start2, prev = start2; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize2(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop: loop2,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop: loop2,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop2, spanGaps) {
  let start2 = 0;
  let end = count - 1;
  if (loop2 && !spanGaps) {
    while (start2 < count && !points[start2].skip) {
      start2++;
    }
  }
  while (start2 < count && points[start2].skip) {
    start2++;
  }
  start2 %= count;
  if (loop2) {
    end += start2;
  }
  while (end > start2 && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start: start2,
    end
  };
}
function solidSegments(points, start2, max2, loop2) {
  const count = points.length;
  const result = [];
  let last = start2;
  let prev = points[start2];
  let end;
  for (end = start2 + 1; end <= max2; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop2 = false;
        result.push({
          start: start2 % count,
          end: (end - 1) % count,
          loop: loop2
        });
        start2 = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start2 = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start2 % count,
      end: last % count,
      loop: loop2
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop2 = !!line._loop;
  const { start: start2, end } = findStartAndEnd(points, count, loop2, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start: start2,
        end,
        loop: loop2
      }
    ], points, segmentOptions);
  }
  const max2 = end < start2 ? end + count : end;
  const completeLoop = !!line._fullLoop && start2 === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start2, max2, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start2 = segments[0].start;
  let i = start2;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start2 = e % count;
    }
  }
  for (const segment of segments) {
    start2 = spanGaps ? start2 : segment.start;
    let prev = points[start2 % count];
    let style;
    for (i = start2 + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start2, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start2 < i - 1) {
      addStyle(start2, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache2 = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache2.includes(value)) {
      cache2.push(value);
    }
    return cache2.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
/*!
 * Chart.js v4.4.2
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class Animator {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date2, type2) {
    const callbacks = anims.listeners[type2];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date2 - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date2 = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date2);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date2, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date2, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date2;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = /* @__PURE__ */ new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color$1(from2 || transparent);
    const c1 = c0.valid && color$1(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
class Animation {
  constructor(cfg, target2, prop, to2) {
    const currentValue = target2[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target2;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date2) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date2 - this._start;
      const remain = this._duration - elapsed;
      this._start = date2;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date2) {
    const elapsed = date2 - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop2 = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop2 || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop2 && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target2, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target2, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target2.options.$animations, newOptions).then(() => {
        target2.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target2, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target2.$animations || (target2.$animations = {});
    const props = Object.keys(values);
    const date2 = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target2, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date2);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target2[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target2, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target2, values) {
    if (this._properties.size === 0) {
      Object.assign(target2, values);
      return;
    }
    const animations = this._createAnimations(target2, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target2, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target2.options;
  if (!options) {
    target2.options = newOptions;
    return;
  }
  if (options.$shared) {
    target2.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max2 = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max2 : min,
    end: reverse ? min : max2
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max: max2, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max2 : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type2) {
  for (const meta of vScale.getMatchingVisibleMetas(type2).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis2) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis2).shift();
}
function createDatasetContext(parent2, index2) {
  return createContext(parent2, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent2, index2, element2) {
  return createContext(parent2, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element: element2,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis2 = meta.vScale && meta.vScale.axis;
  if (!axis2) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis2] === void 0 || stacks[axis2][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis2][datasetIndex];
    if (stacks[axis2]._visualValues !== void 0 && stacks[axis2]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis2]._visualValues[datasetIndex];
    }
  }
}
const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis2, x, y, r) => axis2 === "x" ? x : axis2 === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start2, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start2 === 0 && count === data.length ? true : meta._sorted;
    let prev = start2 > 0 && meta._parsed[start2 - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start2])) {
        parsed = this.parseArrayData(meta, data, start2, count);
      } else if (isObject(data[start2])) {
        parsed = this.parseObjectData(meta, data, start2, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start2, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start2] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start2, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start2;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start2, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start2;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start2, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start2;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range2.min = Math.min(range2.min, value);
    range2.max = Math.max(range2.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range2, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        break;
      }
    }
    return range2;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active2 = [];
    const start2 = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start2;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start2, count);
    }
    for (i = start2; i < start2 + count; ++i) {
      const element2 = elements2[i];
      if (element2.hidden) {
        continue;
      }
      if (element2.active && drawActiveElementsOnTop) {
        active2.push(element2);
      } else {
        element2.draw(ctx, area);
      }
    }
    for (i = 0; i < active2.length; ++i) {
      active2[i].draw(ctx, area);
    }
  }
  getStyle(index2, active2) {
    const mode = active2 ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active2, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element2 = this._cachedMeta.data[index2];
      context = element2.$context || (element2.$context = createDataContext(this.getContext(), index2, element2));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active2;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active2 = mode === "active";
    const cache2 = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache2[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes2 = active2 ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active2, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes2);
    if (values.$shared) {
      values.$shared = sharing;
      cache2[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active2) {
    const chart = this.chart;
    const cache2 = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache2[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index2, active2, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache2[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start2, mode) {
    const firstOpts = this.resolveDataElementOptions(start2, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element2, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element2, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element2, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element2, index2, mode, active2) {
    element2.active = active2;
    const options = this.getStyle(index2, active2);
    this._resolveAnimations(index2, mode, active2).update(element2, {
      options: !active2 && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element2, datasetIndex, index2) {
    this._setStyle(element2, index2, "active", false);
  }
  setHoverStyle(element2, datasetIndex, index2) {
    this._setStyle(element2, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start2, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start2 + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start2; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start2, count);
    if (resetNewElements) {
      this.updateElements(data, start2, count, "reset");
    }
  }
  updateElements(element2, start2, count, mode) {
  }
  _removeElements(start2, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start2, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start2, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start2, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start2,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start2,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type2) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type2);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start2 = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start: start2
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max2 = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max2;
  if (Math.abs(min) > Math.abs(max2)) {
    barStart = max2;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max: max2
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start2, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start2, ilen = start2 + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start2, end, top2, bottom2;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start2 = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start2 = "bottom";
    end = "top";
  }
  if (reverse) {
    top2 = "end";
    bottom2 = "start";
  } else {
    top2 = "start";
    bottom2 = "end";
  }
  return {
    start: start2,
    end,
    reverse,
    top: top2,
    bottom: bottom2
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start: start2, end, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top2;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom2;
    } else {
      res[parseEdge(bottom2, start2, end, reverse)] = true;
      edge = top2;
    }
  }
  res[parseEdge(edge, start2, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start2, end) {
  return v === "start" ? start2 : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start2, count) {
    return parseArrayOrPrimitive(meta, data, start2, count);
  }
  parseArrayData(meta, data, start2, count) {
    return parseArrayOrPrimitive(meta, data, start2, count);
  }
  parseObjectData(meta, data, start2, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start2, ilen = start2 + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range2, scale, parsed, stack) {
    super.updateRangeFromParsed(range2, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range2.min = Math.min(range2.min, custom.min);
      range2.max = Math.max(range2.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start2, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base2 = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    for (let i = start2; i < start2 + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base: base2,
        head: base2
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start2 = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start2 = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start2 = 0;
      }
      start2 += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start2;
    let base2 = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start2 + length);
    } else {
      head = base2;
    }
    size = head - base2;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base2 -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max2 = Math.max(startPixel, endPixel);
      base2 = Math.max(Math.min(base2, max2), min);
      head = base2 + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base2);
      }
    }
    if (base2 === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base2 += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base: base2,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center2, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center2 = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
      size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
    } else {
      center2 = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center2 - size / 2,
      head: center2 + size / 2,
      center: center2,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start2, count) {
    const parsed = super.parsePrimitiveData(meta, data, start2, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start2).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start2, count) {
    const parsed = super.parseArrayData(meta, data, start2, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start2 + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start2).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start2, count) {
    const parsed = super.parseObjectData(meta, data, start2, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start2 + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start2).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max2 = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max2 > 0 && max2;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start2, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start2; i < start2 + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start2, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start2])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start2, ilen = start2 + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max2 = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max2 = Math.max(max2, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max2 - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start2, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start2; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start2; i < start2 + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max2 = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== "inner") {
        max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max2;
  }
  getMaxOffset(arcs) {
    let max2 = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
    }
    return max2;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start2;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start2 = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start2, count, mode);
  }
  updateElements(points, start2, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber$1(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start2 + count;
    const pointsCount = points.length;
    let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start2 || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start2, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start2, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range2 = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element2, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range2.min) {
          range2.min = parsed;
        }
        if (parsed > range2.max) {
          range2.max = parsed;
        }
      }
    });
    return range2;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start2, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start2; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start2; i < start2 + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element2, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
}
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
class PieController extends DoughnutController {
}
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class RadarController extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start2, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start2, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start2, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start2; i < start2 + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class ScatterController extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start2;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start2 = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start2, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start2, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start2, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber$1(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
    for (let i = start2; i < start2 + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max2 = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max2 = Math.max(max2, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max2 > 0 && max2;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
}
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
}
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis2, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis2 === iScale.axis && axis2 !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis2, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range2 = typeof el.getRange === "function" && el.getRange(axis2);
      if (range2) {
        const start2 = lookupMethod(data, axis2, value - range2);
        const end = lookupMethod(data, axis2, value + range2);
        return {
          lo: start2.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis2, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis2];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis2, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element2 = data[j];
      if (!element2.skip) {
        handler(element2, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis2) {
  const useX = axis2.indexOf("x") !== -1;
  const useY = axis2.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis2, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element2, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element2, chart.chartArea, 0)) {
      return;
    }
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis2, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis2, useFinalPosition) {
  let items = [];
  function evaluationFunc(element2, datasetIndex, index2) {
    const { startAngle, endAngle } = element2.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element2, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis2, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis2, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis2);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element2, datasetIndex, index2) {
    const inRange2 = element2.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center2 = element2.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center2);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center2);
    if (distance < minDistance) {
      items = [
        {
          element: element2,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis2, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis2, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis2 === "r" && !intersect ? getNearestRadialItems(chart, position, axis2, useFinalPosition) : getNearestCartesianItems(chart, position, axis2, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis2, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis2 === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis2, position, (element2, datasetIndex, index2) => {
    if (element2[rangeMethod](position[axis2], useFinalPosition)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element2.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis2 = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis2, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis2, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element2 = meta.data[index2];
        if (element2 && !element2.skip) {
          elements2.push({
            element: element2,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis2 = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis2, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis2, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis2 = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis2, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis2 = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis2, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array2, position) {
  return array2.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array2, axis2) {
  return array2.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis2);
}
function sortByWeight(array2, reverse) {
  return array2.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left2.concat(top2),
    rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left2.concat(right2).concat(centerVertical),
    horizontal: top2.concat(bottom2).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left2, top2, width, height) {
  box.top = top2;
  box.left = left2;
  box.right = left2 + width;
  box.bottom = top2 + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class BasePlatform {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type2, listener) {
  }
  removeEventListener(chart, type2, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element2, width, height, aspectRatio) {
    width = Math.max(0, width || element2.width);
    height = height || element2.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
const isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type2, listener) {
  if (node) {
    node.addEventListener(type2, listener, eventListenerOptions);
  }
}
function removeListener(chart, type2, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type2, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type2 = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type: type2,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type2, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type2, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
const drpListeningCharts = /* @__PURE__ */ new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type2, listener) {
  const canvas = chart.canvas;
  const container2 = canvas && _getParentNode(canvas);
  if (!container2) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container2.clientWidth;
    listener(width, height);
    if (w < container2.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container2);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type2, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type2 === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type2, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type2, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type2, listener) {
    this.removeEventListener(chart, type2);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type2] || createProxyAndListen;
    proxies[type2] = handler(chart, type2, listener);
  }
  removeEventListener(chart, type2) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type2];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type2] || removeListener;
    handler(chart, type2, proxy);
    proxies[type2] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container2 = _getParentNode(canvas);
    return !!(container2 && container2.isConnected);
  }
}
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
class Element {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber$1(this.x) && isNumber$1(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks2) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks2) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks2, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks2, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks2, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks2, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks2, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks2.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks2, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks2, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks2.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks2) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks2.length; i < ilen; i++) {
    if (ticks2[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks2, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks2.length; i++) {
    if (i === next) {
      newTicks.push(ticks2[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks2, newTicks, spacing, majorStart, majorEnd) {
  const start2 = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks2.length), ticks2.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start2;
  while (next < 0) {
    count++;
    next = Math.round(start2 + count * spacing);
  }
  for (i = Math.max(start2, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks2[i]);
      count++;
      next = Math.round(start2 + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start2 = scale._startPixel;
  const end = scale._endPixel;
  const epsilon2 = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start2, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start2 - epsilon2 || lineValue > end + epsilon2) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches2, length) {
  each(caches2, (cache2) => {
    const gc = cache2.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache2.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent2, scale) {
  return createContext(parent2, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent2, index2, tick2) {
  return createContext(parent2, {
    tick: tick2,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom2 - top2;
  const width = right2 - left2;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left2, right2);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right2 - left2;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom2, top2);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max: max2, minDefined, maxDefined } = this.getUserBounds();
    let range2;
    if (minDefined && maxDefined) {
      return {
        min,
        max: max2
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range2 = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range2.min);
      }
      if (!maxDefined) {
        max2 = Math.max(max2, range2.max);
      }
    }
    min = maxDefined && min > max2 ? max2 : min;
    max2 = minDefined && min > max2 ? min : max2;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max2, min)),
      max: finiteOrDefault(max2, finiteOrDefault(min, max2))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks2) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick2;
    for (i = 0, ilen = ticks2.length; i < ilen; i++) {
      tick2 = ticks2[i];
      tick2.label = callback(tickOpts.callback, [
        tick2.value,
        i,
        ticks2
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: axis2, position } = this.options;
    return position === "top" || position === "bottom" || axis2 === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks2) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks2);
    let i, ilen;
    for (i = 0, ilen = ticks2.length; i < ilen; i++) {
      if (isNullOrUndef(ticks2[i].label)) {
        ticks2.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks2 = this.ticks;
      if (sampleSize < ticks2.length) {
        ticks2 = sample(ticks2, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks2, ticks2.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks2, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches2 } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache2, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks2[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache2 = caches2[fontString] = caches2[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache2.data, cache2.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache2.data, cache2.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches2, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks2 = this.ticks;
    if (index2 < 0 || index2 > ticks2.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks2[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max: max2 } = this;
    return min < 0 && max2 < 0 ? max2 : min > 0 && max2 > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks2 = this.ticks || [];
    if (index2 >= 0 && index2 < ticks2.length) {
      const tick2 = ticks2[index2];
      return tick2.$context || (tick2.$context = createTickContext(this.getContext(), index2, tick2));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis2 = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid, position, border } = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks2 = this.ticks;
    const ticksLength = ticks2.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis2 === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis2 === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis2 = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks2 = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick2, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis2 === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis2 === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis2 === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks2.length; i < ilen; ++i) {
      tick2 = ticks2[i];
      label = tick2.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top2 = textOffset - labelPadding.top;
        let left2 = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top2 -= height / 2;
            break;
          case "bottom":
            top2 -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left2 -= width / 2;
            break;
          case "right":
            left2 -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left2 -= width;
            } else if (i > 0) {
              left2 -= width / 2;
            }
            break;
        }
        backdrop = {
          left: left2,
          top: top2,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks: ticks2 } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks2.align === "start") {
      align = "left";
    } else if (ticks2.align === "end") {
      align = "right";
    } else if (ticks2.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left: left2, top: top2, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left2, top2, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks2 = this.ticks;
    const index2 = ticks2.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type2) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type2 || meta.type === type2)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
class TypedRegistry {
  constructor(type2, scope, override) {
    this.type = type2;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type2) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type2.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id2 = item.id;
    const scope = this.scope + "." + id2;
    if (!id2) {
      throw new Error("class does not have id: " + item);
    }
    if (id2 in items) {
      return scope;
    }
    items[id2] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id2) {
    return this.items[id2];
  }
  unregister(item) {
    const items = this.items;
    const id2 = item.id;
    const scope = this.scope;
    if (id2 in items) {
      delete items[id2];
    }
    if (scope && id2 in defaults[scope]) {
      delete defaults[scope][id2];
      if (this.override) {
        delete overrides[id2];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge2(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes2) {
  Object.keys(routes2).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes2[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id2) {
    return this._get(id2, this.controllers, "controller");
  }
  getElement(id2) {
    return this._get(id2, this.elements, "element");
  }
  getPlugin(id2) {
    return this._get(id2, this.plugins, "plugin");
  }
  getScale(id2) {
    return this._get(id2, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type2) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type2)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id2, typedRegistry, type2) {
    const item = typedRegistry.get(id2);
    if (item === void 0) {
      throw new Error('"' + id2 + '" is not a registered ' + type2 + ".");
    }
    return item;
  }
}
var registry = /* @__PURE__ */ new Registry();
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter3) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter3 ? this._descriptors(chart).filter(filter3) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all2) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all2 ? [] : createDescriptors(chart, plugins2, options, all2);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
}
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all2) {
  if (!all2 && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all2) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id2 = plugin.id;
    const opts = getOpts(options[id2], all2);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id2]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type2, options) {
  const datasetDefaults = defaults.datasets[type2] || {};
  const datasetOptions = (options.datasets || {})[type2] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id2, indexAxis) {
  let axis2 = id2;
  if (id2 === "_index_") {
    axis2 = indexAxis;
  } else if (id2 === "_value_") {
    axis2 = indexAxis === "x" ? "y" : "x";
  }
  return axis2;
}
function getDefaultScaleIDFromAxis(axis2, indexAxis) {
  return axis2 === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id2) {
  if (id2 === "x" || id2 === "y" || id2 === "r") {
    return id2;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id2, ...scaleOptions) {
  if (idMatchesAxis(id2)) {
    return id2;
  }
  for (const opts of scaleOptions) {
    const axis2 = opts.axis || axisFromPosition(opts.position) || id2.length > 1 && idMatchesAxis(id2[0].toLowerCase());
    if (axis2) {
      return axis2;
    }
  }
  throw new Error(`Cannot determine type of '${id2}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id2, axis2, dataset) {
  if (dataset[axis2 + "AxisID"] === id2) {
    return {
      axis: axis2
    };
  }
}
function retrieveAxisFromDatasets(id2, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id2 || d.yAxisID === id2);
    if (boundDs.length) {
      return getAxisFromDataset(id2, "x", boundDs[0]) || getAxisFromDataset(id2, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id2) => {
    const scaleConf = configScales[id2];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id2}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id2}`);
    }
    const axis2 = determineAxis(id2, scaleConf, retrieveAxisFromDatasets(id2, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis2, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id2] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis: axis2
      },
      scaleConf,
      defaultScaleOptions[axis2],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type2 = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type2, options);
    const datasetDefaults = overrides[type2] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis2 = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id2 = dataset[axis2 + "AxisID"] || axis2;
      scales2[id2] = scales2[id2] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id2], [
        {
          axis: axis2
        },
        configScales[id2],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = /* @__PURE__ */ new Map();
const keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type2) {
    this._config.type = type2;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id2 = plugin.id;
    const type2 = this.type;
    return cachedKeys(`${type2}-plugin-${id2}`, () => [
      [
        `plugins.${id2}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache2 = _scopeCache.get(mainScope);
    if (!cache2 || resetCache) {
      cache2 = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache2);
    }
    return cache2;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type: type2 } = this;
    const cache2 = this._cachedScopes(mainScope, resetCache);
    const cached = cache2.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type2] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array2 = Array.from(scopes);
    if (array2.length === 0) {
      array2.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache2.set(keyLists, array2);
    }
    return array2;
  }
  chartOptionScopes() {
    const { options, type: type2 } = this;
    return [
      options,
      overrides[type2] || {},
      defaults.datasets[type2] || {},
      {
        type: type2
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes2 = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes2);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes2 = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes2);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes2) {
  let cache2 = resolverCache.get(scopes);
  if (!cache2) {
    cache2 = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache2);
  }
  const cacheKey = prefixes2.join();
  let cached = cache2.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes2);
    cached = {
      resolver,
      subPrefixes: prefixes2.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache2.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.4.2";
const KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis2) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis2 === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start2, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start2) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start2) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
class Chart {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id2) => {
      obj[id2] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id2) => {
        const scaleOptions = scaleOpts[id2];
        const axis2 = determineAxis(id2, scaleOptions);
        const isRadial = axis2 === "r";
        const isHorizontal = axis2 === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id2 = scaleOptions.id;
      const axis2 = determineAxis(id2, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis2) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id2] = true;
      let scale = null;
      if (id2 in scales2 && scales2[id2].type === scaleType) {
        scale = scales2[id2];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id: id2,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id2) => {
      if (!hasUpdated) {
        delete scales2[id2];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type2 = dataset.type || this.config.type;
      if (meta.type && meta.type !== type2) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type2;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type2, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type2);
        const { datasetElementType, dataElementType } = defaults.datasets[type2];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start: start2, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start2, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta, this.chartArea);
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform2 = this.platform;
    const _add = (type2, listener2) => {
      platform2.addEventListener(this, type2, listener2);
      listeners[type2] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type2) => _add(type2, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform2 = this.platform;
    const _add = (type2, listener2) => {
      platform2.addEventListener(this, type2, listener2);
      listeners[type2] = listener2;
    };
    const _remove = (type2, listener2) => {
      if (listeners[type2]) {
        platform2.removeEventListener(this, type2, listener2);
        delete listeners[type2];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform2.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type2) => {
      this.platform.removeEventListener(this, type2, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type2) => {
      this.platform.removeEventListener(this, type2, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active2 = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active2, lastActive);
    if (changed) {
      this._active = active2;
      this._lastEvent = null;
      this._updateHoverStyles(active2, lastActive);
    }
  }
  notifyPlugins(hook, args, filter3) {
    return this._plugins.notify(this, hook, args, filter3);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active2, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active2);
    const activated = replay ? active2 : diff(active2, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active2 = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e,
        active2,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e,
          active2,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active2, lastActive);
    if (changed || replay) {
      this._active = active2;
      this._updateHoverStyles(active2, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element2, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element2;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element2, offset, spacing, end, circular) {
  const { x, y, startAngle: start2, pixelMargin, innerRadius: innerR } = element2;
  const outerRadius = Math.max(element2.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start2;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start2 + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element2, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element2, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element2;
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx, element2, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element2, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element2, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element2;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx, element2, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element2, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element2, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
}
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target2) {
  ctx.lineTo(target2.x, target2.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start2 = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start: start2,
    loop: segment.loop,
    ilen: end < start2 && !outside ? count + end - start2 : end - start2
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start: start2, loop: loop2, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start2 + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop2) {
    point = points[(start2 + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop2;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start: start2, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start2 + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start2, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start2, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start2, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start: start2,
      end: start2 + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start2, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start2, count);
  } else {
    strokePathDirect(ctx, line, start2, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop2 = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop2, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start: start2, end } = segments[i];
      const p1 = points[start2];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start2, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop2 = this._loop;
    start2 = start2 || 0;
    count = count || this.points.length - start2;
    for (const segment of segments) {
      loop2 &= segmentMethod(ctx, this, segment, {
        start: start2,
        end: start2 + count - 1
      });
    }
    return !!loop2;
  }
  draw(ctx, chartArea, start2, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start2, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
}
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis2, useFinalPosition) {
  const options = el.options;
  const { [axis2]: value } = el.getProps([
    axis2
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base: base2, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left2, right2, top2, bottom2, half;
  if (bar.horizontal) {
    half = height / 2;
    left2 = Math.min(x, base2);
    right2 = Math.max(x, base2);
    top2 = y - half;
    bottom2 = y + half;
  } else {
    half = width / 2;
    left2 = x - half;
    right2 = x + half;
    top2 = Math.min(y, base2);
    bottom2 = Math.max(y, base2);
  }
  return {
    left: left2,
    top: top2,
    right: right2,
    bottom: bottom2
  };
}
function skipOrLimit(skip2, value, min, max2) {
  return skip2 ? 0 : _limitValue(value, min, max2);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base: base2, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base2) / 2 : x,
      y: horizontal ? y : (y + base2) / 2
    };
  }
  getRange(axis2) {
    return axis2 === "x" ? this.width / 2 : this.height / 2;
  }
}
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
const BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
const BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start2, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start2, start2 + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start2 + count - 1;
  let a = start2;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start2;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start2;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start2;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start2;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start2, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start2 + count - 1;
  const xMin = data[start2].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start2; i < start2 + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start2 = 0;
  let count;
  const { iScale } = meta;
  const { min, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start2 = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start2, pointCount) - start2;
  } else {
    count = pointCount - start2;
  }
  return {
    start: start2,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start: start2, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start2, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start2, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target2, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target2.points;
  const parts = [];
  for (const segment of segments) {
    let { start: start2, end } = segment;
    end = _findSegmentEnd(start2, end, points);
    const bounds = _getBounds(property, points[start2], points[end], segment.loop);
    if (!target2.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start2],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target2, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop2) {
  if (loop2) {
    return;
  }
  let start2 = first[property];
  let end = last[property];
  if (property === "angle") {
    start2 = _normalizeAngle(start2);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start: start2,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start: start2, end }) => {
    end = _findSegmentEnd(start2, end, linePoints);
    const first = linePoints[start2];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start2, end, points) {
  for (; end > start2; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target2;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target2 = sources[fill2];
    if (!target2) {
      return false;
    }
    if (target2.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target2.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target2 = parseFloat(fill2);
  if (isNumberFinite(target2) && Math.floor(target2) === target2) {
    return decodeTargetIndex(fill2[0], index2, target2, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target2, count) {
  if (firstCh === "-" || firstCh === "+") {
    target2 = index2 + target2;
  }
  if (target2 === index2 || target2 < 0 || target2 >= count) {
    return false;
  }
  return target2;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const start2 = options.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start2);
  const target2 = [];
  if (options.grid.circular) {
    const center2 = scale.getPointPositionForValue(0, start2);
    return new simpleArc({
      x: center2.x,
      y: center2.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target2.push(scale.getPointPositionForValue(i, value));
  }
  return target2;
}
function _drawfill(ctx, source, area) {
  const target2 = _getTarget(source);
  const { line, scale, axis: axis2 } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target2 && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target: target2,
      above,
      below,
      area,
      scale,
      axis: axis2
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target: target2, above, below, area, scale } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target2, area.top);
    fill(ctx, {
      line,
      target: target2,
      color: above,
      scale,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target2, area.bottom);
  }
  fill(ctx, {
    line,
    target: target2,
    color: below,
    scale,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target2, clipY) {
  const { segments, points } = target2;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start: start2, end } = segment;
    const firstPoint = points[start2];
    const lastPoint = points[_findSegmentEnd(start2, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target2.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target2.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target: target2, property, color: color2, scale } = cfg;
  const segments = _segments(line, target2, property);
  for (const { source: src, target: tgt, start: start2, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target2 !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && _getBounds(property, start2, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop2;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target2, end, property);
      }
      const targetLoop = !!target2.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop2 = lineLoop && targetLoop;
      if (!loop2) {
        interpolatedLineTo(ctx, target2, start2, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop2 ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, bounds) {
  const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
  const { property, start: start2, end } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start2, top2, end - start2, bottom2 - top2);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target2, point, property) {
  const interpolatedPoint = target2.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index$1 = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
const getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top2 = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top2 += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top: top2,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left2 = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left2 += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left: left2,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
        left2 += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top2;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top2 += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left2 = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left2, left2 + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type2, opts) {
  if ((type2 === "mousemove" || type2 === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type2 === "click" || type2 === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top: top2, left: left2, bottom: bottom2, right: right2, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      titleY = top2 + offset;
      maxWidth = right2 - left2;
    } else {
      if (options.position === "left") {
        titleX = left2 + offset;
        titleY = _alignStartEnd(align, bottom2, top2);
        rotation = PI * -0.5;
      } else {
        titleX = right2 - offset;
        titleY = _alignStartEnd(align, top2, bottom2);
        rotation = PI * 0.5;
      }
      maxWidth = bottom2 - top2;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const map$1 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map$1.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map$1.get(chart));
    map$1.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map$1.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center2 = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center2);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base2, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base2, toPush);
    } else {
      base2.push(toPush);
    }
  }
  return base2;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element: element2, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element: element2
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x, width } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left2 + right2) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent2, tooltip, tooltipItems) {
  return createContext(parent2, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
  beforeTitle: noop$1,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop$1,
  beforeBody: noop$1,
  beforeLabel: noop$1,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop$1,
  afterBody: noop$1,
  beforeFooter: noop$1,
  footer: noop$1,
  afterFooter: noop$1
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active2 = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active2.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active2[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element2, index2, array2) => options.filter(element2, index2, array2, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active2 = this._active;
    let properties;
    let tooltipItems = [];
    if (!active2.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active2, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active2 = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active2);
    const positionChanged = this._positionChanged(active2, eventPosition);
    if (changed || positionChanged) {
      this._active = active2;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active2 = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active2, e);
    const changed = replay || !_elementsEqual(active2, lastActive) || positionChanged;
    if (changed) {
      this._active = active2;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active2 = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active2.reverse();
    }
    return active2;
  }
  _positionChanged(active2, e) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active2, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index$1,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
const validIndex = (index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max: max2 } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max2 = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max2;
  }
  buildTicks() {
    const min = this.min;
    const max2 = this.max;
    const offset = this.options.offset;
    const ticks2 = [];
    let labels = this.getLabels();
    labels = min === 0 && max2 === labels.length - 1 ? labels : labels.slice(min, max2 + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max2; value++) {
      ticks2.push({
        value
      });
    }
    return ticks2;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks2 = this.ticks;
    if (index2 < 0 || index2 > ticks2.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks2[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks2 = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit2 = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max2);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit2) * unit2;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit2) * unit2;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max2 - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max2 - min) / spacing, maxTicks));
    spacing = (max2 - min) / numSpaces;
    niceMin = min;
    niceMax = max2;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max2 : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks2.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max2) {
      break;
    }
    ticks2.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max2) {
    if (ticks2.length && almostEquals(ticks2[ticks2.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
      ticks2[ticks2.length - 1].value = max2;
    } else {
      ticks2.push({
        value: max2
      });
    }
  } else if (!maxDefined || niceMax === max2) {
    ticks2.push({
      value: niceMax
    });
  }
  return ticks2;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max: max2 } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max2 = maxDefined ? max2 : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max2);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max2) {
      let offset = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
      setMax(max2 + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max2;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks2 = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks2, this, "value");
    }
    if (opts.reverse) {
      ticks2.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks2;
  }
  configure() {
    const ticks2 = this.ticks;
    let start2 = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks2.length) {
      const offset = (end - start2) / Math.max(ticks2.length - 1, 1) / 2;
      start2 -= offset;
      end += offset;
    }
    this._startValue = start2;
    this._endValue = end;
    this._valueRange = end - start2;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max2) ? max2 : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
const log10Floor = (v) => Math.floor(log10(v));
const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max2, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start2 = Math.floor(min / rangeStep);
  const end = Math.ceil(max2 / rangeStep);
  return end - start2;
}
function startExp(min, max2) {
  const range2 = max2 - min;
  let rangeExp = log10Floor(range2);
  while (steps(min, max2, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max2, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max: max2 }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks2 = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max2);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base2 = minExp > exp ? Math.pow(10, minExp) : 0;
  const start2 = Math.round((min - base2) * precision) / precision;
  const offset = Math.floor((min - base2) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start2 - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base2 + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max2) {
    ticks2.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base2 + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks2.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks2;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max2 = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max2 = maxDefined ? max2 : v;
    if (min === max2) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max2, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max2, -1));
    }
    if (max2 <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max2;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks2 = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks2, this, "value");
    }
    if (opts.reverse) {
      ticks2.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks2;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start2 = this.min;
    super.configure();
    this._startValue = log10(start2);
    this._valueRange = log10(this.max) - log10(start2);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max2) {
  if (angle === min || angle === max2) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max2) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left2 = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left: left2,
    top: y,
    right: left2 + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left: left2, top: top2, right: right2, bottom: bottom2 } = item;
  const apexesInArea = _isPointInArea({
    x: left2,
    y: top2
  }, area) || _isPointInArea({
    x: left2,
    y: bottom2
  }, area) || _isPointInArea({
    x: right2,
    y: top2
  }, area) || _isPointInArea({
    x: right2,
    y: bottom2
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left: left2, top: top2, right: right2, bottom: bottom2 } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left2 - padding.left;
    const backdropTop = top2 - padding.top;
    const backdropWidth = right2 - left2 + padding.width;
    const backdropHeight = bottom2 - top2 + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent2, index2, label) {
  return createContext(parent2, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max: max2 } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks2) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks2);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = this._pointLabelItems[index2];
    return {
      left: left2,
      top: top2,
      right: right2,
      bottom: bottom2
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick2, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick2.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick2, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick2.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick2.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
}
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse$2(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber$1(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max2, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval2 = INTERVALS[UNITS[i]];
    const factor = interval2.steps ? interval2.steps : Number.MAX_SAFE_INTEGER;
    if (interval2.common && Math.ceil((max2 - min) / (factor * interval2.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max2) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit2 = UNITS[i];
    if (INTERVALS[unit2].common && scale._adapter.diff(max2, min, unit2) >= numTicks - 1) {
      return unit2;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit2) {
  for (let i = UNITS.indexOf(unit2) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks2, time, timestamps) {
  if (!timestamps) {
    ticks2[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks2[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks2, map2, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks2[0].value, majorUnit);
  const last = ticks2[ticks2.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks2[index2].major = true;
    }
  }
  return ticks2;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks2 = [];
  const map2 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map2[value] = i;
    ticks2.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks2 : setMajorTicks(scale, ticks2, map2, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse$2(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit2 = options.time.unit || "day";
    let { min, max: max2, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max2 = Math.max(max2, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit2);
    max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit2) + 1;
    this.min = Math.min(min, max2 - 1);
    this.max = Math.max(min + 1, max2);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max2 = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max2 = arr[arr.length - 1];
    }
    return {
      min,
      max: max2
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max2 = this.max;
    const ticks2 = _filterBetween(timestamps, min, max2);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks2.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks2.reverse();
    }
    return ticksFromTimestamps(this, ticks2, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick2) => +tick2.value));
    }
  }
  initOffsets(timestamps = []) {
    let start2 = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start2 = 1 - first;
      } else {
        start2 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start2 = _limitValue(start2, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start: start2,
      end,
      factor: 1 / (start2 + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max2 = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max2, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber$1(weekday) || weekday === true;
    const ticks2 = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max2, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks2, time, timestamps);
    }
    if (time === max2 || options.bounds === "ticks" || count === 1) {
      addTick(ticks2, time, timestamps);
    }
    return Object.keys(ticks2).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format2) {
    const options = this.options;
    const formats2 = options.time.displayFormats;
    const unit2 = this._unit;
    const fmt = format2 || formats2[unit2];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks2, format2) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks2
      ], this);
    }
    const formats2 = options.time.displayFormats;
    const unit2 = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit2 && formats2[unit2];
    const majorFormat = majorUnit && formats2[majorUnit];
    const tick2 = ticks2[index2];
    const major = majorUnit && majorFormat && tick2 && tick2.major;
    return this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks2) {
    let i, ilen, tick2;
    for (i = 0, ilen = ticks2.length; i < ilen; ++i) {
      tick2 = ticks2[i];
      tick2.label = this._tickFormatFunction(tick2.value, i, ticks2);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format2);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse$2(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate$2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate$2(table, this.min);
    this._tableRange = interpolate$2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max: max2 } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max2) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max2,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max2 = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max2) || timestamps.length === 1) {
      timestamps.push(max2);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate$2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate$2(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
const registerables = [
  controllers,
  elements,
  plugins,
  scales
];
Chart.register(...registerables);
var mapboxGlDraw = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = function(t2, e3) {
      var n2 = { drag: [], click: [], mousemove: [], mousedown: [], mouseup: [], mouseout: [], keydown: [], keyup: [], touchstart: [], touchmove: [], touchend: [], tap: [] }, o2 = { on: function(t3, e4, o3) {
        if (void 0 === n2[t3])
          throw new Error("Invalid event type: " + t3);
        n2[t3].push({ selector: e4, fn: o3 });
      }, render: function(t3) {
        e3.store.featureChanged(t3);
      } }, r2 = function(t3, r3) {
        for (var i2 = n2[t3], a2 = i2.length; a2--; ) {
          var s2 = i2[a2];
          if (s2.selector(r3)) {
            s2.fn.call(o2, r3) || e3.store.render(), e3.ui.updateMapClasses();
            break;
          }
        }
      };
      return t2.start.call(o2), { render: t2.render, stop: function() {
        t2.stop && t2.stop();
      }, trash: function() {
        t2.trash && (t2.trash(), e3.store.render());
      }, combineFeatures: function() {
        t2.combineFeatures && t2.combineFeatures();
      }, uncombineFeatures: function() {
        t2.uncombineFeatures && t2.uncombineFeatures();
      }, drag: function(t3) {
        r2("drag", t3);
      }, click: function(t3) {
        r2("click", t3);
      }, mousemove: function(t3) {
        r2("mousemove", t3);
      }, mousedown: function(t3) {
        r2("mousedown", t3);
      }, mouseup: function(t3) {
        r2("mouseup", t3);
      }, mouseout: function(t3) {
        r2("mouseout", t3);
      }, keydown: function(t3) {
        r2("keydown", t3);
      }, keyup: function(t3) {
        r2("keyup", t3);
      }, touchstart: function(t3) {
        r2("touchstart", t3);
      }, touchmove: function(t3) {
        r2("touchmove", t3);
      }, touchend: function(t3) {
        r2("touchend", t3);
      }, tap: function(t3) {
        r2("tap", t3);
      } };
    };
    function e(t2) {
      return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
    }
    function n(t2) {
      if (t2.__esModule)
        return t2;
      var e3 = t2.default;
      if ("function" == typeof e3) {
        var n2 = function t3() {
          if (this instanceof t3) {
            var n3 = [null];
            n3.push.apply(n3, arguments);
            var o2 = Function.bind.apply(e3, n3);
            return new o2();
          }
          return e3.apply(this, arguments);
        };
        n2.prototype = e3.prototype;
      } else
        n2 = {};
      return Object.defineProperty(n2, "__esModule", { value: true }), Object.keys(t2).forEach(function(e4) {
        var o2 = Object.getOwnPropertyDescriptor(t2, e4);
        Object.defineProperty(n2, e4, o2.get ? o2 : { enumerable: true, get: function() {
          return t2[e4];
        } });
      }), n2;
    }
    var o = {}, r = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 63567523142e-4 }, i = r;
    function a(t2) {
      var e3 = 0;
      if (t2 && t2.length > 0) {
        e3 += Math.abs(s(t2[0]));
        for (var n2 = 1; n2 < t2.length; n2++)
          e3 -= Math.abs(s(t2[n2]));
      }
      return e3;
    }
    function s(t2) {
      var e3, n2, o2, r2, a2, s2, c2 = 0, l2 = t2.length;
      if (l2 > 2) {
        for (s2 = 0; s2 < l2; s2++)
          s2 === l2 - 2 ? (o2 = l2 - 2, r2 = l2 - 1, a2 = 0) : s2 === l2 - 1 ? (o2 = l2 - 1, r2 = 0, a2 = 1) : (o2 = s2, r2 = s2 + 1, a2 = s2 + 2), e3 = t2[o2], n2 = t2[r2], c2 += (u(t2[a2][0]) - u(e3[0])) * Math.sin(u(n2[1]));
        c2 = c2 * i.RADIUS * i.RADIUS / 2;
      }
      return c2;
    }
    function u(t2) {
      return t2 * Math.PI / 180;
    }
    o.geometry = function t2(e3) {
      var n2, o2 = 0;
      switch (e3.type) {
        case "Polygon":
          return a(e3.coordinates);
        case "MultiPolygon":
          for (n2 = 0; n2 < e3.coordinates.length; n2++)
            o2 += a(e3.coordinates[n2]);
          return o2;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
          return 0;
        case "GeometryCollection":
          for (n2 = 0; n2 < e3.geometries.length; n2++)
            o2 += t2(e3.geometries[n2]);
          return o2;
      }
    }, o.ring = s;
    var c = { CONTROL_BASE: "mapboxgl-ctrl", CONTROL_PREFIX: "mapboxgl-ctrl-", CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn", CONTROL_BUTTON_LINE: "mapbox-gl-draw_line", CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon", CONTROL_BUTTON_POINT: "mapbox-gl-draw_point", CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash", CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine", CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine", CONTROL_GROUP: "mapboxgl-ctrl-group", ATTRIBUTION: "mapboxgl-ctrl-attrib", ACTIVE_BUTTON: "active", BOX_SELECT: "mapbox-gl-draw_boxselect" }, l = { HOT: "mapbox-gl-draw-hot", COLD: "mapbox-gl-draw-cold" }, d = { ADD: "add", MOVE: "move", DRAG: "drag", POINTER: "pointer", NONE: "none" }, p = { POLYGON: "polygon", LINE: "line_string", POINT: "point" }, f = { FEATURE: "Feature", POLYGON: "Polygon", LINE_STRING: "LineString", POINT: "Point", FEATURE_COLLECTION: "FeatureCollection", MULTI_PREFIX: "Multi", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon" }, h = { DRAW_LINE_STRING: "draw_line_string", DRAW_POLYGON: "draw_polygon", DRAW_POINT: "draw_point", SIMPLE_SELECT: "simple_select", DIRECT_SELECT: "direct_select", STATIC: "static" }, g = { CREATE: "draw.create", DELETE: "draw.delete", UPDATE: "draw.update", SELECTION_CHANGE: "draw.selectionchange", MODE_CHANGE: "draw.modechange", ACTIONABLE: "draw.actionable", RENDER: "draw.render", COMBINE_FEATURES: "draw.combine", UNCOMBINE_FEATURES: "draw.uncombine" }, y = { MOVE: "move", CHANGE_COORDINATES: "change_coordinates" }, v = { FEATURE: "feature", MIDPOINT: "midpoint", VERTEX: "vertex" }, m = { ACTIVE: "true", INACTIVE: "false" }, _ = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"], b = -85, E = Object.freeze({ __proto__: null, classes: c, sources: l, cursors: d, types: p, geojsonTypes: f, modes: h, events: g, updateActions: y, meta: v, activeStates: m, interactions: _, LAT_MIN: -90, LAT_RENDERED_MIN: b, LAT_MAX: 90, LAT_RENDERED_MAX: 85, LNG_MIN: -270, LNG_MAX: 270 }), T = { Point: 0, LineString: 1, MultiLineString: 1, Polygon: 2 };
    function C(t2, e3) {
      var n2 = T[t2.geometry.type] - T[e3.geometry.type];
      return 0 === n2 && t2.geometry.type === f.POLYGON ? t2.area - e3.area : n2;
    }
    function O(t2) {
      return t2.map(function(t3) {
        return t3.geometry.type === f.POLYGON && (t3.area = o.geometry({ type: f.FEATURE, property: {}, geometry: t3.geometry })), t3;
      }).sort(C).map(function(t3) {
        return delete t3.area, t3;
      });
    }
    function S(t2, e3) {
      return void 0 === e3 && (e3 = 0), [[t2.point.x - e3, t2.point.y - e3], [t2.point.x + e3, t2.point.y + e3]];
    }
    function I(t2) {
      if (this._items = {}, this._nums = {}, this._length = t2 ? t2.length : 0, t2)
        for (var e3 = 0, n2 = t2.length; e3 < n2; e3++)
          this.add(t2[e3]), void 0 !== t2[e3] && ("string" == typeof t2[e3] ? this._items[t2[e3]] = e3 : this._nums[t2[e3]] = e3);
    }
    I.prototype.add = function(t2) {
      return this.has(t2) || (this._length++, "string" == typeof t2 ? this._items[t2] = this._length : this._nums[t2] = this._length), this;
    }, I.prototype.delete = function(t2) {
      return false === this.has(t2) || (this._length--, delete this._items[t2], delete this._nums[t2]), this;
    }, I.prototype.has = function(t2) {
      return ("string" == typeof t2 || "number" == typeof t2) && (void 0 !== this._items[t2] || void 0 !== this._nums[t2]);
    }, I.prototype.values = function() {
      var t2 = this, e3 = [];
      return Object.keys(this._items).forEach(function(n2) {
        e3.push({ k: n2, v: t2._items[n2] });
      }), Object.keys(this._nums).forEach(function(n2) {
        e3.push({ k: JSON.parse(n2), v: t2._nums[n2] });
      }), e3.sort(function(t3, e4) {
        return t3.v - e4.v;
      }).map(function(t3) {
        return t3.k;
      });
    }, I.prototype.clear = function() {
      return this._length = 0, this._items = {}, this._nums = {}, this;
    };
    var x = [v.FEATURE, v.MIDPOINT, v.VERTEX], M = { click: function(t2, e3, n2) {
      return L(t2, e3, n2, n2.options.clickBuffer);
    }, touch: function(t2, e3, n2) {
      return L(t2, e3, n2, n2.options.touchBuffer);
    } };
    function L(t2, e3, n2, o2) {
      if (null === n2.map)
        return [];
      var r2 = t2 ? S(t2, o2) : e3, i2 = {};
      n2.options.styles && (i2.layers = n2.options.styles.map(function(t3) {
        return t3.id;
      }).filter(function(t3) {
        return null != n2.map.getLayer(t3);
      }));
      var a2 = n2.map.queryRenderedFeatures(r2, i2).filter(function(t3) {
        return -1 !== x.indexOf(t3.properties.meta);
      }), s2 = new I(), u2 = [];
      return a2.forEach(function(t3) {
        var e4 = t3.properties.id;
        s2.has(e4) || (s2.add(e4), u2.push(t3));
      }), O(u2);
    }
    function N(t2, e3) {
      var n2 = M.click(t2, null, e3), o2 = { mouse: d.NONE };
      return n2[0] && (o2.mouse = n2[0].properties.active === m.ACTIVE ? d.MOVE : d.POINTER, o2.feature = n2[0].properties.meta), -1 !== e3.events.currentModeName().indexOf("draw") && (o2.mouse = d.ADD), e3.ui.queueMapClasses(o2), e3.ui.updateMapClasses(), n2[0];
    }
    function A(t2, e3) {
      var n2 = t2.x - e3.x, o2 = t2.y - e3.y;
      return Math.sqrt(n2 * n2 + o2 * o2);
    }
    function P(t2, e3, n2) {
      void 0 === n2 && (n2 = {});
      var o2 = null != n2.fineTolerance ? n2.fineTolerance : 4, r2 = null != n2.grossTolerance ? n2.grossTolerance : 12, i2 = null != n2.interval ? n2.interval : 500;
      t2.point = t2.point || e3.point, t2.time = t2.time || e3.time;
      var a2 = A(t2.point, e3.point);
      return a2 < o2 || a2 < r2 && e3.time - t2.time < i2;
    }
    function F(t2, e3, n2) {
      void 0 === n2 && (n2 = {});
      var o2 = null != n2.tolerance ? n2.tolerance : 25, r2 = null != n2.interval ? n2.interval : 250;
      return t2.point = t2.point || e3.point, t2.time = t2.time || e3.time, A(t2.point, e3.point) < o2 && e3.time - t2.time < r2;
    }
    var w = { exports: {} }, R = w.exports = function(t2, e3) {
      if (e3 || (e3 = 16), void 0 === t2 && (t2 = 128), t2 <= 0)
        return "0";
      for (var n2 = Math.log(Math.pow(2, t2)) / Math.log(e3), o2 = 2; n2 === 1 / 0; o2 *= 2)
        n2 = Math.log(Math.pow(2, t2 / o2)) / Math.log(e3) * o2;
      var r2 = n2 - Math.floor(n2), i2 = "";
      for (o2 = 0; o2 < Math.floor(n2); o2++) {
        i2 = Math.floor(Math.random() * e3).toString(e3) + i2;
      }
      if (r2) {
        var a2 = Math.pow(e3, r2);
        i2 = Math.floor(Math.random() * a2).toString(e3) + i2;
      }
      var s2 = parseInt(i2, e3);
      return s2 !== 1 / 0 && s2 >= Math.pow(2, t2) ? R(t2, e3) : i2;
    };
    R.rack = function(t2, e3, n2) {
      var o2 = function(o3) {
        var i2 = 0;
        do {
          if (i2++ > 10) {
            if (!n2)
              throw new Error("too many ID collisions, use more bits");
            t2 += n2;
          }
          var a2 = R(t2, e3);
        } while (Object.hasOwnProperty.call(r2, a2));
        return r2[a2] = o3, a2;
      }, r2 = o2.hats = {};
      return o2.get = function(t3) {
        return o2.hats[t3];
      }, o2.set = function(t3, e4) {
        return o2.hats[t3] = e4, o2;
      }, o2.bits = t2 || 128, o2.base = e3 || 16, o2;
    };
    var k = e(w.exports), D = function(t2, e3) {
      this.ctx = t2, this.properties = e3.properties || {}, this.coordinates = e3.geometry.coordinates, this.id = e3.id || k(), this.type = e3.geometry.type;
    };
    D.prototype.changed = function() {
      this.ctx.store.featureChanged(this.id);
    }, D.prototype.incomingCoords = function(t2) {
      this.setCoordinates(t2);
    }, D.prototype.setCoordinates = function(t2) {
      this.coordinates = t2, this.changed();
    }, D.prototype.getCoordinates = function() {
      return JSON.parse(JSON.stringify(this.coordinates));
    }, D.prototype.setProperty = function(t2, e3) {
      this.properties[t2] = e3;
    }, D.prototype.toGeoJSON = function() {
      return JSON.parse(JSON.stringify({ id: this.id, type: f.FEATURE, properties: this.properties, geometry: { coordinates: this.getCoordinates(), type: this.type } }));
    }, D.prototype.internal = function(t2) {
      var e3 = { id: this.id, meta: v.FEATURE, "meta:type": this.type, active: m.INACTIVE, mode: t2 };
      if (this.ctx.options.userProperties)
        for (var n2 in this.properties)
          e3["user_" + n2] = this.properties[n2];
      return { type: f.FEATURE, properties: e3, geometry: { coordinates: this.getCoordinates(), type: this.type } };
    };
    var U = function(t2, e3) {
      D.call(this, t2, e3);
    };
    (U.prototype = Object.create(D.prototype)).isValid = function() {
      return "number" == typeof this.coordinates[0] && "number" == typeof this.coordinates[1];
    }, U.prototype.updateCoordinate = function(t2, e3, n2) {
      this.coordinates = 3 === arguments.length ? [e3, n2] : [t2, e3], this.changed();
    }, U.prototype.getCoordinate = function() {
      return this.getCoordinates();
    };
    var j = function(t2, e3) {
      D.call(this, t2, e3);
    };
    (j.prototype = Object.create(D.prototype)).isValid = function() {
      return this.coordinates.length > 1;
    }, j.prototype.addCoordinate = function(t2, e3, n2) {
      this.changed();
      var o2 = parseInt(t2, 10);
      this.coordinates.splice(o2, 0, [e3, n2]);
    }, j.prototype.getCoordinate = function(t2) {
      var e3 = parseInt(t2, 10);
      return JSON.parse(JSON.stringify(this.coordinates[e3]));
    }, j.prototype.removeCoordinate = function(t2) {
      this.changed(), this.coordinates.splice(parseInt(t2, 10), 1);
    }, j.prototype.updateCoordinate = function(t2, e3, n2) {
      var o2 = parseInt(t2, 10);
      this.coordinates[o2] = [e3, n2], this.changed();
    };
    var V = function(t2, e3) {
      D.call(this, t2, e3), this.coordinates = this.coordinates.map(function(t3) {
        return t3.slice(0, -1);
      });
    };
    (V.prototype = Object.create(D.prototype)).isValid = function() {
      return 0 !== this.coordinates.length && this.coordinates.every(function(t2) {
        return t2.length > 2;
      });
    }, V.prototype.incomingCoords = function(t2) {
      this.coordinates = t2.map(function(t3) {
        return t3.slice(0, -1);
      }), this.changed();
    }, V.prototype.setCoordinates = function(t2) {
      this.coordinates = t2, this.changed();
    }, V.prototype.addCoordinate = function(t2, e3, n2) {
      this.changed();
      var o2 = t2.split(".").map(function(t3) {
        return parseInt(t3, 10);
      });
      this.coordinates[o2[0]].splice(o2[1], 0, [e3, n2]);
    }, V.prototype.removeCoordinate = function(t2) {
      this.changed();
      var e3 = t2.split(".").map(function(t3) {
        return parseInt(t3, 10);
      }), n2 = this.coordinates[e3[0]];
      n2 && (n2.splice(e3[1], 1), n2.length < 3 && this.coordinates.splice(e3[0], 1));
    }, V.prototype.getCoordinate = function(t2) {
      var e3 = t2.split(".").map(function(t3) {
        return parseInt(t3, 10);
      }), n2 = this.coordinates[e3[0]];
      return JSON.parse(JSON.stringify(n2[e3[1]]));
    }, V.prototype.getCoordinates = function() {
      return this.coordinates.map(function(t2) {
        return t2.concat([t2[0]]);
      });
    }, V.prototype.updateCoordinate = function(t2, e3, n2) {
      this.changed();
      var o2 = t2.split("."), r2 = parseInt(o2[0], 10), i2 = parseInt(o2[1], 10);
      void 0 === this.coordinates[r2] && (this.coordinates[r2] = []), this.coordinates[r2][i2] = [e3, n2];
    };
    var B = { MultiPoint: U, MultiLineString: j, MultiPolygon: V }, G = function(t2, e3, n2, o2, r2) {
      var i2 = n2.split("."), a2 = parseInt(i2[0], 10), s2 = i2[1] ? i2.slice(1).join(".") : null;
      return t2[a2][e3](s2, o2, r2);
    }, J = function(t2, e3) {
      if (D.call(this, t2, e3), delete this.coordinates, this.model = B[e3.geometry.type], void 0 === this.model)
        throw new TypeError(e3.geometry.type + " is not a valid type");
      this.features = this._coordinatesToFeatures(e3.geometry.coordinates);
    };
    function z(t2) {
      this.map = t2.map, this.drawConfig = JSON.parse(JSON.stringify(t2.options || {})), this._ctx = t2;
    }
    (J.prototype = Object.create(D.prototype))._coordinatesToFeatures = function(t2) {
      var e3 = this, n2 = this.model.bind(this);
      return t2.map(function(t3) {
        return new n2(e3.ctx, { id: k(), type: f.FEATURE, properties: {}, geometry: { coordinates: t3, type: e3.type.replace("Multi", "") } });
      });
    }, J.prototype.isValid = function() {
      return this.features.every(function(t2) {
        return t2.isValid();
      });
    }, J.prototype.setCoordinates = function(t2) {
      this.features = this._coordinatesToFeatures(t2), this.changed();
    }, J.prototype.getCoordinate = function(t2) {
      return G(this.features, "getCoordinate", t2);
    }, J.prototype.getCoordinates = function() {
      return JSON.parse(JSON.stringify(this.features.map(function(t2) {
        return t2.type === f.POLYGON ? t2.getCoordinates() : t2.coordinates;
      })));
    }, J.prototype.updateCoordinate = function(t2, e3, n2) {
      G(this.features, "updateCoordinate", t2, e3, n2), this.changed();
    }, J.prototype.addCoordinate = function(t2, e3, n2) {
      G(this.features, "addCoordinate", t2, e3, n2), this.changed();
    }, J.prototype.removeCoordinate = function(t2) {
      G(this.features, "removeCoordinate", t2), this.changed();
    }, J.prototype.getFeatures = function() {
      return this.features;
    }, z.prototype.setSelected = function(t2) {
      return this._ctx.store.setSelected(t2);
    }, z.prototype.setSelectedCoordinates = function(t2) {
      var e3 = this;
      this._ctx.store.setSelectedCoordinates(t2), t2.reduce(function(t3, n2) {
        return void 0 === t3[n2.feature_id] && (t3[n2.feature_id] = true, e3._ctx.store.get(n2.feature_id).changed()), t3;
      }, {});
    }, z.prototype.getSelected = function() {
      return this._ctx.store.getSelected();
    }, z.prototype.getSelectedIds = function() {
      return this._ctx.store.getSelectedIds();
    }, z.prototype.isSelected = function(t2) {
      return this._ctx.store.isSelected(t2);
    }, z.prototype.getFeature = function(t2) {
      return this._ctx.store.get(t2);
    }, z.prototype.select = function(t2) {
      return this._ctx.store.select(t2);
    }, z.prototype.deselect = function(t2) {
      return this._ctx.store.deselect(t2);
    }, z.prototype.deleteFeature = function(t2, e3) {
      return void 0 === e3 && (e3 = {}), this._ctx.store.delete(t2, e3);
    }, z.prototype.addFeature = function(t2) {
      return this._ctx.store.add(t2);
    }, z.prototype.clearSelectedFeatures = function() {
      return this._ctx.store.clearSelected();
    }, z.prototype.clearSelectedCoordinates = function() {
      return this._ctx.store.clearSelectedCoordinates();
    }, z.prototype.setActionableState = function(t2) {
      void 0 === t2 && (t2 = {});
      var e3 = { trash: t2.trash || false, combineFeatures: t2.combineFeatures || false, uncombineFeatures: t2.uncombineFeatures || false };
      return this._ctx.events.actionable(e3);
    }, z.prototype.changeMode = function(t2, e3, n2) {
      return void 0 === e3 && (e3 = {}), void 0 === n2 && (n2 = {}), this._ctx.events.changeMode(t2, e3, n2);
    }, z.prototype.updateUIClasses = function(t2) {
      return this._ctx.ui.queueMapClasses(t2);
    }, z.prototype.activateUIButton = function(t2) {
      return this._ctx.ui.setActiveButton(t2);
    }, z.prototype.featuresAt = function(t2, e3, n2) {
      if (void 0 === n2 && (n2 = "click"), "click" !== n2 && "touch" !== n2)
        throw new Error("invalid buffer type");
      return M[n2](t2, e3, this._ctx);
    }, z.prototype.newFeature = function(t2) {
      var e3 = t2.geometry.type;
      return e3 === f.POINT ? new U(this._ctx, t2) : e3 === f.LINE_STRING ? new j(this._ctx, t2) : e3 === f.POLYGON ? new V(this._ctx, t2) : new J(this._ctx, t2);
    }, z.prototype.isInstanceOf = function(t2, e3) {
      if (t2 === f.POINT)
        return e3 instanceof U;
      if (t2 === f.LINE_STRING)
        return e3 instanceof j;
      if (t2 === f.POLYGON)
        return e3 instanceof V;
      if ("MultiFeature" === t2)
        return e3 instanceof J;
      throw new Error("Unknown feature class: " + t2);
    }, z.prototype.doRender = function(t2) {
      return this._ctx.store.featureChanged(t2);
    }, z.prototype.onSetup = function() {
    }, z.prototype.onDrag = function() {
    }, z.prototype.onClick = function() {
    }, z.prototype.onMouseMove = function() {
    }, z.prototype.onMouseDown = function() {
    }, z.prototype.onMouseUp = function() {
    }, z.prototype.onMouseOut = function() {
    }, z.prototype.onKeyUp = function() {
    }, z.prototype.onKeyDown = function() {
    }, z.prototype.onTouchStart = function() {
    }, z.prototype.onTouchMove = function() {
    }, z.prototype.onTouchEnd = function() {
    }, z.prototype.onTap = function() {
    }, z.prototype.onStop = function() {
    }, z.prototype.onTrash = function() {
    }, z.prototype.onCombineFeature = function() {
    }, z.prototype.onUncombineFeature = function() {
    }, z.prototype.toDisplayFeatures = function() {
      throw new Error("You must overwrite toDisplayFeatures");
    };
    var Y = { drag: "onDrag", click: "onClick", mousemove: "onMouseMove", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseout: "onMouseOut", keyup: "onKeyUp", keydown: "onKeyDown", touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", tap: "onTap" }, $ = Object.keys(Y);
    function q(t2) {
      var e3 = Object.keys(t2);
      return function(n2, o2) {
        void 0 === o2 && (o2 = {});
        var r2 = {}, i2 = e3.reduce(function(e4, n3) {
          return e4[n3] = t2[n3], e4;
        }, new z(n2));
        return { start: function() {
          var e4 = this;
          r2 = i2.onSetup(o2), $.forEach(function(n3) {
            var o3, a2 = Y[n3], s2 = function() {
              return false;
            };
            t2[a2] && (s2 = function() {
              return true;
            }), e4.on(n3, s2, (o3 = a2, function(t3) {
              return i2[o3](r2, t3);
            }));
          });
        }, stop: function() {
          i2.onStop(r2);
        }, trash: function() {
          i2.onTrash(r2);
        }, combineFeatures: function() {
          i2.onCombineFeatures(r2);
        }, uncombineFeatures: function() {
          i2.onUncombineFeatures(r2);
        }, render: function(t3, e4) {
          i2.toDisplayFeatures(r2, t3, e4);
        } };
      };
    }
    function H(t2) {
      return [].concat(t2).filter(function(t3) {
        return void 0 !== t3;
      });
    }
    function X() {
      var t2 = this;
      if (!(t2.ctx.map && void 0 !== t2.ctx.map.getSource(l.HOT)))
        return u2();
      var e3 = t2.ctx.events.currentModeName();
      t2.ctx.ui.queueMapClasses({ mode: e3 });
      var n2 = [], o2 = [];
      t2.isDirty ? o2 = t2.getAllIds() : (n2 = t2.getChangedIds().filter(function(e4) {
        return void 0 !== t2.get(e4);
      }), o2 = t2.sources.hot.filter(function(e4) {
        return e4.properties.id && -1 === n2.indexOf(e4.properties.id) && void 0 !== t2.get(e4.properties.id);
      }).map(function(t3) {
        return t3.properties.id;
      })), t2.sources.hot = [];
      var r2 = t2.sources.cold.length;
      t2.sources.cold = t2.isDirty ? [] : t2.sources.cold.filter(function(t3) {
        var e4 = t3.properties.id || t3.properties.parent;
        return -1 === n2.indexOf(e4);
      });
      var i2 = r2 !== t2.sources.cold.length || o2.length > 0;
      function a2(n3, o3) {
        var r3 = t2.get(n3).internal(e3);
        t2.ctx.events.currentModeRender(r3, function(e4) {
          t2.sources[o3].push(e4);
        });
      }
      if (n2.forEach(function(t3) {
        return a2(t3, "hot");
      }), o2.forEach(function(t3) {
        return a2(t3, "cold");
      }), i2 && t2.ctx.map.getSource(l.COLD).setData({ type: f.FEATURE_COLLECTION, features: t2.sources.cold }), t2.ctx.map.getSource(l.HOT).setData({ type: f.FEATURE_COLLECTION, features: t2.sources.hot }), t2._emitSelectionChange && (t2.ctx.map.fire(g.SELECTION_CHANGE, { features: t2.getSelected().map(function(t3) {
        return t3.toGeoJSON();
      }), points: t2.getSelectedCoordinates().map(function(t3) {
        return { type: f.FEATURE, properties: {}, geometry: { type: f.POINT, coordinates: t3.coordinates } };
      }) }), t2._emitSelectionChange = false), t2._deletedFeaturesToEmit.length) {
        var s2 = t2._deletedFeaturesToEmit.map(function(t3) {
          return t3.toGeoJSON();
        });
        t2._deletedFeaturesToEmit = [], t2.ctx.map.fire(g.DELETE, { features: s2 });
      }
      function u2() {
        t2.isDirty = false, t2.clearChangedIds();
      }
      u2(), t2.ctx.map.fire(g.RENDER, {});
    }
    function Z(t2) {
      var e3, n2 = this;
      this._features = {}, this._featureIds = new I(), this._selectedFeatureIds = new I(), this._selectedCoordinates = [], this._changedFeatureIds = new I(), this._deletedFeaturesToEmit = [], this._emitSelectionChange = false, this._mapInitialConfig = {}, this.ctx = t2, this.sources = { hot: [], cold: [] }, this.render = function() {
        e3 || (e3 = requestAnimationFrame(function() {
          e3 = null, X.call(n2);
        }));
      }, this.isDirty = false;
    }
    function W(t2, e3) {
      var n2 = t2._selectedCoordinates.filter(function(e4) {
        return t2._selectedFeatureIds.has(e4.feature_id);
      });
      t2._selectedCoordinates.length === n2.length || e3.silent || (t2._emitSelectionChange = true), t2._selectedCoordinates = n2;
    }
    Z.prototype.createRenderBatch = function() {
      var t2 = this, e3 = this.render, n2 = 0;
      return this.render = function() {
        n2++;
      }, function() {
        t2.render = e3, n2 > 0 && t2.render();
      };
    }, Z.prototype.setDirty = function() {
      return this.isDirty = true, this;
    }, Z.prototype.featureChanged = function(t2) {
      return this._changedFeatureIds.add(t2), this;
    }, Z.prototype.getChangedIds = function() {
      return this._changedFeatureIds.values();
    }, Z.prototype.clearChangedIds = function() {
      return this._changedFeatureIds.clear(), this;
    }, Z.prototype.getAllIds = function() {
      return this._featureIds.values();
    }, Z.prototype.add = function(t2) {
      return this.featureChanged(t2.id), this._features[t2.id] = t2, this._featureIds.add(t2.id), this;
    }, Z.prototype.delete = function(t2, e3) {
      var n2 = this;
      return void 0 === e3 && (e3 = {}), H(t2).forEach(function(t3) {
        n2._featureIds.has(t3) && (n2._featureIds.delete(t3), n2._selectedFeatureIds.delete(t3), e3.silent || -1 === n2._deletedFeaturesToEmit.indexOf(n2._features[t3]) && n2._deletedFeaturesToEmit.push(n2._features[t3]), delete n2._features[t3], n2.isDirty = true);
      }), W(this, e3), this;
    }, Z.prototype.get = function(t2) {
      return this._features[t2];
    }, Z.prototype.getAll = function() {
      var t2 = this;
      return Object.keys(this._features).map(function(e3) {
        return t2._features[e3];
      });
    }, Z.prototype.select = function(t2, e3) {
      var n2 = this;
      return void 0 === e3 && (e3 = {}), H(t2).forEach(function(t3) {
        n2._selectedFeatureIds.has(t3) || (n2._selectedFeatureIds.add(t3), n2._changedFeatureIds.add(t3), e3.silent || (n2._emitSelectionChange = true));
      }), this;
    }, Z.prototype.deselect = function(t2, e3) {
      var n2 = this;
      return void 0 === e3 && (e3 = {}), H(t2).forEach(function(t3) {
        n2._selectedFeatureIds.has(t3) && (n2._selectedFeatureIds.delete(t3), n2._changedFeatureIds.add(t3), e3.silent || (n2._emitSelectionChange = true));
      }), W(this, e3), this;
    }, Z.prototype.clearSelected = function(t2) {
      return void 0 === t2 && (t2 = {}), this.deselect(this._selectedFeatureIds.values(), { silent: t2.silent }), this;
    }, Z.prototype.setSelected = function(t2, e3) {
      var n2 = this;
      return void 0 === e3 && (e3 = {}), t2 = H(t2), this.deselect(this._selectedFeatureIds.values().filter(function(e4) {
        return -1 === t2.indexOf(e4);
      }), { silent: e3.silent }), this.select(t2.filter(function(t3) {
        return !n2._selectedFeatureIds.has(t3);
      }), { silent: e3.silent }), this;
    }, Z.prototype.setSelectedCoordinates = function(t2) {
      return this._selectedCoordinates = t2, this._emitSelectionChange = true, this;
    }, Z.prototype.clearSelectedCoordinates = function() {
      return this._selectedCoordinates = [], this._emitSelectionChange = true, this;
    }, Z.prototype.getSelectedIds = function() {
      return this._selectedFeatureIds.values();
    }, Z.prototype.getSelected = function() {
      var t2 = this;
      return this._selectedFeatureIds.values().map(function(e3) {
        return t2.get(e3);
      });
    }, Z.prototype.getSelectedCoordinates = function() {
      var t2 = this;
      return this._selectedCoordinates.map(function(e3) {
        return { coordinates: t2.get(e3.feature_id).getCoordinate(e3.coord_path) };
      });
    }, Z.prototype.isSelected = function(t2) {
      return this._selectedFeatureIds.has(t2);
    }, Z.prototype.setFeatureProperty = function(t2, e3, n2) {
      this.get(t2).setProperty(e3, n2), this.featureChanged(t2);
    }, Z.prototype.storeMapConfig = function() {
      var t2 = this;
      _.forEach(function(e3) {
        t2.ctx.map[e3] && (t2._mapInitialConfig[e3] = t2.ctx.map[e3].isEnabled());
      });
    }, Z.prototype.restoreMapConfig = function() {
      var t2 = this;
      Object.keys(this._mapInitialConfig).forEach(function(e3) {
        t2._mapInitialConfig[e3] ? t2.ctx.map[e3].enable() : t2.ctx.map[e3].disable();
      });
    }, Z.prototype.getInitialConfigValue = function(t2) {
      return void 0 === this._mapInitialConfig[t2] || this._mapInitialConfig[t2];
    };
    var K = function() {
      for (var t2 = arguments, e3 = {}, n2 = 0; n2 < arguments.length; n2++) {
        var o2 = t2[n2];
        for (var r2 in o2)
          Q.call(o2, r2) && (e3[r2] = o2[r2]);
      }
      return e3;
    }, Q = Object.prototype.hasOwnProperty;
    var tt = e(K), et = ["mode", "feature", "mouse"];
    function nt(e3) {
      var n2 = null, o2 = null, r2 = { onRemove: function() {
        return e3.map.off("load", r2.connect), clearInterval(o2), r2.removeLayers(), e3.store.restoreMapConfig(), e3.ui.removeButtons(), e3.events.removeEventListeners(), e3.ui.clearMapClasses(), e3.boxZoomInitial && e3.map.boxZoom.enable(), e3.map = null, e3.container = null, e3.store = null, n2 && n2.parentNode && n2.parentNode.removeChild(n2), n2 = null, this;
      }, connect: function() {
        e3.map.off("load", r2.connect), clearInterval(o2), r2.addLayers(), e3.store.storeMapConfig(), e3.events.addEventListeners();
      }, onAdd: function(i2) {
        var a2 = i2.fire;
        return i2.fire = function(t2, e4) {
          var n3 = arguments;
          return 1 === a2.length && 1 !== arguments.length && (n3 = [tt({}, { type: t2 }, e4)]), a2.apply(i2, n3);
        }, e3.map = i2, e3.events = function(e4) {
          var n3 = Object.keys(e4.options.modes).reduce(function(t2, n4) {
            return t2[n4] = q(e4.options.modes[n4]), t2;
          }, {}), o3 = {}, r3 = {}, i3 = {}, a3 = null, s2 = null;
          i3.drag = function(t2, n4) {
            n4({ point: t2.point, time: (/* @__PURE__ */ new Date()).getTime() }) ? (e4.ui.queueMapClasses({ mouse: d.DRAG }), s2.drag(t2)) : t2.originalEvent.stopPropagation();
          }, i3.mousedrag = function(t2) {
            i3.drag(t2, function(t3) {
              return !P(o3, t3);
            });
          }, i3.touchdrag = function(t2) {
            i3.drag(t2, function(t3) {
              return !F(r3, t3);
            });
          }, i3.mousemove = function(t2) {
            if (1 === (void 0 !== t2.originalEvent.buttons ? t2.originalEvent.buttons : t2.originalEvent.which))
              return i3.mousedrag(t2);
            var n4 = N(t2, e4);
            t2.featureTarget = n4, s2.mousemove(t2);
          }, i3.mousedown = function(t2) {
            o3 = { time: (/* @__PURE__ */ new Date()).getTime(), point: t2.point };
            var n4 = N(t2, e4);
            t2.featureTarget = n4, s2.mousedown(t2);
          }, i3.mouseup = function(t2) {
            var n4 = N(t2, e4);
            t2.featureTarget = n4, P(o3, { point: t2.point, time: (/* @__PURE__ */ new Date()).getTime() }) ? s2.click(t2) : s2.mouseup(t2);
          }, i3.mouseout = function(t2) {
            s2.mouseout(t2);
          }, i3.touchstart = function(t2) {
            if (e4.options.touchEnabled) {
              r3 = { time: (/* @__PURE__ */ new Date()).getTime(), point: t2.point };
              var n4 = M.touch(t2, null, e4)[0];
              t2.featureTarget = n4, s2.touchstart(t2);
            }
          }, i3.touchmove = function(t2) {
            if (e4.options.touchEnabled)
              return s2.touchmove(t2), i3.touchdrag(t2);
          }, i3.touchend = function(t2) {
            if (t2.originalEvent.preventDefault(), e4.options.touchEnabled) {
              var n4 = M.touch(t2, null, e4)[0];
              t2.featureTarget = n4, F(r3, { time: (/* @__PURE__ */ new Date()).getTime(), point: t2.point }) ? s2.tap(t2) : s2.touchend(t2);
            }
          };
          var u2 = function(t2) {
            return !(8 === t2 || 46 === t2 || t2 >= 48 && t2 <= 57);
          };
          function c2(o4, r4, i4) {
            void 0 === i4 && (i4 = {}), s2.stop();
            var u3 = n3[o4];
            if (void 0 === u3)
              throw new Error(o4 + " is not valid");
            a3 = o4;
            var c3 = u3(e4, r4);
            s2 = t(c3, e4), i4.silent || e4.map.fire(g.MODE_CHANGE, { mode: o4 }), e4.store.setDirty(), e4.store.render();
          }
          i3.keydown = function(t2) {
            (t2.srcElement || t2.target).classList.contains("mapboxgl-canvas") && (8 !== t2.keyCode && 46 !== t2.keyCode || !e4.options.controls.trash ? u2(t2.keyCode) ? s2.keydown(t2) : 49 === t2.keyCode && e4.options.controls.point ? c2(h.DRAW_POINT) : 50 === t2.keyCode && e4.options.controls.line_string ? c2(h.DRAW_LINE_STRING) : 51 === t2.keyCode && e4.options.controls.polygon && c2(h.DRAW_POLYGON) : (t2.preventDefault(), s2.trash()));
          }, i3.keyup = function(t2) {
            u2(t2.keyCode) && s2.keyup(t2);
          }, i3.zoomend = function() {
            e4.store.changeZoom();
          }, i3.data = function(t2) {
            if ("style" === t2.dataType) {
              var n4 = e4.setup, o4 = e4.map, r4 = e4.options, i4 = e4.store;
              r4.styles.some(function(t3) {
                return o4.getLayer(t3.id);
              }) || (n4.addLayers(), i4.setDirty(), i4.render());
            }
          };
          var l2 = { trash: false, combineFeatures: false, uncombineFeatures: false };
          return { start: function() {
            a3 = e4.options.defaultMode, s2 = t(n3[a3](e4), e4);
          }, changeMode: c2, actionable: function(t2) {
            var n4 = false;
            Object.keys(t2).forEach(function(e6) {
              if (void 0 === l2[e6])
                throw new Error("Invalid action type");
              l2[e6] !== t2[e6] && (n4 = true), l2[e6] = t2[e6];
            }), n4 && e4.map.fire(g.ACTIONABLE, { actions: l2 });
          }, currentModeName: function() {
            return a3;
          }, currentModeRender: function(t2, e6) {
            return s2.render(t2, e6);
          }, fire: function(t2, e6) {
            i3[t2] && i3[t2](e6);
          }, addEventListeners: function() {
            e4.map.on("mousemove", i3.mousemove), e4.map.on("mousedown", i3.mousedown), e4.map.on("mouseup", i3.mouseup), e4.map.on("data", i3.data), e4.map.on("touchmove", i3.touchmove), e4.map.on("touchstart", i3.touchstart), e4.map.on("touchend", i3.touchend), e4.container.addEventListener("mouseout", i3.mouseout), e4.options.keybindings && (e4.container.addEventListener("keydown", i3.keydown), e4.container.addEventListener("keyup", i3.keyup));
          }, removeEventListeners: function() {
            e4.map.off("mousemove", i3.mousemove), e4.map.off("mousedown", i3.mousedown), e4.map.off("mouseup", i3.mouseup), e4.map.off("data", i3.data), e4.map.off("touchmove", i3.touchmove), e4.map.off("touchstart", i3.touchstart), e4.map.off("touchend", i3.touchend), e4.container.removeEventListener("mouseout", i3.mouseout), e4.options.keybindings && (e4.container.removeEventListener("keydown", i3.keydown), e4.container.removeEventListener("keyup", i3.keyup));
          }, trash: function(t2) {
            s2.trash(t2);
          }, combineFeatures: function() {
            s2.combineFeatures();
          }, uncombineFeatures: function() {
            s2.uncombineFeatures();
          }, getMode: function() {
            return a3;
          } };
        }(e3), e3.ui = /* @__PURE__ */ function(t2) {
          var e4 = {}, n3 = null, o3 = { mode: null, feature: null, mouse: null }, r3 = { mode: null, feature: null, mouse: null };
          function i3(t3) {
            r3 = tt(r3, t3);
          }
          function a3() {
            var e6, n4;
            if (t2.container) {
              var i4 = [], a4 = [];
              et.forEach(function(t3) {
                r3[t3] !== o3[t3] && (i4.push(t3 + "-" + o3[t3]), null !== r3[t3] && a4.push(t3 + "-" + r3[t3]));
              }), i4.length > 0 && (e6 = t2.container.classList).remove.apply(e6, i4), a4.length > 0 && (n4 = t2.container.classList).add.apply(n4, a4), o3 = tt(o3, r3);
            }
          }
          function s2(t3, e6) {
            void 0 === e6 && (e6 = {});
            var o4 = document.createElement("button");
            return o4.className = c.CONTROL_BUTTON + " " + e6.className, o4.setAttribute("title", e6.title), e6.container.appendChild(o4), o4.addEventListener("click", function(o5) {
              if (o5.preventDefault(), o5.stopPropagation(), o5.target === n3)
                return u2(), void e6.onDeactivate();
              l2(t3), e6.onActivate();
            }, true), o4;
          }
          function u2() {
            n3 && (n3.classList.remove(c.ACTIVE_BUTTON), n3 = null);
          }
          function l2(t3) {
            u2();
            var o4 = e4[t3];
            o4 && o4 && "trash" !== t3 && (o4.classList.add(c.ACTIVE_BUTTON), n3 = o4);
          }
          return { setActiveButton: l2, queueMapClasses: i3, updateMapClasses: a3, clearMapClasses: function() {
            i3({ mode: null, feature: null, mouse: null }), a3();
          }, addButtons: function() {
            var n4 = t2.options.controls, o4 = document.createElement("div");
            return o4.className = c.CONTROL_GROUP + " " + c.CONTROL_BASE, n4 ? (n4[p.LINE] && (e4[p.LINE] = s2(p.LINE, { container: o4, className: c.CONTROL_BUTTON_LINE, title: "LineString tool " + (t2.options.keybindings ? "(l)" : ""), onActivate: function() {
              return t2.events.changeMode(h.DRAW_LINE_STRING);
            }, onDeactivate: function() {
              return t2.events.trash();
            } })), n4[p.POLYGON] && (e4[p.POLYGON] = s2(p.POLYGON, { container: o4, className: c.CONTROL_BUTTON_POLYGON, title: "Polygon tool " + (t2.options.keybindings ? "(p)" : ""), onActivate: function() {
              return t2.events.changeMode(h.DRAW_POLYGON);
            }, onDeactivate: function() {
              return t2.events.trash();
            } })), n4[p.POINT] && (e4[p.POINT] = s2(p.POINT, { container: o4, className: c.CONTROL_BUTTON_POINT, title: "Marker tool " + (t2.options.keybindings ? "(m)" : ""), onActivate: function() {
              return t2.events.changeMode(h.DRAW_POINT);
            }, onDeactivate: function() {
              return t2.events.trash();
            } })), n4.trash && (e4.trash = s2("trash", { container: o4, className: c.CONTROL_BUTTON_TRASH, title: "Delete", onActivate: function() {
              t2.events.trash();
            } })), n4.combine_features && (e4.combine_features = s2("combineFeatures", { container: o4, className: c.CONTROL_BUTTON_COMBINE_FEATURES, title: "Combine", onActivate: function() {
              t2.events.combineFeatures();
            } })), n4.uncombine_features && (e4.uncombine_features = s2("uncombineFeatures", { container: o4, className: c.CONTROL_BUTTON_UNCOMBINE_FEATURES, title: "Uncombine", onActivate: function() {
              t2.events.uncombineFeatures();
            } })), o4) : o4;
          }, removeButtons: function() {
            Object.keys(e4).forEach(function(t3) {
              var n4 = e4[t3];
              n4.parentNode && n4.parentNode.removeChild(n4), delete e4[t3];
            });
          } };
        }(e3), e3.container = i2.getContainer(), e3.store = new Z(e3), n2 = e3.ui.addButtons(), e3.options.boxSelect && (e3.boxZoomInitial = i2.boxZoom.isEnabled(), i2.boxZoom.disable(), i2.dragPan.disable(), i2.dragPan.enable()), i2.loaded() ? r2.connect() : (i2.on("load", r2.connect), o2 = setInterval(function() {
          i2.loaded() && r2.connect();
        }, 16)), e3.events.start(), n2;
      }, addLayers: function() {
        e3.map.addSource(l.COLD, { data: { type: f.FEATURE_COLLECTION, features: [] }, type: "geojson" }), e3.map.addSource(l.HOT, { data: { type: f.FEATURE_COLLECTION, features: [] }, type: "geojson" }), e3.options.styles.forEach(function(t2) {
          e3.map.addLayer(t2);
        }), e3.store.setDirty(true), e3.store.render();
      }, removeLayers: function() {
        e3.options.styles.forEach(function(t2) {
          e3.map.getLayer(t2.id) && e3.map.removeLayer(t2.id);
        }), e3.map.getSource(l.COLD) && e3.map.removeSource(l.COLD), e3.map.getSource(l.HOT) && e3.map.removeSource(l.HOT);
      } };
      return e3.setup = r2, r2;
    }
    var ot = [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": "#3bb2d0", "fill-outline-color": "#3bb2d0", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#3bb2d0" } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": 7, "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }];
    function rt(t2) {
      return function(e3) {
        var n2 = e3.featureTarget;
        return !!n2 && (!!n2.properties && n2.properties.meta === t2);
      };
    }
    function it(t2) {
      return !!t2.originalEvent && (!!t2.originalEvent.shiftKey && 0 === t2.originalEvent.button);
    }
    function at(t2) {
      return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === m.ACTIVE && t2.featureTarget.properties.meta === v.FEATURE));
    }
    function st(t2) {
      return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === m.INACTIVE && t2.featureTarget.properties.meta === v.FEATURE));
    }
    function ut(t2) {
      return void 0 === t2.featureTarget;
    }
    function ct(t2) {
      return !!t2.featureTarget && (!!t2.featureTarget.properties && t2.featureTarget.properties.meta === v.FEATURE);
    }
    function lt(t2) {
      var e3 = t2.featureTarget;
      return !!e3 && (!!e3.properties && e3.properties.meta === v.VERTEX);
    }
    function dt(t2) {
      return !!t2.originalEvent && true === t2.originalEvent.shiftKey;
    }
    function pt(t2) {
      return 27 === t2.keyCode;
    }
    function ft(t2) {
      return 13 === t2.keyCode;
    }
    var ht = Object.freeze({ __proto__: null, isOfMetaType: rt, isShiftMousedown: it, isActiveFeature: at, isInactiveFeature: st, noTarget: ut, isFeature: ct, isVertex: lt, isShiftDown: dt, isEscapeKey: pt, isEnterKey: ft, isTrue: function() {
      return true;
    } }), gt = yt;
    function yt(t2, e3) {
      this.x = t2, this.y = e3;
    }
    yt.prototype = { clone: function() {
      return new yt(this.x, this.y);
    }, add: function(t2) {
      return this.clone()._add(t2);
    }, sub: function(t2) {
      return this.clone()._sub(t2);
    }, multByPoint: function(t2) {
      return this.clone()._multByPoint(t2);
    }, divByPoint: function(t2) {
      return this.clone()._divByPoint(t2);
    }, mult: function(t2) {
      return this.clone()._mult(t2);
    }, div: function(t2) {
      return this.clone()._div(t2);
    }, rotate: function(t2) {
      return this.clone()._rotate(t2);
    }, rotateAround: function(t2, e3) {
      return this.clone()._rotateAround(t2, e3);
    }, matMult: function(t2) {
      return this.clone()._matMult(t2);
    }, unit: function() {
      return this.clone()._unit();
    }, perp: function() {
      return this.clone()._perp();
    }, round: function() {
      return this.clone()._round();
    }, mag: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }, equals: function(t2) {
      return this.x === t2.x && this.y === t2.y;
    }, dist: function(t2) {
      return Math.sqrt(this.distSqr(t2));
    }, distSqr: function(t2) {
      var e3 = t2.x - this.x, n2 = t2.y - this.y;
      return e3 * e3 + n2 * n2;
    }, angle: function() {
      return Math.atan2(this.y, this.x);
    }, angleTo: function(t2) {
      return Math.atan2(this.y - t2.y, this.x - t2.x);
    }, angleWith: function(t2) {
      return this.angleWithSep(t2.x, t2.y);
    }, angleWithSep: function(t2, e3) {
      return Math.atan2(this.x * e3 - this.y * t2, this.x * t2 + this.y * e3);
    }, _matMult: function(t2) {
      var e3 = t2[0] * this.x + t2[1] * this.y, n2 = t2[2] * this.x + t2[3] * this.y;
      return this.x = e3, this.y = n2, this;
    }, _add: function(t2) {
      return this.x += t2.x, this.y += t2.y, this;
    }, _sub: function(t2) {
      return this.x -= t2.x, this.y -= t2.y, this;
    }, _mult: function(t2) {
      return this.x *= t2, this.y *= t2, this;
    }, _div: function(t2) {
      return this.x /= t2, this.y /= t2, this;
    }, _multByPoint: function(t2) {
      return this.x *= t2.x, this.y *= t2.y, this;
    }, _divByPoint: function(t2) {
      return this.x /= t2.x, this.y /= t2.y, this;
    }, _unit: function() {
      return this._div(this.mag()), this;
    }, _perp: function() {
      var t2 = this.y;
      return this.y = this.x, this.x = -t2, this;
    }, _rotate: function(t2) {
      var e3 = Math.cos(t2), n2 = Math.sin(t2), o2 = e3 * this.x - n2 * this.y, r2 = n2 * this.x + e3 * this.y;
      return this.x = o2, this.y = r2, this;
    }, _rotateAround: function(t2, e3) {
      var n2 = Math.cos(t2), o2 = Math.sin(t2), r2 = e3.x + n2 * (this.x - e3.x) - o2 * (this.y - e3.y), i2 = e3.y + o2 * (this.x - e3.x) + n2 * (this.y - e3.y);
      return this.x = r2, this.y = i2, this;
    }, _round: function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    } }, yt.convert = function(t2) {
      return t2 instanceof yt ? t2 : Array.isArray(t2) ? new yt(t2[0], t2[1]) : t2;
    };
    var vt = e(gt);
    function mt(t2, e3) {
      var n2 = e3.getBoundingClientRect();
      return new vt(t2.clientX - n2.left - (e3.clientLeft || 0), t2.clientY - n2.top - (e3.clientTop || 0));
    }
    function _t(t2, e3, n2, o2) {
      return { type: f.FEATURE, properties: { meta: v.VERTEX, parent: t2, coord_path: n2, active: o2 ? m.ACTIVE : m.INACTIVE }, geometry: { type: f.POINT, coordinates: e3 } };
    }
    function bt(t2, e3, n2) {
      var o2 = e3.geometry.coordinates, r2 = n2.geometry.coordinates;
      if (o2[1] > 85 || o2[1] < b || r2[1] > 85 || r2[1] < b)
        return null;
      var i2 = { lng: (o2[0] + r2[0]) / 2, lat: (o2[1] + r2[1]) / 2 };
      return { type: f.FEATURE, properties: { meta: v.MIDPOINT, parent: t2, lng: i2.lng, lat: i2.lat, coord_path: n2.properties.coord_path }, geometry: { type: f.POINT, coordinates: [i2.lng, i2.lat] } };
    }
    function Et(t2, e3, n2) {
      void 0 === e3 && (e3 = {}), void 0 === n2 && (n2 = null);
      var o2, r2 = t2.geometry, i2 = r2.type, a2 = r2.coordinates, s2 = t2.properties && t2.properties.id, u2 = [];
      function c2(t3, n3) {
        var o3 = "", r3 = null;
        t3.forEach(function(t4, i3) {
          var a3 = null != n3 ? n3 + "." + i3 : String(i3), c3 = _t(s2, t4, a3, l2(a3));
          if (e3.midpoints && r3) {
            var d2 = bt(s2, r3, c3);
            d2 && u2.push(d2);
          }
          r3 = c3;
          var p2 = JSON.stringify(t4);
          o3 !== p2 && u2.push(c3), 0 === i3 && (o3 = p2);
        });
      }
      function l2(t3) {
        return !!e3.selectedPaths && -1 !== e3.selectedPaths.indexOf(t3);
      }
      return i2 === f.POINT ? u2.push(_t(s2, a2, n2, l2(n2))) : i2 === f.POLYGON ? a2.forEach(function(t3, e4) {
        c2(t3, null !== n2 ? n2 + "." + e4 : String(e4));
      }) : i2 === f.LINE_STRING ? c2(a2, n2) : 0 === i2.indexOf(f.MULTI_PREFIX) && (o2 = i2.replace(f.MULTI_PREFIX, ""), a2.forEach(function(n3, r3) {
        var i3 = { type: f.FEATURE, properties: t2.properties, geometry: { type: o2, coordinates: n3 } };
        u2 = u2.concat(Et(i3, e3, r3));
      })), u2;
    }
    var Tt = { enable: function(t2) {
      setTimeout(function() {
        t2.map && t2.map.doubleClickZoom && t2._ctx && t2._ctx.store && t2._ctx.store.getInitialConfigValue && t2._ctx.store.getInitialConfigValue("doubleClickZoom") && t2.map.doubleClickZoom.enable();
      }, 0);
    }, disable: function(t2) {
      setTimeout(function() {
        t2.map && t2.map.doubleClickZoom && t2.map.doubleClickZoom.disable();
      }, 0);
    } }, Ct = { exports: {} }, Ot = function(t2) {
      if (!t2 || !t2.type)
        return null;
      var e3 = St[t2.type];
      if (!e3)
        return null;
      if ("geometry" === e3)
        return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: t2 }] };
      if ("feature" === e3)
        return { type: "FeatureCollection", features: [t2] };
      if ("featurecollection" === e3)
        return t2;
    }, St = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" };
    var It = e(Ot);
    var xt = Object.freeze({ __proto__: null, default: function t2(e3) {
      switch (e3 && e3.type || null) {
        case "FeatureCollection":
          return e3.features = e3.features.reduce(function(e4, n2) {
            return e4.concat(t2(n2));
          }, []), e3;
        case "Feature":
          return e3.geometry ? t2(e3.geometry).map(function(t3) {
            var n2 = { type: "Feature", properties: JSON.parse(JSON.stringify(e3.properties)), geometry: t3 };
            return void 0 !== e3.id && (n2.id = e3.id), n2;
          }) : [e3];
        case "MultiPoint":
          return e3.coordinates.map(function(t3) {
            return { type: "Point", coordinates: t3 };
          });
        case "MultiPolygon":
          return e3.coordinates.map(function(t3) {
            return { type: "Polygon", coordinates: t3 };
          });
        case "MultiLineString":
          return e3.coordinates.map(function(t3) {
            return { type: "LineString", coordinates: t3 };
          });
        case "GeometryCollection":
          return e3.geometries.map(t2).reduce(function(t3, e4) {
            return t3.concat(e4);
          }, []);
        case "Point":
        case "Polygon":
        case "LineString":
          return [e3];
      }
    } }), Mt = Ot, Lt = n(xt), Nt = function(t2) {
      return function t3(e3) {
        if (Array.isArray(e3) && e3.length && "number" == typeof e3[0])
          return [e3];
        return e3.reduce(function(e4, n2) {
          return Array.isArray(n2) && Array.isArray(n2[0]) ? e4.concat(t3(n2)) : (e4.push(n2), e4);
        }, []);
      }(t2);
    };
    Lt instanceof Function || (Lt = Lt.default);
    var At = { exports: {} }, Pt = At.exports = function(t2) {
      return new Ft(t2);
    };
    function Ft(t2) {
      this.value = t2;
    }
    function wt(t2, e3, n2) {
      var o2 = [], r2 = [], i2 = true;
      return function t3(a2) {
        var s2 = n2 ? Rt(a2) : a2, u2 = {}, c2 = true, l2 = { node: s2, node_: a2, path: [].concat(o2), parent: r2[r2.length - 1], parents: r2, key: o2.slice(-1)[0], isRoot: 0 === o2.length, level: o2.length, circular: null, update: function(t4, e4) {
          l2.isRoot || (l2.parent.node[l2.key] = t4), l2.node = t4, e4 && (c2 = false);
        }, delete: function(t4) {
          delete l2.parent.node[l2.key], t4 && (c2 = false);
        }, remove: function(t4) {
          Ut(l2.parent.node) ? l2.parent.node.splice(l2.key, 1) : delete l2.parent.node[l2.key], t4 && (c2 = false);
        }, keys: null, before: function(t4) {
          u2.before = t4;
        }, after: function(t4) {
          u2.after = t4;
        }, pre: function(t4) {
          u2.pre = t4;
        }, post: function(t4) {
          u2.post = t4;
        }, stop: function() {
          i2 = false;
        }, block: function() {
          c2 = false;
        } };
        if (!i2)
          return l2;
        function d2() {
          if ("object" == typeof l2.node && null !== l2.node) {
            l2.keys && l2.node_ === l2.node || (l2.keys = kt(l2.node)), l2.isLeaf = 0 == l2.keys.length;
            for (var t4 = 0; t4 < r2.length; t4++)
              if (r2[t4].node_ === a2) {
                l2.circular = r2[t4];
                break;
              }
          } else
            l2.isLeaf = true, l2.keys = null;
          l2.notLeaf = !l2.isLeaf, l2.notRoot = !l2.isRoot;
        }
        d2();
        var p2 = e3.call(l2, l2.node);
        return void 0 !== p2 && l2.update && l2.update(p2), u2.before && u2.before.call(l2, l2.node), c2 ? ("object" != typeof l2.node || null === l2.node || l2.circular || (r2.push(l2), d2(), jt(l2.keys, function(e4, r3) {
          o2.push(e4), u2.pre && u2.pre.call(l2, l2.node[e4], e4);
          var i3 = t3(l2.node[e4]);
          n2 && Vt.call(l2.node, e4) && (l2.node[e4] = i3.node), i3.isLast = r3 == l2.keys.length - 1, i3.isFirst = 0 == r3, u2.post && u2.post.call(l2, i3), o2.pop();
        }), r2.pop()), u2.after && u2.after.call(l2, l2.node), l2) : l2;
      }(t2).node;
    }
    function Rt(t2) {
      if ("object" == typeof t2 && null !== t2) {
        var e3;
        if (Ut(t2))
          e3 = [];
        else if ("[object Date]" === Dt(t2))
          e3 = new Date(t2.getTime ? t2.getTime() : t2);
        else if (function(t3) {
          return "[object RegExp]" === Dt(t3);
        }(t2))
          e3 = new RegExp(t2);
        else if (function(t3) {
          return "[object Error]" === Dt(t3);
        }(t2))
          e3 = { message: t2.message };
        else if (function(t3) {
          return "[object Boolean]" === Dt(t3);
        }(t2))
          e3 = new Boolean(t2);
        else if (function(t3) {
          return "[object Number]" === Dt(t3);
        }(t2))
          e3 = new Number(t2);
        else if (function(t3) {
          return "[object String]" === Dt(t3);
        }(t2))
          e3 = new String(t2);
        else if (Object.create && Object.getPrototypeOf)
          e3 = Object.create(Object.getPrototypeOf(t2));
        else if (t2.constructor === Object)
          e3 = {};
        else {
          var n2 = t2.constructor && t2.constructor.prototype || t2.__proto__ || {}, o2 = function() {
          };
          o2.prototype = n2, e3 = new o2();
        }
        return jt(kt(t2), function(n3) {
          e3[n3] = t2[n3];
        }), e3;
      }
      return t2;
    }
    Ft.prototype.get = function(t2) {
      for (var e3 = this.value, n2 = 0; n2 < t2.length; n2++) {
        var o2 = t2[n2];
        if (!e3 || !Vt.call(e3, o2)) {
          e3 = void 0;
          break;
        }
        e3 = e3[o2];
      }
      return e3;
    }, Ft.prototype.has = function(t2) {
      for (var e3 = this.value, n2 = 0; n2 < t2.length; n2++) {
        var o2 = t2[n2];
        if (!e3 || !Vt.call(e3, o2))
          return false;
        e3 = e3[o2];
      }
      return true;
    }, Ft.prototype.set = function(t2, e3) {
      for (var n2 = this.value, o2 = 0; o2 < t2.length - 1; o2++) {
        var r2 = t2[o2];
        Vt.call(n2, r2) || (n2[r2] = {}), n2 = n2[r2];
      }
      return n2[t2[o2]] = e3, e3;
    }, Ft.prototype.map = function(t2) {
      return wt(this.value, t2, true);
    }, Ft.prototype.forEach = function(t2) {
      return this.value = wt(this.value, t2, false), this.value;
    }, Ft.prototype.reduce = function(t2, e3) {
      var n2 = 1 === arguments.length, o2 = n2 ? this.value : e3;
      return this.forEach(function(e4) {
        this.isRoot && n2 || (o2 = t2.call(this, o2, e4));
      }), o2;
    }, Ft.prototype.paths = function() {
      var t2 = [];
      return this.forEach(function(e3) {
        t2.push(this.path);
      }), t2;
    }, Ft.prototype.nodes = function() {
      var t2 = [];
      return this.forEach(function(e3) {
        t2.push(this.node);
      }), t2;
    }, Ft.prototype.clone = function() {
      var t2 = [], e3 = [];
      return function n2(o2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          if (t2[r2] === o2)
            return e3[r2];
        if ("object" == typeof o2 && null !== o2) {
          var i2 = Rt(o2);
          return t2.push(o2), e3.push(i2), jt(kt(o2), function(t3) {
            i2[t3] = n2(o2[t3]);
          }), t2.pop(), e3.pop(), i2;
        }
        return o2;
      }(this.value);
    };
    var kt = Object.keys || function(t2) {
      var e3 = [];
      for (var n2 in t2)
        e3.push(n2);
      return e3;
    };
    function Dt(t2) {
      return Object.prototype.toString.call(t2);
    }
    var Ut = Array.isArray || function(t2) {
      return "[object Array]" === Object.prototype.toString.call(t2);
    }, jt = function(t2, e3) {
      if (t2.forEach)
        return t2.forEach(e3);
      for (var n2 = 0; n2 < t2.length; n2++)
        e3(t2[n2], n2, t2);
    };
    jt(kt(Ft.prototype), function(t2) {
      Pt[t2] = function(e3) {
        var n2 = [].slice.call(arguments, 1), o2 = new Ft(e3);
        return o2[t2].apply(o2, n2);
      };
    });
    var Vt = Object.hasOwnProperty || function(t2, e3) {
      return e3 in t2;
    }, Bt = At.exports, Gt = Jt;
    function Jt(t2) {
      if (!(this instanceof Jt))
        return new Jt(t2);
      this._bbox = t2 || [1 / 0, 1 / 0, -1 / 0, -1 / 0], this._valid = !!t2;
    }
    Jt.prototype.include = function(t2) {
      return this._valid = true, this._bbox[0] = Math.min(this._bbox[0], t2[0]), this._bbox[1] = Math.min(this._bbox[1], t2[1]), this._bbox[2] = Math.max(this._bbox[2], t2[0]), this._bbox[3] = Math.max(this._bbox[3], t2[1]), this;
    }, Jt.prototype.equals = function(t2) {
      var e3;
      return e3 = t2 instanceof Jt ? t2.bbox() : t2, this._bbox[0] == e3[0] && this._bbox[1] == e3[1] && this._bbox[2] == e3[2] && this._bbox[3] == e3[3];
    }, Jt.prototype.center = function(t2) {
      return this._valid ? [(this._bbox[0] + this._bbox[2]) / 2, (this._bbox[1] + this._bbox[3]) / 2] : null;
    }, Jt.prototype.union = function(t2) {
      var e3;
      return this._valid = true, e3 = t2 instanceof Jt ? t2.bbox() : t2, this._bbox[0] = Math.min(this._bbox[0], e3[0]), this._bbox[1] = Math.min(this._bbox[1], e3[1]), this._bbox[2] = Math.max(this._bbox[2], e3[2]), this._bbox[3] = Math.max(this._bbox[3], e3[3]), this;
    }, Jt.prototype.bbox = function() {
      return this._valid ? this._bbox : null;
    }, Jt.prototype.contains = function(t2) {
      if (!t2)
        return this._fastContains();
      if (!this._valid)
        return null;
      var e3 = t2[0], n2 = t2[1];
      return this._bbox[0] <= e3 && this._bbox[1] <= n2 && this._bbox[2] >= e3 && this._bbox[3] >= n2;
    }, Jt.prototype.intersect = function(t2) {
      return this._valid ? (e3 = t2 instanceof Jt ? t2.bbox() : t2, !(this._bbox[0] > e3[2] || this._bbox[2] < e3[0] || this._bbox[3] < e3[1] || this._bbox[1] > e3[3])) : null;
      var e3;
    }, Jt.prototype._fastContains = function() {
      if (!this._valid)
        return new Function("return null;");
      var t2 = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
      return new Function("ll", t2);
    }, Jt.prototype.polygon = function() {
      return this._valid ? { type: "Polygon", coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]] } : null;
    };
    var zt = function(t2) {
      if (!t2)
        return [];
      var e3 = Lt(Mt(t2)), n2 = [];
      return e3.features.forEach(function(t3) {
        t3.geometry && (n2 = n2.concat(Nt(t3.geometry.coordinates)));
      }), n2;
    }, Yt = Bt, $t = Gt, qt = { features: ["FeatureCollection"], coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], geometry: ["Feature"], geometries: ["GeometryCollection"] }, Ht = Object.keys(qt);
    function Xt(t2) {
      for (var e3 = $t(), n2 = zt(t2), o2 = 0; o2 < n2.length; o2++)
        e3.include(n2[o2]);
      return e3;
    }
    Ct.exports = function(t2) {
      return Xt(t2).bbox();
    }, Ct.exports.polygon = function(t2) {
      return Xt(t2).polygon();
    }, Ct.exports.bboxify = function(t2) {
      return Yt(t2).map(function(t3) {
        t3 && (Ht.some(function(e3) {
          return !!t3[e3] && -1 !== qt[e3].indexOf(t3.type);
        }) && (t3.bbox = Xt(t3).bbox(), this.update(t3)));
      });
    };
    var Zt = e(Ct.exports), Wt = -90;
    function Kt(t2, e3) {
      var n2 = Wt, o2 = 90, r2 = Wt, i2 = 90, a2 = 270, s2 = -270;
      t2.forEach(function(t3) {
        var e4 = Zt(t3), u3 = e4[1], c2 = e4[3], l2 = e4[0], d2 = e4[2];
        u3 > n2 && (n2 = u3), c2 < o2 && (o2 = c2), c2 > r2 && (r2 = c2), u3 < i2 && (i2 = u3), l2 < a2 && (a2 = l2), d2 > s2 && (s2 = d2);
      });
      var u2 = e3;
      return n2 + u2.lat > 85 && (u2.lat = 85 - n2), r2 + u2.lat > 90 && (u2.lat = 90 - r2), o2 + u2.lat < -85 && (u2.lat = -85 - o2), i2 + u2.lat < Wt && (u2.lat = Wt - i2), a2 + u2.lng <= -270 && (u2.lng += 360 * Math.ceil(Math.abs(u2.lng) / 360)), s2 + u2.lng >= 270 && (u2.lng -= 360 * Math.ceil(Math.abs(u2.lng) / 360)), u2;
    }
    function Qt(t2, e3) {
      var n2 = Kt(t2.map(function(t3) {
        return t3.toGeoJSON();
      }), e3);
      t2.forEach(function(t3) {
        var e4, o2 = t3.getCoordinates(), r2 = function(t4) {
          var e6 = { lng: t4[0] + n2.lng, lat: t4[1] + n2.lat };
          return [e6.lng, e6.lat];
        }, i2 = function(t4) {
          return t4.map(function(t5) {
            return r2(t5);
          });
        };
        t3.type === f.POINT ? e4 = r2(o2) : t3.type === f.LINE_STRING || t3.type === f.MULTI_POINT ? e4 = o2.map(r2) : t3.type === f.POLYGON || t3.type === f.MULTI_LINE_STRING ? e4 = o2.map(i2) : t3.type === f.MULTI_POLYGON && (e4 = o2.map(function(t4) {
          return t4.map(function(t5) {
            return i2(t5);
          });
        })), t3.incomingCoords(e4);
      });
    }
    var te = { onSetup: function(t2) {
      var e3 = this, n2 = { dragMoveLocation: null, boxSelectStartLocation: null, boxSelectElement: void 0, boxSelecting: false, canBoxSelect: false, dragMoving: false, canDragMove: false, initiallySelectedFeatureIds: t2.featureIds || [] };
      return this.setSelected(n2.initiallySelectedFeatureIds.filter(function(t3) {
        return void 0 !== e3.getFeature(t3);
      })), this.fireActionable(), this.setActionableState({ combineFeatures: true, uncombineFeatures: true, trash: true }), n2;
    }, fireUpdate: function() {
      this.map.fire(g.UPDATE, { action: y.MOVE, features: this.getSelected().map(function(t2) {
        return t2.toGeoJSON();
      }) });
    }, fireActionable: function() {
      var t2 = this, e3 = this.getSelected(), n2 = e3.filter(function(e4) {
        return t2.isInstanceOf("MultiFeature", e4);
      }), o2 = false;
      if (e3.length > 1) {
        o2 = true;
        var r2 = e3[0].type.replace("Multi", "");
        e3.forEach(function(t3) {
          t3.type.replace("Multi", "") !== r2 && (o2 = false);
        });
      }
      var i2 = n2.length > 0, a2 = e3.length > 0;
      this.setActionableState({ combineFeatures: o2, uncombineFeatures: i2, trash: a2 });
    }, getUniqueIds: function(t2) {
      return t2.length ? t2.map(function(t3) {
        return t3.properties.id;
      }).filter(function(t3) {
        return void 0 !== t3;
      }).reduce(function(t3, e3) {
        return t3.add(e3), t3;
      }, new I()).values() : [];
    }, stopExtendedInteractions: function(t2) {
      t2.boxSelectElement && (t2.boxSelectElement.parentNode && t2.boxSelectElement.parentNode.removeChild(t2.boxSelectElement), t2.boxSelectElement = null), this.map.dragPan.enable(), t2.boxSelecting = false, t2.canBoxSelect = false, t2.dragMoving = false, t2.canDragMove = false;
    }, onStop: function() {
      Tt.enable(this);
    }, onMouseMove: function(t2, e3) {
      return ct(e3) && t2.dragMoving && this.fireUpdate(), this.stopExtendedInteractions(t2), true;
    }, onMouseOut: function(t2) {
      return !t2.dragMoving || this.fireUpdate();
    } };
    te.onTap = te.onClick = function(t2, e3) {
      return ut(e3) ? this.clickAnywhere(t2, e3) : rt(v.VERTEX)(e3) ? this.clickOnVertex(t2, e3) : ct(e3) ? this.clickOnFeature(t2, e3) : void 0;
    }, te.clickAnywhere = function(t2) {
      var e3 = this, n2 = this.getSelectedIds();
      n2.length && (this.clearSelectedFeatures(), n2.forEach(function(t3) {
        return e3.doRender(t3);
      })), Tt.enable(this), this.stopExtendedInteractions(t2);
    }, te.clickOnVertex = function(t2, e3) {
      this.changeMode(h.DIRECT_SELECT, { featureId: e3.featureTarget.properties.parent, coordPath: e3.featureTarget.properties.coord_path, startPos: e3.lngLat }), this.updateUIClasses({ mouse: d.MOVE });
    }, te.startOnActiveFeature = function(t2, e3) {
      this.stopExtendedInteractions(t2), this.map.dragPan.disable(), this.doRender(e3.featureTarget.properties.id), t2.canDragMove = true, t2.dragMoveLocation = e3.lngLat;
    }, te.clickOnFeature = function(t2, e3) {
      var n2 = this;
      Tt.disable(this), this.stopExtendedInteractions(t2);
      var o2 = dt(e3), r2 = this.getSelectedIds(), i2 = e3.featureTarget.properties.id, a2 = this.isSelected(i2);
      if (!o2 && a2 && this.getFeature(i2).type !== f.POINT)
        return this.changeMode(h.DIRECT_SELECT, { featureId: i2 });
      a2 && o2 ? (this.deselect(i2), this.updateUIClasses({ mouse: d.POINTER }), 1 === r2.length && Tt.enable(this)) : !a2 && o2 ? (this.select(i2), this.updateUIClasses({ mouse: d.MOVE })) : a2 || o2 || (r2.forEach(function(t3) {
        return n2.doRender(t3);
      }), this.setSelected(i2), this.updateUIClasses({ mouse: d.MOVE })), this.doRender(i2);
    }, te.onMouseDown = function(t2, e3) {
      return at(e3) ? this.startOnActiveFeature(t2, e3) : this.drawConfig.boxSelect && it(e3) ? this.startBoxSelect(t2, e3) : void 0;
    }, te.startBoxSelect = function(t2, e3) {
      this.stopExtendedInteractions(t2), this.map.dragPan.disable(), t2.boxSelectStartLocation = mt(e3.originalEvent, this.map.getContainer()), t2.canBoxSelect = true;
    }, te.onTouchStart = function(t2, e3) {
      if (at(e3))
        return this.startOnActiveFeature(t2, e3);
    }, te.onDrag = function(t2, e3) {
      return t2.canDragMove ? this.dragMove(t2, e3) : this.drawConfig.boxSelect && t2.canBoxSelect ? this.whileBoxSelect(t2, e3) : void 0;
    }, te.whileBoxSelect = function(t2, e3) {
      t2.boxSelecting = true, this.updateUIClasses({ mouse: d.ADD }), t2.boxSelectElement || (t2.boxSelectElement = document.createElement("div"), t2.boxSelectElement.classList.add(c.BOX_SELECT), this.map.getContainer().appendChild(t2.boxSelectElement));
      var n2 = mt(e3.originalEvent, this.map.getContainer()), o2 = Math.min(t2.boxSelectStartLocation.x, n2.x), r2 = Math.max(t2.boxSelectStartLocation.x, n2.x), i2 = Math.min(t2.boxSelectStartLocation.y, n2.y), a2 = Math.max(t2.boxSelectStartLocation.y, n2.y), s2 = "translate(" + o2 + "px, " + i2 + "px)";
      t2.boxSelectElement.style.transform = s2, t2.boxSelectElement.style.WebkitTransform = s2, t2.boxSelectElement.style.width = r2 - o2 + "px", t2.boxSelectElement.style.height = a2 - i2 + "px";
    }, te.dragMove = function(t2, e3) {
      t2.dragMoving = true, e3.originalEvent.stopPropagation();
      var n2 = { lng: e3.lngLat.lng - t2.dragMoveLocation.lng, lat: e3.lngLat.lat - t2.dragMoveLocation.lat };
      Qt(this.getSelected(), n2), t2.dragMoveLocation = e3.lngLat;
    }, te.onTouchEnd = te.onMouseUp = function(t2, e3) {
      var n2 = this;
      if (t2.dragMoving)
        this.fireUpdate();
      else if (t2.boxSelecting) {
        var o2 = [t2.boxSelectStartLocation, mt(e3.originalEvent, this.map.getContainer())], r2 = this.featuresAt(null, o2, "click"), i2 = this.getUniqueIds(r2).filter(function(t3) {
          return !n2.isSelected(t3);
        });
        i2.length && (this.select(i2), i2.forEach(function(t3) {
          return n2.doRender(t3);
        }), this.updateUIClasses({ mouse: d.MOVE }));
      }
      this.stopExtendedInteractions(t2);
    }, te.toDisplayFeatures = function(t2, e3, n2) {
      e3.properties.active = this.isSelected(e3.properties.id) ? m.ACTIVE : m.INACTIVE, n2(e3), this.fireActionable(), e3.properties.active === m.ACTIVE && e3.geometry.type !== f.POINT && Et(e3).forEach(n2);
    }, te.onTrash = function() {
      this.deleteFeature(this.getSelectedIds()), this.fireActionable();
    }, te.onCombineFeatures = function() {
      var t2 = this.getSelected();
      if (!(0 === t2.length || t2.length < 2)) {
        for (var e3 = [], n2 = [], o2 = t2[0].type.replace("Multi", ""), r2 = 0; r2 < t2.length; r2++) {
          var i2 = t2[r2];
          if (i2.type.replace("Multi", "") !== o2)
            return;
          i2.type.includes("Multi") ? i2.getCoordinates().forEach(function(t3) {
            e3.push(t3);
          }) : e3.push(i2.getCoordinates()), n2.push(i2.toGeoJSON());
        }
        if (n2.length > 1) {
          var a2 = this.newFeature({ type: f.FEATURE, properties: n2[0].properties, geometry: { type: "Multi" + o2, coordinates: e3 } });
          this.addFeature(a2), this.deleteFeature(this.getSelectedIds(), { silent: true }), this.setSelected([a2.id]), this.map.fire(g.COMBINE_FEATURES, { createdFeatures: [a2.toGeoJSON()], deletedFeatures: n2 });
        }
        this.fireActionable();
      }
    }, te.onUncombineFeatures = function() {
      var t2 = this, e3 = this.getSelected();
      if (0 !== e3.length) {
        for (var n2 = [], o2 = [], r2 = function(r3) {
          var i3 = e3[r3];
          t2.isInstanceOf("MultiFeature", i3) && (i3.getFeatures().forEach(function(e4) {
            t2.addFeature(e4), e4.properties = i3.properties, n2.push(e4.toGeoJSON()), t2.select([e4.id]);
          }), t2.deleteFeature(i3.id, { silent: true }), o2.push(i3.toGeoJSON()));
        }, i2 = 0; i2 < e3.length; i2++)
          r2(i2);
        n2.length > 1 && this.map.fire(g.UNCOMBINE_FEATURES, { createdFeatures: n2, deletedFeatures: o2 }), this.fireActionable();
      }
    };
    var ee = rt(v.VERTEX), ne = rt(v.MIDPOINT), oe = { fireUpdate: function() {
      this.map.fire(g.UPDATE, { action: y.CHANGE_COORDINATES, features: this.getSelected().map(function(t2) {
        return t2.toGeoJSON();
      }) });
    }, fireActionable: function(t2) {
      this.setActionableState({ combineFeatures: false, uncombineFeatures: false, trash: t2.selectedCoordPaths.length > 0 });
    }, startDragging: function(t2, e3) {
      this.map.dragPan.disable(), t2.canDragMove = true, t2.dragMoveLocation = e3.lngLat;
    }, stopDragging: function(t2) {
      this.map.dragPan.enable(), t2.dragMoving = false, t2.canDragMove = false, t2.dragMoveLocation = null;
    }, onVertex: function(t2, e3) {
      this.startDragging(t2, e3);
      var n2 = e3.featureTarget.properties, o2 = t2.selectedCoordPaths.indexOf(n2.coord_path);
      dt(e3) || -1 !== o2 ? dt(e3) && -1 === o2 && t2.selectedCoordPaths.push(n2.coord_path) : t2.selectedCoordPaths = [n2.coord_path];
      var r2 = this.pathsToCoordinates(t2.featureId, t2.selectedCoordPaths);
      this.setSelectedCoordinates(r2);
    }, onMidpoint: function(t2, e3) {
      this.startDragging(t2, e3);
      var n2 = e3.featureTarget.properties;
      t2.feature.addCoordinate(n2.coord_path, n2.lng, n2.lat), this.fireUpdate(), t2.selectedCoordPaths = [n2.coord_path];
    }, pathsToCoordinates: function(t2, e3) {
      return e3.map(function(e4) {
        return { feature_id: t2, coord_path: e4 };
      });
    }, onFeature: function(t2, e3) {
      0 === t2.selectedCoordPaths.length ? this.startDragging(t2, e3) : this.stopDragging(t2);
    }, dragFeature: function(t2, e3, n2) {
      Qt(this.getSelected(), n2), t2.dragMoveLocation = e3.lngLat;
    }, dragVertex: function(t2, e3, n2) {
      for (var o2 = t2.selectedCoordPaths.map(function(e4) {
        return t2.feature.getCoordinate(e4);
      }), r2 = Kt(o2.map(function(t3) {
        return { type: f.FEATURE, properties: {}, geometry: { type: f.POINT, coordinates: t3 } };
      }), n2), i2 = 0; i2 < o2.length; i2++) {
        var a2 = o2[i2];
        t2.feature.updateCoordinate(t2.selectedCoordPaths[i2], a2[0] + r2.lng, a2[1] + r2.lat);
      }
    }, clickNoTarget: function() {
      this.changeMode(h.SIMPLE_SELECT);
    }, clickInactive: function() {
      this.changeMode(h.SIMPLE_SELECT);
    }, clickActiveFeature: function(t2) {
      t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), t2.feature.changed();
    }, onSetup: function(t2) {
      var e3 = t2.featureId, n2 = this.getFeature(e3);
      if (!n2)
        throw new Error("You must provide a featureId to enter direct_select mode");
      if (n2.type === f.POINT)
        throw new TypeError("direct_select mode doesn't handle point features");
      var o2 = { featureId: e3, feature: n2, dragMoveLocation: t2.startPos || null, dragMoving: false, canDragMove: false, selectedCoordPaths: t2.coordPath ? [t2.coordPath] : [] };
      return this.setSelectedCoordinates(this.pathsToCoordinates(e3, o2.selectedCoordPaths)), this.setSelected(e3), Tt.disable(this), this.setActionableState({ trash: true }), o2;
    }, onStop: function() {
      Tt.enable(this), this.clearSelectedCoordinates();
    }, toDisplayFeatures: function(t2, e3, n2) {
      t2.featureId === e3.properties.id ? (e3.properties.active = m.ACTIVE, n2(e3), Et(e3, { map: this.map, midpoints: true, selectedPaths: t2.selectedCoordPaths }).forEach(n2)) : (e3.properties.active = m.INACTIVE, n2(e3)), this.fireActionable(t2);
    }, onTrash: function(t2) {
      t2.selectedCoordPaths.sort(function(t3, e3) {
        return e3.localeCompare(t3, "en", { numeric: true });
      }).forEach(function(e3) {
        return t2.feature.removeCoordinate(e3);
      }), this.fireUpdate(), t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), this.fireActionable(t2), false === t2.feature.isValid() && (this.deleteFeature([t2.featureId]), this.changeMode(h.SIMPLE_SELECT, {}));
    }, onMouseMove: function(t2, e3) {
      var n2 = at(e3), o2 = ee(e3), r2 = ne(e3), i2 = 0 === t2.selectedCoordPaths.length;
      return n2 && i2 || o2 && !i2 ? this.updateUIClasses({ mouse: d.MOVE }) : this.updateUIClasses({ mouse: d.NONE }), (o2 || n2 || r2) && t2.dragMoving && this.fireUpdate(), this.stopDragging(t2), true;
    }, onMouseOut: function(t2) {
      return t2.dragMoving && this.fireUpdate(), true;
    } };
    oe.onTouchStart = oe.onMouseDown = function(t2, e3) {
      return ee(e3) ? this.onVertex(t2, e3) : at(e3) ? this.onFeature(t2, e3) : ne(e3) ? this.onMidpoint(t2, e3) : void 0;
    }, oe.onDrag = function(t2, e3) {
      if (true === t2.canDragMove) {
        t2.dragMoving = true, e3.originalEvent.stopPropagation();
        var n2 = { lng: e3.lngLat.lng - t2.dragMoveLocation.lng, lat: e3.lngLat.lat - t2.dragMoveLocation.lat };
        t2.selectedCoordPaths.length > 0 ? this.dragVertex(t2, e3, n2) : this.dragFeature(t2, e3, n2), t2.dragMoveLocation = e3.lngLat;
      }
    }, oe.onClick = function(t2, e3) {
      return ut(e3) ? this.clickNoTarget(t2, e3) : at(e3) ? this.clickActiveFeature(t2, e3) : st(e3) ? this.clickInactive(t2, e3) : void this.stopDragging(t2);
    }, oe.onTap = function(t2, e3) {
      return ut(e3) ? this.clickNoTarget(t2, e3) : at(e3) ? this.clickActiveFeature(t2, e3) : st(e3) ? this.clickInactive(t2, e3) : void 0;
    }, oe.onTouchEnd = oe.onMouseUp = function(t2) {
      t2.dragMoving && this.fireUpdate(), this.stopDragging(t2);
    };
    var re2 = {};
    function ie(t2, e3) {
      return !!t2.lngLat && (t2.lngLat.lng === e3[0] && t2.lngLat.lat === e3[1]);
    }
    re2.onSetup = function() {
      var t2 = this.newFeature({ type: f.FEATURE, properties: {}, geometry: { type: f.POINT, coordinates: [] } });
      return this.addFeature(t2), this.clearSelectedFeatures(), this.updateUIClasses({ mouse: d.ADD }), this.activateUIButton(p.POINT), this.setActionableState({ trash: true }), { point: t2 };
    }, re2.stopDrawingAndRemove = function(t2) {
      this.deleteFeature([t2.point.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT);
    }, re2.onTap = re2.onClick = function(t2, e3) {
      this.updateUIClasses({ mouse: d.MOVE }), t2.point.updateCoordinate("", e3.lngLat.lng, e3.lngLat.lat), this.map.fire(g.CREATE, { features: [t2.point.toGeoJSON()] }), this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.point.id] });
    }, re2.onStop = function(t2) {
      this.activateUIButton(), t2.point.getCoordinate().length || this.deleteFeature([t2.point.id], { silent: true });
    }, re2.toDisplayFeatures = function(t2, e3, n2) {
      var o2 = e3.properties.id === t2.point.id;
      if (e3.properties.active = o2 ? m.ACTIVE : m.INACTIVE, !o2)
        return n2(e3);
    }, re2.onTrash = re2.stopDrawingAndRemove, re2.onKeyUp = function(t2, e3) {
      if (pt(e3) || ft(e3))
        return this.stopDrawingAndRemove(t2, e3);
    };
    var ae = { onSetup: function() {
      var t2 = this.newFeature({ type: f.FEATURE, properties: {}, geometry: { type: f.POLYGON, coordinates: [[]] } });
      return this.addFeature(t2), this.clearSelectedFeatures(), Tt.disable(this), this.updateUIClasses({ mouse: d.ADD }), this.activateUIButton(p.POLYGON), this.setActionableState({ trash: true }), { polygon: t2, currentVertexPosition: 0 };
    }, clickAnywhere: function(t2, e3) {
      if (t2.currentVertexPosition > 0 && ie(e3, t2.polygon.coordinates[0][t2.currentVertexPosition - 1]))
        return this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
      this.updateUIClasses({ mouse: d.ADD }), t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), t2.currentVertexPosition++, t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat);
    }, clickOnVertex: function(t2) {
      return this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
    }, onMouseMove: function(t2, e3) {
      t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), lt(e3) && this.updateUIClasses({ mouse: d.POINTER });
    } };
    ae.onTap = ae.onClick = function(t2, e3) {
      return lt(e3) ? this.clickOnVertex(t2, e3) : this.clickAnywhere(t2, e3);
    }, ae.onKeyUp = function(t2, e3) {
      pt(e3) ? (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT)) : ft(e3) && this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
    }, ae.onStop = function(t2) {
      this.updateUIClasses({ mouse: d.NONE }), Tt.enable(this), this.activateUIButton(), void 0 !== this.getFeature(t2.polygon.id) && (t2.polygon.removeCoordinate("0." + t2.currentVertexPosition), t2.polygon.isValid() ? this.map.fire(g.CREATE, { features: [t2.polygon.toGeoJSON()] }) : (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT, {}, { silent: true })));
    }, ae.toDisplayFeatures = function(t2, e3, n2) {
      var o2 = e3.properties.id === t2.polygon.id;
      if (e3.properties.active = o2 ? m.ACTIVE : m.INACTIVE, !o2)
        return n2(e3);
      if (0 !== e3.geometry.coordinates.length) {
        var r2 = e3.geometry.coordinates[0].length;
        if (!(r2 < 3)) {
          if (e3.properties.meta = v.FEATURE, n2(_t(t2.polygon.id, e3.geometry.coordinates[0][0], "0.0", false)), r2 > 3) {
            var i2 = e3.geometry.coordinates[0].length - 3;
            n2(_t(t2.polygon.id, e3.geometry.coordinates[0][i2], "0." + i2, false));
          }
          if (r2 <= 4) {
            var a2 = [[e3.geometry.coordinates[0][0][0], e3.geometry.coordinates[0][0][1]], [e3.geometry.coordinates[0][1][0], e3.geometry.coordinates[0][1][1]]];
            if (n2({ type: f.FEATURE, properties: e3.properties, geometry: { coordinates: a2, type: f.LINE_STRING } }), 3 === r2)
              return;
          }
          return n2(e3);
        }
      }
    }, ae.onTrash = function(t2) {
      this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT);
    };
    var se = { onSetup: function(t2) {
      var e3, n2, o2 = (t2 = t2 || {}).featureId, r2 = "forward";
      if (o2) {
        if (!(e3 = this.getFeature(o2)))
          throw new Error("Could not find a feature with the provided featureId");
        var i2 = t2.from;
        if (i2 && "Feature" === i2.type && i2.geometry && "Point" === i2.geometry.type && (i2 = i2.geometry), i2 && "Point" === i2.type && i2.coordinates && 2 === i2.coordinates.length && (i2 = i2.coordinates), !i2 || !Array.isArray(i2))
          throw new Error("Please use the `from` property to indicate which point to continue the line from");
        var a2 = e3.coordinates.length - 1;
        if (e3.coordinates[a2][0] === i2[0] && e3.coordinates[a2][1] === i2[1])
          n2 = a2 + 1, e3.addCoordinate.apply(e3, [n2].concat(e3.coordinates[a2]));
        else {
          if (e3.coordinates[0][0] !== i2[0] || e3.coordinates[0][1] !== i2[1])
            throw new Error("`from` should match the point at either the start or the end of the provided LineString");
          r2 = "backwards", n2 = 0, e3.addCoordinate.apply(e3, [n2].concat(e3.coordinates[0]));
        }
      } else
        e3 = this.newFeature({ type: f.FEATURE, properties: {}, geometry: { type: f.LINE_STRING, coordinates: [] } }), n2 = 0, this.addFeature(e3);
      return this.clearSelectedFeatures(), Tt.disable(this), this.updateUIClasses({ mouse: d.ADD }), this.activateUIButton(p.LINE), this.setActionableState({ trash: true }), { line: e3, currentVertexPosition: n2, direction: r2 };
    }, clickAnywhere: function(t2, e3) {
      if (t2.currentVertexPosition > 0 && ie(e3, t2.line.coordinates[t2.currentVertexPosition - 1]) || "backwards" === t2.direction && ie(e3, t2.line.coordinates[t2.currentVertexPosition + 1]))
        return this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.line.id] });
      this.updateUIClasses({ mouse: d.ADD }), t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), "forward" === t2.direction ? (t2.currentVertexPosition++, t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat)) : t2.line.addCoordinate(0, e3.lngLat.lng, e3.lngLat.lat);
    }, clickOnVertex: function(t2) {
      return this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.line.id] });
    }, onMouseMove: function(t2, e3) {
      t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), lt(e3) && this.updateUIClasses({ mouse: d.POINTER });
    } };
    se.onTap = se.onClick = function(t2, e3) {
      if (lt(e3))
        return this.clickOnVertex(t2, e3);
      this.clickAnywhere(t2, e3);
    }, se.onKeyUp = function(t2, e3) {
      ft(e3) ? this.changeMode(h.SIMPLE_SELECT, { featureIds: [t2.line.id] }) : pt(e3) && (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT));
    }, se.onStop = function(t2) {
      Tt.enable(this), this.activateUIButton(), void 0 !== this.getFeature(t2.line.id) && (t2.line.removeCoordinate("" + t2.currentVertexPosition), t2.line.isValid() ? this.map.fire(g.CREATE, { features: [t2.line.toGeoJSON()] }) : (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT, {}, { silent: true })));
    }, se.onTrash = function(t2) {
      this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(h.SIMPLE_SELECT);
    }, se.toDisplayFeatures = function(t2, e3, n2) {
      var o2 = e3.properties.id === t2.line.id;
      if (e3.properties.active = o2 ? m.ACTIVE : m.INACTIVE, !o2)
        return n2(e3);
      e3.geometry.coordinates.length < 2 || (e3.properties.meta = v.FEATURE, n2(_t(t2.line.id, e3.geometry.coordinates["forward" === t2.direction ? e3.geometry.coordinates.length - 2 : 1], "" + ("forward" === t2.direction ? e3.geometry.coordinates.length - 2 : 1), false)), n2(e3));
    };
    var ue = { simple_select: te, direct_select: oe, draw_point: re2, draw_polygon: ae, draw_line_string: se }, ce = { defaultMode: h.SIMPLE_SELECT, keybindings: true, touchEnabled: true, clickBuffer: 2, touchBuffer: 25, boxSelect: true, displayControlsDefault: true, styles: ot, modes: ue, controls: {}, userProperties: false }, le = { point: true, line_string: true, polygon: true, trash: true, combine_features: true, uncombine_features: true }, de = { point: false, line_string: false, polygon: false, trash: false, combine_features: false, uncombine_features: false };
    function pe(t2, e3) {
      return t2.map(function(t3) {
        return t3.source ? t3 : tt(t3, { id: t3.id + "." + e3, source: "hot" === e3 ? l.HOT : l.COLD });
      });
    }
    var fe = { exports: {} };
    !function(t2, e3) {
      var n2 = "__lodash_hash_undefined__", o2 = 9007199254740991, r2 = "[object Arguments]", i2 = "[object Array]", a2 = "[object Boolean]", s2 = "[object Date]", u2 = "[object Error]", c2 = "[object Function]", l2 = "[object Map]", d2 = "[object Number]", p2 = "[object Object]", f2 = "[object Promise]", h3 = "[object RegExp]", g2 = "[object Set]", y2 = "[object String]", v2 = "[object Symbol]", m2 = "[object WeakMap]", _2 = "[object ArrayBuffer]", b2 = "[object DataView]", E2 = /^\[object .+?Constructor\]$/, T2 = /^(?:0|[1-9]\d*)$/, C2 = {};
      C2["[object Float32Array]"] = C2["[object Float64Array]"] = C2["[object Int8Array]"] = C2["[object Int16Array]"] = C2["[object Int32Array]"] = C2["[object Uint8Array]"] = C2["[object Uint8ClampedArray]"] = C2["[object Uint16Array]"] = C2["[object Uint32Array]"] = true, C2[r2] = C2[i2] = C2[_2] = C2[a2] = C2[b2] = C2[s2] = C2[u2] = C2[c2] = C2[l2] = C2[d2] = C2[p2] = C2[h3] = C2[g2] = C2[y2] = C2[m2] = false;
      var O2 = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, S2 = "object" == typeof self && self && self.Object === Object && self, I2 = O2 || S2 || Function("return this")(), x2 = e3 && !e3.nodeType && e3, M2 = x2 && t2 && !t2.nodeType && t2, L2 = M2 && M2.exports === x2, N2 = L2 && O2.process, A2 = function() {
        try {
          return N2 && N2.binding && N2.binding("util");
        } catch (t3) {
        }
      }(), P2 = A2 && A2.isTypedArray;
      function F2(t3, e4) {
        for (var n3 = -1, o3 = null == t3 ? 0 : t3.length; ++n3 < o3; )
          if (e4(t3[n3], n3, t3))
            return true;
        return false;
      }
      function w2(t3) {
        var e4 = -1, n3 = Array(t3.size);
        return t3.forEach(function(t4, o3) {
          n3[++e4] = [o3, t4];
        }), n3;
      }
      function R2(t3) {
        var e4 = -1, n3 = Array(t3.size);
        return t3.forEach(function(t4) {
          n3[++e4] = t4;
        }), n3;
      }
      var k2, D2, U2, j2 = Array.prototype, V2 = Function.prototype, B2 = Object.prototype, G2 = I2["__core-js_shared__"], J2 = V2.toString, z2 = B2.hasOwnProperty, Y2 = (k2 = /[^.]+$/.exec(G2 && G2.keys && G2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + k2 : "", $2 = B2.toString, q2 = RegExp("^" + J2.call(z2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), H2 = L2 ? I2.Buffer : void 0, X2 = I2.Symbol, Z2 = I2.Uint8Array, W2 = B2.propertyIsEnumerable, K2 = j2.splice, Q2 = X2 ? X2.toStringTag : void 0, tt2 = Object.getOwnPropertySymbols, et2 = H2 ? H2.isBuffer : void 0, nt2 = (D2 = Object.keys, U2 = Object, function(t3) {
        return D2(U2(t3));
      }), ot2 = At2(I2, "DataView"), rt2 = At2(I2, "Map"), it2 = At2(I2, "Promise"), at2 = At2(I2, "Set"), st2 = At2(I2, "WeakMap"), ut2 = At2(Object, "create"), ct2 = Rt2(ot2), lt2 = Rt2(rt2), dt2 = Rt2(it2), pt2 = Rt2(at2), ft2 = Rt2(st2), ht2 = X2 ? X2.prototype : void 0, gt2 = ht2 ? ht2.valueOf : void 0;
      function yt2(t3) {
        var e4 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.clear(); ++e4 < n3; ) {
          var o3 = t3[e4];
          this.set(o3[0], o3[1]);
        }
      }
      function vt2(t3) {
        var e4 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.clear(); ++e4 < n3; ) {
          var o3 = t3[e4];
          this.set(o3[0], o3[1]);
        }
      }
      function mt2(t3) {
        var e4 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.clear(); ++e4 < n3; ) {
          var o3 = t3[e4];
          this.set(o3[0], o3[1]);
        }
      }
      function _t2(t3) {
        var e4 = -1, n3 = null == t3 ? 0 : t3.length;
        for (this.__data__ = new mt2(); ++e4 < n3; )
          this.add(t3[e4]);
      }
      function bt2(t3) {
        var e4 = this.__data__ = new vt2(t3);
        this.size = e4.size;
      }
      function Et2(t3, e4) {
        var n3 = Ut2(t3), o3 = !n3 && Dt2(t3), r3 = !n3 && !o3 && jt2(t3), i3 = !n3 && !o3 && !r3 && zt2(t3), a3 = n3 || o3 || r3 || i3, s3 = a3 ? function(t4, e6) {
          for (var n4 = -1, o4 = Array(t4); ++n4 < t4; )
            o4[n4] = e6(n4);
          return o4;
        }(t3.length, String) : [], u3 = s3.length;
        for (var c3 in t3)
          !e4 && !z2.call(t3, c3) || a3 && ("length" == c3 || r3 && ("offset" == c3 || "parent" == c3) || i3 && ("buffer" == c3 || "byteLength" == c3 || "byteOffset" == c3) || wt2(c3, u3)) || s3.push(c3);
        return s3;
      }
      function Tt2(t3, e4) {
        for (var n3 = t3.length; n3--; )
          if (kt2(t3[n3][0], e4))
            return n3;
        return -1;
      }
      function Ct2(t3) {
        return null == t3 ? void 0 === t3 ? "[object Undefined]" : "[object Null]" : Q2 && Q2 in Object(t3) ? function(t4) {
          var e4 = z2.call(t4, Q2), n3 = t4[Q2];
          try {
            t4[Q2] = void 0;
            var o3 = true;
          } catch (t5) {
          }
          var r3 = $2.call(t4);
          o3 && (e4 ? t4[Q2] = n3 : delete t4[Q2]);
          return r3;
        }(t3) : function(t4) {
          return $2.call(t4);
        }(t3);
      }
      function Ot2(t3) {
        return Jt2(t3) && Ct2(t3) == r2;
      }
      function St2(t3, e4, n3, o3, c3) {
        return t3 === e4 || (null == t3 || null == e4 || !Jt2(t3) && !Jt2(e4) ? t3 != t3 && e4 != e4 : function(t4, e6, n4, o4, c4, f3) {
          var m3 = Ut2(t4), E3 = Ut2(e6), T3 = m3 ? i2 : Ft2(t4), C3 = E3 ? i2 : Ft2(e6), O3 = (T3 = T3 == r2 ? p2 : T3) == p2, S3 = (C3 = C3 == r2 ? p2 : C3) == p2, I3 = T3 == C3;
          if (I3 && jt2(t4)) {
            if (!jt2(e6))
              return false;
            m3 = true, O3 = false;
          }
          if (I3 && !O3)
            return f3 || (f3 = new bt2()), m3 || zt2(t4) ? Mt2(t4, e6, n4, o4, c4, f3) : function(t5, e7, n5, o5, r3, i3, c5) {
              switch (n5) {
                case b2:
                  if (t5.byteLength != e7.byteLength || t5.byteOffset != e7.byteOffset)
                    return false;
                  t5 = t5.buffer, e7 = e7.buffer;
                case _2:
                  return !(t5.byteLength != e7.byteLength || !i3(new Z2(t5), new Z2(e7)));
                case a2:
                case s2:
                case d2:
                  return kt2(+t5, +e7);
                case u2:
                  return t5.name == e7.name && t5.message == e7.message;
                case h3:
                case y2:
                  return t5 == e7 + "";
                case l2:
                  var p3 = w2;
                case g2:
                  var f4 = 1 & o5;
                  if (p3 || (p3 = R2), t5.size != e7.size && !f4)
                    return false;
                  var m4 = c5.get(t5);
                  if (m4)
                    return m4 == e7;
                  o5 |= 2, c5.set(t5, e7);
                  var E4 = Mt2(p3(t5), p3(e7), o5, r3, i3, c5);
                  return c5.delete(t5), E4;
                case v2:
                  if (gt2)
                    return gt2.call(t5) == gt2.call(e7);
              }
              return false;
            }(t4, e6, T3, n4, o4, c4, f3);
          if (!(1 & n4)) {
            var x3 = O3 && z2.call(t4, "__wrapped__"), M3 = S3 && z2.call(e6, "__wrapped__");
            if (x3 || M3) {
              var L3 = x3 ? t4.value() : t4, N3 = M3 ? e6.value() : e6;
              return f3 || (f3 = new bt2()), c4(L3, N3, n4, o4, f3);
            }
          }
          if (!I3)
            return false;
          return f3 || (f3 = new bt2()), function(t5, e7, n5, o5, r3, i3) {
            var a3 = 1 & n5, s3 = Lt2(t5), u3 = s3.length, c5 = Lt2(e7).length;
            if (u3 != c5 && !a3)
              return false;
            var l3 = u3;
            for (; l3--; ) {
              var d3 = s3[l3];
              if (!(a3 ? d3 in e7 : z2.call(e7, d3)))
                return false;
            }
            var p3 = i3.get(t5);
            if (p3 && i3.get(e7))
              return p3 == e7;
            var f4 = true;
            i3.set(t5, e7), i3.set(e7, t5);
            var h4 = a3;
            for (; ++l3 < u3; ) {
              var g3 = t5[d3 = s3[l3]], y3 = e7[d3];
              if (o5)
                var v3 = a3 ? o5(y3, g3, d3, e7, t5, i3) : o5(g3, y3, d3, t5, e7, i3);
              if (!(void 0 === v3 ? g3 === y3 || r3(g3, y3, n5, o5, i3) : v3)) {
                f4 = false;
                break;
              }
              h4 || (h4 = "constructor" == d3);
            }
            if (f4 && !h4) {
              var m4 = t5.constructor, _3 = e7.constructor;
              m4 == _3 || !("constructor" in t5) || !("constructor" in e7) || "function" == typeof m4 && m4 instanceof m4 && "function" == typeof _3 && _3 instanceof _3 || (f4 = false);
            }
            return i3.delete(t5), i3.delete(e7), f4;
          }(t4, e6, n4, o4, c4, f3);
        }(t3, e4, n3, o3, St2, c3));
      }
      function It2(t3) {
        return !(!Gt2(t3) || function(t4) {
          return !!Y2 && Y2 in t4;
        }(t3)) && (Vt2(t3) ? q2 : E2).test(Rt2(t3));
      }
      function xt2(t3) {
        if (n3 = (e4 = t3) && e4.constructor, o3 = "function" == typeof n3 && n3.prototype || B2, e4 !== o3)
          return nt2(t3);
        var e4, n3, o3, r3 = [];
        for (var i3 in Object(t3))
          z2.call(t3, i3) && "constructor" != i3 && r3.push(i3);
        return r3;
      }
      function Mt2(t3, e4, n3, o3, r3, i3) {
        var a3 = 1 & n3, s3 = t3.length, u3 = e4.length;
        if (s3 != u3 && !(a3 && u3 > s3))
          return false;
        var c3 = i3.get(t3);
        if (c3 && i3.get(e4))
          return c3 == e4;
        var l3 = -1, d3 = true, p3 = 2 & n3 ? new _t2() : void 0;
        for (i3.set(t3, e4), i3.set(e4, t3); ++l3 < s3; ) {
          var f3 = t3[l3], h4 = e4[l3];
          if (o3)
            var g3 = a3 ? o3(h4, f3, l3, e4, t3, i3) : o3(f3, h4, l3, t3, e4, i3);
          if (void 0 !== g3) {
            if (g3)
              continue;
            d3 = false;
            break;
          }
          if (p3) {
            if (!F2(e4, function(t4, e6) {
              if (a4 = e6, !p3.has(a4) && (f3 === t4 || r3(f3, t4, n3, o3, i3)))
                return p3.push(e6);
              var a4;
            })) {
              d3 = false;
              break;
            }
          } else if (f3 !== h4 && !r3(f3, h4, n3, o3, i3)) {
            d3 = false;
            break;
          }
        }
        return i3.delete(t3), i3.delete(e4), d3;
      }
      function Lt2(t3) {
        return function(t4, e4, n3) {
          var o3 = e4(t4);
          return Ut2(t4) ? o3 : function(t5, e6) {
            for (var n4 = -1, o4 = e6.length, r3 = t5.length; ++n4 < o4; )
              t5[r3 + n4] = e6[n4];
            return t5;
          }(o3, n3(t4));
        }(t3, Yt2, Pt2);
      }
      function Nt2(t3, e4) {
        var n3, o3, r3 = t3.__data__;
        return ("string" == (o3 = typeof (n3 = e4)) || "number" == o3 || "symbol" == o3 || "boolean" == o3 ? "__proto__" !== n3 : null === n3) ? r3["string" == typeof e4 ? "string" : "hash"] : r3.map;
      }
      function At2(t3, e4) {
        var n3 = function(t4, e6) {
          return null == t4 ? void 0 : t4[e6];
        }(t3, e4);
        return It2(n3) ? n3 : void 0;
      }
      yt2.prototype.clear = function() {
        this.__data__ = ut2 ? ut2(null) : {}, this.size = 0;
      }, yt2.prototype.delete = function(t3) {
        var e4 = this.has(t3) && delete this.__data__[t3];
        return this.size -= e4 ? 1 : 0, e4;
      }, yt2.prototype.get = function(t3) {
        var e4 = this.__data__;
        if (ut2) {
          var o3 = e4[t3];
          return o3 === n2 ? void 0 : o3;
        }
        return z2.call(e4, t3) ? e4[t3] : void 0;
      }, yt2.prototype.has = function(t3) {
        var e4 = this.__data__;
        return ut2 ? void 0 !== e4[t3] : z2.call(e4, t3);
      }, yt2.prototype.set = function(t3, e4) {
        var o3 = this.__data__;
        return this.size += this.has(t3) ? 0 : 1, o3[t3] = ut2 && void 0 === e4 ? n2 : e4, this;
      }, vt2.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, vt2.prototype.delete = function(t3) {
        var e4 = this.__data__, n3 = Tt2(e4, t3);
        return !(n3 < 0) && (n3 == e4.length - 1 ? e4.pop() : K2.call(e4, n3, 1), --this.size, true);
      }, vt2.prototype.get = function(t3) {
        var e4 = this.__data__, n3 = Tt2(e4, t3);
        return n3 < 0 ? void 0 : e4[n3][1];
      }, vt2.prototype.has = function(t3) {
        return Tt2(this.__data__, t3) > -1;
      }, vt2.prototype.set = function(t3, e4) {
        var n3 = this.__data__, o3 = Tt2(n3, t3);
        return o3 < 0 ? (++this.size, n3.push([t3, e4])) : n3[o3][1] = e4, this;
      }, mt2.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new yt2(), map: new (rt2 || vt2)(), string: new yt2() };
      }, mt2.prototype.delete = function(t3) {
        var e4 = Nt2(this, t3).delete(t3);
        return this.size -= e4 ? 1 : 0, e4;
      }, mt2.prototype.get = function(t3) {
        return Nt2(this, t3).get(t3);
      }, mt2.prototype.has = function(t3) {
        return Nt2(this, t3).has(t3);
      }, mt2.prototype.set = function(t3, e4) {
        var n3 = Nt2(this, t3), o3 = n3.size;
        return n3.set(t3, e4), this.size += n3.size == o3 ? 0 : 1, this;
      }, _t2.prototype.add = _t2.prototype.push = function(t3) {
        return this.__data__.set(t3, n2), this;
      }, _t2.prototype.has = function(t3) {
        return this.__data__.has(t3);
      }, bt2.prototype.clear = function() {
        this.__data__ = new vt2(), this.size = 0;
      }, bt2.prototype.delete = function(t3) {
        var e4 = this.__data__, n3 = e4.delete(t3);
        return this.size = e4.size, n3;
      }, bt2.prototype.get = function(t3) {
        return this.__data__.get(t3);
      }, bt2.prototype.has = function(t3) {
        return this.__data__.has(t3);
      }, bt2.prototype.set = function(t3, e4) {
        var n3 = this.__data__;
        if (n3 instanceof vt2) {
          var o3 = n3.__data__;
          if (!rt2 || o3.length < 199)
            return o3.push([t3, e4]), this.size = ++n3.size, this;
          n3 = this.__data__ = new mt2(o3);
        }
        return n3.set(t3, e4), this.size = n3.size, this;
      };
      var Pt2 = tt2 ? function(t3) {
        return null == t3 ? [] : (t3 = Object(t3), function(t4, e4) {
          for (var n3 = -1, o3 = null == t4 ? 0 : t4.length, r3 = 0, i3 = []; ++n3 < o3; ) {
            var a3 = t4[n3];
            e4(a3, n3, t4) && (i3[r3++] = a3);
          }
          return i3;
        }(tt2(t3), function(e4) {
          return W2.call(t3, e4);
        }));
      } : function() {
        return [];
      }, Ft2 = Ct2;
      function wt2(t3, e4) {
        return !!(e4 = null == e4 ? o2 : e4) && ("number" == typeof t3 || T2.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e4;
      }
      function Rt2(t3) {
        if (null != t3) {
          try {
            return J2.call(t3);
          } catch (t4) {
          }
          try {
            return t3 + "";
          } catch (t4) {
          }
        }
        return "";
      }
      function kt2(t3, e4) {
        return t3 === e4 || t3 != t3 && e4 != e4;
      }
      (ot2 && Ft2(new ot2(new ArrayBuffer(1))) != b2 || rt2 && Ft2(new rt2()) != l2 || it2 && Ft2(it2.resolve()) != f2 || at2 && Ft2(new at2()) != g2 || st2 && Ft2(new st2()) != m2) && (Ft2 = function(t3) {
        var e4 = Ct2(t3), n3 = e4 == p2 ? t3.constructor : void 0, o3 = n3 ? Rt2(n3) : "";
        if (o3)
          switch (o3) {
            case ct2:
              return b2;
            case lt2:
              return l2;
            case dt2:
              return f2;
            case pt2:
              return g2;
            case ft2:
              return m2;
          }
        return e4;
      });
      var Dt2 = Ot2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Ot2 : function(t3) {
        return Jt2(t3) && z2.call(t3, "callee") && !W2.call(t3, "callee");
      }, Ut2 = Array.isArray;
      var jt2 = et2 || function() {
        return false;
      };
      function Vt2(t3) {
        if (!Gt2(t3))
          return false;
        var e4 = Ct2(t3);
        return e4 == c2 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
      }
      function Bt2(t3) {
        return "number" == typeof t3 && t3 > -1 && t3 % 1 == 0 && t3 <= o2;
      }
      function Gt2(t3) {
        var e4 = typeof t3;
        return null != t3 && ("object" == e4 || "function" == e4);
      }
      function Jt2(t3) {
        return null != t3 && "object" == typeof t3;
      }
      var zt2 = P2 ? /* @__PURE__ */ function(t3) {
        return function(e4) {
          return t3(e4);
        };
      }(P2) : function(t3) {
        return Jt2(t3) && Bt2(t3.length) && !!C2[Ct2(t3)];
      };
      function Yt2(t3) {
        return null != (e4 = t3) && Bt2(e4.length) && !Vt2(e4) ? Et2(t3) : xt2(t3);
        var e4;
      }
      t2.exports = function(t3, e4) {
        return St2(t3, e4);
      };
    }(fe, fe.exports);
    var he = e(fe.exports);
    function ge(t2, e3) {
      return t2.length === e3.length && JSON.stringify(t2.map(function(t3) {
        return t3;
      }).sort()) === JSON.stringify(e3.map(function(t3) {
        return t3;
      }).sort());
    }
    var ye = { Polygon: V, LineString: j, Point: U, MultiPolygon: J, MultiLineString: J, MultiPoint: J };
    var ve = Object.freeze({ __proto__: null, CommonSelectors: ht, constrainFeatureMovement: Kt, createMidPoint: bt, createSupplementaryPoints: Et, createVertex: _t, doubleClickZoom: Tt, euclideanDistance: A, featuresAt: M, getFeatureAtAndSetCursors: N, isClick: P, isEventAtCoordinates: ie, isTap: F, mapEventToBoundingBox: S, ModeHandler: t, moveFeatures: Qt, sortFeatures: O, stringSetsAreEqual: ge, StringSet: I, theme: ot, toDenseArray: H }), me = function(t2, e3) {
      var n2 = { options: t2 = function(t3) {
        void 0 === t3 && (t3 = {});
        var e4 = tt(t3);
        return t3.controls || (e4.controls = {}), false === t3.displayControlsDefault ? e4.controls = tt(de, t3.controls) : e4.controls = tt(le, t3.controls), (e4 = tt(ce, e4)).styles = pe(e4.styles, "cold").concat(pe(e4.styles, "hot")), e4;
      }(t2) };
      e3 = function(t3, e4) {
        return e4.modes = h, e4.getFeatureIdsAt = function(e6) {
          return M.click({ point: e6 }, null, t3).map(function(t4) {
            return t4.properties.id;
          });
        }, e4.getSelectedIds = function() {
          return t3.store.getSelectedIds();
        }, e4.getSelected = function() {
          return { type: f.FEATURE_COLLECTION, features: t3.store.getSelectedIds().map(function(e6) {
            return t3.store.get(e6);
          }).map(function(t4) {
            return t4.toGeoJSON();
          }) };
        }, e4.getSelectedPoints = function() {
          return { type: f.FEATURE_COLLECTION, features: t3.store.getSelectedCoordinates().map(function(t4) {
            return { type: f.FEATURE, properties: {}, geometry: { type: f.POINT, coordinates: t4.coordinates } };
          }) };
        }, e4.set = function(n3) {
          if (void 0 === n3.type || n3.type !== f.FEATURE_COLLECTION || !Array.isArray(n3.features))
            throw new Error("Invalid FeatureCollection");
          var o3 = t3.store.createRenderBatch(), r2 = t3.store.getAllIds().slice(), i2 = e4.add(n3), a2 = new I(i2);
          return (r2 = r2.filter(function(t4) {
            return !a2.has(t4);
          })).length && e4.delete(r2), o3(), i2;
        }, e4.add = function(e6) {
          var n3 = JSON.parse(JSON.stringify(It(e6))).features.map(function(e7) {
            if (e7.id = e7.id || k(), null === e7.geometry)
              throw new Error("Invalid geometry: null");
            if (void 0 === t3.store.get(e7.id) || t3.store.get(e7.id).type !== e7.geometry.type) {
              var n4 = ye[e7.geometry.type];
              if (void 0 === n4)
                throw new Error("Invalid geometry type: " + e7.geometry.type + ".");
              var o3 = new n4(t3, e7);
              t3.store.add(o3);
            } else {
              var r2 = t3.store.get(e7.id);
              r2.properties = e7.properties, he(r2.properties, e7.properties) || t3.store.featureChanged(r2.id), he(r2.getCoordinates(), e7.geometry.coordinates) || r2.incomingCoords(e7.geometry.coordinates);
            }
            return e7.id;
          });
          return t3.store.render(), n3;
        }, e4.get = function(e6) {
          var n3 = t3.store.get(e6);
          if (n3)
            return n3.toGeoJSON();
        }, e4.getAll = function() {
          return { type: f.FEATURE_COLLECTION, features: t3.store.getAll().map(function(t4) {
            return t4.toGeoJSON();
          }) };
        }, e4.delete = function(n3) {
          return t3.store.delete(n3, { silent: true }), e4.getMode() !== h.DIRECT_SELECT || t3.store.getSelectedIds().length ? t3.store.render() : t3.events.changeMode(h.SIMPLE_SELECT, void 0, { silent: true }), e4;
        }, e4.deleteAll = function() {
          return t3.store.delete(t3.store.getAllIds(), { silent: true }), e4.getMode() === h.DIRECT_SELECT ? t3.events.changeMode(h.SIMPLE_SELECT, void 0, { silent: true }) : t3.store.render(), e4;
        }, e4.changeMode = function(n3, o3) {
          return void 0 === o3 && (o3 = {}), n3 === h.SIMPLE_SELECT && e4.getMode() === h.SIMPLE_SELECT ? (ge(o3.featureIds || [], t3.store.getSelectedIds()) || (t3.store.setSelected(o3.featureIds, { silent: true }), t3.store.render()), e4) : (n3 === h.DIRECT_SELECT && e4.getMode() === h.DIRECT_SELECT && o3.featureId === t3.store.getSelectedIds()[0] || t3.events.changeMode(n3, o3, { silent: true }), e4);
        }, e4.getMode = function() {
          return t3.events.getMode();
        }, e4.trash = function() {
          return t3.events.trash({ silent: true }), e4;
        }, e4.combineFeatures = function() {
          return t3.events.combineFeatures({ silent: true }), e4;
        }, e4.uncombineFeatures = function() {
          return t3.events.uncombineFeatures({ silent: true }), e4;
        }, e4.setFeatureProperty = function(n3, o3, r2) {
          return t3.store.setFeatureProperty(n3, o3, r2), e4;
        }, e4;
      }(n2, e3), n2.api = e3;
      var o2 = nt(n2);
      return e3.onAdd = o2.onAdd, e3.onRemove = o2.onRemove, e3.types = p, e3.options = t2, e3;
    };
    function _e(t2) {
      me(t2, this);
    }
    return _e.modes = ue, _e.constants = E, _e.lib = ve, _e;
  });
})(mapboxGlDraw);
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function tick_spring(ctx, last_value, current_value, target_value) {
  if (typeof current_value === "number" || is_date(current_value)) {
    const delta = target_value - current_value;
    const velocity = (current_value - last_value) / (ctx.dt || 1 / 60);
    const spring2 = ctx.opts.stiffness * delta;
    const damper = ctx.opts.damping * velocity;
    const acceleration = (spring2 - damper) * ctx.inv_mass;
    const d = (velocity + acceleration) * ctx.dt;
    if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
      return target_value;
    } else {
      ctx.settled = false;
      return is_date(current_value) ? new Date(current_value.getTime() + d) : current_value + d;
    }
  } else if (Array.isArray(current_value)) {
    return current_value.map(
      (_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i])
    );
  } else if (typeof current_value === "object") {
    const next_value = {};
    for (const k in current_value) {
      next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
    }
    return next_value;
  } else {
    throw new Error(`Cannot spring ${typeof current_value} values`);
  }
}
function spring(value, opts = {}) {
  const store = writable(value);
  const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
  let last_time;
  let task;
  let current_token;
  let last_value = value;
  let target_value = value;
  let inv_mass = 1;
  let inv_mass_recovery_rate = 0;
  let cancel_task = false;
  function set2(new_value, opts2 = {}) {
    target_value = new_value;
    const token2 = current_token = {};
    if (value == null || opts2.hard || spring2.stiffness >= 1 && spring2.damping >= 1) {
      cancel_task = true;
      last_time = now$1();
      last_value = new_value;
      store.set(value = target_value);
      return Promise.resolve();
    } else if (opts2.soft) {
      const rate = opts2.soft === true ? 0.5 : +opts2.soft;
      inv_mass_recovery_rate = 1 / (rate * 60);
      inv_mass = 0;
    }
    if (!task) {
      last_time = now$1();
      cancel_task = false;
      task = loop((now2) => {
        if (cancel_task) {
          cancel_task = false;
          task = null;
          return false;
        }
        inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
        const ctx = {
          inv_mass,
          opts: spring2,
          settled: true,
          dt: (now2 - last_time) * 60 / 1e3
        };
        const next_value = tick_spring(ctx, last_value, value, target_value);
        last_time = now2;
        last_value = value;
        store.set(value = next_value);
        if (ctx.settled) {
          task = null;
        }
        return !ctx.settled;
      });
    }
    return new Promise((fulfil) => {
      task.promise.then(() => {
        if (token2 === current_token)
          fulfil();
      });
    });
  }
  const spring2 = {
    set: set2,
    update: (fn, opts2) => set2(fn(target_value, value), opts2),
    subscribe: store.subscribe,
    stiffness,
    damping,
    precision
  };
  return spring2;
}
function cubicInOut$1(t) {
  return t < 0.5 ? 4 * t * t * t : 0.5 * Math.pow(2 * t - 2, 3) + 1;
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function sineIn(t) {
  const v = Math.cos(t * Math.PI * 0.5);
  if (Math.abs(v) < 1e-14)
    return 1;
  else
    return 1 - v;
}
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  child_ctx[39] = i;
  return child_ctx;
}
function create_if_block_9(ctx) {
  let span;
  let span_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*all*/
    (ctx[6] === "label" || /*first*/
    ctx[7] === "label") && create_if_block_10(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children$1(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pip first");
      attr(span, "style", span_style_value = /*orientationStart*/
      ctx[14] + ": 0%;");
      toggle_class(
        span,
        "selected",
        /*isSelected*/
        ctx[18](
          /*min*/
          ctx[0]
        )
      );
      toggle_class(
        span,
        "in-range",
        /*inRange*/
        ctx[17](
          /*min*/
          ctx[0]
        )
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block)
        if_block.m(span, null);
      if (!mounted) {
        dispose = [
          listen(
            span,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[30]
          ),
          listen(
            span,
            "pointerup",
            /*pointerup_handler*/
            ctx[31]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*all*/
        ctx2[6] === "label" || /*first*/
        ctx2[7] === "label"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_10(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart*/
      16384 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx2[14] + ": 0%;")) {
        attr(span, "style", span_style_value);
      }
      if (dirty[0] & /*isSelected, min*/
      262145) {
        toggle_class(
          span,
          "selected",
          /*isSelected*/
          ctx2[18](
            /*min*/
            ctx2[0]
          )
        );
      }
      if (dirty[0] & /*inRange, min*/
      131073) {
        toggle_class(
          span,
          "in-range",
          /*inRange*/
          ctx2[17](
            /*min*/
            ctx2[0]
          )
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  let if_block0_anchor;
  let html_tag;
  let raw_value = (
    /*formatter*/
    ctx[12](
      /*fixFloat*/
      ctx[16](
        /*min*/
        ctx[0]
      ),
      0,
      0
    ) + ""
  );
  let html_anchor;
  let if_block0 = (
    /*prefix*/
    ctx[10] && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[11] && create_if_block_11(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty$1();
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      if (if_block0)
        if_block0.l(span_nodes);
      if_block0_anchor = empty$1();
      html_tag = claim_html_tag(span_nodes, false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
      attr(span, "class", "pipVal");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_hydration(span, if_block0_anchor);
      html_tag.m(raw_value, span);
      append_hydration(span, html_anchor);
      if (if_block1)
        if_block1.m(span, null);
    },
    p(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(span, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*formatter, fixFloat, min*/
      69633 && raw_value !== (raw_value = /*formatter*/
      ctx2[12](
        /*fixFloat*/
        ctx2[16](
          /*min*/
          ctx2[0]
        ),
        0,
        0
      ) + ""))
        html_tag.p(raw_value);
      if (
        /*suffix*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_11(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_12(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[10]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*prefix*/
        ctx[10]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pipVal-prefix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      1024)
        set_data(
          t,
          /*prefix*/
          ctx2[10]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_11(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[11]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*suffix*/
        ctx[11]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pipVal-suffix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      2048)
        set_data(
          t,
          /*suffix*/
          ctx2[11]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_4$1(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(Array(
    /*pipCount*/
    ctx[20] + 1
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty$1();
    },
    l(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty$1();
    },
    m(target2, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target2, anchor);
        }
      }
      insert_hydration(target2, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelDown, labelUp, suffix, formatter, prefix, all, rest, min, max, pipCount*/
      8314435) {
        each_value = ensure_array_like(Array(
          /*pipCount*/
          ctx2[20] + 1
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let span;
  let t;
  let span_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*all*/
    (ctx[6] === "label" || /*rest*/
    ctx[9] === "label") && create_if_block_6(ctx)
  );
  function pointerup_handler_1(...args) {
    return (
      /*pointerup_handler_1*/
      ctx[33](
        /*i*/
        ctx[39],
        ...args
      )
    );
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t = space();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children$1(span);
      if (if_block)
        if_block.l(span_nodes);
      t = claim_space(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pip");
      attr(span, "style", span_style_value = /*orientationStart*/
      ctx[14] + ": " + /*percentOf*/
      ctx[15](
        /*pipVal*/
        ctx[19](
          /*i*/
          ctx[39]
        )
      ) + "%;");
      toggle_class(
        span,
        "selected",
        /*isSelected*/
        ctx[18](
          /*pipVal*/
          ctx[19](
            /*i*/
            ctx[39]
          )
        )
      );
      toggle_class(
        span,
        "in-range",
        /*inRange*/
        ctx[17](
          /*pipVal*/
          ctx[19](
            /*i*/
            ctx[39]
          )
        )
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block)
        if_block.m(span, null);
      append_hydration(span, t);
      if (!mounted) {
        dispose = [
          listen(
            span,
            "pointerdown",
            /*pointerdown_handler_1*/
            ctx[32]
          ),
          listen(span, "pointerup", pointerup_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*all*/
        ctx[6] === "label" || /*rest*/
        ctx[9] === "label"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_6(ctx);
          if_block.c();
          if_block.m(span, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart, percentOf, pipVal*/
      573440 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx[14] + ": " + /*percentOf*/
      ctx[15](
        /*pipVal*/
        ctx[19](
          /*i*/
          ctx[39]
        )
      ) + "%;")) {
        attr(span, "style", span_style_value);
      }
      if (dirty[0] & /*isSelected, pipVal*/
      786432) {
        toggle_class(
          span,
          "selected",
          /*isSelected*/
          ctx[18](
            /*pipVal*/
            ctx[19](
              /*i*/
              ctx[39]
            )
          )
        );
      }
      if (dirty[0] & /*inRange, pipVal*/
      655360) {
        toggle_class(
          span,
          "in-range",
          /*inRange*/
          ctx[17](
            /*pipVal*/
            ctx[19](
              /*i*/
              ctx[39]
            )
          )
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_6(ctx) {
  let span;
  let if_block0_anchor;
  let html_tag;
  let raw_value = (
    /*formatter*/
    ctx[12](
      /*pipVal*/
      ctx[19](
        /*i*/
        ctx[39]
      ),
      /*i*/
      ctx[39],
      /*percentOf*/
      ctx[15](
        /*pipVal*/
        ctx[19](
          /*i*/
          ctx[39]
        )
      )
    ) + ""
  );
  let html_anchor;
  let if_block0 = (
    /*prefix*/
    ctx[10] && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[11] && create_if_block_7(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty$1();
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      if (if_block0)
        if_block0.l(span_nodes);
      if_block0_anchor = empty$1();
      html_tag = claim_html_tag(span_nodes, false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
      attr(span, "class", "pipVal");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_hydration(span, if_block0_anchor);
      html_tag.m(raw_value, span);
      append_hydration(span, html_anchor);
      if (if_block1)
        if_block1.m(span, null);
    },
    p(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          if_block0.m(span, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*formatter, pipVal, percentOf*/
      561152 && raw_value !== (raw_value = /*formatter*/
      ctx2[12](
        /*pipVal*/
        ctx2[19](
          /*i*/
          ctx2[39]
        ),
        /*i*/
        ctx2[39],
        /*percentOf*/
        ctx2[15](
          /*pipVal*/
          ctx2[19](
            /*i*/
            ctx2[39]
          )
        )
      ) + ""))
        html_tag.p(raw_value);
      if (
        /*suffix*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[10]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*prefix*/
        ctx[10]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pipVal-prefix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      1024)
        set_data(
          t,
          /*prefix*/
          ctx2[10]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[11]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*suffix*/
        ctx[11]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pipVal-suffix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      2048)
        set_data(
          t,
          /*suffix*/
          ctx2[11]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block$2(ctx) {
  let show_if = (
    /*pipVal*/
    ctx[19](
      /*i*/
      ctx[39]
    ) !== /*min*/
    ctx[0] && /*pipVal*/
    ctx[19](
      /*i*/
      ctx[39]
    ) !== /*max*/
    ctx[1]
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_5(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$1();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty$1();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert_hydration(target2, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*pipVal, min, max*/
      524291)
        show_if = /*pipVal*/
        ctx2[19](
          /*i*/
          ctx2[39]
        ) !== /*min*/
        ctx2[0] && /*pipVal*/
        ctx2[19](
          /*i*/
          ctx2[39]
        ) !== /*max*/
        ctx2[1];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block$6(ctx) {
  let span;
  let span_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*all*/
    (ctx[6] === "label" || /*last*/
    ctx[8] === "label") && create_if_block_1$4(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children$1(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pip last");
      attr(span, "style", span_style_value = /*orientationStart*/
      ctx[14] + ": 100%;");
      toggle_class(
        span,
        "selected",
        /*isSelected*/
        ctx[18](
          /*max*/
          ctx[1]
        )
      );
      toggle_class(
        span,
        "in-range",
        /*inRange*/
        ctx[17](
          /*max*/
          ctx[1]
        )
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block)
        if_block.m(span, null);
      if (!mounted) {
        dispose = [
          listen(
            span,
            "pointerdown",
            /*pointerdown_handler_2*/
            ctx[34]
          ),
          listen(
            span,
            "pointerup",
            /*pointerup_handler_2*/
            ctx[35]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*all*/
        ctx2[6] === "label" || /*last*/
        ctx2[8] === "label"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$4(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart*/
      16384 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx2[14] + ": 100%;")) {
        attr(span, "style", span_style_value);
      }
      if (dirty[0] & /*isSelected, max*/
      262146) {
        toggle_class(
          span,
          "selected",
          /*isSelected*/
          ctx2[18](
            /*max*/
            ctx2[1]
          )
        );
      }
      if (dirty[0] & /*inRange, max*/
      131074) {
        toggle_class(
          span,
          "in-range",
          /*inRange*/
          ctx2[17](
            /*max*/
            ctx2[1]
          )
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$4(ctx) {
  let span;
  let if_block0_anchor;
  let html_tag;
  let raw_value = (
    /*formatter*/
    ctx[12](
      /*fixFloat*/
      ctx[16](
        /*max*/
        ctx[1]
      ),
      /*pipCount*/
      ctx[20],
      100
    ) + ""
  );
  let html_anchor;
  let if_block0 = (
    /*prefix*/
    ctx[10] && create_if_block_3$1(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[11] && create_if_block_2$4(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty$1();
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      if (if_block0)
        if_block0.l(span_nodes);
      if_block0_anchor = empty$1();
      html_tag = claim_html_tag(span_nodes, false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
      attr(span, "class", "pipVal");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_hydration(span, if_block0_anchor);
      html_tag.m(raw_value, span);
      append_hydration(span, html_anchor);
      if (if_block1)
        if_block1.m(span, null);
    },
    p(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$1(ctx2);
          if_block0.c();
          if_block0.m(span, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*formatter, fixFloat, max, pipCount*/
      1118210 && raw_value !== (raw_value = /*formatter*/
      ctx2[12](
        /*fixFloat*/
        ctx2[16](
          /*max*/
          ctx2[1]
        ),
        /*pipCount*/
        ctx2[20],
        100
      ) + ""))
        html_tag.p(raw_value);
      if (
        /*suffix*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$4(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_3$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[10]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*prefix*/
        ctx[10]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pipVal-prefix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      1024)
        set_data(
          t,
          /*prefix*/
          ctx2[10]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[11]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*suffix*/
        ctx[11]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "pipVal-suffix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      2048)
        set_data(
          t,
          /*suffix*/
          ctx2[11]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let t0;
  let t1;
  let if_block0 = (
    /*all*/
    (ctx[6] && /*first*/
    ctx[7] !== false || /*first*/
    ctx[7]) && create_if_block_9(ctx)
  );
  let if_block1 = (
    /*all*/
    (ctx[6] && /*rest*/
    ctx[9] !== false || /*rest*/
    ctx[9]) && create_if_block_4$1(ctx)
  );
  let if_block2 = (
    /*all*/
    (ctx[6] && /*last*/
    ctx[8] !== false || /*last*/
    ctx[8]) && create_if_block$6(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "rangePips");
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div,
        "hoverable",
        /*hoverable*/
        ctx[4]
      );
      toggle_class(
        div,
        "vertical",
        /*vertical*/
        ctx[2]
      );
      toggle_class(
        div,
        "reversed",
        /*reversed*/
        ctx[3]
      );
      toggle_class(
        div,
        "focus",
        /*focus*/
        ctx[13]
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration(div, t1);
      if (if_block2)
        if_block2.m(div, null);
    },
    p(ctx2, dirty) {
      if (
        /*all*/
        ctx2[6] && /*first*/
        ctx2[7] !== false || /*first*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_9(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*all*/
        ctx2[6] && /*rest*/
        ctx2[9] !== false || /*rest*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$1(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*all*/
        ctx2[6] && /*last*/
        ctx2[8] !== false || /*last*/
        ctx2[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$6(ctx2);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*hoverable*/
      16) {
        toggle_class(
          div,
          "hoverable",
          /*hoverable*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*vertical*/
      4) {
        toggle_class(
          div,
          "vertical",
          /*vertical*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*reversed*/
      8) {
        toggle_class(
          div,
          "reversed",
          /*reversed*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*focus*/
      8192) {
        toggle_class(
          div,
          "focus",
          /*focus*/
          ctx2[13]
        );
      }
    },
    i: noop$4,
    o: noop$4,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let pipStep;
  let pipCount;
  let pipVal;
  let isSelected;
  let inRange2;
  let { range: range2 = false } = $$props;
  let { min = 0 } = $$props;
  let { max: max2 = 100 } = $$props;
  let { step = 1 } = $$props;
  let { values = [(max2 + min) / 2] } = $$props;
  let { vertical = false } = $$props;
  let { reversed = false } = $$props;
  let { hoverable = true } = $$props;
  let { disabled = false } = $$props;
  let { pipstep = void 0 } = $$props;
  let { all: all2 = true } = $$props;
  let { first = void 0 } = $$props;
  let { last = void 0 } = $$props;
  let { rest = void 0 } = $$props;
  let { prefix = "" } = $$props;
  let { suffix = "" } = $$props;
  let { formatter = (v, i, p) => v } = $$props;
  let { focus: focus2 = void 0 } = $$props;
  let { orientationStart = void 0 } = $$props;
  let { percentOf = void 0 } = $$props;
  let { moveHandle = void 0 } = $$props;
  let { fixFloat = void 0 } = $$props;
  let { normalisedClient: normalisedClient2 = void 0 } = $$props;
  let clientStart;
  function labelDown(e) {
    e = normalisedClient2(e);
    clientStart = { x: e.clientX, y: e.clientY };
  }
  function labelUp(val, e) {
    e = normalisedClient2(e);
    if (!disabled) {
      const distanceMoved = Math.sqrt(Math.pow(clientStart.x - e.clientX, 2) + Math.pow(clientStart.y - e.clientY, 2));
      if (clientStart && distanceMoved <= 5) {
        moveHandle(void 0, val);
      }
    }
  }
  const pointerdown_handler = (e) => {
    labelDown(e);
  };
  const pointerup_handler = (e) => {
    labelUp(min, e);
  };
  const pointerdown_handler_1 = (e) => {
    labelDown(e);
  };
  const pointerup_handler_1 = (i, e) => {
    labelUp(pipVal(i), e);
  };
  const pointerdown_handler_2 = (e) => {
    labelDown(e);
  };
  const pointerup_handler_2 = (e) => {
    labelUp(max2, e);
  };
  $$self.$$set = ($$props2) => {
    if ("range" in $$props2)
      $$invalidate(23, range2 = $$props2.range);
    if ("min" in $$props2)
      $$invalidate(0, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(1, max2 = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(24, step = $$props2.step);
    if ("values" in $$props2)
      $$invalidate(25, values = $$props2.values);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("reversed" in $$props2)
      $$invalidate(3, reversed = $$props2.reversed);
    if ("hoverable" in $$props2)
      $$invalidate(4, hoverable = $$props2.hoverable);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("pipstep" in $$props2)
      $$invalidate(26, pipstep = $$props2.pipstep);
    if ("all" in $$props2)
      $$invalidate(6, all2 = $$props2.all);
    if ("first" in $$props2)
      $$invalidate(7, first = $$props2.first);
    if ("last" in $$props2)
      $$invalidate(8, last = $$props2.last);
    if ("rest" in $$props2)
      $$invalidate(9, rest = $$props2.rest);
    if ("prefix" in $$props2)
      $$invalidate(10, prefix = $$props2.prefix);
    if ("suffix" in $$props2)
      $$invalidate(11, suffix = $$props2.suffix);
    if ("formatter" in $$props2)
      $$invalidate(12, formatter = $$props2.formatter);
    if ("focus" in $$props2)
      $$invalidate(13, focus2 = $$props2.focus);
    if ("orientationStart" in $$props2)
      $$invalidate(14, orientationStart = $$props2.orientationStart);
    if ("percentOf" in $$props2)
      $$invalidate(15, percentOf = $$props2.percentOf);
    if ("moveHandle" in $$props2)
      $$invalidate(27, moveHandle = $$props2.moveHandle);
    if ("fixFloat" in $$props2)
      $$invalidate(16, fixFloat = $$props2.fixFloat);
    if ("normalisedClient" in $$props2)
      $$invalidate(28, normalisedClient2 = $$props2.normalisedClient);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*pipstep, max, min, step, vertical*/
    83886087) {
      $$invalidate(29, pipStep = pipstep || ((max2 - min) / step >= (vertical ? 50 : 100) ? (max2 - min) / (vertical ? 10 : 20) : 1));
    }
    if ($$self.$$.dirty[0] & /*max, min, step, pipStep*/
    553648131) {
      $$invalidate(20, pipCount = parseInt((max2 - min) / (step * pipStep), 10));
    }
    if ($$self.$$.dirty[0] & /*fixFloat, min, step, pipStep*/
    553713665) {
      $$invalidate(19, pipVal = function(val) {
        return fixFloat(min + val * step * pipStep);
      });
    }
    if ($$self.$$.dirty[0] & /*values, fixFloat*/
    33619968) {
      $$invalidate(18, isSelected = function(val) {
        return values.some((v) => fixFloat(v) === fixFloat(val));
      });
    }
    if ($$self.$$.dirty[0] & /*range, values*/
    41943040) {
      $$invalidate(17, inRange2 = function(val) {
        if (range2 === "min") {
          return values[0] > val;
        } else if (range2 === "max") {
          return values[0] < val;
        } else if (range2) {
          return values[0] < val && values[1] > val;
        }
      });
    }
  };
  return [
    min,
    max2,
    vertical,
    reversed,
    hoverable,
    disabled,
    all2,
    first,
    last,
    rest,
    prefix,
    suffix,
    formatter,
    focus2,
    orientationStart,
    percentOf,
    fixFloat,
    inRange2,
    isSelected,
    pipVal,
    pipCount,
    labelDown,
    labelUp,
    range2,
    step,
    values,
    pipstep,
    moveHandle,
    normalisedClient2,
    pipStep,
    pointerdown_handler,
    pointerup_handler,
    pointerdown_handler_1,
    pointerup_handler_1,
    pointerdown_handler_2,
    pointerup_handler_2
  ];
}
class RangePips extends SvelteComponent {
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$7,
      create_fragment$7,
      safe_not_equal,
      {
        range: 23,
        min: 0,
        max: 1,
        step: 24,
        values: 25,
        vertical: 2,
        reversed: 3,
        hoverable: 4,
        disabled: 5,
        pipstep: 26,
        all: 6,
        first: 7,
        last: 8,
        rest: 9,
        prefix: 10,
        suffix: 11,
        formatter: 12,
        focus: 13,
        orientationStart: 14,
        percentOf: 15,
        moveHandle: 27,
        fixFloat: 16,
        normalisedClient: 28
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[65] = list[i];
  child_ctx[67] = i;
  return child_ctx;
}
function create_if_block_2$3(ctx) {
  let span;
  let if_block0_anchor;
  let html_tag;
  let raw_value = (
    /*handleFormatter*/
    ctx[21](
      /*value*/
      ctx[65],
      /*index*/
      ctx[67],
      /*percentOf*/
      ctx[24](
        /*value*/
        ctx[65]
      )
    ) + ""
  );
  let html_anchor;
  let if_block0 = (
    /*prefix*/
    ctx[18] && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[19] && create_if_block_3(ctx)
  );
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty$1();
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      if (if_block0)
        if_block0.l(span_nodes);
      if_block0_anchor = empty$1();
      html_tag = claim_html_tag(span_nodes, false);
      html_anchor = empty$1();
      if (if_block1)
        if_block1.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      html_tag.a = html_anchor;
      attr(span, "class", "rangeFloat");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_hydration(span, if_block0_anchor);
      html_tag.m(raw_value, span);
      append_hydration(span, html_anchor);
      if (if_block1)
        if_block1.m(span, null);
    },
    p(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[18]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(span, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*handleFormatter, values, percentOf*/
      18874369 && raw_value !== (raw_value = /*handleFormatter*/
      ctx2[21](
        /*value*/
        ctx2[65],
        /*index*/
        ctx2[67],
        /*percentOf*/
        ctx2[24](
          /*value*/
          ctx2[65]
        )
      ) + ""))
        html_tag.p(raw_value);
      if (
        /*suffix*/
        ctx2[19]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[18]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*prefix*/
        ctx[18]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "rangeFloat-prefix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      262144)
        set_data(
          t,
          /*prefix*/
          ctx2[18]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[19]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*suffix*/
        ctx[19]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "rangeFloat-suffix");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      524288)
        set_data(
          t,
          /*suffix*/
          ctx2[19]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block$1(ctx) {
  let span1;
  let span0;
  let t;
  let span1_style_value;
  let span1_aria_label_value;
  let span1_aria_valuemin_value;
  let span1_aria_valuemax_value;
  let span1_aria_valuenow_value;
  let span1_aria_valuetext_value;
  let span1_aria_orientation_value;
  let span1_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*float*/
    ctx[7] && create_if_block_2$3(ctx)
  );
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", {
        role: true,
        class: true,
        "data-handle": true,
        style: true,
        "aria-label": true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true,
        "aria-valuetext": true,
        "aria-orientation": true,
        "aria-disabled": true,
        disabled: true,
        tabindex: true
      });
      var span1_nodes = children$1(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      children$1(span0).forEach(detach);
      t = claim_space(span1_nodes);
      if (if_block)
        if_block.l(span1_nodes);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "rangeNub");
      attr(span1, "role", "slider");
      attr(span1, "class", "rangeHandle");
      attr(
        span1,
        "data-handle",
        /*index*/
        ctx[67]
      );
      attr(span1, "style", span1_style_value = /*orientationStart*/
      ctx[29] + ": " + /*$springPositions*/
      ctx[30][
        /*index*/
        ctx[67]
      ] + "%; z-index: " + /*activeHandle*/
      (ctx[27] === /*index*/
      ctx[67] ? 3 : 2) + ";");
      attr(span1, "aria-label", span1_aria_label_value = /*ariaLabels*/
      ctx[22][
        /*index*/
        ctx[67]
      ]);
      attr(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/
      ctx[2] === true && /*index*/
      ctx[67] === 1 ? (
        /*values*/
        ctx[0][0]
      ) : (
        /*min*/
        ctx[3]
      ));
      attr(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/
      ctx[2] === true && /*index*/
      ctx[67] === 0 ? (
        /*values*/
        ctx[0][1]
      ) : (
        /*max*/
        ctx[4]
      ));
      attr(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/
      ctx[65]);
      attr(span1, "aria-valuetext", span1_aria_valuetext_value = "" + /*prefix*/
      (ctx[18] + pureText(
        /*handleFormatter*/
        ctx[21](
          /*value*/
          ctx[65],
          /*index*/
          ctx[67],
          /*percentOf*/
          ctx[24](
            /*value*/
            ctx[65]
          )
        )
      ) + /*suffix*/
      ctx[19]));
      attr(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/
      ctx[6] ? "vertical" : "horizontal");
      attr(
        span1,
        "aria-disabled",
        /*disabled*/
        ctx[10]
      );
      attr(
        span1,
        "disabled",
        /*disabled*/
        ctx[10]
      );
      attr(span1, "tabindex", span1_tabindex_value = /*disabled*/
      ctx[10] ? -1 : 0);
      toggle_class(
        span1,
        "active",
        /*focus*/
        ctx[25] && /*activeHandle*/
        ctx[27] === /*index*/
        ctx[67]
      );
      toggle_class(
        span1,
        "press",
        /*handlePressed*/
        ctx[26] && /*activeHandle*/
        ctx[27] === /*index*/
        ctx[67]
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span1, t);
      if (if_block)
        if_block.m(span1, null);
      if (!mounted) {
        dispose = [
          listen(
            span1,
            "blur",
            /*sliderBlurHandle*/
            ctx[35]
          ),
          listen(
            span1,
            "focus",
            /*sliderFocusHandle*/
            ctx[36]
          ),
          listen(
            span1,
            "keydown",
            /*sliderKeydown*/
            ctx[37]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*float*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$3(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/
      1744830464 && span1_style_value !== (span1_style_value = /*orientationStart*/
      ctx2[29] + ": " + /*$springPositions*/
      ctx2[30][
        /*index*/
        ctx2[67]
      ] + "%; z-index: " + /*activeHandle*/
      (ctx2[27] === /*index*/
      ctx2[67] ? 3 : 2) + ";")) {
        attr(span1, "style", span1_style_value);
      }
      if (dirty[0] & /*ariaLabels*/
      4194304 && span1_aria_label_value !== (span1_aria_label_value = /*ariaLabels*/
      ctx2[22][
        /*index*/
        ctx2[67]
      ])) {
        attr(span1, "aria-label", span1_aria_label_value);
      }
      if (dirty[0] & /*range, values, min*/
      13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/
      ctx2[2] === true && /*index*/
      ctx2[67] === 1 ? (
        /*values*/
        ctx2[0][0]
      ) : (
        /*min*/
        ctx2[3]
      ))) {
        attr(span1, "aria-valuemin", span1_aria_valuemin_value);
      }
      if (dirty[0] & /*range, values, max*/
      21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/
      ctx2[2] === true && /*index*/
      ctx2[67] === 0 ? (
        /*values*/
        ctx2[0][1]
      ) : (
        /*max*/
        ctx2[4]
      ))) {
        attr(span1, "aria-valuemax", span1_aria_valuemax_value);
      }
      if (dirty[0] & /*values*/
      1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/
      ctx2[65])) {
        attr(span1, "aria-valuenow", span1_aria_valuenow_value);
      }
      if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/
      19660801 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + /*prefix*/
      (ctx2[18] + pureText(
        /*handleFormatter*/
        ctx2[21](
          /*value*/
          ctx2[65],
          /*index*/
          ctx2[67],
          /*percentOf*/
          ctx2[24](
            /*value*/
            ctx2[65]
          )
        )
      ) + /*suffix*/
      ctx2[19]))) {
        attr(span1, "aria-valuetext", span1_aria_valuetext_value);
      }
      if (dirty[0] & /*vertical*/
      64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/
      ctx2[6] ? "vertical" : "horizontal")) {
        attr(span1, "aria-orientation", span1_aria_orientation_value);
      }
      if (dirty[0] & /*disabled*/
      1024) {
        attr(
          span1,
          "aria-disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*disabled*/
      1024) {
        attr(
          span1,
          "disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*disabled*/
      1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/
      ctx2[10] ? -1 : 0)) {
        attr(span1, "tabindex", span1_tabindex_value);
      }
      if (dirty[0] & /*focus, activeHandle*/
      167772160) {
        toggle_class(
          span1,
          "active",
          /*focus*/
          ctx2[25] && /*activeHandle*/
          ctx2[27] === /*index*/
          ctx2[67]
        );
      }
      if (dirty[0] & /*handlePressed, activeHandle*/
      201326592) {
        toggle_class(
          span1,
          "press",
          /*handlePressed*/
          ctx2[26] && /*activeHandle*/
          ctx2[27] === /*index*/
          ctx2[67]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$3(ctx) {
  let span;
  let span_style_value;
  return {
    c() {
      span = element("span");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      children$1(span).forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "rangeBar");
      attr(span, "style", span_style_value = /*orientationStart*/
      ctx[29] + ": " + /*rangeStart*/
      ctx[33](
        /*$springPositions*/
        ctx[30]
      ) + "%; " + /*orientationEnd*/
      ctx[28] + ": " + /*rangeEnd*/
      ctx[34](
        /*$springPositions*/
        ctx[30]
      ) + "%;");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/
      1879048192 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx2[29] + ": " + /*rangeStart*/
      ctx2[33](
        /*$springPositions*/
        ctx2[30]
      ) + "%; " + /*orientationEnd*/
      ctx2[28] + ": " + /*rangeEnd*/
      ctx2[34](
        /*$springPositions*/
        ctx2[30]
      ) + "%;")) {
        attr(span, "style", span_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$5(ctx) {
  let rangepips;
  let current2;
  rangepips = new RangePips({
    props: {
      values: (
        /*values*/
        ctx[0]
      ),
      min: (
        /*min*/
        ctx[3]
      ),
      max: (
        /*max*/
        ctx[4]
      ),
      step: (
        /*step*/
        ctx[5]
      ),
      range: (
        /*range*/
        ctx[2]
      ),
      vertical: (
        /*vertical*/
        ctx[6]
      ),
      reversed: (
        /*reversed*/
        ctx[8]
      ),
      orientationStart: (
        /*orientationStart*/
        ctx[29]
      ),
      hoverable: (
        /*hoverable*/
        ctx[9]
      ),
      disabled: (
        /*disabled*/
        ctx[10]
      ),
      all: (
        /*all*/
        ctx[13]
      ),
      first: (
        /*first*/
        ctx[14]
      ),
      last: (
        /*last*/
        ctx[15]
      ),
      rest: (
        /*rest*/
        ctx[16]
      ),
      pipstep: (
        /*pipstep*/
        ctx[12]
      ),
      prefix: (
        /*prefix*/
        ctx[18]
      ),
      suffix: (
        /*suffix*/
        ctx[19]
      ),
      formatter: (
        /*formatter*/
        ctx[20]
      ),
      focus: (
        /*focus*/
        ctx[25]
      ),
      percentOf: (
        /*percentOf*/
        ctx[24]
      ),
      moveHandle: (
        /*moveHandle*/
        ctx[32]
      ),
      fixFloat: (
        /*fixFloat*/
        ctx[31]
      ),
      normalisedClient
    }
  });
  return {
    c() {
      create_component(rangepips.$$.fragment);
    },
    l(nodes) {
      claim_component(rangepips.$$.fragment, nodes);
    },
    m(target2, anchor) {
      mount_component(rangepips, target2, anchor);
      current2 = true;
    },
    p(ctx2, dirty) {
      const rangepips_changes = {};
      if (dirty[0] & /*values*/
      1)
        rangepips_changes.values = /*values*/
        ctx2[0];
      if (dirty[0] & /*min*/
      8)
        rangepips_changes.min = /*min*/
        ctx2[3];
      if (dirty[0] & /*max*/
      16)
        rangepips_changes.max = /*max*/
        ctx2[4];
      if (dirty[0] & /*step*/
      32)
        rangepips_changes.step = /*step*/
        ctx2[5];
      if (dirty[0] & /*range*/
      4)
        rangepips_changes.range = /*range*/
        ctx2[2];
      if (dirty[0] & /*vertical*/
      64)
        rangepips_changes.vertical = /*vertical*/
        ctx2[6];
      if (dirty[0] & /*reversed*/
      256)
        rangepips_changes.reversed = /*reversed*/
        ctx2[8];
      if (dirty[0] & /*orientationStart*/
      536870912)
        rangepips_changes.orientationStart = /*orientationStart*/
        ctx2[29];
      if (dirty[0] & /*hoverable*/
      512)
        rangepips_changes.hoverable = /*hoverable*/
        ctx2[9];
      if (dirty[0] & /*disabled*/
      1024)
        rangepips_changes.disabled = /*disabled*/
        ctx2[10];
      if (dirty[0] & /*all*/
      8192)
        rangepips_changes.all = /*all*/
        ctx2[13];
      if (dirty[0] & /*first*/
      16384)
        rangepips_changes.first = /*first*/
        ctx2[14];
      if (dirty[0] & /*last*/
      32768)
        rangepips_changes.last = /*last*/
        ctx2[15];
      if (dirty[0] & /*rest*/
      65536)
        rangepips_changes.rest = /*rest*/
        ctx2[16];
      if (dirty[0] & /*pipstep*/
      4096)
        rangepips_changes.pipstep = /*pipstep*/
        ctx2[12];
      if (dirty[0] & /*prefix*/
      262144)
        rangepips_changes.prefix = /*prefix*/
        ctx2[18];
      if (dirty[0] & /*suffix*/
      524288)
        rangepips_changes.suffix = /*suffix*/
        ctx2[19];
      if (dirty[0] & /*formatter*/
      1048576)
        rangepips_changes.formatter = /*formatter*/
        ctx2[20];
      if (dirty[0] & /*focus*/
      33554432)
        rangepips_changes.focus = /*focus*/
        ctx2[25];
      if (dirty[0] & /*percentOf*/
      16777216)
        rangepips_changes.percentOf = /*percentOf*/
        ctx2[24];
      rangepips.$set(rangepips_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(rangepips.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(rangepips.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(rangepips, detaching);
    }
  };
}
function create_fragment$6(ctx) {
  let div;
  let t0;
  let t1;
  let current2;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*values*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  let if_block0 = (
    /*range*/
    ctx[2] && create_if_block_1$3(ctx)
  );
  let if_block1 = (
    /*pips*/
    ctx[11] && create_if_block$5(ctx)
  );
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { id: true, role: true, class: true });
      var div_nodes = children$1(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t0 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        div,
        "id",
        /*id*/
        ctx[17]
      );
      attr(div, "role", "none");
      attr(div, "class", "rangeSlider");
      toggle_class(
        div,
        "range",
        /*range*/
        ctx[2]
      );
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        div,
        "hoverable",
        /*hoverable*/
        ctx[9]
      );
      toggle_class(
        div,
        "vertical",
        /*vertical*/
        ctx[6]
      );
      toggle_class(
        div,
        "reversed",
        /*reversed*/
        ctx[8]
      );
      toggle_class(
        div,
        "focus",
        /*focus*/
        ctx[25]
      );
      toggle_class(
        div,
        "min",
        /*range*/
        ctx[2] === "min"
      );
      toggle_class(
        div,
        "max",
        /*range*/
        ctx[2] === "max"
      );
      toggle_class(
        div,
        "pips",
        /*pips*/
        ctx[11]
      );
      toggle_class(
        div,
        "pip-labels",
        /*all*/
        ctx[13] === "label" || /*first*/
        ctx[14] === "label" || /*last*/
        ctx[15] === "label" || /*rest*/
        ctx[16] === "label"
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      ctx[51](div);
      current2 = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "mousedown",
            /*bodyInteractStart*/
            ctx[40]
          ),
          listen(
            window,
            "touchstart",
            /*bodyInteractStart*/
            ctx[40]
          ),
          listen(
            window,
            "mousemove",
            /*bodyInteract*/
            ctx[41]
          ),
          listen(
            window,
            "touchmove",
            /*bodyInteract*/
            ctx[41]
          ),
          listen(
            window,
            "mouseup",
            /*bodyMouseUp*/
            ctx[42]
          ),
          listen(
            window,
            "touchend",
            /*bodyTouchEnd*/
            ctx[43]
          ),
          listen(
            window,
            "keydown",
            /*bodyKeyDown*/
            ctx[44]
          ),
          listen(
            div,
            "mousedown",
            /*sliderInteractStart*/
            ctx[38]
          ),
          listen(
            div,
            "mouseup",
            /*sliderInteractEnd*/
            ctx[39]
          ),
          listen(div, "touchstart", prevent_default(
            /*sliderInteractStart*/
            ctx[38]
          )),
          listen(div, "touchend", prevent_default(
            /*sliderInteractEnd*/
            ctx[39]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*orientationStart, $springPositions, activeHandle, ariaLabels, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/
      1869350109 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/
      112) {
        each_value = ensure_array_like(
          /*values*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*range*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$3(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*pips*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*pips*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current2 || dirty[0] & /*id*/
      131072) {
        attr(
          div,
          "id",
          /*id*/
          ctx2[17]
        );
      }
      if (!current2 || dirty[0] & /*range*/
      4) {
        toggle_class(
          div,
          "range",
          /*range*/
          ctx2[2]
        );
      }
      if (!current2 || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current2 || dirty[0] & /*hoverable*/
      512) {
        toggle_class(
          div,
          "hoverable",
          /*hoverable*/
          ctx2[9]
        );
      }
      if (!current2 || dirty[0] & /*vertical*/
      64) {
        toggle_class(
          div,
          "vertical",
          /*vertical*/
          ctx2[6]
        );
      }
      if (!current2 || dirty[0] & /*reversed*/
      256) {
        toggle_class(
          div,
          "reversed",
          /*reversed*/
          ctx2[8]
        );
      }
      if (!current2 || dirty[0] & /*focus*/
      33554432) {
        toggle_class(
          div,
          "focus",
          /*focus*/
          ctx2[25]
        );
      }
      if (!current2 || dirty[0] & /*range*/
      4) {
        toggle_class(
          div,
          "min",
          /*range*/
          ctx2[2] === "min"
        );
      }
      if (!current2 || dirty[0] & /*range*/
      4) {
        toggle_class(
          div,
          "max",
          /*range*/
          ctx2[2] === "max"
        );
      }
      if (!current2 || dirty[0] & /*pips*/
      2048) {
        toggle_class(
          div,
          "pips",
          /*pips*/
          ctx2[11]
        );
      }
      if (!current2 || dirty[0] & /*all, first, last, rest*/
      122880) {
        toggle_class(
          div,
          "pip-labels",
          /*all*/
          ctx2[13] === "label" || /*first*/
          ctx2[14] === "label" || /*last*/
          ctx2[15] === "label" || /*rest*/
          ctx2[16] === "label"
        );
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block1);
      current2 = true;
    },
    o(local) {
      transition_out(if_block1);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[51](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function index(el) {
  if (!el)
    return -1;
  var i = 0;
  while (el = el.previousElementSibling) {
    i++;
  }
  return i;
}
function normalisedClient(e) {
  if (e.type.includes("touch")) {
    return e.touches[0] || e.changedTouches[0];
  } else {
    return e;
  }
}
function pureText(possibleHtml) {
  return `${possibleHtml}`.replace(/<[^>]*>/g, "");
}
function instance$6($$self, $$props, $$invalidate) {
  let percentOf;
  let clampValue;
  let alignValueToStep;
  let orientationStart;
  let orientationEnd;
  let $springPositions, $$unsubscribe_springPositions = noop$4, $$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, ($$value) => $$invalidate(30, $springPositions = $$value)), springPositions);
  $$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
  let { slider = void 0 } = $$props;
  let { range: range2 = false } = $$props;
  let { pushy = false } = $$props;
  let { min = 0 } = $$props;
  let { max: max2 = 100 } = $$props;
  let { step = 1 } = $$props;
  let { values = [(max2 + min) / 2] } = $$props;
  let { vertical = false } = $$props;
  let { float = false } = $$props;
  let { reversed = false } = $$props;
  let { hoverable = true } = $$props;
  let { disabled = false } = $$props;
  let { pips = false } = $$props;
  let { pipstep = void 0 } = $$props;
  let { all: all2 = void 0 } = $$props;
  let { first = void 0 } = $$props;
  let { last = void 0 } = $$props;
  let { rest = void 0 } = $$props;
  let { id: id2 = void 0 } = $$props;
  let { prefix = "" } = $$props;
  let { suffix = "" } = $$props;
  let { formatter = (v, i, p) => v } = $$props;
  let { handleFormatter = formatter } = $$props;
  let { ariaLabels = [] } = $$props;
  let { precision = 2 } = $$props;
  let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;
  const dispatch2 = createEventDispatcher();
  let valueLength = 0;
  let focus2 = false;
  let handleActivated = false;
  let handlePressed = false;
  let keyboardActive = false;
  let activeHandle = values.length - 1;
  let startValue;
  let previousValue;
  let springPositions;
  const fixFloat = (v) => parseFloat((+v).toFixed(precision));
  function targetIsHandle(el) {
    const handles = slider.querySelectorAll(".handle");
    const isHandle = Array.prototype.includes.call(handles, el);
    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));
    return isHandle || isChild;
  }
  function trimRange(values2) {
    if (range2 === "min" || range2 === "max") {
      return values2.slice(0, 1);
    } else if (range2) {
      return values2.slice(0, 2);
    } else {
      return values2;
    }
  }
  function getSliderDimensions() {
    return slider.getBoundingClientRect();
  }
  function getClosestHandle(clientPos) {
    const dims = getSliderDimensions();
    let handlePos = 0;
    let handlePercent = 0;
    let handleVal = 0;
    if (vertical) {
      handlePos = clientPos.clientY - dims.top;
      handlePercent = handlePos / dims.height * 100;
      handlePercent = reversed ? handlePercent : 100 - handlePercent;
    } else {
      handlePos = clientPos.clientX - dims.left;
      handlePercent = handlePos / dims.width * 100;
      handlePercent = reversed ? 100 - handlePercent : handlePercent;
    }
    handleVal = (max2 - min) / 100 * handlePercent + min;
    let closest;
    if (range2 === true && values[0] === values[1]) {
      if (handleVal > values[1]) {
        return 1;
      } else {
        return 0;
      }
    } else {
      closest = values.indexOf(
        [...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
      );
    }
    return closest;
  }
  function handleInteract(clientPos) {
    const dims = getSliderDimensions();
    let handlePos = 0;
    let handlePercent = 0;
    let handleVal = 0;
    if (vertical) {
      handlePos = clientPos.clientY - dims.top;
      handlePercent = handlePos / dims.height * 100;
      handlePercent = reversed ? handlePercent : 100 - handlePercent;
    } else {
      handlePos = clientPos.clientX - dims.left;
      handlePercent = handlePos / dims.width * 100;
      handlePercent = reversed ? 100 - handlePercent : handlePercent;
    }
    handleVal = (max2 - min) / 100 * handlePercent + min;
    moveHandle(activeHandle, handleVal);
  }
  function moveHandle(index2, value) {
    value = alignValueToStep(value);
    if (typeof index2 === "undefined") {
      index2 = activeHandle;
    }
    if (range2) {
      if (index2 === 0 && value > values[1]) {
        if (pushy) {
          $$invalidate(0, values[1] = value, values);
        } else {
          value = values[1];
        }
      } else if (index2 === 1 && value < values[0]) {
        if (pushy) {
          $$invalidate(0, values[0] = value, values);
        } else {
          value = values[0];
        }
      }
    }
    if (values[index2] !== value) {
      $$invalidate(0, values[index2] = value, values);
    }
    if (previousValue !== value) {
      eChange();
      previousValue = value;
    }
    return value;
  }
  function rangeStart(values2) {
    if (range2 === "min") {
      return 0;
    } else {
      return values2[0];
    }
  }
  function rangeEnd(values2) {
    if (range2 === "max") {
      return 0;
    } else if (range2 === "min") {
      return 100 - values2[0];
    } else {
      return 100 - values2[1];
    }
  }
  function sliderBlurHandle(e) {
    if (keyboardActive) {
      $$invalidate(25, focus2 = false);
      handleActivated = false;
      $$invalidate(26, handlePressed = false);
    }
  }
  function sliderFocusHandle(e) {
    if (!disabled) {
      $$invalidate(27, activeHandle = index(e.target));
      $$invalidate(25, focus2 = true);
    }
  }
  function sliderKeydown(e) {
    if (!disabled) {
      const handle = index(e.target);
      let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
      let prevent = false;
      switch (e.key) {
        case "PageDown":
          jump *= 10;
        case "ArrowRight":
        case "ArrowUp":
          moveHandle(handle, values[handle] + jump);
          prevent = true;
          break;
        case "PageUp":
          jump *= 10;
        case "ArrowLeft":
        case "ArrowDown":
          moveHandle(handle, values[handle] - jump);
          prevent = true;
          break;
        case "Home":
          moveHandle(handle, min);
          prevent = true;
          break;
        case "End":
          moveHandle(handle, max2);
          prevent = true;
          break;
      }
      if (prevent) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }
  function sliderInteractStart(e) {
    if (!disabled) {
      const el = e.target;
      const clientPos = normalisedClient(e);
      $$invalidate(25, focus2 = true);
      handleActivated = true;
      $$invalidate(26, handlePressed = true);
      $$invalidate(27, activeHandle = getClosestHandle(clientPos));
      startValue = previousValue = alignValueToStep(values[activeHandle]);
      eStart();
      if (e.type === "touchstart" && !el.matches(".pipVal")) {
        handleInteract(clientPos);
      }
    }
  }
  function sliderInteractEnd(e) {
    if (e.type === "touchend") {
      eStop();
    }
    $$invalidate(26, handlePressed = false);
  }
  function bodyInteractStart(e) {
    keyboardActive = false;
    if (focus2 && e.target !== slider && !slider.contains(e.target)) {
      $$invalidate(25, focus2 = false);
    }
  }
  function bodyInteract(e) {
    if (!disabled) {
      if (handleActivated) {
        handleInteract(normalisedClient(e));
      }
    }
  }
  function bodyMouseUp(e) {
    if (!disabled) {
      const el = e.target;
      if (handleActivated) {
        if (el === slider || slider.contains(el)) {
          $$invalidate(25, focus2 = true);
          if (!targetIsHandle(el) && !el.matches(".pipVal")) {
            handleInteract(normalisedClient(e));
          }
        }
        eStop();
      }
    }
    handleActivated = false;
    $$invalidate(26, handlePressed = false);
  }
  function bodyTouchEnd(e) {
    handleActivated = false;
    $$invalidate(26, handlePressed = false);
  }
  function bodyKeyDown(e) {
    if (!disabled) {
      if (e.target === slider || slider.contains(e.target)) {
        keyboardActive = true;
      }
    }
  }
  function eStart() {
    !disabled && dispatch2("start", {
      activeHandle,
      value: startValue,
      values: values.map((v) => alignValueToStep(v))
    });
  }
  function eStop() {
    !disabled && dispatch2("stop", {
      activeHandle,
      startValue,
      value: values[activeHandle],
      values: values.map((v) => alignValueToStep(v))
    });
  }
  function eChange() {
    !disabled && dispatch2("change", {
      activeHandle,
      startValue,
      previousValue: typeof previousValue === "undefined" ? startValue : previousValue,
      value: values[activeHandle],
      values: values.map((v) => alignValueToStep(v))
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      slider = $$value;
      $$invalidate(1, slider);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("slider" in $$props2)
      $$invalidate(1, slider = $$props2.slider);
    if ("range" in $$props2)
      $$invalidate(2, range2 = $$props2.range);
    if ("pushy" in $$props2)
      $$invalidate(45, pushy = $$props2.pushy);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max2 = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("vertical" in $$props2)
      $$invalidate(6, vertical = $$props2.vertical);
    if ("float" in $$props2)
      $$invalidate(7, float = $$props2.float);
    if ("reversed" in $$props2)
      $$invalidate(8, reversed = $$props2.reversed);
    if ("hoverable" in $$props2)
      $$invalidate(9, hoverable = $$props2.hoverable);
    if ("disabled" in $$props2)
      $$invalidate(10, disabled = $$props2.disabled);
    if ("pips" in $$props2)
      $$invalidate(11, pips = $$props2.pips);
    if ("pipstep" in $$props2)
      $$invalidate(12, pipstep = $$props2.pipstep);
    if ("all" in $$props2)
      $$invalidate(13, all2 = $$props2.all);
    if ("first" in $$props2)
      $$invalidate(14, first = $$props2.first);
    if ("last" in $$props2)
      $$invalidate(15, last = $$props2.last);
    if ("rest" in $$props2)
      $$invalidate(16, rest = $$props2.rest);
    if ("id" in $$props2)
      $$invalidate(17, id2 = $$props2.id);
    if ("prefix" in $$props2)
      $$invalidate(18, prefix = $$props2.prefix);
    if ("suffix" in $$props2)
      $$invalidate(19, suffix = $$props2.suffix);
    if ("formatter" in $$props2)
      $$invalidate(20, formatter = $$props2.formatter);
    if ("handleFormatter" in $$props2)
      $$invalidate(21, handleFormatter = $$props2.handleFormatter);
    if ("ariaLabels" in $$props2)
      $$invalidate(22, ariaLabels = $$props2.ariaLabels);
    if ("precision" in $$props2)
      $$invalidate(46, precision = $$props2.precision);
    if ("springValues" in $$props2)
      $$invalidate(47, springValues = $$props2.springValues);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*min, max*/
    24) {
      $$invalidate(50, clampValue = function(val) {
        return val <= min ? min : val >= max2 ? max2 : val;
      });
    }
    if ($$self.$$.dirty[0] & /*min, max, step*/
    56 | $$self.$$.dirty[1] & /*clampValue*/
    524288) {
      $$invalidate(49, alignValueToStep = function(val) {
        if (val <= min) {
          return fixFloat(min);
        } else if (val >= max2) {
          return fixFloat(max2);
        } else {
          val = fixFloat(val);
        }
        let remainder = (val - min) % step;
        let aligned = val - remainder;
        if (Math.abs(remainder) * 2 >= step) {
          aligned += remainder > 0 ? step : -step;
        }
        aligned = clampValue(aligned);
        return fixFloat(aligned);
      });
    }
    if ($$self.$$.dirty[0] & /*min, max*/
    24) {
      $$invalidate(24, percentOf = function(val) {
        let perc = (val - min) / (max2 - min) * 100;
        if (isNaN(perc) || perc <= 0) {
          return 0;
        } else if (perc >= 100) {
          return 100;
        } else {
          return fixFloat(perc);
        }
      });
    }
    if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions, ariaLabels*/
    29360153 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/
    458752) {
      {
        if (!Array.isArray(values)) {
          $$invalidate(0, values = [(max2 + min) / 2]);
          console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
        }
        const trimmedAlignedValues = trimRange(values.map((v) => alignValueToStep(v)));
        if (!(values.length === trimmedAlignedValues.length) || !values.every((element2, index2) => fixFloat(element2) === trimmedAlignedValues[index2])) {
          $$invalidate(0, values = trimmedAlignedValues);
        }
        if (valueLength !== values.length) {
          $$subscribe_springPositions($$invalidate(23, springPositions = spring(values.map((v) => percentOf(v)), springValues)));
        } else {
          springPositions.set(values.map((v) => percentOf(v)));
        }
        $$invalidate(48, valueLength = values.length);
        if (values.length > 1 && !Array.isArray(ariaLabels)) {
          console.warn(`'ariaLabels' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)`);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*vertical, reversed*/
    320) {
      $$invalidate(29, orientationStart = vertical ? reversed ? "top" : "bottom" : reversed ? "right" : "left");
    }
    if ($$self.$$.dirty[0] & /*vertical, reversed*/
    320) {
      $$invalidate(28, orientationEnd = vertical ? reversed ? "bottom" : "top" : reversed ? "left" : "right");
    }
  };
  return [
    values,
    slider,
    range2,
    min,
    max2,
    step,
    vertical,
    float,
    reversed,
    hoverable,
    disabled,
    pips,
    pipstep,
    all2,
    first,
    last,
    rest,
    id2,
    prefix,
    suffix,
    formatter,
    handleFormatter,
    ariaLabels,
    springPositions,
    percentOf,
    focus2,
    handlePressed,
    activeHandle,
    orientationEnd,
    orientationStart,
    $springPositions,
    fixFloat,
    moveHandle,
    rangeStart,
    rangeEnd,
    sliderBlurHandle,
    sliderFocusHandle,
    sliderKeydown,
    sliderInteractStart,
    sliderInteractEnd,
    bodyInteractStart,
    bodyInteract,
    bodyMouseUp,
    bodyTouchEnd,
    bodyKeyDown,
    pushy,
    precision,
    springValues,
    valueLength,
    alignValueToStep,
    clampValue,
    div_binding
  ];
}
class RangeSlider extends SvelteComponent {
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$6,
      create_fragment$6,
      safe_not_equal,
      {
        slider: 1,
        range: 2,
        pushy: 45,
        min: 3,
        max: 4,
        step: 5,
        values: 0,
        vertical: 6,
        float: 7,
        reversed: 8,
        hoverable: 9,
        disabled: 10,
        pips: 11,
        pipstep: 12,
        all: 13,
        first: 14,
        last: 15,
        rest: 16,
        id: 17,
        prefix: 18,
        suffix: 19,
        formatter: 20,
        handleFormatter: 21,
        ariaLabels: 22,
        precision: 46,
        springValues: 47
      },
      null,
      [-1, -1, -1]
    );
  }
}
function create_if_block$4(ctx) {
  let div;
  let span0;
  let t0_value = ("00" + /*browseDate*/
  ctx[0].getHours()).slice(-2) + "";
  let t0;
  let t1;
  let span1;
  let t2_value = ("00" + /*browseDate*/
  ctx[0].getMinutes()).slice(-2) + "";
  let t2;
  let t3;
  let mounted;
  let dispose;
  let if_block = (
    /*timePrecision*/
    ctx[1] !== "minute" && create_if_block_1$2(ctx)
  );
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = text(":\n		");
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children$1(div);
      span0 = claim_element(div_nodes, "SPAN", {
        role: true,
        "aria-label": true,
        tabindex: true,
        contenteditable: true,
        inputmode: true,
        class: true
      });
      var span0_nodes = children$1(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach);
      t1 = claim_text(div_nodes, ":\n		");
      span1 = claim_element(div_nodes, "SPAN", {
        role: true,
        "aria-label": true,
        tabindex: true,
        contenteditable: true,
        inputmode: true,
        class: true
      });
      var span1_nodes = children$1(span1);
      t2 = claim_text(span1_nodes, t2_value);
      span1_nodes.forEach(detach);
      t3 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "role", "spinbutton");
      attr(span0, "aria-label", "Hours");
      attr(span0, "tabindex", "0");
      attr(span0, "contenteditable", "");
      attr(span0, "inputmode", "numeric");
      attr(span0, "class", "svelte-132npca");
      attr(span1, "role", "spinbutton");
      attr(span1, "aria-label", "Minutes");
      attr(span1, "tabindex", "0");
      attr(span1, "contenteditable", "");
      attr(span1, "inputmode", "numeric");
      attr(span1, "class", "svelte-132npca");
      attr(div, "class", "time-picker svelte-132npca");
      attr(div, "role", "none");
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      append_hydration(div, span0);
      append_hydration(span0, t0);
      ctx[6](span0);
      append_hydration(div, t1);
      append_hydration(div, span1);
      append_hydration(span1, t2);
      ctx[7](span1);
      append_hydration(div, t3);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(
            span0,
            "keydown",
            /*keydown*/
            ctx[3]
          ),
          listen(
            span0,
            "input",
            /*input*/
            ctx[4]
          ),
          listen(span0, "focus", focus),
          listen(
            span1,
            "keydown",
            /*keydown*/
            ctx[3]
          ),
          listen(
            span1,
            "input",
            /*input*/
            ctx[4]
          ),
          listen(span1, "focus", focus),
          listen(
            div,
            "mousedown",
            /*mousedown_handler*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*browseDate*/
      1 && t0_value !== (t0_value = ("00" + /*browseDate*/
      ctx2[0].getHours()).slice(-2) + ""))
        set_data_contenteditable(t0, t0_value);
      if (dirty & /*browseDate*/
      1 && t2_value !== (t2_value = ("00" + /*browseDate*/
      ctx2[0].getMinutes()).slice(-2) + ""))
        set_data_contenteditable(t2, t2_value);
      if (
        /*timePrecision*/
        ctx2[1] !== "minute"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[6](null);
      ctx[7](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$2(ctx) {
  let t0;
  let span;
  let t1_value = ("00" + /*browseDate*/
  ctx[0].getSeconds()).slice(-2) + "";
  let t1;
  let t2;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*timePrecision*/
    ctx[1] !== "second" && create_if_block_2$2(ctx)
  );
  return {
    c() {
      t0 = text(":");
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty$1();
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, ":");
      span = claim_element(nodes, "SPAN", {
        role: true,
        "aria-label": true,
        tabindex: true,
        contenteditable: true,
        inputmode: true,
        class: true
      });
      var span_nodes = children$1(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty$1();
      this.h();
    },
    h() {
      attr(span, "role", "spinbutton");
      attr(span, "aria-label", "Seconds");
      attr(span, "tabindex", "0");
      attr(span, "contenteditable", "");
      attr(span, "inputmode", "numeric");
      attr(span, "class", "svelte-132npca");
    },
    m(target2, anchor) {
      insert_hydration(target2, t0, anchor);
      insert_hydration(target2, span, anchor);
      append_hydration(span, t1);
      ctx[8](span);
      insert_hydration(target2, t2, anchor);
      if (if_block)
        if_block.m(target2, anchor);
      insert_hydration(target2, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(
            span,
            "keydown",
            /*keydown*/
            ctx[3]
          ),
          listen(
            span,
            "input",
            /*input*/
            ctx[4]
          ),
          listen(span, "focus", focus)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*browseDate*/
      1 && t1_value !== (t1_value = ("00" + /*browseDate*/
      ctx2[0].getSeconds()).slice(-2) + ""))
        set_data_contenteditable(t1, t1_value);
      if (
        /*timePrecision*/
        ctx2[1] !== "second"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
        detach(t2);
        detach(if_block_anchor);
      }
      ctx[8](null);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$2(ctx) {
  let t0;
  let span;
  let t1_value = ("000" + /*browseDate*/
  ctx[0].getMilliseconds()).slice(-3) + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      t0 = text(".");
      span = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l(nodes) {
      t0 = claim_text(nodes, ".");
      span = claim_element(nodes, "SPAN", {
        role: true,
        "aria-label": true,
        tabindex: true,
        contenteditable: true,
        inputmode: true,
        class: true
      });
      var span_nodes = children$1(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "role", "spinbutton");
      attr(span, "aria-label", "Milliseconds");
      attr(span, "tabindex", "0");
      attr(span, "contenteditable", "");
      attr(span, "inputmode", "numeric");
      attr(span, "class", "svelte-132npca");
    },
    m(target2, anchor) {
      insert_hydration(target2, t0, anchor);
      insert_hydration(target2, span, anchor);
      append_hydration(span, t1);
      ctx[9](span);
      if (!mounted) {
        dispose = [
          listen(
            span,
            "keydown",
            /*keydown*/
            ctx[3]
          ),
          listen(
            span,
            "input",
            /*input*/
            ctx[4]
          ),
          listen(span, "focus", focus)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*browseDate*/
      1 && t1_value !== (t1_value = ("000" + /*browseDate*/
      ctx2[0].getMilliseconds()).slice(-3) + ""))
        set_data_contenteditable(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5(ctx) {
  let if_block_anchor;
  let if_block = (
    /*timePrecision*/
    ctx[1] && create_if_block$4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$1();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty$1();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert_hydration(target2, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*timePrecision*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$4,
    o: noop$4,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function select$1(node) {
  const selection2 = window.getSelection();
  const range2 = document.createRange();
  range2.selectNodeContents(node);
  selection2 == null ? void 0 : selection2.removeAllRanges();
  selection2 == null ? void 0 : selection2.addRange(range2);
}
function clamp$1(value, max2, loop_around) {
  if (loop_around && value < 0) {
    return max2;
  } else if (loop_around && value > max2) {
    return 0;
  } else {
    return Math.max(0, Math.min(max2, value));
  }
}
function get_field(element2) {
  const label = element2.getAttribute("aria-label");
  if (label === "Hours") {
    return { label, len: 2, max: 23 };
  } else if (label === "Minutes") {
    return { label, len: 2, max: 59 };
  } else if (label === "Seconds") {
    return { label, len: 2, max: 59 };
  } else if (label === "Milliseconds") {
    return { label, len: 3, max: 999 };
  } else {
    throw new Error("Invalid label " + label);
  }
}
function parse$1(text2, length) {
  return parseInt(text2.replace(/[^\d]/g, "").slice(-length));
}
function focus(e) {
  select$1(e.currentTarget);
}
function instance$5($$self, $$props, $$invalidate) {
  let { browseDate } = $$props;
  let { timePrecision } = $$props;
  let { setTime } = $$props;
  let fields = [];
  function keydown(e) {
    if (e.key === "ArrowUp" || e.key === "ArrowDown") {
      const value = get_value(e.currentTarget);
      const delta = e.key === "ArrowUp" ? 1 : -1;
      set_value(e.currentTarget, value + delta, true);
      e.preventDefault();
      select$1(e.currentTarget);
    } else if (e.key === "ArrowLeft" || e.key === "ArrowRight" || ":;-,.".includes(e.key)) {
      const field_index = fields.indexOf(e.currentTarget);
      const delta = e.key === "ArrowLeft" ? -1 : 1;
      const el = fields[field_index + delta];
      e.preventDefault();
      if (el) {
        el.focus();
        select$1(el);
      }
    }
  }
  function get_value(node) {
    const label = get_field(node).label;
    if (label === "Hours") {
      return browseDate.getHours();
    } else if (label === "Minutes") {
      return browseDate.getMinutes();
    } else if (label === "Seconds") {
      return browseDate.getSeconds();
    } else {
      return browseDate.getMilliseconds();
    }
  }
  function setText(d) {
    const hours = ("00" + d.getHours()).slice(-2);
    const minutes = ("00" + d.getMinutes()).slice(-2);
    const seconds = ("00" + d.getSeconds()).slice(-2);
    const milliseconds = ("000" + d.getMilliseconds()).slice(-3);
    if (fields[0] && fields[0].innerText !== hours) {
      $$invalidate(2, fields[0].innerText = hours, fields);
    }
    if (fields[1] && fields[1].innerText !== minutes) {
      $$invalidate(2, fields[1].innerText = minutes, fields);
    }
    if (fields[2] && fields[2].innerText !== seconds) {
      $$invalidate(2, fields[2].innerText = seconds, fields);
    }
    if (fields[3] && fields[3].innerText !== milliseconds) {
      $$invalidate(2, fields[3].innerText = milliseconds, fields);
    }
  }
  function set_value(node, value, loop_around = false) {
    const field = get_field(node);
    value = clamp$1(value, field.max, loop_around);
    if (field.label === "Hours") {
      browseDate.setHours(value);
    } else if (field.label === "Minutes") {
      browseDate.setMinutes(value);
    } else if (field.label === "Seconds") {
      browseDate.setSeconds(value);
    } else if (field.label === "Milliseconds") {
      browseDate.setMilliseconds(value);
    }
    $$invalidate(0, browseDate = setTime(browseDate));
    setText(browseDate);
  }
  function input(e_unknown) {
    const e = e_unknown;
    const field = get_field(e.currentTarget);
    let new_value;
    if (e.inputType === "insertText") {
      const original_text = "000" + get_value(e.currentTarget);
      new_value = parse$1(original_text + e.currentTarget.innerText, field.len);
      if (new_value > field.max && e.data) {
        new_value = parse$1(e.data, field.len);
      }
    } else {
      new_value = parse$1("000" + e.currentTarget.innerText, field.len);
    }
    set_value(e.currentTarget, new_value);
    select$1(e.currentTarget);
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fields[0] = $$value;
      $$invalidate(2, fields);
    });
  }
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fields[1] = $$value;
      $$invalidate(2, fields);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fields[2] = $$value;
      $$invalidate(2, fields);
    });
  }
  function span_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fields[3] = $$value;
      $$invalidate(2, fields);
    });
  }
  const mousedown_handler = (e) => {
    if (e.target instanceof HTMLElement && e.target.tagName === "SPAN") {
      e.target.focus();
      e.preventDefault();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("browseDate" in $$props2)
      $$invalidate(0, browseDate = $$props2.browseDate);
    if ("timePrecision" in $$props2)
      $$invalidate(1, timePrecision = $$props2.timePrecision);
    if ("setTime" in $$props2)
      $$invalidate(5, setTime = $$props2.setTime);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*browseDate*/
    1) {
      setText(browseDate);
    }
  };
  return [
    browseDate,
    timePrecision,
    fields,
    keydown,
    input,
    setTime,
    span0_binding,
    span1_binding,
    span_binding,
    span_binding_1,
    mousedown_handler
  ];
}
class TimePicker extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$5, create_fragment$5, safe_not_equal, {
      browseDate: 0,
      timePrecision: 1,
      setTime: 5
    });
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function getMonthLength(year, month) {
  const feb = isLeapYear(year) ? 29 : 28;
  const monthLengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return monthLengths[month];
}
function toText(date2, formatTokens) {
  let text2 = "";
  if (date2) {
    for (const token2 of formatTokens) {
      if (typeof token2 === "string") {
        text2 += token2;
      } else {
        text2 += token2.toString(date2);
      }
    }
  }
  return text2;
}
function getMonthDays(year, month) {
  const monthLength = getMonthLength(year, month);
  const days = [];
  for (let i = 0; i < monthLength; i++) {
    days.push({
      year,
      month,
      number: i + 1
    });
  }
  return days;
}
function getCalendarDays(value, weekStartsOn) {
  const year = value.getFullYear();
  const month = value.getMonth();
  const firstWeekday = new Date(year, month, 1).getDay();
  let days = [];
  const daysBefore = (firstWeekday - weekStartsOn + 7) % 7;
  if (daysBefore > 0) {
    let lastMonth = month - 1;
    let lastMonthYear = year;
    if (lastMonth === -1) {
      lastMonth = 11;
      lastMonthYear = year - 1;
    }
    days = getMonthDays(lastMonthYear, lastMonth).slice(-daysBefore);
  }
  days = days.concat(getMonthDays(year, month));
  let nextMonth = month + 1;
  let nextMonthYear = year;
  if (nextMonth === 12) {
    nextMonth = 0;
    nextMonthYear = year + 1;
  }
  const daysAfter = 42 - days.length;
  days = days.concat(getMonthDays(nextMonthYear, nextMonth).slice(0, daysAfter));
  return days;
}
function getLocaleDefaults() {
  return {
    weekdays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    weekStartsOn: 1
  };
}
function getInnerLocale(locale2 = {}) {
  const innerLocale = getLocaleDefaults();
  if (typeof locale2.weekStartsOn === "number") {
    innerLocale.weekStartsOn = locale2.weekStartsOn;
  }
  if (locale2.months)
    innerLocale.months = locale2.months;
  if (locale2.weekdays)
    innerLocale.weekdays = locale2.weekdays;
  return innerLocale;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[38] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function get_each_context_6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i];
  child_ctx[43] = i;
  return child_ctx;
}
function create_each_block_6(ctx) {
  let option;
  let t_value = (
    /*monthName*/
    ctx[49] + ""
  );
  let t;
  let option_disabled_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children$1(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach);
      this.h();
    },
    h() {
      option.disabled = option_disabled_value = new Date(
        /*browseYear*/
        ctx[9],
        /*i*/
        ctx[43],
        getMonthLength(
          /*browseYear*/
          ctx[9],
          /*i*/
          ctx[43]
        ),
        23,
        59,
        59,
        999
      ) < /*min*/
      ctx[2] || new Date(
        /*browseYear*/
        ctx[9],
        /*i*/
        ctx[43]
      ) > /*max*/
      ctx[3];
      option.__value = /*i*/
      ctx[43];
      set_input_value(option, option.__value);
    },
    m(target2, anchor) {
      insert_hydration(target2, option, anchor);
      append_hydration(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      32 && t_value !== (t_value = /*monthName*/
      ctx2[49] + ""))
        set_data(t, t_value);
      if (dirty[0] & /*browseYear, min, max, years*/
      588 && option_disabled_value !== (option_disabled_value = new Date(
        /*browseYear*/
        ctx2[9],
        /*i*/
        ctx2[43],
        getMonthLength(
          /*browseYear*/
          ctx2[9],
          /*i*/
          ctx2[43]
        ),
        23,
        59,
        59,
        999
      ) < /*min*/
      ctx2[2] || new Date(
        /*browseYear*/
        ctx2[9],
        /*i*/
        ctx2[43]
      ) > /*max*/
      ctx2[3])) {
        option.disabled = option_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_5(ctx) {
  let option;
  let t_value = (
    /*monthName*/
    ctx[49] + ""
  );
  let t;
  let option_selected_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children$1(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach);
      this.h();
    },
    h() {
      option.__value = /*i*/
      ctx[43];
      set_input_value(option, option.__value);
      option.selected = option_selected_value = /*i*/
      ctx[43] === /*browseMonth*/
      ctx[8];
    },
    m(target2, anchor) {
      insert_hydration(target2, option, anchor);
      append_hydration(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      32 && t_value !== (t_value = /*monthName*/
      ctx2[49] + ""))
        set_data(t, t_value);
      if (dirty[0] & /*browseMonth*/
      256 && option_selected_value !== (option_selected_value = /*i*/
      ctx2[43] === /*browseMonth*/
      ctx2[8])) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_4(ctx) {
  let option;
  let t_value = (
    /*v*/
    ctx[44] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children$1(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach);
      this.h();
    },
    h() {
      option.__value = option_value_value = /*v*/
      ctx[44];
      set_input_value(option, option.__value);
    },
    m(target2, anchor) {
      insert_hydration(target2, option, anchor);
      append_hydration(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*years*/
      64 && t_value !== (t_value = /*v*/
      ctx2[44] + ""))
        set_data(t, t_value);
      if (dirty[0] & /*years*/
      64 && option_value_value !== (option_value_value = /*v*/
      ctx2[44])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_3(ctx) {
  let option;
  let t_value = (
    /*v*/
    ctx[44] + ""
  );
  let t;
  let option_value_value;
  let option_selected_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children$1(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach);
      this.h();
    },
    h() {
      option.__value = option_value_value = /*v*/
      ctx[44];
      set_input_value(option, option.__value);
      option.selected = option_selected_value = /*v*/
      ctx[44] === /*browseDate*/
      ctx[4].getFullYear();
    },
    m(target2, anchor) {
      insert_hydration(target2, option, anchor);
      append_hydration(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*years*/
      64 && t_value !== (t_value = /*v*/
      ctx2[44] + ""))
        set_data(t, t_value);
      if (dirty[0] & /*years*/
      64 && option_value_value !== (option_value_value = /*v*/
      ctx2[44])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
      if (dirty[0] & /*years, browseDate*/
      80 && option_selected_value !== (option_selected_value = /*v*/
      ctx2[44] === /*browseDate*/
      ctx2[4].getFullYear())) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_else_block$1(ctx) {
  let div;
  let t_value = (
    /*iLocale*/
    ctx[5].weekdays[
      /*iLocale*/
      ctx[5].weekStartsOn + /*i*/
      ctx[43] - 7
    ] + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "header-cell svelte-go79cf");
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      append_hydration(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      32 && t_value !== (t_value = /*iLocale*/
      ctx2[5].weekdays[
        /*iLocale*/
        ctx2[5].weekStartsOn + /*i*/
        ctx2[43] - 7
      ] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block$3(ctx) {
  let div;
  let t_value = (
    /*iLocale*/
    ctx[5].weekdays[
      /*iLocale*/
      ctx[5].weekStartsOn + /*i*/
      ctx[43]
    ] + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "header-cell svelte-go79cf");
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      append_hydration(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      32 && t_value !== (t_value = /*iLocale*/
      ctx2[5].weekdays[
        /*iLocale*/
        ctx2[5].weekStartsOn + /*i*/
        ctx2[43]
      ] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[43] + /*iLocale*/
      ctx2[5].weekStartsOn < 7
    )
      return create_if_block$3;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty$1();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty$1();
    },
    m(target2, anchor) {
      if_block.m(target2, anchor);
      insert_hydration(target2, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let span;
  let t_value = (
    /*calendarDay*/
    ctx[39].number + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[27](
        /*calendarDay*/
        ctx[39]
      )
    );
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "svelte-go79cf");
      attr(div, "class", "cell svelte-go79cf");
      toggle_class(div, "disabled", !dayIsInRange(
        /*calendarDay*/
        ctx[39],
        /*min*/
        ctx[2],
        /*max*/
        ctx[3]
      ));
      toggle_class(
        div,
        "selected",
        /*value*/
        ctx[0] && /*calendarDay*/
        ctx[39].year === /*value*/
        ctx[0].getFullYear() && /*calendarDay*/
        ctx[39].month === /*value*/
        ctx[0].getMonth() && /*calendarDay*/
        ctx[39].number === /*value*/
        ctx[0].getDate()
      );
      toggle_class(
        div,
        "today",
        /*calendarDay*/
        ctx[39].year === /*todayDate*/
        ctx[11].getFullYear() && /*calendarDay*/
        ctx[39].month === /*todayDate*/
        ctx[11].getMonth() && /*calendarDay*/
        ctx[39].number === /*todayDate*/
        ctx[11].getDate()
      );
      toggle_class(
        div,
        "other-month",
        /*calendarDay*/
        ctx[39].month !== /*browseMonth*/
        ctx[8]
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      append_hydration(div, span);
      append_hydration(span, t);
      if (!mounted) {
        dispose = listen(div, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*calendarDays*/
      128 && t_value !== (t_value = /*calendarDay*/
      ctx[39].number + ""))
        set_data(t, t_value);
      if (dirty[0] & /*calendarDays, min, max*/
      140) {
        toggle_class(div, "disabled", !dayIsInRange(
          /*calendarDay*/
          ctx[39],
          /*min*/
          ctx[2],
          /*max*/
          ctx[3]
        ));
      }
      if (dirty[0] & /*value, calendarDays*/
      129) {
        toggle_class(
          div,
          "selected",
          /*value*/
          ctx[0] && /*calendarDay*/
          ctx[39].year === /*value*/
          ctx[0].getFullYear() && /*calendarDay*/
          ctx[39].month === /*value*/
          ctx[0].getMonth() && /*calendarDay*/
          ctx[39].number === /*value*/
          ctx[0].getDate()
        );
      }
      if (dirty[0] & /*calendarDays, todayDate*/
      2176) {
        toggle_class(
          div,
          "today",
          /*calendarDay*/
          ctx[39].year === /*todayDate*/
          ctx[11].getFullYear() && /*calendarDay*/
          ctx[39].month === /*todayDate*/
          ctx[11].getMonth() && /*calendarDay*/
          ctx[39].number === /*todayDate*/
          ctx[11].getDate()
        );
      }
      if (dirty[0] & /*calendarDays, browseMonth*/
      384) {
        toggle_class(
          div,
          "other-month",
          /*calendarDay*/
          ctx[39].month !== /*browseMonth*/
          ctx[8]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let div;
  let each_value_1 = ensure_array_like(
    /*calendarDays*/
    ctx[7].slice(
      /*weekIndex*/
      ctx[38] * 7,
      /*weekIndex*/
      ctx[38] * 7 + 7
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "week svelte-go79cf");
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*calendarDays, min, max, value, todayDate, browseMonth, selectDay*/
      18829) {
        each_value_1 = ensure_array_like(
          /*calendarDays*/
          ctx2[7].slice(
            /*weekIndex*/
            ctx2[38] * 7,
            /*weekIndex*/
            ctx2[38] * 7 + 7
          )
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let div5;
  let div4;
  let div2;
  let button0;
  let textContent = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="svelte-go79cf"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z" transform="rotate(180, 12, 12)"></path></svg>`;
  let t0;
  let div0;
  let select0;
  let t1;
  let select1;
  let t2;
  let svg1;
  let path1;
  let t3;
  let div1;
  let select2;
  let t4;
  let select3;
  let t5;
  let svg2;
  let path2;
  let t6;
  let button1;
  let textContent_1 = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="svelte-go79cf"><path d="M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z"></path></svg>`;
  let t7;
  let div3;
  let t8;
  let t9;
  let timepicker;
  let updating_browseDate;
  let t10;
  let current2;
  let mounted;
  let dispose;
  let each_value_6 = ensure_array_like(
    /*iLocale*/
    ctx[5].months
  );
  let each_blocks_5 = [];
  for (let i = 0; i < each_value_6.length; i += 1) {
    each_blocks_5[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
  }
  let each_value_5 = ensure_array_like(
    /*iLocale*/
    ctx[5].months
  );
  let each_blocks_4 = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks_4[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  let each_value_4 = ensure_array_like(
    /*years*/
    ctx[6]
  );
  let each_blocks_3 = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks_3[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  let each_value_3 = ensure_array_like(
    /*years*/
    ctx[6]
  );
  let each_blocks_2 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_2[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = ensure_array_like(Array(7));
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = ensure_array_like(Array(6));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  function timepicker_browseDate_binding(value) {
    ctx[28](value);
  }
  let timepicker_props = {
    timePrecision: (
      /*timePrecision*/
      ctx[1]
    ),
    setTime: (
      /*setTime*/
      ctx[10]
    )
  };
  if (
    /*browseDate*/
    ctx[4] !== void 0
  ) {
    timepicker_props.browseDate = /*browseDate*/
    ctx[4];
  }
  timepicker = new TimePicker({ props: timepicker_props });
  binding_callbacks.push(() => bind$3(timepicker, "browseDate", timepicker_browseDate_binding));
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      button0 = element("button");
      button0.innerHTML = textContent;
      t0 = space();
      div0 = element("div");
      select0 = element("select");
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].c();
      }
      t1 = space();
      select1 = element("select");
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].c();
      }
      t2 = space();
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t3 = space();
      div1 = element("div");
      select2 = element("select");
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].c();
      }
      t4 = space();
      select3 = element("select");
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      t5 = space();
      svg2 = svg_element("svg");
      path2 = svg_element("path");
      t6 = space();
      button1 = element("button");
      button1.innerHTML = textContent_1;
      t7 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t8 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t9 = space();
      create_component(timepicker.$$.fragment);
      t10 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true, tabindex: true });
      var div5_nodes = children$1(div5);
      div4 = claim_element(div5_nodes, "DIV", { class: true, tabindex: true });
      var div4_nodes = children$1(div4);
      div2 = claim_element(div4_nodes, "DIV", { class: true });
      var div2_nodes = children$1(div2);
      button0 = claim_element(div2_nodes, "BUTTON", {
        type: true,
        class: true,
        tabindex: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-t4cock")
        button0.innerHTML = textContent;
      t0 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children$1(div0);
      select0 = claim_element(div0_nodes, "SELECT", { class: true });
      var select0_nodes = children$1(select0);
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].l(select0_nodes);
      }
      select0_nodes.forEach(detach);
      t1 = claim_space(div0_nodes);
      select1 = claim_element(div0_nodes, "SELECT", { class: true, tabindex: true });
      var select1_nodes = children$1(select1);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].l(select1_nodes);
      }
      select1_nodes.forEach(detach);
      t2 = claim_space(div0_nodes);
      svg1 = claim_svg_element(div0_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg1_nodes = children$1(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", { d: true, transform: true });
      children$1(path1).forEach(detach);
      svg1_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children$1(div1);
      select2 = claim_element(div1_nodes, "SELECT", { class: true });
      var select2_nodes = children$1(select2);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].l(select2_nodes);
      }
      select2_nodes.forEach(detach);
      t4 = claim_space(div1_nodes);
      select3 = claim_element(div1_nodes, "SELECT", { class: true, tabindex: true });
      var select3_nodes = children$1(select3);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].l(select3_nodes);
      }
      select3_nodes.forEach(detach);
      t5 = claim_space(div1_nodes);
      svg2 = claim_svg_element(div1_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg2_nodes = children$1(svg2);
      path2 = claim_svg_element(svg2_nodes, "path", { d: true, transform: true });
      children$1(path2).forEach(detach);
      svg2_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t6 = claim_space(div2_nodes);
      button1 = claim_element(div2_nodes, "BUTTON", {
        type: true,
        class: true,
        tabindex: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1a006lp")
        button1.innerHTML = textContent_1;
      div2_nodes.forEach(detach);
      t7 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children$1(div3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div3_nodes);
      }
      div3_nodes.forEach(detach);
      t8 = claim_space(div4_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div4_nodes);
      }
      t9 = claim_space(div4_nodes);
      claim_component(timepicker.$$.fragment, div4_nodes);
      t10 = claim_space(div4_nodes);
      if (default_slot)
        default_slot.l(div4_nodes);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button0, "type", "button");
      attr(button0, "class", "page-button svelte-go79cf");
      attr(button0, "tabindex", "-1");
      attr(select0, "class", "svelte-go79cf");
      attr(select1, "class", "dummy-select svelte-go79cf");
      attr(select1, "tabindex", "-1");
      attr(path1, "d", "M6 0l12 12-12 12z");
      attr(path1, "transform", "rotate(90, 12, 12)");
      attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg1, "width", "24");
      attr(svg1, "height", "24");
      attr(svg1, "viewBox", "0 0 24 24");
      attr(svg1, "class", "svelte-go79cf");
      attr(div0, "class", "dropdown month svelte-go79cf");
      attr(select2, "class", "svelte-go79cf");
      attr(select3, "class", "dummy-select svelte-go79cf");
      attr(select3, "tabindex", "-1");
      attr(path2, "d", "M6 0l12 12-12 12z");
      attr(path2, "transform", "rotate(90, 12, 12)");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "width", "24");
      attr(svg2, "height", "24");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(svg2, "class", "svelte-go79cf");
      attr(div1, "class", "dropdown year svelte-go79cf");
      attr(button1, "type", "button");
      attr(button1, "class", "page-button svelte-go79cf");
      attr(button1, "tabindex", "-1");
      attr(div2, "class", "top svelte-go79cf");
      attr(div3, "class", "header svelte-go79cf");
      attr(div4, "class", "tab-container svelte-go79cf");
      attr(div4, "tabindex", "-1");
      attr(div5, "class", "date-time-picker svelte-go79cf");
      attr(div5, "tabindex", "0");
    },
    m(target2, anchor) {
      insert_hydration(target2, div5, anchor);
      append_hydration(div5, div4);
      append_hydration(div4, div2);
      append_hydration(div2, button0);
      append_hydration(div2, t0);
      append_hydration(div2, div0);
      append_hydration(div0, select0);
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        if (each_blocks_5[i]) {
          each_blocks_5[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*browseMonth*/
        ctx[8]
      );
      append_hydration(div0, t1);
      append_hydration(div0, select1);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        if (each_blocks_4[i]) {
          each_blocks_4[i].m(select1, null);
        }
      }
      append_hydration(div0, t2);
      append_hydration(div0, svg1);
      append_hydration(svg1, path1);
      append_hydration(div2, t3);
      append_hydration(div2, div1);
      append_hydration(div1, select2);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        if (each_blocks_3[i]) {
          each_blocks_3[i].m(select2, null);
        }
      }
      select_option(
        select2,
        /*browseYear*/
        ctx[9]
      );
      append_hydration(div1, t4);
      append_hydration(div1, select3);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        if (each_blocks_2[i]) {
          each_blocks_2[i].m(select3, null);
        }
      }
      append_hydration(div1, t5);
      append_hydration(div1, svg2);
      append_hydration(svg2, path2);
      append_hydration(div2, t6);
      append_hydration(div2, button1);
      append_hydration(div4, t7);
      append_hydration(div4, div3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div3, null);
        }
      }
      append_hydration(div4, t8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div4, null);
        }
      }
      append_hydration(div4, t9);
      mount_component(timepicker, div4, null);
      append_hydration(div4, t10);
      if (default_slot) {
        default_slot.m(div4, null);
      }
      current2 = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[23]
          ),
          listen(
            select0,
            "keydown",
            /*monthKeydown*/
            ctx[16]
          ),
          listen(
            select0,
            "input",
            /*input_handler*/
            ctx[24]
          ),
          listen(
            select2,
            "input",
            /*input_handler_1*/
            ctx[25]
          ),
          listen(
            select2,
            "keydown",
            /*yearKeydown*/
            ctx[15]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[26]
          ),
          listen(
            div5,
            "focusout",
            /*focusout_handler*/
            ctx[22]
          ),
          listen(
            div5,
            "keydown",
            /*keydown*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*browseYear, min, max, iLocale*/
      556) {
        each_value_6 = ensure_array_like(
          /*iLocale*/
          ctx2[5].months
        );
        let i;
        for (i = 0; i < each_value_6.length; i += 1) {
          const child_ctx = get_each_context_6(ctx2, each_value_6, i);
          if (each_blocks_5[i]) {
            each_blocks_5[i].p(child_ctx, dirty);
          } else {
            each_blocks_5[i] = create_each_block_6(child_ctx);
            each_blocks_5[i].c();
            each_blocks_5[i].m(select0, null);
          }
        }
        for (; i < each_blocks_5.length; i += 1) {
          each_blocks_5[i].d(1);
        }
        each_blocks_5.length = each_value_6.length;
      }
      if (!current2 || dirty[0] & /*browseMonth*/
      256) {
        select_option(
          select0,
          /*browseMonth*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*browseMonth, iLocale*/
      288) {
        each_value_5 = ensure_array_like(
          /*iLocale*/
          ctx2[5].months
        );
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks_4[i]) {
            each_blocks_4[i].p(child_ctx, dirty);
          } else {
            each_blocks_4[i] = create_each_block_5(child_ctx);
            each_blocks_4[i].c();
            each_blocks_4[i].m(select1, null);
          }
        }
        for (; i < each_blocks_4.length; i += 1) {
          each_blocks_4[i].d(1);
        }
        each_blocks_4.length = each_value_5.length;
      }
      if (dirty[0] & /*years*/
      64) {
        each_value_4 = ensure_array_like(
          /*years*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks_3[i]) {
            each_blocks_3[i].p(child_ctx, dirty);
          } else {
            each_blocks_3[i] = create_each_block_4(child_ctx);
            each_blocks_3[i].c();
            each_blocks_3[i].m(select2, null);
          }
        }
        for (; i < each_blocks_3.length; i += 1) {
          each_blocks_3[i].d(1);
        }
        each_blocks_3.length = each_value_4.length;
      }
      if (!current2 || dirty[0] & /*browseYear, years*/
      576) {
        select_option(
          select2,
          /*browseYear*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*years, browseDate*/
      80) {
        each_value_3 = ensure_array_like(
          /*years*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_2[i]) {
            each_blocks_2[i].p(child_ctx, dirty);
          } else {
            each_blocks_2[i] = create_each_block_3(child_ctx);
            each_blocks_2[i].c();
            each_blocks_2[i].m(select3, null);
          }
        }
        for (; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].d(1);
        }
        each_blocks_2.length = each_value_3.length;
      }
      if (dirty[0] & /*iLocale*/
      32) {
        each_value_2 = ensure_array_like(Array(7));
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div3, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & /*calendarDays, min, max, value, todayDate, browseMonth, selectDay*/
      18829) {
        each_value = ensure_array_like(Array(6));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div4, t9);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      const timepicker_changes = {};
      if (dirty[0] & /*timePrecision*/
      2)
        timepicker_changes.timePrecision = /*timePrecision*/
        ctx2[1];
      if (!updating_browseDate && dirty[0] & /*browseDate*/
      16) {
        updating_browseDate = true;
        timepicker_changes.browseDate = /*browseDate*/
        ctx2[4];
        add_flush_callback(() => updating_browseDate = false);
      }
      timepicker.$set(timepicker_changes);
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(timepicker.$$.fragment, local);
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(timepicker.$$.fragment, local);
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_each(each_blocks_5, detaching);
      destroy_each(each_blocks_4, detaching);
      destroy_each(each_blocks_3, detaching);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(timepicker);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function cloneDate(d) {
  return new Date(d.getTime());
}
function clamp(d, min2, max2) {
  if (d > max2) {
    return cloneDate(max2);
  } else if (d < min2) {
    return cloneDate(min2);
  } else {
    return cloneDate(d);
  }
}
function clampDate(d, min2, max2) {
  const limit = clamp(d, min2, max2);
  if (limit.getTime() !== d.getTime()) {
    d = new Date(limit.getFullYear(), limit.getMonth(), limit.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
    d = clamp(d, min2, max2);
  }
  return d;
}
function getYears(min2, max2) {
  let years2 = [];
  for (let i = min2.getFullYear(); i <= max2.getFullYear(); i++) {
    years2.push(i);
  }
  return years2;
}
function dayIsInRange(calendarDay, min2, max2) {
  const date2 = new Date(calendarDay.year, calendarDay.month, calendarDay.number);
  const minDate = new Date(min2.getFullYear(), min2.getMonth(), min2.getDate());
  const maxDate = new Date(max2.getFullYear(), max2.getMonth(), max2.getDate());
  return date2 >= minDate && date2 <= maxDate;
}
function instance$4($$self, $$props, $$invalidate) {
  let iLocale;
  let browseYear;
  let browseMonth;
  let calendarDays;
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch2 = createEventDispatcher();
  let { value = null } = $$props;
  function setValue(d) {
    if (d.getTime() !== (value == null ? void 0 : value.getTime())) {
      $$invalidate(4, browseDate = clamp(d, min, max2));
      $$invalidate(0, value = cloneDate(browseDate));
    }
  }
  function setValueDate(d) {
    if (d.getTime() !== (value == null ? void 0 : value.getTime())) {
      $$invalidate(4, browseDate = clampDate(d, min, max2));
      $$invalidate(0, value = cloneDate(browseDate));
    }
  }
  function browse(d) {
    $$invalidate(4, browseDate = clampDate(d, min, max2));
    if (!browseWithoutSelecting && value) {
      setValue(browseDate);
    }
  }
  function setTime(d) {
    $$invalidate(4, browseDate = clamp(d, min, max2));
    if (value) {
      setValue(browseDate);
    }
    return browseDate;
  }
  const todayDate = /* @__PURE__ */ new Date();
  const defaultDate = /* @__PURE__ */ new Date();
  let { timePrecision = null } = $$props;
  let { min = new Date(defaultDate.getFullYear() - 20, 0, 1) } = $$props;
  let { max: max2 = new Date(defaultDate.getFullYear(), 11, 31, 23, 59, 59, 999) } = $$props;
  let browseDate = value ? cloneDate(value) : cloneDate(clampDate(defaultDate, min, max2));
  function setBrowseDate(value2) {
    if (browseDate.getTime() !== (value2 == null ? void 0 : value2.getTime())) {
      $$invalidate(4, browseDate = value2 ? cloneDate(value2) : browseDate);
    }
  }
  let years = getYears(min, max2);
  let { locale: locale2 = {} } = $$props;
  let { browseWithoutSelecting = false } = $$props;
  function setYear(newYear) {
    browseDate.setFullYear(newYear);
    browse(browseDate);
  }
  function setMonth(newMonth) {
    let newYear = browseDate.getFullYear();
    if (newMonth === 12) {
      newMonth = 0;
      newYear++;
    } else if (newMonth === -1) {
      newMonth = 11;
      newYear--;
    }
    const maxDate = getMonthLength(newYear, newMonth);
    const newDate = Math.min(browseDate.getDate(), maxDate);
    browse(new Date(newYear, newMonth, newDate, browseDate.getHours(), browseDate.getMinutes(), browseDate.getSeconds(), browseDate.getMilliseconds()));
  }
  function selectDay(calendarDay) {
    if (dayIsInRange(calendarDay, min, max2)) {
      browseDate.setFullYear(0);
      browseDate.setMonth(0);
      browseDate.setDate(1);
      browseDate.setFullYear(calendarDay.year);
      browseDate.setMonth(calendarDay.month);
      browseDate.setDate(calendarDay.number);
      setValueDate(browseDate);
      dispatch2("select", cloneDate(browseDate));
    }
  }
  function shiftKeydown(e) {
    if (e.shiftKey && e.key === "ArrowUp") {
      setYear(browseDate.getFullYear() - 1);
    } else if (e.shiftKey && e.key === "ArrowDown") {
      setYear(browseDate.getFullYear() + 1);
    } else if (e.shiftKey && e.key === "ArrowLeft") {
      setMonth(browseDate.getMonth() - 1);
    } else if (e.shiftKey && e.key === "ArrowRight") {
      setMonth(browseDate.getMonth() + 1);
    } else {
      return false;
    }
    e.preventDefault();
    return true;
  }
  function yearKeydown(e) {
    let shift = e.shiftKey || e.altKey;
    if (shift) {
      shiftKeydown(e);
      return;
    } else if (e.key === "ArrowUp") {
      setYear(browseDate.getFullYear() - 1);
    } else if (e.key === "ArrowDown") {
      setYear(browseDate.getFullYear() + 1);
    } else if (e.key === "ArrowLeft") {
      setMonth(browseDate.getMonth() - 1);
    } else if (e.key === "ArrowRight") {
      setMonth(browseDate.getMonth() + 1);
    } else {
      shiftKeydown(e);
      return;
    }
    e.preventDefault();
  }
  function monthKeydown(e) {
    let shift = e.shiftKey || e.altKey;
    if (shift) {
      shiftKeydown(e);
      return;
    } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
      setMonth(browseDate.getMonth() - 1);
    } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
      setMonth(browseDate.getMonth() + 1);
    } else {
      shiftKeydown(e);
      return;
    }
    e.preventDefault();
  }
  function keydown(e) {
    var _a2, _b2;
    let shift = e.shiftKey || e.altKey;
    if (((_a2 = e.target) == null ? void 0 : _a2.tagName) === "SELECT" || ((_b2 = e.target) == null ? void 0 : _b2.tagName) === "SPAN") {
      return;
    }
    if (shift) {
      shiftKeydown(e);
      return;
    } else if (e.key === "ArrowUp") {
      browseDate.setDate(browseDate.getDate() - 7);
      setValueDate(browseDate);
    } else if (e.key === "ArrowDown") {
      browseDate.setDate(browseDate.getDate() + 7);
      setValueDate(browseDate);
    } else if (e.key === "ArrowLeft") {
      browseDate.setDate(browseDate.getDate() - 1);
      setValueDate(browseDate);
    } else if (e.key === "ArrowRight") {
      browseDate.setDate(browseDate.getDate() + 1);
      setValueDate(browseDate);
    } else if (e.key === "Enter") {
      setValue(browseDate);
      dispatch2("select", cloneDate(browseDate));
    } else {
      return;
    }
    e.preventDefault();
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => setMonth(browseDate.getMonth() - 1);
  const input_handler = (e) => setMonth(parseInt(e.currentTarget.value));
  const input_handler_1 = (e) => setYear(parseInt(e.currentTarget.value));
  const click_handler_1 = () => setMonth(browseDate.getMonth() + 1);
  const click_handler_2 = (calendarDay) => selectDay(calendarDay);
  function timepicker_browseDate_binding(value2) {
    browseDate = value2;
    $$invalidate(4, browseDate);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("timePrecision" in $$props2)
      $$invalidate(1, timePrecision = $$props2.timePrecision);
    if ("min" in $$props2)
      $$invalidate(2, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(3, max2 = $$props2.max);
    if ("locale" in $$props2)
      $$invalidate(18, locale2 = $$props2.locale);
    if ("browseWithoutSelecting" in $$props2)
      $$invalidate(19, browseWithoutSelecting = $$props2.browseWithoutSelecting);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, max, min*/
    13) {
      if (value && value > max2) {
        setValue(max2);
      } else if (value && value < min) {
        setValue(min);
      }
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      setBrowseDate(value);
    }
    if ($$self.$$.dirty[0] & /*min, max*/
    12) {
      $$invalidate(6, years = getYears(min, max2));
    }
    if ($$self.$$.dirty[0] & /*locale*/
    262144) {
      $$invalidate(5, iLocale = getInnerLocale(locale2));
    }
    if ($$self.$$.dirty[0] & /*browseDate*/
    16) {
      $$invalidate(9, browseYear = browseDate.getFullYear());
    }
    if ($$self.$$.dirty[0] & /*browseDate*/
    16) {
      $$invalidate(8, browseMonth = browseDate.getMonth());
    }
    if ($$self.$$.dirty[0] & /*browseDate, iLocale*/
    48) {
      $$invalidate(7, calendarDays = getCalendarDays(browseDate, iLocale.weekStartsOn));
    }
  };
  return [
    value,
    timePrecision,
    min,
    max2,
    browseDate,
    iLocale,
    years,
    calendarDays,
    browseMonth,
    browseYear,
    setTime,
    todayDate,
    setYear,
    setMonth,
    selectDay,
    yearKeydown,
    monthKeydown,
    keydown,
    locale2,
    browseWithoutSelecting,
    $$scope,
    slots,
    focusout_handler,
    click_handler,
    input_handler,
    input_handler_1,
    click_handler_1,
    click_handler_2,
    timepicker_browseDate_binding
  ];
}
class DatePicker extends SvelteComponent {
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$4,
      create_fragment$4,
      safe_not_equal,
      {
        value: 0,
        timePrecision: 1,
        min: 2,
        max: 3,
        locale: 18,
        browseWithoutSelecting: 19
      },
      null,
      [-1, -1]
    );
  }
}
function blur(node, { delay = 0, duration = 400, easing = cubicInOut$1, amount = 5, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const f = style.filter === "none" ? "" : style.filter;
  const od = target_opacity * (1 - opacity);
  const [value, unit2] = split_css_unit(amount);
  return {
    delay,
    duration,
    easing,
    css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit2});`
  };
}
function fade(node, { delay = 0, duration = 400, easing = identity$4 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  const [xValue, xUnit] = split_css_unit(x);
  const [yValue, yUnit] = split_css_unit(y);
  return {
    delay,
    duration,
    easing,
    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u}`
  };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis: axis2 = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis2 === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis2 === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e) => `${e[0].toUpperCase()}${e.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}
function parse(str, tokens, baseDate) {
  let missingPunctuation = "";
  let valid = true;
  baseDate = baseDate || new Date(2020, 0, 1, 0, 0, 0, 0);
  let year = baseDate.getFullYear();
  let month = baseDate.getMonth();
  let day = baseDate.getDate();
  let hours = baseDate.getHours();
  let minutes = baseDate.getMinutes();
  let seconds = baseDate.getSeconds();
  const ms = baseDate.getMilliseconds();
  function parseString(token2) {
    for (let i = 0; i < token2.length; i++) {
      if (str.startsWith(token2[i])) {
        str = str.slice(1);
      } else {
        valid = false;
        if (str.length === 0)
          missingPunctuation = token2.slice(i);
        return;
      }
    }
  }
  function parseUint(pattern, min, max2) {
    const matches = str.match(pattern);
    if (matches == null ? void 0 : matches[0]) {
      str = str.slice(matches[0].length);
      const n = parseInt(matches[0]);
      if (n > max2 || n < min) {
        valid = false;
        return null;
      } else {
        return n;
      }
    } else {
      valid = false;
      return null;
    }
  }
  function parseToken(token2) {
    if (typeof token2 === "string") {
      parseString(token2);
    } else if (token2.id === "yy") {
      const value = parseUint(/^[0-9]{2}/, 0, 99);
      if (value !== null)
        year = 2e3 + value;
    } else if (token2.id === "yyyy") {
      const value = parseUint(/^[0-9]{4}/, 0, 9999);
      if (value !== null)
        year = value;
    } else if (token2.id === "MM") {
      const value = parseUint(/^[0-9]{2}/, 1, 12);
      if (value !== null)
        month = value - 1;
    } else if (token2.id === "dd") {
      const value = parseUint(/^[0-9]{2}/, 1, 31);
      if (value !== null)
        day = value;
    } else if (token2.id === "HH") {
      const value = parseUint(/^[0-9]{2}/, 0, 23);
      if (value !== null)
        hours = value;
    } else if (token2.id === "mm") {
      const value = parseUint(/^[0-9]{2}/, 0, 59);
      if (value !== null)
        minutes = value;
    } else if (token2.id === "ss") {
      const value = parseUint(/^[0-9]{2}/, 0, 59);
      if (value !== null)
        seconds = value;
    }
  }
  for (const token2 of tokens) {
    parseToken(token2);
    if (!valid)
      break;
  }
  const monthLength = getMonthLength(year, month);
  if (day > monthLength) {
    valid = false;
  }
  return {
    date: valid ? new Date(year, month, day, hours, minutes, seconds, ms) : null,
    missingPunctuation
  };
}
function twoDigit(value) {
  return ("0" + value.toString()).slice(-2);
}
const ruleTokens = [
  {
    id: "yyyy",
    toString: (d) => d.getFullYear().toString()
  },
  {
    id: "yy",
    toString: (d) => d.getFullYear().toString().slice(-2)
  },
  {
    id: "MM",
    toString: (d) => twoDigit(d.getMonth() + 1)
  },
  {
    id: "dd",
    toString: (d) => twoDigit(d.getDate())
  },
  {
    id: "HH",
    toString: (d) => twoDigit(d.getHours())
  },
  {
    id: "mm",
    toString: (d) => twoDigit(d.getMinutes())
  },
  {
    id: "ss",
    toString: (d) => twoDigit(d.getSeconds())
  }
];
function parseRule(s) {
  for (const token2 of ruleTokens) {
    if (s.startsWith(token2.id)) {
      return token2;
    }
  }
}
function createFormat(s) {
  const tokens = [];
  while (s.length > 0) {
    const token2 = parseRule(s);
    if (token2) {
      tokens.push(token2);
      s = s.slice(token2.id.length);
    } else if (typeof tokens[tokens.length - 1] === "string") {
      tokens[tokens.length - 1] += s[0];
      s = s.slice(1);
    } else {
      tokens.push(s[0]);
      s = s.slice(1);
    }
  }
  return tokens;
}
function create_if_block$2(ctx) {
  let div;
  let datetimepicker;
  let updating_value;
  let div_transition;
  let style___picker_left_position = `${/*pickerLeftPosition*/
  ctx[18]}px`;
  let current2;
  function datetimepicker_value_binding(value) {
    ctx[34](value);
  }
  let datetimepicker_props = {
    min: (
      /*min*/
      ctx[3]
    ),
    max: (
      /*max*/
      ctx[4]
    ),
    locale: (
      /*locale*/
      ctx[10]
    ),
    browseWithoutSelecting: (
      /*browseWithoutSelecting*/
      ctx[11]
    ),
    timePrecision: (
      /*timePrecision*/
      ctx[12]
    ),
    $$slots: { default: [create_default_slot$1] },
    $$scope: { ctx }
  };
  if (
    /*$store*/
    ctx[14] !== void 0
  ) {
    datetimepicker_props.value = /*$store*/
    ctx[14];
  }
  datetimepicker = new DatePicker({ props: datetimepicker_props });
  binding_callbacks.push(() => bind$3(datetimepicker, "value", datetimepicker_value_binding));
  datetimepicker.$on(
    "focusout",
    /*onFocusOut*/
    ctx[21]
  );
  datetimepicker.$on(
    "select",
    /*onSelect*/
    ctx[23]
  );
  return {
    c() {
      div = element("div");
      create_component(datetimepicker.$$.fragment);
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      claim_component(datetimepicker.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div, "class", "picker svelte-1vabmef");
      toggle_class(
        div,
        "visible",
        /*visible*/
        ctx[2]
      );
      toggle_class(
        div,
        "above",
        /*showAbove*/
        ctx[17]
      );
      set_style(div, "--picker-left-position", style___picker_left_position);
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      mount_component(datetimepicker, div, null);
      ctx[35](div);
      current2 = true;
    },
    p(ctx2, dirty) {
      const datetimepicker_changes = {};
      if (dirty[0] & /*min*/
      8)
        datetimepicker_changes.min = /*min*/
        ctx2[3];
      if (dirty[0] & /*max*/
      16)
        datetimepicker_changes.max = /*max*/
        ctx2[4];
      if (dirty[0] & /*locale*/
      1024)
        datetimepicker_changes.locale = /*locale*/
        ctx2[10];
      if (dirty[0] & /*browseWithoutSelecting*/
      2048)
        datetimepicker_changes.browseWithoutSelecting = /*browseWithoutSelecting*/
        ctx2[11];
      if (dirty[0] & /*timePrecision*/
      4096)
        datetimepicker_changes.timePrecision = /*timePrecision*/
        ctx2[12];
      if (dirty[1] & /*$$scope*/
      32) {
        datetimepicker_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty[0] & /*$store*/
      16384) {
        updating_value = true;
        datetimepicker_changes.value = /*$store*/
        ctx2[14];
        add_flush_callback(() => updating_value = false);
      }
      datetimepicker.$set(datetimepicker_changes);
      if (!current2 || dirty[0] & /*visible*/
      4) {
        toggle_class(
          div,
          "visible",
          /*visible*/
          ctx2[2]
        );
      }
      if (!current2 || dirty[0] & /*showAbove*/
      131072) {
        toggle_class(
          div,
          "above",
          /*showAbove*/
          ctx2[17]
        );
      }
      if (dirty[0] & /*pickerLeftPosition*/
      262144 && style___picker_left_position !== (style___picker_left_position = `${/*pickerLeftPosition*/
      ctx2[18]}px`)) {
        set_style(div, "--picker-left-position", style___picker_left_position);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(datetimepicker.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current2)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              /*flyAutoPosition*/
              ctx[24],
              {},
              true
            );
          div_transition.run(1);
        });
      }
      current2 = true;
    },
    o(local) {
      transition_out(datetimepicker.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            /*flyAutoPosition*/
            ctx[24],
            {},
            false
          );
        div_transition.run(0);
      }
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(datetimepicker);
      ctx[35](null);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot$1(ctx) {
  let current2;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[36],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target2, anchor) {
      if (default_slot) {
        default_slot.m(target2, anchor);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty[1] & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[36],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[36]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[36],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$3(ctx) {
  let div;
  let input;
  let t;
  let div_class_value;
  let current2;
  let mounted;
  let dispose;
  let if_block = (
    /*visible*/
    ctx[2] && !/*disabled*/
    ctx[7] && create_if_block$2(ctx)
  );
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children$1(div);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        id: true,
        placeholder: true,
        class: true
      });
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "text");
      input.value = /*text*/
      ctx[0];
      attr(
        input,
        "id",
        /*id*/
        ctx[5]
      );
      attr(
        input,
        "placeholder",
        /*placeholder*/
        ctx[6]
      );
      input.disabled = /*disabled*/
      ctx[7];
      input.required = /*required*/
      ctx[8];
      attr(input, "class", "svelte-1vabmef");
      toggle_class(input, "invalid", !/*valid*/
      ctx[1]);
      attr(div, "class", div_class_value = "date-time-field " + /*classes*/
      ctx[9] + " svelte-1vabmef");
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      append_hydration(div, input);
      ctx[30](input);
      append_hydration(div, t);
      if (if_block)
        if_block.m(div, null);
      current2 = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "focus",
            /*focus_handler*/
            ctx[31]
          ),
          listen(
            input,
            "mousedown",
            /*mousedown_handler*/
            ctx[32]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[33]
          ),
          listen(
            div,
            "focusout",
            /*onFocusOut*/
            ctx[21]
          ),
          listen(
            div,
            "keydown",
            /*keydown*/
            ctx[22]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current2 || dirty[0] & /*text*/
      1 && input.value !== /*text*/
      ctx2[0]) {
        input.value = /*text*/
        ctx2[0];
      }
      if (!current2 || dirty[0] & /*id*/
      32) {
        attr(
          input,
          "id",
          /*id*/
          ctx2[5]
        );
      }
      if (!current2 || dirty[0] & /*placeholder*/
      64) {
        attr(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[6]
        );
      }
      if (!current2 || dirty[0] & /*disabled*/
      128) {
        input.disabled = /*disabled*/
        ctx2[7];
      }
      if (!current2 || dirty[0] & /*required*/
      256) {
        input.required = /*required*/
        ctx2[8];
      }
      if (!current2 || dirty[0] & /*valid*/
      2) {
        toggle_class(input, "invalid", !/*valid*/
        ctx2[1]);
      }
      if (
        /*visible*/
        ctx2[2] && !/*disabled*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*visible, disabled*/
          132) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current2 || dirty[0] & /*classes*/
      512 && div_class_value !== (div_class_value = "date-time-field " + /*classes*/
      ctx2[9] + " svelte-1vabmef")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[30](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $store;
  let $innerStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch2 = createEventDispatcher();
  const defaultDate = /* @__PURE__ */ new Date();
  const innerStore = writable(null);
  component_subscribe($$self, innerStore, (value2) => $$invalidate(37, $innerStore = value2));
  const store = (() => {
    return {
      subscribe: innerStore.subscribe,
      set: (date2) => {
        if (date2 === null || date2 === void 0) {
          innerStore.set(null);
          $$invalidate(25, value = date2);
        } else if (date2.getTime() !== ($innerStore == null ? void 0 : $innerStore.getTime())) {
          innerStore.set(date2);
          $$invalidate(25, value = date2);
        }
      }
    };
  })();
  component_subscribe($$self, store, (value2) => $$invalidate(14, $store = value2));
  let { value = null } = $$props;
  let { min = new Date(defaultDate.getFullYear() - 20, 0, 1) } = $$props;
  let { max: max2 = new Date(defaultDate.getFullYear(), 11, 31, 23, 59, 59, 999) } = $$props;
  let { id: id2 = null } = $$props;
  let { placeholder = "2020-12-31 23:00:00" } = $$props;
  let { valid = true } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { class: classes = "" } = $$props;
  let { format: format2 = "yyyy-MM-dd HH:mm:ss" } = $$props;
  let formatTokens = createFormat(format2);
  let { locale: locale2 = {} } = $$props;
  function valueUpdate(value2, formatTokens2) {
    $$invalidate(0, text2 = toText(value2, formatTokens2));
  }
  let { text: text2 = toText($store, formatTokens) } = $$props;
  function textUpdate(text22, formatTokens2) {
    if (text22.length) {
      const result = parse(text22, formatTokens2, $store);
      if (result.date !== null) {
        $$invalidate(1, valid = true);
        store.set(result.date);
      } else {
        $$invalidate(1, valid = false);
      }
    } else {
      $$invalidate(1, valid = true);
      if (value) {
        $$invalidate(25, value = null);
        store.set(null);
      }
    }
  }
  let { visible = false } = $$props;
  let { closeOnSelection = false } = $$props;
  let { browseWithoutSelecting = false } = $$props;
  let { timePrecision = null } = $$props;
  function onFocusOut(e) {
    if ((e == null ? void 0 : e.currentTarget) instanceof HTMLElement && e.relatedTarget && e.relatedTarget instanceof Node && e.currentTarget.contains(e.relatedTarget)) {
      return;
    } else {
      $$invalidate(2, visible = false);
    }
  }
  function keydown(e) {
    if (e.key === "Escape" && visible) {
      $$invalidate(2, visible = false);
      e.preventDefault();
      e.stopPropagation();
    } else if (e.key === "Enter") {
      $$invalidate(2, visible = !visible);
      e.preventDefault();
    }
  }
  function onSelect(e) {
    dispatch2("select", e.detail);
    if (closeOnSelection) {
      $$invalidate(2, visible = false);
    }
  }
  let { dynamicPositioning = false } = $$props;
  let InputElement;
  let pickerElement;
  let showAbove = false;
  let pickerLeftPosition = null;
  function setDatePickerPosition() {
    $$invalidate(17, showAbove = false);
    $$invalidate(18, pickerLeftPosition = null);
    if (visible && pickerElement && dynamicPositioning) {
      const inputRect = InputElement.getBoundingClientRect();
      const horizontalOverflow = pickerElement.offsetWidth - inputRect.width;
      const bottomThreshold = inputRect.bottom + pickerElement.offsetHeight + 5;
      const rightThreshold = inputRect.left + pickerElement.offsetWidth + 5;
      if (bottomThreshold > window.innerHeight) {
        $$invalidate(17, showAbove = true);
      }
      if (rightThreshold > window.innerWidth) {
        $$invalidate(18, pickerLeftPosition = -horizontalOverflow);
        if (inputRect.left < horizontalOverflow + 5) {
          const windowCenterPos = window.innerWidth / 2;
          const newPos = windowCenterPos - pickerElement.offsetWidth / 2;
          $$invalidate(18, pickerLeftPosition = newPos - inputRect.left);
        }
      }
    }
  }
  function flyAutoPosition(node) {
    setDatePickerPosition();
    return fly(node, {
      duration: 200,
      easing: cubicInOut$1,
      y: showAbove ? 5 : -5
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      InputElement = $$value;
      $$invalidate(15, InputElement);
    });
  }
  const focus_handler = () => $$invalidate(2, visible = true);
  const mousedown_handler = () => $$invalidate(2, visible = true);
  const input_handler = (e) => {
    if (e instanceof InputEvent && e.inputType === "insertText" && typeof e.data === "string" && e.currentTarget.value === text2 + e.data) {
      let result = parse(text2, formatTokens, $store);
      if (result.missingPunctuation !== "" && !result.missingPunctuation.startsWith(e.data)) {
        $$invalidate(0, text2 = text2 + result.missingPunctuation + e.data);
        return;
      }
    }
    $$invalidate(0, text2 = e.currentTarget.value);
  };
  function datetimepicker_value_binding(value2) {
    $store = value2;
    store.set($store);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pickerElement = $$value;
      $$invalidate(16, pickerElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(25, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max2 = $$props2.max);
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
    if ("placeholder" in $$props2)
      $$invalidate(6, placeholder = $$props2.placeholder);
    if ("valid" in $$props2)
      $$invalidate(1, valid = $$props2.valid);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("required" in $$props2)
      $$invalidate(8, required = $$props2.required);
    if ("class" in $$props2)
      $$invalidate(9, classes = $$props2.class);
    if ("format" in $$props2)
      $$invalidate(26, format2 = $$props2.format);
    if ("locale" in $$props2)
      $$invalidate(10, locale2 = $$props2.locale);
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("visible" in $$props2)
      $$invalidate(2, visible = $$props2.visible);
    if ("closeOnSelection" in $$props2)
      $$invalidate(27, closeOnSelection = $$props2.closeOnSelection);
    if ("browseWithoutSelecting" in $$props2)
      $$invalidate(11, browseWithoutSelecting = $$props2.browseWithoutSelecting);
    if ("timePrecision" in $$props2)
      $$invalidate(12, timePrecision = $$props2.timePrecision);
    if ("dynamicPositioning" in $$props2)
      $$invalidate(28, dynamicPositioning = $$props2.dynamicPositioning);
    if ("$$scope" in $$props2)
      $$invalidate(36, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    33554432) {
      store.set(value);
    }
    if ($$self.$$.dirty[0] & /*format*/
    67108864) {
      $$invalidate(13, formatTokens = createFormat(format2));
    }
    if ($$self.$$.dirty[0] & /*$store, formatTokens*/
    24576) {
      valueUpdate($store, formatTokens);
    }
    if ($$self.$$.dirty[0] & /*text, formatTokens*/
    8193) {
      textUpdate(text2, formatTokens);
    }
  };
  return [
    text2,
    valid,
    visible,
    min,
    max2,
    id2,
    placeholder,
    disabled,
    required,
    classes,
    locale2,
    browseWithoutSelecting,
    timePrecision,
    formatTokens,
    $store,
    InputElement,
    pickerElement,
    showAbove,
    pickerLeftPosition,
    innerStore,
    store,
    onFocusOut,
    keydown,
    onSelect,
    flyAutoPosition,
    value,
    format2,
    closeOnSelection,
    dynamicPositioning,
    slots,
    input_binding,
    focus_handler,
    mousedown_handler,
    input_handler,
    datetimepicker_value_binding,
    div_binding,
    $$scope
  ];
}
class DateInput extends SvelteComponent {
  constructor(options) {
    super();
    init$1(
      this,
      options,
      instance$3,
      create_fragment$3,
      safe_not_equal,
      {
        value: 25,
        min: 3,
        max: 4,
        id: 5,
        placeholder: 6,
        valid: 1,
        disabled: 7,
        required: 8,
        class: 9,
        format: 26,
        locale: 10,
        text: 0,
        visible: 2,
        closeOnSelection: 27,
        browseWithoutSelecting: 11,
        timePrecision: 12,
        dynamicPositioning: 28
      },
      null,
      [-1, -1]
    );
  }
}
function ascending$1(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending$1;
    compare2 = (d, x) => ascending$1(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending$1 || f === descending ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left2(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x, lo = 0, hi = a.length) {
    const i = left2(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$1() {
  return 0;
}
function number$2(x) {
  return x === null ? NaN : +x;
}
const ascendingBisect = bisector(ascending$1);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start2, stop, count) {
  const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start2, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  if (!(count > 0))
    return [];
  if (start2 === stop)
    return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  return tickSpec(start2, stop, count)[2];
}
function tickStep(start2, stop, count) {
  stop = +stop, start2 = +start2, count = +count;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function identity$3(x) {
  return x;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon = 1e-6;
function translateX(x) {
  return "translate(" + x + ",0)";
}
function translateY(y) {
  return "translate(0," + y + ")";
}
function number$1(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$3 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position = (scale.bandwidth ? center : number$1)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path = selection2.selectAll(".domain").data([null]), tick2 = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick2.exit(), tickEnter = tick2.enter().append("g").attr("class", "tick"), line = tick2.select("line"), text2 = tick2.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick2 = tick2.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path = path.transition(context);
      tick2 = tick2.transition(context);
      line = line.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick2.attr("opacity", 1).attr("transform", function(d) {
      return transform(position(d) + offset);
    });
    line.attr(x + "2", k * tickSizeInner);
    text2.attr(x, k * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback2) {
    var _ = this._, T = parseTypenames$1(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name)))
          return t;
      return;
    }
    if (callback2 != null && typeof callback2 !== "function")
      throw new Error("invalid callback: " + callback2);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set$1(_[t], typename.name, callback2);
      else if (callback2 == null)
        for (t in _)
          _[t] = set$1(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _)
      copy2[t] = _[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$1(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set$1(type2, name, callback2) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback2 != null)
    type2.push({ name, value: callback2 });
  return type2;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri2 = this.namespaceURI;
    return uri2 === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri2, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter2 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter2.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update2) {
  return new Array(update2.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent2, datum2) {
  this.ownerDocument = parent2.ownerDocument;
  this.namespaceURI = parent2.namespaceURI;
  this._next = null;
  this._parent = parent2;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$1(x) {
  return function() {
    return x;
  };
}
function bindIndex(parent2, group, enter, update2, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update2[i] = node;
    } else {
      enter[i] = new EnterNode(parent2, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent2, group, enter, update2, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent2, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update2[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent2, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind3 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$1(value);
  for (var m = groups.length, update2 = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent2 = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent2, parent2 && parent2.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind3(parent2, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update2 = new Selection$1(update2, parents);
  update2._enter = enter;
  update2._exit = exit;
  return update2;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update2 = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update2 = onupdate(update2);
    if (update2)
      update2 = update2.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update2 ? enter.merge(update2).order() : update2;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge3[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback2 = arguments[0];
  arguments[0] = this;
  callback2.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback2) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        callback2.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names2) {
  var list = classList(node), i = -1, n = names2.length;
  while (++i < n)
    list.add(names2[i]);
}
function classedRemove(node, names2) {
  var list = classList(node), i = -1, n = names2.length;
  while (++i < n)
    list.remove(names2[i]);
}
function classedTrue(names2) {
  return function() {
    classedAdd(this, names2);
  };
}
function classedFalse(names2) {
  return function() {
    classedRemove(this, names2);
  };
}
function classedFunction(names2, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
  };
}
function selection_classed(name, value) {
  var names2 = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names2.length;
    while (++i < n)
      if (!list.contains(names2[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent2 = this.parentNode;
  if (parent2)
    parent2.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent(node, type2, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i])
        yield node;
    }
  }
}
var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
}
function define(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend(parent2, definition) {
  var prototype2 = Object.create(parent2.prototype);
  for (var key in definition)
    prototype2[key] = definition[key];
  return prototype2;
}
function Color2() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color2, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color2))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color2))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min, l = (max2 + min) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min : 2 - max2 - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const constant = (x) => () => x;
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
}
const interpolateRgb = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb$1(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = interpolate$1(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}
function date(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate$1(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate$1(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}
var degrees = 180 / Math.PI;
var identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$2 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity$2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$2;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate2(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback2, delay, time) {
    if (typeof callback2 !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback2;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback2, delay, time) {
  var t = new Timer();
  t.restart(callback2, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback2, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback2(elapsed + delay);
  }, delay, time);
  return t;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick2, self2.delay, self2.time);
        tick2(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick2(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active2, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active2 = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active2 ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get(node, id2).value[name];
  };
}
function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set(this, id2).ease = v;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge3 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge3[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent2 = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent2)
      parent2.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id2, i, subgroup, get(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select2.call(node, node.__data__, i, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve2, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve2();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0)
      resolve2();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}
function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}
var prefixExponent;
function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}
function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded(x * 100, p),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};
function identity$1(x) {
  return x;
}
var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$1 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$1 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
    if (zero2 || fill2 === "0" && align === "=")
      zero2 = true, fill2 = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill2) : "";
      if (comma && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function constants(x) {
  return function() {
    return x;
  };
}
function number(x) {
  return +x;
}
var unit = [0, 1];
function identity(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range2, interpolate2) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x) {
    var i2 = bisectRight(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target2) {
  return target2.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate2 = interpolate$1, transform, untransform, unknown, clamp2 = identity, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp2 !== identity)
      clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate2)))(transform(clamp2(x)));
  }
  scale.invert = function(y) {
    return clamp2(untransform((input || (input = piecewise(range2, domain.map(transform), interpolateNumber)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity, rescale()) : clamp2 !== identity;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity, identity);
}
function tickFormat(start2, stop, count, specifier) {
  var step = tickStep(start2, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null)
      count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
Transform.prototype;
const CLASS_PART_SEPARATOR = "-";
function createClassUtils(config) {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  function getClassGroupId(className) {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  var _a2;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a2 = classPartObject.validators.find(({
    validator: validator2
  }) => validator2(classRest))) == null ? void 0 : _a2.classGroupId;
}
const arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache2 = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  function update2(key, value) {
    cache2.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = /* @__PURE__ */ new Map();
    }
  }
  return {
    get(key) {
      let value = cache2.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update2(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache2.has(key)) {
        cache2.set(key, value);
      } else {
        update2(key, value);
      }
    }
  };
}
const IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config) {
  const separator = config.separator;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  return function splitModifiers(className) {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
const SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList2, configUtils) {
  const {
    splitModifiers,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList2.trim().split(SPLIT_CLASSES_REGEX).map((originalClassName) => {
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = splitModifiers(originalClassName);
    let classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter((parsed) => {
    if (!parsed.isTailwindClass) {
      return true;
    }
    const {
      modifierId,
      classGroupId,
      hasPostfixModifier
    } = parsed;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach((group) => classGroupsInConflict.add(modifierId + group));
    return true;
  }).reverse().map((parsed) => parsed.originalClassName).join(" ");
}
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList2) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList2);
  }
  function tailwindMerge(classList2) {
    const cachedResult = cacheGet(classList2);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList2, configUtils);
    cacheSet(classList2, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isNumber(value) {
  return Boolean(value) && !Number.isNaN(Number(value));
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isInteger(value) {
  return Boolean(value) && Number.isInteger(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, sizeLabels, isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
function isArbitraryImage(value) {
  return getIsArbitraryValue(value, imageLabels, isImage);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function isAny() {
  return true;
}
function getIsArbitraryValue(value, label, testValue) {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
}
function isNever() {
  return false;
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function isImage(value) {
  return imageRegex.test(value);
}
function getDefaultConfig() {
  const colors2 = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur2 = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space2 = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumber = () => [isNumber, isArbitraryNumber];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors2],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors2],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space2]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space2]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors2]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors2]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors2]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors2]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors2]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors2]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors2]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur2]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur2]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors2]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors2]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors2, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors2, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
const get_default_slot_changes_1 = (dirty) => ({ svgSize: dirty & /*size*/
4 });
const get_default_slot_context_1 = (ctx) => ({
  svgSize: (
    /*svgSizes*/
    ctx[5][
      /*size*/
      ctx[2]
    ]
  )
});
const get_default_slot_changes$1 = (dirty) => ({ svgSize: dirty & /*size*/
4 });
const get_default_slot_context$1 = (ctx) => ({
  svgSize: (
    /*svgSizes*/
    ctx[5][
      /*size*/
      ctx[2]
    ]
  )
});
function create_else_block(ctx) {
  let button;
  let t;
  let button_aria_label_value;
  let current2;
  let mounted;
  let dispose;
  let if_block = (
    /*name*/
    ctx[0] && create_if_block_2$1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context_1
  );
  let button_levels = [
    { type: "button" },
    /*$$restProps*/
    ctx[6],
    { class: (
      /*buttonClass*/
      ctx[4]
    ) },
    {
      "aria-label": button_aria_label_value = /*ariaLabel*/
      ctx[1] ?? /*name*/
      ctx[0]
    }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign$1(button_data, button_levels[i]);
  }
  return {
    c() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        "aria-label": true
      });
      var button_nodes = children$1(button);
      if (if_block)
        if_block.l(button_nodes);
      t = claim_space(button_nodes);
      if (default_slot)
        default_slot.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(button, button_data);
    },
    m(target2, anchor) {
      insert_hydration(target2, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration(button, t);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current2 = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*name*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$1(ctx2);
          if_block.c();
          if_block.m(button, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope, size*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current2 || dirty & /*buttonClass*/
        16) && { class: (
          /*buttonClass*/
          ctx2[4]
        ) },
        (!current2 || dirty & /*ariaLabel, name*/
        3 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/
        ctx2[1] ?? /*name*/
        ctx2[0])) && { "aria-label": button_aria_label_value }
      ]));
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1(ctx) {
  let a;
  let t;
  let a_aria_label_value;
  let current2;
  let if_block = (
    /*name*/
    ctx[0] && create_if_block_1$1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context$1
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[3]
    ) },
    /*$$restProps*/
    ctx[6],
    { class: (
      /*buttonClass*/
      ctx[4]
    ) },
    {
      "aria-label": a_aria_label_value = /*ariaLabel*/
      ctx[1] ?? /*name*/
      ctx[0]
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign$1(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        class: true,
        "aria-label": true
      });
      var a_nodes = children$1(a);
      if (if_block)
        if_block.l(a_nodes);
      t = claim_space(a_nodes);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(a, a_data);
    },
    m(target2, anchor) {
      insert_hydration(target2, a, anchor);
      if (if_block)
        if_block.m(a, null);
      append_hydration(a, t);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current2 = true;
    },
    p(ctx2, dirty) {
      if (
        /*name*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          if_block.m(a, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope, size*/
        260)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes$1
            ),
            get_default_slot_context$1
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current2 || dirty & /*href*/
        8) && { href: (
          /*href*/
          ctx2[3]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current2 || dirty & /*buttonClass*/
        16) && { class: (
          /*buttonClass*/
          ctx2[4]
        ) },
        (!current2 || dirty & /*ariaLabel, name*/
        3 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/
        ctx2[1] ?? /*name*/
        ctx2[0])) && { "aria-label": a_aria_label_value }
      ]));
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*name*/
        ctx[0]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*name*/
        ctx[0]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "sr-only");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*name*/
        ctx[0]
      );
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children$1(span);
      t = claim_text(
        span_nodes,
        /*name*/
        ctx[0]
      );
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "sr-only");
    },
    m(target2, anchor) {
      insert_hydration(target2, span, anchor);
      append_hydration(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*name*/
      1)
        set_data(
          t,
          /*name*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current2;
  const if_block_creators = [create_if_block$1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*href*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty$1();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty$1();
    },
    m(target2, anchor) {
      if_blocks[current_block_type_index].m(target2, anchor);
      insert_hydration(target2, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  const omit_props_names = ["color", "name", "ariaLabel", "size", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const background = getContext("background");
  let { color: color2 = "default" } = $$props;
  let { name = void 0 } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { size = "md" } = $$props;
  let { href = void 0 } = $$props;
  const colors2 = {
    dark: "text-gray-500 hover:text-gray-900 hover:bg-gray-200 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-600",
    gray: "text-gray-500 focus:ring-gray-400 hover:bg-gray-200 dark:hover:bg-gray-800 dark:hover:text-gray-300",
    red: "text-red-500 focus:ring-red-400 hover:bg-red-200 dark:hover:bg-red-800 dark:hover:text-red-300",
    yellow: "text-yellow-500 focus:ring-yellow-400 hover:bg-yellow-200 dark:hover:bg-yellow-800 dark:hover:text-yellow-300",
    green: "text-green-500 focus:ring-green-400 hover:bg-green-200 dark:hover:bg-green-800 dark:hover:text-green-300",
    indigo: "text-indigo-500 focus:ring-indigo-400 hover:bg-indigo-200 dark:hover:bg-indigo-800 dark:hover:text-indigo-300",
    purple: "text-purple-500 focus:ring-purple-400 hover:bg-purple-200 dark:hover:bg-purple-800 dark:hover:text-purple-300",
    pink: "text-pink-500 focus:ring-pink-400 hover:bg-pink-200 dark:hover:bg-pink-800 dark:hover:text-pink-300",
    blue: "text-blue-500 focus:ring-blue-400 hover:bg-blue-200 dark:hover:bg-blue-800 dark:hover:text-blue-300",
    primary: "text-primary-500 focus:ring-primary-400 hover:bg-primary-200 dark:hover:bg-primary-800 dark:hover:text-primary-300",
    default: "focus:ring-gray-400"
  };
  const sizing = {
    xs: "m-0.5 rounded-sm focus:ring-1 p-0.5",
    sm: "m-0.5 rounded focus:ring-1 p-0.5",
    md: "m-0.5 rounded-lg focus:ring-2 p-1.5",
    lg: "m-0.5 rounded-lg focus:ring-2 p-2.5"
  };
  let buttonClass;
  const svgSizes = {
    xs: "w-3 h-3",
    sm: "w-3.5 h-3.5",
    md: "w-5 h-5",
    lg: "w-5 h-5"
  };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(7, color2 = $$new_props.color);
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("ariaLabel" in $$new_props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(4, buttonClass = twMerge(
      "focus:outline-none whitespace-normal",
      sizing[size],
      colors2[color2],
      color2 === "default" && (background ? "hover:bg-gray-100 dark:hover:bg-gray-600" : "hover:bg-gray-100 dark:hover:bg-gray-700"),
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    ariaLabel,
    size,
    href,
    buttonClass,
    svgSizes,
    $$restProps,
    color2,
    $$scope,
    slots,
    click_handler
  ];
}
class ToolbarButton extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$2, create_fragment$2, safe_not_equal, {
      color: 7,
      name: 0,
      ariaLabel: 1,
      size: 2,
      href: 3
    });
  }
}
function create_default_slot(ctx) {
  let svg;
  let path;
  let svg_class_value;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        fill: true,
        viewBox: true,
        xmlns: true
      });
      var svg_nodes = children$1(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children$1(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "class", svg_class_value = /*svgSize*/
      ctx[4]);
      attr(svg, "fill", "currentColor");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target2, anchor) {
      insert_hydration(target2, svg, anchor);
      append_hydration(svg, path);
    },
    p(ctx2, dirty) {
      if (dirty & /*svgSize*/
      16 && svg_class_value !== (svg_class_value = /*svgSize*/
      ctx2[4])) {
        attr(svg, "class", svg_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_fragment$1(ctx) {
  let toolbarbutton;
  let current2;
  const toolbarbutton_spread_levels = [
    { name: (
      /*name*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[1],
    {
      class: twMerge(
        "ms-auto",
        /*$$props*/
        ctx[2].class
      )
    }
  ];
  let toolbarbutton_props = {
    $$slots: {
      default: [
        create_default_slot,
        ({ svgSize }) => ({ 4: svgSize }),
        ({ svgSize }) => svgSize ? 16 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < toolbarbutton_spread_levels.length; i += 1) {
    toolbarbutton_props = assign$1(toolbarbutton_props, toolbarbutton_spread_levels[i]);
  }
  toolbarbutton = new ToolbarButton({ props: toolbarbutton_props });
  toolbarbutton.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  return {
    c() {
      create_component(toolbarbutton.$$.fragment);
    },
    l(nodes) {
      claim_component(toolbarbutton.$$.fragment, nodes);
    },
    m(target2, anchor) {
      mount_component(toolbarbutton, target2, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      const toolbarbutton_changes = dirty & /*name, $$restProps, $$props*/
      7 ? get_spread_update(toolbarbutton_spread_levels, [
        dirty & /*name*/
        1 && { name: (
          /*name*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty & /*$$props*/
        4 && {
          class: twMerge(
            "ms-auto",
            /*$$props*/
            ctx2[2].class
          )
        }
      ]) : {};
      if (dirty & /*$$scope, svgSize*/
      48) {
        toolbarbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbarbutton.$set(toolbarbutton_changes);
    },
    i(local) {
      if (current2)
        return;
      transition_in(toolbarbutton.$$.fragment, local);
      current2 = true;
    },
    o(local) {
      transition_out(toolbarbutton.$$.fragment, local);
      current2 = false;
    },
    d(detaching) {
      destroy_component(toolbarbutton, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  const omit_props_names = ["name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { name = "Close" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
  };
  $$props = exclude_internal_props($$props);
  return [name, $$restProps, $$props, click_handler];
}
class CloseButton extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance$1, create_fragment$1, safe_not_equal, { name: 0 });
  }
}
const clickOutside = (node, callback2) => {
  const handleClick = (event) => {
    if (!(event == null ? void 0 : event.target))
      return;
    if (node && !node.contains(event.target) && !event.defaultPrevented) {
      callback2();
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
};
const get_default_slot_changes = (dirty) => ({ hidden: dirty & /*hidden*/
1 });
const get_default_slot_context = (ctx) => ({ hidden: (
  /*hidden*/
  ctx[0]
) });
function create_if_block(ctx) {
  let t;
  let div;
  let div_class_value;
  let div_transition;
  let current2;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*backdrop*/
      ctx2[4] && /*activateClickOutside*/
      ctx2[1]
    )
      return create_if_block_1;
    if (
      /*backdrop*/
      ctx2[4] && !/*activateClickOutside*/
      ctx2[1]
    )
      return create_if_block_2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_default_slot_context
  );
  let div_levels = [
    { id: (
      /*id*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[15],
    {
      class: div_class_value = twMerge(
        /*divClass*/
        ctx[7],
        /*width*/
        ctx[3],
        /*position*/
        ctx[2],
        /*placements*/
        ctx[10][
          /*placement*/
          ctx[5]
        ],
        /*$$props*/
        ctx[16].class
      )
    },
    { tabindex: "-1" },
    { "aria-controls": (
      /*id*/
      ctx[6]
    ) },
    { "aria-labelledby": (
      /*id*/
      ctx[6]
    ) }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign$1(div_data, div_levels[i]);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        tabindex: true,
        "aria-controls": true,
        "aria-labelledby": true
      });
      var div_nodes = children$1(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div, div_data);
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert_hydration(target2, t, anchor);
      insert_hydration(target2, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current2 = true;
      if (!mounted) {
        dispose = action_destroyer(
          /*clickOutsideWrapper*/
          ctx[14].call(
            null,
            div,
            /*handleClickOutside*/
            ctx[12]
          )
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current2 || dirty & /*$$scope, hidden*/
        16777217)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[24],
            !current2 ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[24],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current2 || dirty & /*id*/
        64) && { id: (
          /*id*/
          ctx[6]
        ) },
        dirty & /*$$restProps*/
        32768 && /*$$restProps*/
        ctx[15],
        (!current2 || dirty & /*divClass, width, position, placement, $$props*/
        65708 && div_class_value !== (div_class_value = twMerge(
          /*divClass*/
          ctx[7],
          /*width*/
          ctx[3],
          /*position*/
          ctx[2],
          /*placements*/
          ctx[10][
            /*placement*/
            ctx[5]
          ],
          /*$$props*/
          ctx[16].class
        ))) && { class: div_class_value },
        { tabindex: "-1" },
        (!current2 || dirty & /*id*/
        64) && { "aria-controls": (
          /*id*/
          ctx[6]
        ) },
        (!current2 || dirty & /*id*/
        64) && { "aria-labelledby": (
          /*id*/
          ctx[6]
        ) }
      ]));
    },
    i(local) {
      if (current2)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current2)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              /*multiple*/
              ctx[9],
              /*transitionParams*/
              ctx[8],
              true
            );
          div_transition.run(1);
        });
      }
      current2 = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            /*multiple*/
            ctx[9],
            /*transitionParams*/
            ctx[8],
            false
          );
        div_transition.run(0);
      }
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(div);
      }
      if (if_block) {
        if_block.d(detaching);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      children$1(div).forEach(detach);
      this.h();
    },
    h() {
      attr(div, "role", "presentation");
      attr(
        div,
        "class",
        /*backdropDivClass*/
        ctx[13]
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
    },
    p: noop$4,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      this.h();
    },
    l(nodes) {
      div = claim_element(nodes, "DIV", { role: true, class: true });
      children$1(div).forEach(detach);
      this.h();
    },
    h() {
      attr(div, "role", "presentation");
      attr(
        div,
        "class",
        /*backdropDivClass*/
        ctx[13]
      );
    },
    m(target2, anchor) {
      insert_hydration(target2, div, anchor);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*click_handler*/
          ctx[26]
        );
        mounted = true;
      }
    },
    p: noop$4,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current2;
  let if_block = !/*hidden*/
  ctx[0] && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty$1();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty$1();
    },
    m(target2, anchor) {
      if (if_block)
        if_block.m(target2, anchor);
      insert_hydration(target2, if_block_anchor, anchor);
      current2 = true;
    },
    p(ctx2, [dirty]) {
      if (!/*hidden*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hidden*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current2)
        return;
      transition_in(if_block);
      current2 = true;
    },
    o(local) {
      transition_out(if_block);
      current2 = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "activateClickOutside",
    "hidden",
    "position",
    "leftOffset",
    "rightOffset",
    "topOffset",
    "bottomOffset",
    "width",
    "backdrop",
    "bgColor",
    "bgOpacity",
    "placement",
    "id",
    "divClass",
    "transitionParams",
    "transitionType"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { activateClickOutside = true } = $$props;
  let { hidden = true } = $$props;
  let { position = "fixed" } = $$props;
  let { leftOffset = "inset-y-0 start-0" } = $$props;
  let { rightOffset = "inset-y-0 end-0" } = $$props;
  let { topOffset = "inset-x-0 top-0" } = $$props;
  let { bottomOffset = "inset-x-0 bottom-0" } = $$props;
  let { width = "w-80" } = $$props;
  let { backdrop = true } = $$props;
  let { bgColor = "bg-gray-900" } = $$props;
  let { bgOpacity = "bg-opacity-75" } = $$props;
  let { placement = "left" } = $$props;
  let { id: id2 = "drawer-example" } = $$props;
  let { divClass = "overflow-y-auto z-50 p-4 bg-white dark:bg-gray-800" } = $$props;
  let { transitionParams = {} } = $$props;
  let { transitionType = "fly" } = $$props;
  function multiple(node, params) {
    switch (transitionType) {
      case "slide":
        return slide(node, params);
      case "blur":
        return blur(node, params);
      case "fade":
        return fade(node, params);
      default:
        return fly(node, params);
    }
  }
  const placements = {
    left: leftOffset,
    right: rightOffset,
    top: topOffset,
    bottom: bottomOffset
  };
  const handleDrawer = () => {
    $$invalidate(0, hidden = !hidden);
  };
  const handleClickOutside = () => activateClickOutside && !hidden && handleDrawer();
  let backdropDivClass = twMerge("fixed top-0 start-0 z-50 w-full h-full", backdrop && bgColor, backdrop && bgOpacity);
  function clickOutsideWrapper(node, callback2) {
    return activateClickOutside ? clickOutside(node, callback2) : void 0;
  }
  const click_handler = () => !hidden && handleDrawer();
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("activateClickOutside" in $$new_props)
      $$invalidate(1, activateClickOutside = $$new_props.activateClickOutside);
    if ("hidden" in $$new_props)
      $$invalidate(0, hidden = $$new_props.hidden);
    if ("position" in $$new_props)
      $$invalidate(2, position = $$new_props.position);
    if ("leftOffset" in $$new_props)
      $$invalidate(17, leftOffset = $$new_props.leftOffset);
    if ("rightOffset" in $$new_props)
      $$invalidate(18, rightOffset = $$new_props.rightOffset);
    if ("topOffset" in $$new_props)
      $$invalidate(19, topOffset = $$new_props.topOffset);
    if ("bottomOffset" in $$new_props)
      $$invalidate(20, bottomOffset = $$new_props.bottomOffset);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("backdrop" in $$new_props)
      $$invalidate(4, backdrop = $$new_props.backdrop);
    if ("bgColor" in $$new_props)
      $$invalidate(21, bgColor = $$new_props.bgColor);
    if ("bgOpacity" in $$new_props)
      $$invalidate(22, bgOpacity = $$new_props.bgOpacity);
    if ("placement" in $$new_props)
      $$invalidate(5, placement = $$new_props.placement);
    if ("id" in $$new_props)
      $$invalidate(6, id2 = $$new_props.id);
    if ("divClass" in $$new_props)
      $$invalidate(7, divClass = $$new_props.divClass);
    if ("transitionParams" in $$new_props)
      $$invalidate(8, transitionParams = $$new_props.transitionParams);
    if ("transitionType" in $$new_props)
      $$invalidate(23, transitionType = $$new_props.transitionType);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    hidden,
    activateClickOutside,
    position,
    width,
    backdrop,
    placement,
    id2,
    divClass,
    transitionParams,
    multiple,
    placements,
    handleDrawer,
    handleClickOutside,
    backdropDivClass,
    clickOutsideWrapper,
    $$restProps,
    $$props,
    leftOffset,
    rightOffset,
    topOffset,
    bottomOffset,
    bgColor,
    bgOpacity,
    transitionType,
    $$scope,
    slots,
    click_handler
  ];
}
class Drawer extends SvelteComponent {
  constructor(options) {
    super();
    init$1(this, options, instance, create_fragment, safe_not_equal, {
      activateClickOutside: 1,
      hidden: 0,
      position: 2,
      leftOffset: 17,
      rightOffset: 18,
      topOffset: 19,
      bottomOffset: 20,
      width: 3,
      backdrop: 4,
      bgColor: 21,
      bgOpacity: 22,
      placement: 5,
      id: 6,
      divClass: 7,
      transitionParams: 8,
      transitionType: 23
    });
  }
}
export {
  bubble as $,
  set_data as A,
  group_outros as B,
  binding_callbacks as C,
  construct_svelte_component as D,
  Error$1 as E,
  create_component as F,
  claim_component as G,
  mount_component as H,
  destroy_component as I,
  tick as J,
  writable as K,
  noop$4 as L,
  component_subscribe as M,
  setContext as N,
  mapboxgl as O,
  set_store_value as P,
  DateInput as Q,
  bind$3 as R,
  SvelteComponent as S,
  RangeSlider as T,
  add_flush_callback as U,
  axios as V,
  stop_propagation as W,
  self$1 as X,
  run_all as Y,
  onDestroy as Z,
  __vitePreload as _,
  space as a,
  linear as a0,
  select as a1,
  axisBottom as a2,
  ensure_array_like as a3,
  add_render_callback as a4,
  select_option as a5,
  destroy_each as a6,
  set_input_value as a7,
  select_value as a8,
  src_url_equal as a9,
  Drawer as aa,
  CloseButton as ab,
  sineIn as ac,
  Chart as ad,
  qs as ae,
  start$1 as af,
  claim_element as b,
  create_slot as c,
  children$1 as d,
  element as e,
  claim_space as f,
  get_svelte_dataset as g,
  detach as h,
  init$1 as i,
  attr as j,
  insert_hydration as k,
  append_hydration as l,
  listen as m,
  get_all_dirty_from_scope as n,
  get_slot_changes as o,
  transition_out as p,
  empty$1 as q,
  check_outros as r,
  safe_not_equal as s,
  transition_in as t,
  update_slot_base as u,
  afterUpdate as v,
  onMount as w,
  set_style as x,
  text as y,
  claim_text as z
};
